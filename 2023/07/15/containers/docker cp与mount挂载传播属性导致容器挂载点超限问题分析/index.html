<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>docker cp mount挂载属性传播 | 远辰</title><meta name="keywords" content="container"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="docker cp mount挂载属性传播"><meta name="application-name" content="docker cp mount挂载属性传播"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="docker cp mount挂载属性传播"><meta property="og:url" content="https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="1 问题结论docker cp命令导致容器内mount挂载点残留，需同时满足以下3个条件：  满足以下(1)或(2)条件中的任意一个    (1) 在所有的-v挂载目录，有docker根目录或docker根目录的父&amp;#x2F;子目录。且，没有-v目录指定传播模式为shared&amp;#x2F;rshared。"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1 问题结论docker cp命令导致容器内mount挂载点残留，需同时满足以下3个条件：  满足以下(1)或(2)条件中的任意一个    (1) 在所有的-v挂载目录，有docker根目录或docker根目录的父&amp;#x2F;子目录。且，没有-v目录指定传播模式为shared&amp;#x2F;rshared。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: 'docker cp mount挂载属性传播',
  postAI: '',
  pageFillDescription: '1 问题结论, 2 问题现象, 3 问题背景知识——linux mount机制, 3.1 mnt命名空间, 3.2 查看mount点, 3.2.1 cat /proc/self/mountinfo, 3.2.2 findmnt, 3.3 父子挂载点, 3.3.1 如何判断父挂载点, 3.4 共享组, 3.4.1 shared传播, 3.4.2 slave传播, 3.4.3 如何确定组属, 3.5 mount的内核结构, 3.6 docker容器下的mount, 4 docker中的mount传播属性, 4.1 docker run过程分析, 4.1.1 容器根目录传播模式与-v目录及其传播模式的关系, 4.1.2 docker run启动容器的mount流程分析, 4.1.3 docker run mount在dockerd和runc中的代码流程, 4.1.3.1 dockerd中的函数实现, 4.1.3.2 runc中的函数实现, 4.2 docker cp mount流程分析, 4.2.1 docker cp在docker代码流程总览, 4.2.2 docker cp在实际操作流程, 4.2.2.1 cp前主机及容器mount状态, 4.2.2.2 docker cp的第一次mount, 4.2.2.3 docker cp的第二次mount操作修改挂载属性无实质挂载, 4.2.2.4 docker cp的umount操作, 4.2.2.5 umount传播事件的流程, 4.2.3 docker cp流程总结, 4.3 讨论, 4.3.1 docker cp 为何要设置为rprivate, 5 总结, 参考文献问题结论命令导致容器内挂载点残留需同时满足以下个条件满足以下或条件中的任意一个在所有的挂载目录有根目录或根目录的父子目录且没有目录指定传播模式为例如根目录或根目录下的子目录或根目录的父目录挂载目录中指定挂载传播模式为且没有任何一个传播模式设置为例如存在一条其他的挂载目录不指定模式或指定为总之不能是挂载目录中在主机上是挂载点且有子挂载点例如主机上存在挂载点和则则满足条件如果则不满足该条件使用命令拷贝任意文件进容器问题现象使用将宿主机目录挂载进容器该目录在宿主机上有子挂载点然后再在宿主机上使用命令拷贝任意文件进入容器此时容器内挂载点残留执行后容器内的挂载点残留导致挂载点增加从增加至问题背景知识机制本章节介绍命名空间相关知识如果读者已熟悉相关内容请移步第四章命名空间上存在命名空间不同的进程可以有不同的命名空间也可以共用同一个命名空间可以通过查看某个进程命名空间特别的可以使用查看当前进程的命名空间其中的表示命名空间当不同的进程共用同一个命名空间时只要在该命名空间中有任意一个进程进行操作在该命名空间中的其他所有进程都会同步到该命名空间的变化操作实际上是对命名空间的操作进程的挂载点均是引用的这个命名空间的挂载点例如为的进程与为的进程是同一个命名空间此时在进程内进行操作进程与进程的信息都增加了一条本次的事件为条该命名空间增加了一条信息这两个进程引用这个命名空间所以这两个进程的挂载点都增加了如果两个进程不是共用同一个命名空间则只能通过共享组将事件传播到其他的命名空间中如果其他命名空间中没有该共享组的挂载点则无法接收到事件共享组在节讲述与主机侧其他大部分进程一样都是共用同一个命名空间以下简称主机侧如果要创建一个与这些进程不一样的命名空间的进程则可以通过以下命令实现新建了一个进程该进程的命名空间与其父进程的命名空间隔离查看点通过命令可以查看任意的进程的挂载点特别的通过可以查看当前进程的挂载点也可以使用命令查看挂载点树结构以上各参数代表的含义如下表示本次产生的为表示本次的为即本次的父挂载点不是父目录为第一个表示本次挂载的挂载源是根文件系统与后面的有关后面两个表示含义不同第一个表示文件系统第二个表示设备连起来挂载源可以理解为表示挂载点目录都是挂载属性与本次内容无关表示该挂载点为共享组组为同一列除了外还可能是表示此源自于传播产生的挂载如果没有此列表示为挂载产生具体见后文再比如根目录挂载表示本次产生的为表示本次的为即本次的父挂载点为第一个表示本次挂载的挂载源是根文件系统与后面的和有关表示文件系统类型为表示设备连起来挂载源可以理解为第二个表示挂载点目录都是挂载属性与本次内容无关表示该挂载点为共享组组为父子挂载点挂载点存在父子关系在内核的结构体中对应内核代码讲解见节例如在主机上存在以下一条挂载点信息在这条挂载信息中表示本次产生的为表示本次的为而这个在内核的处理中就是将其作为也就是本次的父挂载点的为而为的挂载点在主机上是根目录挂载如何判断父挂载点父挂载点是根据挂载点目录来进行确定的与之相对的共享组的确定是通过挂载源共享组的确定在节讲解判断方法是这样的在执行命令的进程命名空间中的挂载点目录中查找本次挂载的挂载点目录如果该挂载点目录已经被挂载过则设置本次挂载的父挂载点为上一次该挂载点目录的挂载点如果本次挂载的挂载点在命名空间中的挂载点目录中不存在则查找本次挂载点目录的父目录如果父目录在命名空间中存在则本次挂载的父挂载点就是该挂载点的父目录挂载时的挂载点这一段比较绕直接看例子例主机上存在挂载点创建一个新的挂载点在节有讲解挂载点这里不再赘述这条挂载点产生的流程如下在命名空间中的挂载点目录中查找发现该目录没有被挂载过继续第二步继续查找父目录即查找同样没有继续第三步继续查找没有被挂载过继续第四步查找发现有挂载点本次挂载点的父挂载点为所以本次挂载为例主机上存在刚刚挂载的挂载点将挂载到下这条挂载点产生的流程如下在命名空间中的挂载点目录中查找发现该目录没有被挂载过继续第二步继续查找父目录即查找命名空间中存在挂载点本次挂载点的父挂载点为所以本次挂载为共享组在生成挂载点的时候如果指定挂载属性为则不属于任何共享组如果设置为则存在一个父组如果设置为则属于组这个属性的关系如下图所示其中属性的挂载点则会在不同的命名空间中相互传播事件而属性的命名空间在产生事件时只会将该事件传播给该挂载点的子组不会传给父组而属性的挂载点只会影响到自己的命名空间不会传播给其他命名空间传播例如通过命令产生一个与主机隔离的命名空间为此时在主机上产生一个事件且为模式并且该组在为进程的命名空间中也存在则会传播例如在主机侧将目录挂载至目录下则会在主机侧产生一个挂载点该挂载点组属具体组属多少在下一节讲此时主机侧组属的挂载点有两个一个是新增的这个挂载点还有一个是的挂载点新增的这个挂载点通过共享组传播到了为命名空间中如果在上执行这一次挂载也会将挂载传播到主机侧是双向传播传播传播模式是单向传播模式事件只能从父组传递给子组不能从子组将事件反向传播给父组例如通过命令产生一个与主机隔离的命名空间为此时在主机上产生一个事件且为模式并且该组在为进程的命名空间中也存在对应的组则也会传播本次事件例如在主机侧将目录挂载至目录下则会在主机侧产生一个挂载点该挂载点组属此时主机侧组属的挂载点有两个一个是新增的这个挂载点还有一个是的挂载点新增的这个挂载点通过共享组传播到了为命名空间中传播组图如下所示如果在进程上执行这一次挂载则不会将挂载传播到主机侧这是因为在中的组是属于主机侧的的子组在模式下子组的挂载不会反向传播给父组模式是单向传播如何确定组属挂载时组属设置是根据挂载源进行设置先在执行命令的进程命名空间中的挂载点目录中查找该挂载源如果该挂载源已经被挂载过则设置组属为上一次挂载的组属否则继续查找挂载源的父目录直到找到上一次挂载这一段比较绕看例子例在主机上进行挂载点挂载本次挂载生成的挂载点组属为流程如下查找该进程命名空间挂载点目录是否有没有找到进行第二步查找该进程命名空间挂载点目录是否有没有找到进行第三步查找该进程命名空间挂载点目录是否有没有找到进行第四步查找该进程命名空间挂载点目录是否有找到为根目录挂载根目录挂载点的组属为设置本次挂载的组属也为挂载方式未指定默认为所以最终组属为例在主机上进行挂载点挂载组属为流程如下查找该进程命名空间挂载点目录是否有没有找到进行第二步查找该进程命名空间挂载点目录是否有找到为目录挂载挂载点的组属为设置本次挂载的组属也为挂载方式指定为所以最终组属为表示为组的子组的内核结构本节中列举出结构内容如读者对内核代码不感兴趣请跳过此节在内核中一个会产生一个结构体对象表示其定义如下内核靠链入链表是从该链表搜索结构和中靠把链入链表并且链入表的键值是父结构的成员该的挂载点父竟然设置为挂点目录所在文件系统的也说也是挂载源的的父是挂载点目录所在的文件系统的结构挂载点设置为挂载点目录包含块设备的根目录每个结构对应一个唯一的靠把结构添加到的的链表所以这个看着是的子结构保存的链表里根据返回其结构和靠把结构添加到的的链表创建的新并靠添加到该链表搞不懂有什么用把本次挂载的通过其链接到克隆母体的链表中把本次挂载属性的结构链接到克隆母体的链表结构的链表是保存子的凡是照着一个结构克隆生成的都添加到克隆母体的链表克隆的是母体子中把本次挂载属性的结构链接到克隆母体的链表中克隆母体是属性而本次没有指定属性则被添加到与克隆母体同一个组链表具体添加形式是结构靠其添加到克隆母体的链表和克隆母体靠各自的构成链表二者是同一个组成员如果靠其添加到克隆母体的链表则二者是父子关系不是同组关系中本次挂载是属性克隆生成的即其指向克隆母体的结构中本次挂载没有指定属性而克隆母体又是属性则的就是克隆母体的二者属于同一个组正常这样生成的其是的属性的其是所属命名空间中把结构添加到父的的链表挂载点结构包含挂载点中设置一个组里所有的结构的一样就是靠这个判断两个是否属于同一个每一次挂载块设备或者都要生成一个结构体结构每次挂载都生成一个作为本次挂载的是挂载点目录的所在文件系统的结构和是相对的现在的说不定下次就成了比如挂载到根目录假设本次挂载的结构是可以理解成根文件系统对应的结构是接着假设本次挂载生成是由于挂载点目录是根文件系统下的目录则是上次的即如果再接着有假设本次挂载的结构是由于挂载点目录是文件系统下的目录所以本次的是上次的即结构的成员指向其父结构所谓父子就是本次的挂载的和构成父子关系即容器下的起一个容器会在主机上产生一个容器的根文件系统挂载点这条挂载信息用命令行的方式实现则是如下简化一下这条挂载点是容器的根文件系统的挂载是将等挂载到目录下挂载源是等挂载点目录是挂载流程如下以挂载源生成一个结构体生成为将挂载点目录的父目录挂载时生成的作为本次挂载的结构体生成注意这里挂载点目录的父目录是没有挂载点再继续找父目录也没有挂载点再继续直到存在挂载点是将为的结构体作为本次的结构体本次挂载的生成由于本次挂载是根文件系统挂载所以新建一个本次生成的为由未指定参数默认为模式即中的传播属性在中有三个功能都涉及到传播第一个是时刻通过将主机的目录文件映射到容器内部第二个是创建容器根挂在点过程中第三个是在过程中下文将依次讲述过程分析在创建容器时刻可以通过主机侧容器侧传播属性实现将主机的目录文件映射到容器内部其中有一共种模式它们是系统调用的种传播模式字母表示会将挂载点的子挂载点一并挂载进容器默认情况下的参数为容器根目录传播模式与目录及其传播模式的关系启动容器根目录的传播模式和参数的传播模式参数的关系如下默认情况下容器内的根目录传播模式是挂载时有任一挂载点的传播模式设置为容器内的根目录传播模式是最高优先级挂载时没有挂载点有任一挂载点传播模式设置为时容器根目录的传播模式是挂载时没有挂载点中有根目录的父子等目录例如子或者父容器内根目录的传播模式为兄弟目录不影响例如目录传播模式容器内根目录传播模式有根目录的父子目录例如子父无指定的挂载点模式默认有任一指定为的挂载点指定挂载点为没有根目录的父子目录其他非根目录树的目录无指定的挂载点模式默认有任一指定为的挂载点指定为且无指定挂载点启动容器的流程分析执行命令主机源容器内目录传播模式命令执行过程创建容器执行挂载将容器根文件系统挂载到主机目录上传播模式为默认用命令行表述本次挂载行为则是主机创建容器的命名空间此命名空间采用方式与主机命名空间隔离此时容器内的挂载点存在以下两条将容器的根目录属性写入文件中读取文件并将容器根目录属性写入文件读取获得此时容器内的根文件系统的挂载属性此时容器内的根文件系统还是与主机上的一致是主机上的目录在容器内按照中的字段的值修改根文件系统的挂载属性用命令行表述本次挂载行为则是选择的值是根据中的字段的值来设置的查找的父挂载点如果父挂载点的挂载属性是则将其改为由于的父挂载点是主机根目录的挂载创建容器新的根文件系统挂载点将目录挂载到目录上执行本步骤的原因是为第步骤中的系统调用切换根文件系统挂载做准备本次挂载的父是即执行容器内必要目录的挂载主要有挂载目录这些目录为文件中的标签下的内容将这些内容挂载到目录下的对应路径例如挂载到挂载到执行系统调用切换文件系统以及重新挂载根文件系统用命令表述则是执行系统调用以后挂载点切换为容器根文件系统完成切换此时容器内的切换为之前的目录打开老根的文件描述符使用命令卸载老根及其子挂载点此时容器内只剩新建的挂载点完成挂载在和中的代码流程下面对流程中涉及到传播问题的函数进行讲解如果读者对和代码实现不感兴趣请移步下一节中的函数实现首先在中设置容器内根文件系统挂载传播属性这部分内容在中的函数中实现中的函数实现是实际上对容器内进行操作整个流程是在的函数中实现其中有个关键函数用于将老根设置为创建新根的挂载点将其他挂载点挂载到新根上将容器内的根文件系统切换到新根上随后卸载老根及其子挂载点将老根设置为创建新根的挂载点将其他挂载点挂载到新根上切换新根随后老根函数用于将老根设置为查找新根的父挂载点如果新根的父挂载点是则将其设置为防止在后面的函数中将其他挂载点挂载到新根的时候传播到主机侧创建新根的挂载点根据文件中的字段设置老根传播模式为如果父挂载点是则将其改为防止在后面的函数中把其他挂载点挂载到新根的时候传播到主机侧函数执行系统调用将容器内的根文件系统切换到新根原来的目录变为容器内的老根的文件描述符后面用于新根的文件描述符后面用于系统调用切换到新根路径系统调用将容器内的根文件系统切换到新根原来的目录变为容器内的切换到老根路径上卸载当前路径挂载点及其子挂载点即卸载老根及其自挂载点切换到新根完成容器内挂载点的挂载流程分析除去容器启动流程中涉及到挂载点传播问题在过程中也会涉及到挂载点传播问题下面将详细讲解的相关流程如果对内部实现流程不感兴趣的读者可直接跳至结论小节在代码流程总览下面对流程中涉及到的传播问题函数进行调用关系讲解客户端发送请求参数发送请求参数服务端收到请求收到请求真正的函数创建容器的时候函数会在主机上把容器根目录挂载上的时候该函数直接返回并赋值的时候也是只返回不会执行调用操作在这里执行操作在这里执行函数第一个参数等进行主机侧挂载点检测如果主机侧有挂载则返回如果没有则在该函数内进行挂载操作修改属性为函数进行主机侧挂载点检测或主机侧执行挂载调用函数在主机侧检查挂载点如果主机上有该挂载点则不再进行挂载如果不存在该挂载点则调用函数将其挂载到主机上即在主机侧读取的文件读取查找挂载点如果主机上有挂载点则不再二次挂载直接返回如果不存在以下挂载点则继续往下执行进行挂载目录例如查找函数执行系统调用即函数将挂载点及其子挂载点递归设置为如果这里不设置为则在后续的操作的时候会将主机侧的挂载点也掉此时挂载点已经挂载在主机上所以这里的返回相关函数卸载卷在实际操作流程本小节将介绍过程中和传播的实际流程不含代码的具体实现注意执行过程是在宿主机侧完成操作的是宿主机侧的命名空间前主机及容器状态起一个容器在执行前主机侧存在一个挂载点该挂载点是启动容器的时候挂载的容器根文件系统共享组为本次产生的为为为主机侧根文件系统挂载主机侧还存在及子目录的挂载点存在即这两条挂载信息的逻辑完全一致本文以为例省略的分析过程简化视图容器内存在根目录挂载点这条挂载点是从属于主机侧组传播模式为只能由其父组往下传播不能从子组往父组反向传播此时主机侧与容器内各个挂载点之间的关系如下图的第一次在主机侧进行第一次对应中的本次挂载属性是表示会将目录下的所有挂载点也挂载进去即也执行一次挂载这次挂载是在内核函数中以传播的形式完成非系统调用主机侧新增挂载点主机侧精简一下主机侧通过的传播模式传播至容器内导致容器内也出现挂载点容器侧精简一下此时的关系图如下的第二次操作修改挂载属性无实质挂载在主机侧进行第二次对应中的本次修改属性为表示会将目录下的所有挂载点的属性也修改为主机侧的挂载点信息变更为主机侧精简一下容器内的挂载点信息不变此时的关系如下图所示的操作在主机侧进行操作对应的传递给内核的参数是本次事件用命令行表达则是此时将事件传递给内核执行操作传播事件的流程因为事件会在过程中传递到目标点并通过传播属性找到需要同目标一同卸载的下面结合内核代码内核实现对过程中的过程及最终导致残留的原因进行讲解内核收到命令传来的系统调用传播过程及各挂载点关系如下图所示内核收到系统调用参数为因此内核执行函数将所有需要的挂载点添加到链表中等待入参表示所有待的子挂载为对象生成时刻的将当前加入成员组成的链表以为初始遍历的取出下一个对象找到的子也就是动作生成因为产生的对象由于事件是在主机侧产生因此遍历所有主机侧需要的挂载点先将主机侧需要卸载的挂载点添加进待卸载链表遍历共享组内的待卸载挂载点查找的方法是在内核函数内完成以为初始遍历的取出下一个对象表示主机侧的的表示父挂载点即为的挂载点执行函数查找挂载点的子组主机侧挂载点的子组是容器内的根目录挂载点查找容器内的挂载遍历的所有子挂载点并将其添加进待卸载链表再执行内核函数此时表示主机侧的的表示父挂载点即为的挂载点执行函数查找挂载点的子组由于已经是模式没有子组所以函数结束此时可以看到容器内部的挂载点并没有被添加到待卸载链表中在卸载的时候该链表不会被卸载将待卸载链表中的挂载点全部卸载此时主机侧的待卸载挂载点全部卸载卸载事件返回卸载成功但是容器内被添加到待卸载链表中的挂载点只有没有所以在卸载容器内的挂载点由于存在子挂载点无法卸载导致容器内两条挂载点全部残留流程总结将容器内的挂载点及其子挂载点挂载到主机的容器目录上主机上模式没有设置默认是如果容器内的根目录传播模式为则会传播进入容器容器内会出现这条挂载点及其子挂载点如果容器内的根目录传播模式为则不会传播进入容器容器内不会出现这条挂载点及其子挂载点实行真正的拷贝将主机侧的挂载点设置为属性修改属性不会进行操作不增加挂载点如果不将属性改为则会导致的时候把主机上该目录及其子目录全部卸载掉具体可见进行卸载挂载点由于改为了导致容器内残留讨论为何要设置为如果不将属性改为则会导致在主机侧进行系统调用的时候把主机上该目录及其子目录全部卸载掉命令在执行了第一次系统调用以后见此时的关系图如下如果不再进行一次调用设置传播属性为则会导致主机侧保持传播组此时如果对这一条挂载点进行卸载则会在组内传播挂载点的事件会导致主机上的及其子挂载点全部被卸载导致系统错误如果其他容器也挂载了该目录同时也连在组内那么其他容器也会收到本次事件导致事件大量传播所有收到事件的容器全部卸载目录总结命令操作过于繁重涉及大量系统调用生产环境使用中应当限制的大规模使用只让作为一个调测手段由开发人员使用因为作为调测手段而言人为操作后即便泄露的挂载点总量也可控限制容器的使用也是一种方法如果能保证所有都是且不包含根目录的父子目录那么也不会有问题参考文献官方文档内核过程超复杂的函数详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 16:22:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 1.05rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 1.05rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 1.05rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>41</sup></a><a href="/tags/network/" style="font-size: 1.05rem;">network<sup>9</sup></a><a href="/tags/pppoe/" style="font-size: 1.05rem;">pppoe<sup>1</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 1.05rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/container/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>container</span></a></span></div></div><h1 class="post-title" itemprop="name headline">docker cp mount挂载属性传播</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-07-15T12:15:00.000Z" title="发表于 2023-07-15 20:15:00">2023-07-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.043Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"><header><a href="/tags/container/" tabindex="-1" itemprop="url">container</a><h1 id="CrawlerTitle" itemprop="name headline">docker cp mount挂载属性传播</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2023-07-15T12:15:00.000Z" title="发表于 2023-07-15 20:15:00">2023-07-15</time><time itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.043Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></header><h1 id="1-问题结论"><a href="#1-问题结论" class="headerlink" title="1 问题结论"></a>1 问题结论</h1><p><code>docker cp</code>命令导致容器内<code>mount</code>挂载点残留，需同时满足以下3个条件：</p>
<ul>
<li>满足以下(1)或(2)条件中的任意一个</li>
</ul>
<p>  (1) 在所有的<code>-v</code>挂载目录，有<code>docker</code>根目录或<code>docker</code>根目录的父&#x2F;子目录。且，没有<code>-v</code>目录指定传播模式为<code>shared/rshared</code>。</p>
<p>   例如<code>-v /var/lib/docker</code>(<code>docker</code>根目录)或<code>-v /var/lib/docker/containerd</code>(<code>docker</code>根目录下的子目录)或<code>-v /var/lib</code>(<code>docker</code>根目录的父目录)</p>
<p>  (2) <code>-v</code>挂载目录中，指定挂载传播模式为<code>slave/rslave</code>，且没有任何一个传播模式设置为<code>shared/rshared</code></p>
<p>   例如：存在一条<code>-v /test:/home/test:rslave</code>，其他的<code>-v</code>挂载目录不指定模式或指定为<code>rslave/rprivate</code>，总之不能是<code>shared/rshared</code>。</p>
<ul>
<li><code>-v</code>挂载目录中，在主机上是挂载点，且有子挂载点。</li>
</ul>
<p>   例如：主机上存在挂载点<code>/</code>, <code>/var/run</code>和<code>/</code>, <code>/var/run/user/0</code>。则<code>-v /var/run:/var/run</code>则满足条件。如果<code>-v /var/run/user/0</code>则不满足该条件。</p>
<ul>
<li>使用<code>docker cp</code>命令拷贝任意文件进容器。</li>
</ul>
<h1 id="2-问题现象"><a href="#2-问题现象" class="headerlink" title="2 问题现象"></a>2 问题现象</h1><p>使用<code>docker run -v /var/run:/var/run:rslave</code>，将宿主机目录挂载进容器，该目录在宿主机上有子挂载点，然后再在宿主机上使用<code>docker cp</code>命令拷贝任意文件进入容器，此时容器内挂载点残留。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run --name mount-test -id -v /var/run:/var/run:rslave busybox:latest /bin/sh  </span></span><br><span class="line"><span class="comment"># docker exec -it mount-test sh  </span></span><br><span class="line">/ <span class="comment"># cat /proc/self/mountinfo | wc -l  </span></span><br><span class="line">38</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker cp 1.txt mount-test:/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker exec -it mount-test sh  </span></span><br><span class="line">/ <span class="comment"># cat /proc/self/mountinfo | wc -l  </span></span><br><span class="line">44</span><br></pre></td></tr></table></figure>

<p><code>docker cp</code>执行后，容器内的挂载点残留，导致挂载点增加（从38增加至44）。</p>
<h1 id="3-问题背景知识——linux-mount机制"><a href="#3-问题背景知识——linux-mount机制" class="headerlink" title="3 问题背景知识——linux mount机制"></a>3 问题背景知识——linux mount机制</h1><p>本章节介绍<code>Linux mount</code>命名空间相关知识，如果读者已熟悉相关内容请移步第四章。</p>
<h2 id="3-1-mnt命名空间"><a href="#3-1-mnt命名空间" class="headerlink" title="3.1 mnt命名空间"></a>3.1 mnt命名空间</h2><p><code>linux</code>上存在<code>mnt</code>命名空间，不同的进程可以有不同的<code>mnt</code>命名空间，也可以共用同一个命名空间。</p>
<p>可以通过<code>ls -l /proc/pid/ns</code>查看某个进程命名空间。特别的，可以使用<code>ls -l /proc/self/ns</code>查看当前进程的命名空间。其中的<code>mnt</code>表示<code>mnt</code>命名空间<code>id</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l /proc/1/ns</span></span><br><span class="line">total 0  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 ipc -&gt; ipc:[4026531839]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 mnt -&gt; mnt:[4026531840]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 net -&gt; net:[4026531956]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 pid -&gt; pid:[4026531836]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:37 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>

<p>当不同的进程共用同一个命名空间时，只要在该命名空间中有任意一个进程进行<code>mount</code>操作，在该命名空间中的其他所有进程都会同步到该命名空间的变化。<code>mount</code>操作实际上是对<code>mnt</code>命名空间的操作。进程的挂载点均是引用的这个<code>mnt</code>命名空间的挂载点。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l /proc/11811/ns   </span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:23 ipc -&gt; ipc:[4026532185]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:23 mnt -&gt; mnt:[4026532183]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:23 net -&gt; net:[4026532188]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:23 pid -&gt; pid:[4026532186]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:23 uts -&gt; uts:[4026532184]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/11859/ns</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 ipc -&gt; ipc:[4026532185]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 mnt -&gt; mnt:[4026532183]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 net -&gt; net:[4026532188]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 pid -&gt; pid:[4026532186]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 19:47 uts -&gt; uts:[4026532184]</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/11811/mountinfo | wc -l  </span></span><br><span class="line">44</span><br><span class="line"><span class="comment"># cat /proc/11859/mountinfo | wc -l  </span></span><br><span class="line">44</span><br><span class="line"><span class="comment"># cat /proco | wc -l  </span></span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p><code>pid</code>为<code>11811</code>的进程与<code>pid</code>为<code>11859</code>的进程是同一个<code>mnt</code>命名空间，此时，在<code>11811</code>进程内进行<code>mount</code>操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount --rbind 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/11811/mountinfo | wc -l  </span></span><br><span class="line">45  </span><br><span class="line">[root@v5 ~]/11859/mountinfo | <span class="built_in">wc</span> -l  </span><br><span class="line">45 </span><br></pre></td></tr></table></figure>

<p><code>11859</code>进程与<code>11811</code>进程的<code>mount</code>信息都增加了一条。本次<code>mount</code>的<code>mount</code>事件为1条，该<code>mnt</code>命名空间增加了一条<code>mount</code>信息，这两个进程引用这个<code>mn</code>t命名空间，所以这两个进程的<code>mount</code>挂载点都增加了。</p>
<p>如果两个进程不是共用同一个命名空间，则只能通过<strong>共享组</strong>，将<code>mount</code>事件传播到其他的<code>mnt</code>命名空间中。如果其他<code>mnt</code>命名空间中没有该共享组的挂载点，则无法接收到<code>mount</code>事件。共享组在3.4节讲述。</p>
<p><code>dockerd</code>、<code>shim</code>与主机侧其他大部分进程一样，都是共用同一个命名空间，以下简称主机侧。</p>
<p>如果要创建一个与这些进程不一样的命名空间的进程，则可以通过以下命令实现：</p>
<p><code>unshare --mount --propagation slave sh</code>  </p>
<p>新建了一个<code>sh</code>进程，该进程的<code>mnt</code>命名空间与其父进程的<code>mnt</code>命名空间隔离。</p>
<h2 id="3-2-查看mount点"><a href="#3-2-查看mount点" class="headerlink" title="3.2 查看mount点"></a>3.2 查看mount点</h2><p>通过命令<code>cat /proc/pid/mountinfo</code>可以查看任意<code>pid</code>的进程的挂载点。特别的，通过<code>cat /proc/self/mountinfo</code>可以查看当前进程的挂载点。也可以使用<code>findmnt</code>命令查看挂载点树结构。</p>
<h3 id="3-2-1-cat-proc-self-mountinfo"><a href="#3-2-1-cat-proc-self-mountinfo" class="headerlink" title="3.2.1 cat /proc/self/mountinfo"></a>3.2.1 <code>cat /proc/self/mountinfo</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/self/mountinfo   </span></span><br><span class="line">17 38 0:16 / /sys rw,nosuid,nodev,noexec,relatime shared:6 - sysfs sysfs rw,seclabel  </span><br><span class="line">18 38 0:3 / /proc rw,nosuid,nodev,noexec,relatime shared:5 - proc proc rw  </span><br><span class="line">19 38 0:5 / /dev rw,nosuid shared:2 - devtmpfs devtmpfs rw,seclabel,size=1929988k,nr_inodes=482497,mode=755  </span><br><span class="line">20 17 0:15 / /sys/kernel/security rw,nosuid,nodev,noexec,relatime shared:7 - securityfs securityfs rw  </span><br><span class="line">21 19 0:17 / /dev/shm rw,nosuid,nodev,noexec,relatime shared:3 - tmpfs tmpfs rw,seclabel  </span><br><span class="line">22 19 0:11 / /dev/pts rw,nosuid,noexec,relatime shared:4 - devpts devpts rw,seclabel,gid=5,mode=620,ptmxmode=000  </span><br><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">24 17 0:19 / /sys/fs/cgroup ro,nosuid,nodev,noexec shared:8 - tmpfs tmpfs ro,seclabel,mode=755  </span><br><span class="line">25 24 0:20 / /sys/fs/cgroup/systemd rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd  </span><br><span class="line">26 17 0:21 / /sys/fs/pstore rw,nosuid,nodev,noexec,relatime shared:20 - pstore pstore rw  </span><br><span class="line">27 24 0:22 / /sys/fs/cgroup/perf_event rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,perf_event  </span><br><span class="line">28 24 0:23 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,memory  </span><br><span class="line">29 24 0:24 / /sys/fs/cgroup/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,cpuacct,cpu  </span><br><span class="line">30 24 0:25 / /sys/fs/cgroup/blkio rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,blkio  </span><br><span class="line">31 24 0:26 / /sys/fs/cgroup/pids rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,pids  </span><br><span class="line">32 24 0:27 / /sys/fs/cgroup/cpuset rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,cpuset  </span><br><span class="line">33 24 0:28 / /sys/fs/cgroup/devices rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,devices  </span><br><span class="line">34 24 0:29 / /sys/fs/cgroup/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,net_prio,net_cls  </span><br><span class="line">35 24 0:30 / /sys/fs/cgroup/freezer rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,freezer  </span><br><span class="line">36 24 0:31 / /sys/fs/cgroup/hugetlb rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,hugetlb  </span><br><span class="line">37 17 0:32 / /sys/kernel/config rw,relatime shared:21 - configfs configfs rw  </span><br><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota  </span><br><span class="line">39 17 0:14 / /sys/fs/selinux rw,relatime shared:22 - selinuxfs selinuxfs rw  </span><br><span class="line">40 18 0:33 / /proc/sys/fs/binfmt_misc rw,relatime shared:24 - autofs systemd-1 rw,fd=30,pgrp=1,<span class="built_in">timeout</span>=0,minproto=5,maxproto=5,direct,pipe_ino=12631  </span><br><span class="line">41 19 0:13 / /dev/mqueue rw,relatime shared:25 - mqueue mqueue rw,seclabel  </span><br><span class="line">42 19 0:34 / /dev/hugepages rw,relatime shared:26 - hugetlbfs hugetlbfs rw,seclabel  </span><br><span class="line">43 17 0:6 / /sys/kernel/debug rw,relatime shared:27 - debugfs debugfs rw  </span><br><span class="line">44 38 0:35 / /tmp rw,nosuid,nodev,noexec shared:28 - tmpfs tmpfs rw,seclabel  </span><br><span class="line">45 38 8:1 / /boot rw,relatime shared:29 - xfs /dev/sda1 rw,seclabel,attr2,inode64,noquota  </span><br><span class="line">47 23 0:37 / /run/user/0 rw,nosuid,nodev,relatime shared:30 - tmpfs tmpfs rw,seclabel,size=388124k,mode=700</span><br></pre></td></tr></table></figure>

<p>以上各参数代表的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<ul>
<li><p>23表示本次<code>mount</code>产生的<code>source mount id</code>为23</p>
</li>
<li><p>38表示本次<code>mount</code>的<code>dest mount id</code>为38，即本次mount的父挂载点（不是父目录）<code>mount id</code>为38</p>
</li>
<li><p>第一个<code>/</code>表示本次挂载的挂载源，是根文件系统，与后面的<code>tmpfs</code>有关，后面两个<code>tmpfs</code>表示含义不同</p>
<ul>
<li><p>第一个<code>tmpfs</code>表示<code>tmpfs</code>文件系统</p>
</li>
<li><p>第二个<code>tmpfs</code>表示<code>tmpfs</code>设备。连起来，挂载源可以理解为，<code>/tmpfs/tmpfs/</code></p>
</li>
</ul>
</li>
<li><p>&#x2F;run表示挂载点目录</p>
</li>
<li><p><code>rw,nosuid,nodev</code>都是挂载属性，与本次mount内容无关</p>
</li>
<li><p><code>shared:23</code>表示，该挂载点为<code>shared</code>共享组，组<code>id</code>为23（同一列除了<code>shared</code>外还可能是<code>master：id</code> ，表示此<code>mount</code>源自于<code>slave</code>传播产生的挂载，如果没有此列表示为<code>private</code>挂载产生，具体见后文）</p>
</li>
</ul>
<p>再比如，根目录挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<ul>
<li><p>38表示本次<code>mount</code>产生的<code>source mount id</code>为38</p>
</li>
<li><p>1表示本次<code>mount</code>的<code>dest mount id</code>为1，即本次<code>mount</code>的父挂载点<code>mount id</code>为1</p>
</li>
<li><p>第一个<code>/</code>表示本次挂载的挂载源，是根文件系统，与后面的<code>xfs</code>和<code>/dev/mapper/ncl-root</code>有关，<code>xfs</code>表示文件系统类型为<code>xfs</code>，<code>/dev/mapper/ncl-root</code>表示设备。连起来，挂载源可以理解为，<code>/dev/mapper/ncl-root/xfs/</code>。第二个<code>/</code>表示挂载点目录。<code>rw,relatime</code>都是挂载属性，与本次<code>mount</code>内容无关。<code>shared:1</code>表示，该挂载点为<code>shared</code>共享组，组<code>id</code>为1。</p>
</li>
</ul>
<h3 id="3-2-2-findmnt"><a href="#3-2-2-findmnt" class="headerlink" title="3.2.2 findmnt"></a>3.2.2 <code>findmnt</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># findmnt</span><br><span class="line"></span><br><span class="line">TARGET                                SOURCE     FSTYPE    OPTIONS  </span><br><span class="line">/                                     /dev/mapper/ncl-root  </span><br><span class="line"> xfs       rw,relatime,seclabel,attr2,inode64,  </span><br><span class="line">├─/sys                                sysfs      sysfs     rw,nosuid,nodev,noexec,relatime,sec  </span><br><span class="line">│ ├─/sys/kernel/security              securityfs securityf rw,nosuid,nodev,noexec,relatime  </span><br><span class="line">│ ├─/sys/fs/cgroup                    tmpfs      tmpfs     ro,nosuid,nodev,noexec,seclabel,mod  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/systemd          cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,xat  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/perf_event       cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,per  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/memory           cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,mem  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/cpu,cpuacct      cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,cpu  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/blkio            cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,blk  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/pids             cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,pid  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/cpuset           cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,cpu  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/devices          cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,dev  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/net_cls,net_prio cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,net  </span><br><span class="line">│ │ ├─/sys/fs/cgroup/freezer          cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,fre  </span><br><span class="line">│ │ └─/sys/fs/cgroup/hugetlb          cgroup     cgroup    rw,nosuid,nodev,noexec,relatime,hug  </span><br><span class="line">│ ├─/sys/fs/pstore                    pstore     pstore    rw,nosuid,nodev,noexec,relatime  </span><br><span class="line">│ ├─/sys/kernel/config                configfs   configfs  rw,relatime  </span><br><span class="line">│ ├─/sys/fs/selinux                   selinuxfs  selinuxfs rw,relatime  </span><br><span class="line">│ └─/sys/kernel/debug                 debugfs    debugfs   rw,relatime  </span><br><span class="line">├─/proc                               proc       proc      rw,nosuid,nodev,noexec,relatime  </span><br><span class="line">│ └─/proc/sys/fs/binfmt_misc          systemd-1  autofs    rw,relatime,fd=30,pgrp=1,timeout=0,  </span><br><span class="line">├─/dev                                devtmpfs   devtmpfs  rw,nosuid,seclabel,size=1929988k,nr  </span><br><span class="line">│ ├─/dev/shm                          tmpfs      tmpfs     rw,nosuid,nodev,noexec,relatime,sec  </span><br><span class="line">│ ├─/dev/pts                          devpts     devpts    rw,nosuid,noexec,relatime,seclabel,  </span><br><span class="line">│ ├─/dev/mqueue                       mqueue     mqueue    rw,relatime,seclabel  </span><br><span class="line">│ └─/dev/hugepages                    hugetlbfs  hugetlbfs rw,relatime,seclabel  </span><br><span class="line">├─/run                                tmpfs      tmpfs     rw,nosuid,nodev,seclabel,mode=755  </span><br><span class="line">│ └─/run/user/0                       tmpfs      tmpfs     rw,nosuid,nodev,relatime,seclabel,s  </span><br><span class="line">├─/tmp                                tmpfs      tmpfs     rw,nosuid,nodev,noexec,seclabel  </span><br><span class="line">└─/boot                               /dev/sda1  xfs       rw,relatime,seclabel,attr2,inode64,</span><br></pre></td></tr></table></figure>

<h2 id="3-3-父子挂载点"><a href="#3-3-父子挂载点" class="headerlink" title="3.3 父子挂载点"></a>3.3 父子挂载点</h2><p>挂载点存在父子关系，在内核的<code>mount</code>结构体中，对应<code>mnt_parent</code>，内核代码讲解见3.5节。</p>
<p>例如，在主机上存在以下一条挂载点信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>在这条挂载信息中</p>
<ul>
<li><p>23表示本次<code>mount</code>产生的<code>source mount id</code>为23</p>
</li>
<li><p>38表示本次<code>mount</code>的<code>dest mount id</code>为38，而这个<code>dest mount</code>在内核的处理中，就是将其作<code>为mnt_parent</code>，也就是本次<code>mount</code>的父挂载点的<code>id</code>为38。而<code>id</code>为38的挂载点在主机上是根目录挂载。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-如何判断父挂载点"><a href="#3-3-1-如何判断父挂载点" class="headerlink" title="3.3.1 如何判断父挂载点"></a>3.3.1 如何判断父挂载点</h3><p>父挂载点是根据挂载点目录来进行确定的。与之相对的，共享组的确定是通过挂载源，共享组的确定在3.4节讲解。</p>
<p>判断方法是这样的，在执行mount命令的进程mnt命名空间中的挂载点目录中，查找本次挂载的挂载点目录，如果该挂载点目录已经被挂载过，则设置本次挂载的父挂载点为上一次该挂载点目录的挂载点。如果本次挂载的挂载点在mnt命名空间中的挂载点目录中不存在，则查找本次挂载点目录的父目录，如果父目录在mnt命名空间中存在，则本次挂载的父挂载点就是该挂载点的父目录挂载时的挂载点。这一段比较绕，直接看例子。  </p>
<p>例1：</p>
<p>主机上存在挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<p>创建一个新的tmpfs挂载点，在3.2节有讲解tmpfs挂载点，这里不再赘述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount -t tmpfs tmpfs /root/mount-test/run  </span><br><span class="line">51 38 0:39 / /root/mount-test/run rw,relatime shared:31 - tmpfs tmpfs rw,seclabel </span><br></pre></td></tr></table></figure>

<p>这条挂载点产生的流程如下：</p>
<ul>
<li><p>在<code>mnt</code>命名空间中的挂载点目录中查找<code>/root/mount-test/run</code>，发现该目录没有被挂载过，继续第二步</p>
</li>
<li><p>继续查找父目录，即查找<code>/root/mount-test</code>，同样没有，继续第三步</p>
</li>
<li><p>继续查找<code>/roo</code>t，没有被挂载过，继续第四步</p>
</li>
<li><p>查找<code>/</code>，发现有挂载点<code>38 1 / /</code></p>
</li>
<li><p>本次挂载点的父挂载点为38。所以本次挂载为<code>51 38 / /root/mount-test/run</code></p>
</li>
</ul>
<p>例2：</p>
<p>主机上存在刚刚挂载的<code>/root/mount-test/run</code>挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51 38 0:39 / /root/mount-test/run rw,relatime shared:31 - tmpfs tmpfs rw,seclabel</span><br></pre></td></tr></table></figure>

<p>将<code>/var/run/user</code>挂载到<code>/root/mount-test/run/user</code>下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount --rbind /var/run/user /root/mount-test/run/user  </span><br><span class="line">53 51 0:18 /user /root/mount-test/run/user rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>这条挂载点产生的流程如下：</p>
<ul>
<li><p>在mnt命名空间中的挂载点目录中查找<code>/root/mount-test/run/user</code>，发现该目录没有被挂载过，继续第二步</p>
</li>
<li><p>继续查找父目录，即查找<code>/root/mount-test/run</code>，<code>mnt</code>命名空间中存在<code>51 38 / /root/mount-test/run</code>挂载点。</p>
</li>
<li><p>本次挂载点的父挂载点为51。所以本次挂载为<code>53 51 /user /root/mount-test/run/user</code></p>
</li>
</ul>
<h2 id="3-4-共享组"><a href="#3-4-共享组" class="headerlink" title="3.4 共享组"></a>3.4 共享组</h2><p>在生成挂载点的时候，如果指定挂载属性为<code>private/rprivate</code>，则不属于任何共享组。如果设置为<code>slave/rslave</code>，则存在一个父组。如果设置为<code>shared/rshared</code>，则属于<code>shared</code>组。</p>
<p>这3个属性的关系如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iIEFob.jpeg" alt="propagations.jpg" title="propagations.jpg">    </p>
<p>其中，<code>shared</code>属性的挂载点，则会在不同的命名空间中相互传播<code>mount</code>事件。而<code>slave</code>属性的命名空间在产生<code>mount</code>事件时，只会将该<code>mount</code>事件传播给该挂载点的子组，不会传给父组。而<code>private</code>属性的挂载点，只会影响到自己的命名空间，不会传播给其他命名空间。</p>
<h3 id="3-4-1-shared传播"><a href="#3-4-1-shared传播" class="headerlink" title="3.4.1 shared传播"></a>3.4.1 shared传播</h3><p>例如，通过<code>unshare</code>命令产生一个与主机隔离的<code>shared</code>命名空间，<code>pid</code>为<code>12172</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># unshare --mount --propagation shared /bin/sh</span><br><span class="line"></span><br><span class="line"># cat /proc/12172/ns  </span><br><span class="line">total 0  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 ipc -&gt; ipc:[4026531839]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 mnt -&gt; mnt:[4026532244]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 net -&gt; net:[4026531956]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 pid -&gt; pid:[4026531836]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:07 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br><span class="line"># ls -l /protal 0  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 ipc -&gt; ipc:[4026531839]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 mnt -&gt; mnt:[4026531840]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 net -&gt; net:[4026531956]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 pid -&gt; pid:[4026531836]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:08 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>

<p>此时，在主机上产生一个<code>mount</code>事件，且为<code>shared</code>模式，并且该<code>shared</code>组在<code>pid</code>为<code>12172</code>进程的命名空间中也存在，则会传播。</p>
<p>例如，在主机侧，将<code>/run/user</code>目录挂载至<code>/root/mount-test/3</code>目录下，则会在主机侧产生一个挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount --bind /run/user /root/mount-test/3</span><br><span class="line">135 38 0:18 /user /root/mount-test/3 rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>该挂载点组属<code>shared:23</code>，具体组属多少，在下一节讲。此时，主机侧组属<code>shared:23</code>的挂载点有两个，一个是新增的这个<code>/root/mount-test/3</code>挂载点，还有一个是<code>/run</code>的挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/self/mountinfo | grep shared:23</span><br><span class="line"></span><br><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">135 38 0:18 /user /root/mount-test/3 rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>新增的这个<code>/root/mount-test/3</code>挂载点通过<code>shared:23</code>共享组，传播到了<code>pid</code>为<code>12172</code>命名空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/self/mountinfo | grep shared:23 </span><br><span class="line"></span><br><span class="line">128 56 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">136 56 0:18 /user /root/mount-test/3 rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>如果在<code>12172</code>上执行这一次挂载，也会将挂载传播到主机侧。<code>shared</code>是双向传播。</p>
<h3 id="3-4-2-slave传播"><a href="#3-4-2-slave传播" class="headerlink" title="3.4.2 slave传播"></a>3.4.2 slave传播</h3><p><code>slave</code>传播模式是单向传播模式，<code>mount/umount</code>事件只能从父组传递给子组，不能从子组将<code>mount/umount</code>事件反向传播给父组。</p>
<p>例如，通过<code>unshare</code>命令产生一个与主机隔离的<code>shared</code>命名空间，<code>pid</code>为<code>12214</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># unshare --mount --propagation slave /bin/sh</span><br><span class="line"></span><br><span class="line"># cat /proc/12214/ns  </span><br><span class="line">total 0  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 ipc -&gt; ipc:[4026531839]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 mnt -&gt; mnt:[4026532244]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 net -&gt; net:[4026531956]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 pid -&gt; pid:[4026531836]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 uts -&gt; uts:[4026531838]  </span><br><span class="line"></span><br><span class="line"># ls -l /protal 0  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 ipc -&gt; ipc:[4026531839]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 mnt -&gt; mnt:[4026531840]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 net -&gt; net:[4026531956]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 pid -&gt; pid:[4026531836]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 user -&gt; user:[4026531837]  </span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 10 21:23 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>

<p>此时，在主机上产生一个<code>mount</code>事件，且为<code>shared</code>模式，并且该<code>shared</code>组在<code>pid</code>为<code>12214</code>进程的命名空间中也存在对应的<code>master</code>组，则也会传播本次<code>mount</code>事件。</p>
<p>例如，在主机侧，将<code>/run/user</code>目录挂载至<code>/root/mount-test/3</code>目录下，则会在主机侧产生一个挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount --bind /run/user /root/mount-test/3</span><br><span class="line"></span><br><span class="line">135 38 0:18 /user /root/mount-test/3 rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>该挂载点组属<code>shared:23</code>。此时，主机侧组属<code>shared:23</code>的挂载点有两个，一个是新增的这个<code>/root/mount-test/3</code>挂载点，还有一个是<code>/run</code>的挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/self/mountinfo | grep shared:23</span><br><span class="line"></span><br><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">135 38 0:18 /user /root/mount-test/3 rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>新增的这个<code>/root/mount-test/3</code>挂载点通过<code>shared:23</code>共享组，传播到了<code>pid</code>为<code>12214</code>命名空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/self/mountinfo | grep master:23   </span><br><span class="line">128 56 0:18 / /run rw,nosuid,nodev master:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">136 56 0:18 /user /root/mount-test/3 rw,nosuid,nodev master:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>传播组图如下所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iIEFob.jpeg" alt="shared-slave.jpg" title="shared-slave.jpg">    </p>
<p>如果在<code>12214</code>进程上执行这一次挂载，则不会将挂载传播到主机侧。这是因为在<code>12214</code>中的<code>master:23</code>组，是属于主机侧的<code>shared:23</code>的子组，在<code>slave</code>模式下，子组的挂载不会反向传播给父组。<code>slave</code>模式是单向传播。</p>
<h3 id="3-4-3-如何确定组属"><a href="#3-4-3-如何确定组属" class="headerlink" title="3.4.3 如何确定组属"></a>3.4.3 如何确定组属</h3><p>挂载时，组属设置是根据挂载源进行设置。先在执行<code>mount</code>命令的进程<code>mnt</code>命名空间中的挂载点目录中，查找该挂载源，如果该挂载源已经被挂载过，则设置组属为上一次挂载的组属。否则，继续查找挂载源的父目录，直到找到上一次挂载。这一段比较绕，看例子</p>
<p>例1，在主机上进行挂载点挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount --bind /root/mount-test/1 /root/mount-test/2  </span><br><span class="line">74 38 253:0 /root/mount-test/1 /root/mount-test/2 rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<p>本次挂载生成的挂载点组属为<code>shared:1</code>。</p>
<p>流程如下：</p>
<ul>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有<code>/root/mount-test/1</code>。没有找到，进行第二步</p>
</li>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有<code>/root/mount-test</code>。没有找到，进行第三步</p>
</li>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有&#x2F;root。没有找到，进行第四步</p>
</li>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有<code>/</code>。找到，为根目录挂载，根目录挂载点的组属为<code>shared:1</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<ul>
<li>设置本次挂载的组属也为1，挂载方式未指定，默认为<code>shared</code>，所以最终组属为<code>shared:1</code>。</li>
</ul>
<p>例2，在主机上进行挂载点挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount --bind --make-slave /run/user /mount-test/3  </span><br><span class="line">75 38 0:18 /user /root/mount-test/3 rw,nosuid,nodev master:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<p>组属为<code>shared:23</code>。</p>
<p>流程如下：</p>
<ul>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有<code>/run/user</code>。没有找到，进行第二步</p>
</li>
<li><p>查找该进程<code>mnt</code>命名空间，<code>dest_dir</code>挂载点目录是否有<code>/run</code>。找到，为<code>/run</code>目录挂载，挂载点的组属为<code>shared:23</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<ul>
<li>设置本次挂载的组属也为<code>23</code>，挂载方式指定为<code>slave</code>，所以最终组属为<code>master:23</code>，表示为组<code>shared:23</code>的<code>slave</code>子组。</li>
</ul>
<h2 id="3-5-mount的内核结构"><a href="#3-5-mount的内核结构" class="headerlink" title="3.5 mount的内核结构"></a>3.5 mount的内核结构</h2><p>本节中列举出<code>mount</code>结构内容，如读者对内核代码不感兴趣请跳过此节。在内核中一个<code>moun</code>t会产生一个<code>mount</code>结构体对象表示，其定义如下（3-10内核）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span>  </span><br><span class="line"> <span class="comment">/*mount靠mnt_hash链入mount hash链表，__lookup_mnt()是从该mount hash链表 </span></span><br><span class="line"><span class="comment">    搜索mount结构。commit_tree()和attach_mnt()中靠mnt_hash把mount链入mount hash </span></span><br><span class="line"><span class="comment">    链表，并且链入hash表的键值是(父mount结构的vfsmount成员+该mount的挂载点dentry)*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_hash</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*父mount,attach_recursive_mnt-&gt;mnt_set_mountpoint(),竟然设置为挂点目录所 </span></span><br><span class="line"><span class="comment">     在文件系统的mount，也说也是，挂载源的mount的父mount是挂载点目录所在的文件系统的mount结构*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*挂载点dentry，attach_recursive_mnt-&gt;mnt_set_mountpoint()设置为挂载点目录dentry*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//包含块设备的根目录dentry，每个mount结构对应一个唯一的vfsmount。  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*commit_tree()靠mnt_child把mount结构添加到mount的parent mount的 </span></span><br><span class="line"><span class="comment">    mnt_mounts链表，所以这个看着是mount的子mount结构保存的链表*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*next_mnt()里根据mnt_child返回其mount结构，commit_tree()和attach_mnt()靠 </span></span><br><span class="line"><span class="comment">    mnt_child把mount结构添加到mount的mnt_parent的mnt_mounts链表*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//copy_tree()创建的新mount并靠mnt_list添加到该链表，搞不懂有什么用?  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//clone_mnt()把本次挂载的source mount通过其mnt_share链接到克隆母体的mnt_share链表  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*clone_mnt()中，把本次挂载slave属性的source mount结构链接到克隆母体mount </span></span><br><span class="line"><span class="comment">    的mnt_slave_list链表。mount结构的mnt_slave_list链表是保存子slave mount的，凡 </span></span><br><span class="line"><span class="comment">    是照着一个mount结构克隆生成的mount，都添加到克隆母体的mnt_slave_list链表，克 </span></span><br><span class="line"><span class="comment">    隆的mount是母体子slave mount*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 1 clone_mnt()中，把本次挂载source slave属性的mount结构链接到克隆母体mount  </span></span><br><span class="line"><span class="comment"> 的mnt_slave_list链表2 clone_mnt()中，克隆母体是slave属性而本次source mount没  </span></span><br><span class="line"><span class="comment"> 有指定属性，则source mount被添加到与克隆母体同一个mount salve组链表具体添加形  </span></span><br><span class="line"><span class="comment"> 式是，source mount结构靠其mnt_slave添加到克隆母体的mnt_slave链表。source mount  </span></span><br><span class="line"><span class="comment"> 和克隆母体靠各自的mnt_slave构成链表,二者是同一个mount slave组成员。如果source  </span></span><br><span class="line"><span class="comment"> mount靠其mnt_slave添加到克隆母体的mnt_slave_list链表，则二者是父子关系，不是同组关系。*/</span> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 1 clone_mnt()中，本次挂载是slave属性，克隆生成的source mount，即mnt，其  </span></span><br><span class="line"><span class="comment"> mnt_master指向克隆母体的mount结构。2 clone_mnt()中，本次挂载没有指定mount属性，  </span></span><br><span class="line"><span class="comment"> 而克隆母体又是slave属性，则souece mount的mnt_master就是克隆母体的  </span></span><br><span class="line"><span class="comment"> mount-&gt;mnt_master，二者属于同一个mount slave组。3 正常mount /dev/sda3 /home这  </span></span><br><span class="line"><span class="comment"> 样生成的mount其mnt_master是NULL，mount bind的share属性的mount其mnt_master是NULL*/</span>  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_master</span>;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//mount所属命名空间，commit_tree()中把mount结构添加到父mount的mnt_ns的list链表  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>  </span><br><span class="line"> <span class="comment">//挂载点结构，包含挂载点dentry，attach_recursive_mnt-&gt;mnt_set_mountpoint()中设置  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mnt_mp</span>;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//mount group id，一个mount组里，所有的mount结构的mnt_group_id一样.就是靠这个判断两个mount是否属于同一个peer group  </span></span><br><span class="line"> <span class="type">int</span> mnt_group_id;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每一次<code>mount</code>挂载块设备或者<code>tmpfs</code>都要生成一个<code>mount</code>结构体。<code>mount</code>结构每次<code>mount</code>挂载都生成一个，作为本次挂载的<code>source mount</code>，<code>dest mount</code>是挂载点目录的所在文件系统的<code>mount</code>结构。<code>source mount</code>和<code>dest mount</code>是相对的，现在的<code>source mount</code>说不定下次就成了<code>dest mount</code>。比如<code>mount -t ext4 /dev/sda1 /</code>挂载到根目录，假设本次挂载<code>sda1</code>的<code>source mount</code>结构是<code>mount1</code>，可以理解成根文件系统对应的<code>mount</code>结构是<code>mount1</code>。接着<code>mount -t ext4 /dev/sda3 /home/</code>，假设本次挂载<code>sda3</code>生成<code>source mount</code>是<code>mount2</code>，由于挂载点目录<code>/home</code>是根文件系统下的目录，则<code>dest mount</code>是上次的<code>source mount</code>，即<code>mount1</code>。如果再接着有<code>mount -t ext4 /dev/sda5 /home/test</code>，假设本次挂载<code>sda5</code>的<code>source mount</code>结构是<code>mount3</code>，由于挂载点目录<code>/home/test</code>是<code>sda3 ext4</code>文件系统下的<code>test</code>目录，所以本次的<code>dest mount</code>是上次的<code>source mount</code>，即<code>mount2</code>。</p>
</li>
<li><p><code>mount</code>结构的成员<code>struct mount *mnt_parent</code>指向其父<code>mount</code>结构，所谓父子<code>mount</code>就是本次的挂载的<code>source mount</code>和<code>dest mount</code>构成父子关系，即<code>source mount-&gt;mnt_parent=dest mount</code>。</p>
</li>
</ul>
<h2 id="3-6-docker容器下的mount"><a href="#3-6-docker容器下的mount" class="headerlink" title="3.6 docker容器下的mount"></a>3.6 docker容器下的mount</h2><p>起一个容器，会在主机上产生一个容器的根文件系统挂载点：</p>
<p><code>48 38 0:38 / /var/lib/docker/overlay2/1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1/merged rw,relatime shared:32 - overlay overlay rw,context=&quot;system_u:object_r:container_file_t:s0:c141,c217&quot;,lowerdir=/var/lib/docker/overlay2/l/MYJKEQPHQPEBBVM5EM4L5GWM7L:/var/lib/docker/overlay2/l/O5E22LECDUO27ISLIQMO4LQB74,upperdir=/var/lib/docker/overlay2/1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1/diff,workdir=/var/lib/docker/overlay2/1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1/work</code></p>
<p>这条挂载信息用命令行的方式实现则是如下：</p>
<p>&#96;mount -t overlay overlay -o lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;MYJKEQPHQPEBBVM5EM4L5GWM7L:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;O5E22LECDUO27ISLIQMO4LQB74,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1&#x2F;work &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;1a7c8c803d0c23da694b1c0aa19589d346f07a5f871fc76f1a2bc8870a22edf1&#x2F;merged&#96;&#96;</p>
<p>简化一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t overlay overlay -o lowerdir=xxx/lowerdir,upperdir=xxx/upperdir,workdir=xxx/workdir xxx/merged</span><br></pre></td></tr></table></figure>

<p>这条挂载点是容器的根文件系统的挂载，是将<code>xxx/lowerdir/overlay/</code>等挂载到<code>xxx/merged</code>目录下。挂载源<code>source</code>是<code>xxx/lowerdir</code>等，挂载点目录是<code>xxx/merged</code>。</p>
<p>挂载流程如下：</p>
<ul>
<li><p>以挂载源<code>xxx/lowerdir,xxx/upperdir,xxx/workdir</code>生成一个<code>source mount</code>结构体，生成<code>mount id</code>，为48</p>
</li>
<li><p>将挂载点目录<code>/var/lib/docker/overlay2/id/merged</code>的父目录挂载时生成的<code>source mount</code>作为本次挂载的<code>dest mount</code>结构体，生成<code>dest mount id</code>。</p>
</li>
</ul>
<p>注意，这里挂载点目录<code>/var/lib/docker/overlay2/id/merged</code>的父目录是<code>/var/lib/docker/overlay2/id</code>，没有挂载点，再继续找父目录，也没有挂载点，再继续。直到<code>/</code>，存在挂载点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38 1 253:0 / / rw,relatime shared:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota</span><br></pre></td></tr></table></figure>

<p><code>mount id</code>是38。将<code>source mount id</code>为38的<code>moun</code>t结构体作为本次<code>mount</code>的<code>dest mount</code>结构体。本次挂载的<code>48 38</code>生成。</p>
<ul>
<li>由于本次挂载是根文件系统挂载，所以新建一个<code>mount peer group</code>。本次生成的<code>group id</code>为32，由<code>mount</code>未指定<code>propagation</code>参数，默认为<code>shared</code>模式，即<code>shared:32</code>。</li>
</ul>
<h1 id="4-docker中的mount传播属性"><a href="#4-docker中的mount传播属性" class="headerlink" title="4 docker中的mount传播属性"></a>4 docker中的mount传播属性</h1><p>在<code>docker</code>中有三个功能都涉及到<code>mount</code>传播</p>
<ul>
<li><p>第一个是<code>docker run（docker create）</code>时刻通过<code>-v</code>将主机的目录（文件）映射到容器内部</p>
</li>
<li><p>第二个是<code>docker run（docker create）</code>创建容器根挂在点过程中。</p>
</li>
<li><p>第三个是在<code>docker cp</code>过程中。下文将依次讲述。</p>
</li>
</ul>
<h2 id="4-1-docker-run过程分析"><a href="#4-1-docker-run过程分析" class="headerlink" title="4.1 docker run过程分析"></a>4.1 docker run过程分析</h2><p><code>docker</code>在创建容器时刻，可以通过<code>-v source(主机侧):dest(容器侧):propagation(传播属性)</code>实现将主机的目录（文件）映射到容器内部。</p>
<p>其中<code>propagation</code>有<code>share[rshare], slave[rslave], private[rprivate]</code>一共6种模式。它们是系统调用<code>mount --bind</code>的6种传播模式，字母<code>r</code>表示<code>recursive</code>，会将挂载点的子挂载点一并挂载进容器。</p>
<p>默认情况下，<code>-v</code>的参数为<code>rprivate</code>。</p>
<h3 id="4-1-1-容器根目录传播模式与-v目录及其传播模式的关系"><a href="#4-1-1-容器根目录传播模式与-v目录及其传播模式的关系" class="headerlink" title="4.1.1 容器根目录传播模式与-v目录及其传播模式的关系"></a>4.1.1 容器根目录传播模式与-v目录及其传播模式的关系</h3><p><code>docker run</code>启动容器根目录的传播模式和<code>docker run -v</code>参数的传播模式参数的关系如下：</p>
<ul>
<li><p>默认情况下，容器内的根目录传播模式是<code>rprivate</code>；</p>
</li>
<li><p><code>-v</code>挂载时，有任一挂载点的传播模式设置为<code>rshared</code>，容器内的根目录传播模式是<code>rprivate</code>。（最高优先级）</p>
</li>
<li><p><code>-v</code>挂载时，没有<code>rshared</code>挂载点，有任一挂载点传播模式设置为<code>rslave</code>时，容器根目录的传播模式是<code>rslave</code>。</p>
</li>
<li><p><code>-v</code>挂载时，没有<code>rshared</code>挂载点，<code>source</code>中有<code>docker</code>根目录的父&#x2F;子等目录（例如<code>/var/lib/docker/containerd/volume(子)或者/var(父)</code>），容器内根目录的传播模式为<code>rslave</code>。兄弟目录不影响，例如<code>/var/lib/libvert</code>。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>-v 目录</th>
<th>传播模式</th>
<th>容器内根目录传播模式</th>
</tr>
</thead>
<tbody><tr>
<td>有docker根目录的父子目录例如：<br/>(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containerd&#x2F;volume(子)&#x2F;var&#x2F;lib(父))</td>
<td>无指定的挂载点模式，默认</td>
<td>rslave</td>
</tr>
<tr>
<td>有任一指定为rshared的挂载点</td>
<td>rprivate</td>
<td></td>
</tr>
<tr>
<td>指定挂载点为rslave</td>
<td>rslave</td>
<td></td>
</tr>
<tr>
<td>没有docker根目录的父子目录其他非docker根目录树的目录</td>
<td>无指定的挂载点模式，默认</td>
<td>rprivate</td>
</tr>
<tr>
<td>有任一指定为rshared的挂载点</td>
<td>rprivate</td>
<td></td>
</tr>
<tr>
<td>指定为rslave，且无指定rshared挂载点</td>
<td>rslave</td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-1-2-docker-run启动容器的mount流程分析"><a href="#4-1-2-docker-run启动容器的mount流程分析" class="headerlink" title="4.1.2 docker run启动容器的mount流程分析"></a>4.1.2 docker run启动容器的mount流程分析</h3><p>执行命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -v <span class="built_in">source</span>(主机源):dest(容器内目录):propagation(传播模式)</span></span><br></pre></td></tr></table></figure>

<p>命令执行过程：</p>
<ul>
<li>创建容器，<code>dockerd</code>执行挂载，将容器根文件系统挂载到主机<code>/var/lib/docker/overlay2/layer_id/merged</code>目录上，传播模式为<code>rshared</code>（默认）。</li>
</ul>
<p>用命令行表述本次挂载行为则是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#主机</span><br><span class="line"></span><br><span class="line">mount -t overlay overlay -o lowerdir=/var/run/lib/docker/overlay2/xxx,upperdir=/var/lib/docker/overlay2/xxx,workdir=/var/lib/docker/overlay2/xxx /var/lib/docker/overlay2/merged</span><br></pre></td></tr></table></figure>

<ul>
<li>创建容器的<code>mnt命</code>名空间，此命名空间采用<code>unshare</code>方式，与主机命名空间隔离。此时容器内的挂载点存在以下两条</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">57 56 253:0 / / rw,relatime master:1 - xfs /dev/mapper/ncl-root rw,seclabel,attr2,inode64,noquota  </span><br><span class="line">89 57 0:41 / /root/mount-test/overlay/merged rw,relatime master:30 - overlay overlay rw,seclabel,lowerdir=/root/mount-test/overlay/lowerdir/,upperdir=/root/mount-test/overlay/upperdir/,workdir=/root/mount-test/overlay/workdir</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将容器的根目录属性写入<code>/var/run/docker/libcontainerd/id/config.json</code>文件中</p>
</li>
<li><p><code>runc</code>读取<code>/var/run/docker/libcontainerd/id/config.json</code>文件，并将容器根目录属性写入<code>/var/run/runc/id/state.json</code>文件</p>
</li>
<li><p><code>runc</code>读取<code>/var/run/runc/id/state.json</code>，获得此时容器内的根文件系统的挂载属性。（此时容器内的根文件系统还是与主机上的一致，是主机上的<code>/</code>目录）</p>
</li>
<li><p><code>runc</code>在容器内按照<code>/var/run/runc/id/state.json</code>中的<code>rootPropagation</code>字段的值，修改根文件系统的挂载属性。用命令行表述本次挂载行为则是</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rslave/--make-rprivate /  </span><br><span class="line"># 选择--make-rslave/--make-rprivate的值是根据/var/run/runc/id/state.json中的rootPropagation字段的值来设置的。  </span><br></pre></td></tr></table></figure>

<ul>
<li>查找<code>/var/lib/docker/overlay2/layer_id/merged</code>的父挂载点，如果父挂载点的挂载属性是<code>shared/rshared</code>，则将其改为<code>rprivate</code>。由于<code>/var/lib/docker/overlay2/layer_id/merged</code>的父挂载点是主机根目录的挂载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># if &quot;/&quot; mount-propagation=shared/rshared</span><br><span class="line"></span><br><span class="line">mount --make-rprivate /</span><br></pre></td></tr></table></figure>

<ul>
<li>创建容器新的根文件系统挂载点。将<code>xxx/merged</code>目录挂载到<code>xxx/merged</code>目录上。执行本步骤的原因是为第<code>xxx</code>步骤中的<code>pivot_root</code>系统调用切换根文件系统挂载做准备。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount --rbind /var/lib/docker/overlay2/layer_id/merged /var/lib/docker/overlay2/layer_id/merged  </span><br><span class="line">91 89 0:41 / /root/mount-test/overlay/merged rw,relatime master:30 - overlay overlay rw,seclabel,lowerdir=/root/mount-test/overlay/lowerdir/,upperdir=/root/mount-test/overlay/upperdir/,workdir=/root/mount-test/overlay/workdir/ </span><br></pre></td></tr></table></figure>

<p>本次挂载的父是89，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89 57 0:41 / /root/mount-test/overlay/merged</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行容器内必要目录的挂载，主要有<code>/dev</code>, <code>/sys</code>, <code>/sys/fs/cgroup</code>, <code>/dev/shm</code>, <code>/proc</code>, <code>/dev/pts</code>, <code>/dev/mqueue</code>, <code>/etc/resolv.conf</code>, <code>/etc/hostname</code>, <code>/etc/hosts</code>, <code>-v</code>挂载目录。这些目录为<code>/var/run/runc/id/state.json</code>文件中的<code>mounts</code>标签下的内容。将这些内容挂载到<code>/var/lib/docker/overlay2/layer_id/merged</code>目录下的对应路径。例如：<code>/dev</code>挂载到<code>/var/lib/docker/overlay2/layer_id/merged/dev</code>，<code>/sys</code>挂载到<code>/var/lib/docker/overlay2/layer_id/merged/sys</code>。</p>
</li>
<li><p>执行<code>pivot_root</code>系统调用。切换文件系统以及重新挂载根文件系统。</p>
</li>
</ul>
<p>用命令表述则是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/docker/overlay2/layer_id/merged  </span><br><span class="line">pivot_root . .  </span><br><span class="line">91 56 0:41 / / rw,relatime master:30 - overlay overlay rw,seclabel,lowerdir=/root/mount-test/overlay/lowerdir/,upperdir=/root/mount-test/overlay/upperdir/,workdir=/root/mount-test/overlay/workdir/</span><br></pre></td></tr></table></figure>

<p>执行<code>pivot_root</code>系统调用以后，<code>91 89 / /root/mount-test/overlay/merged</code>挂载点切换为<code>91 56 / / rw</code>。容器根文件系统完成切换。此时，容器内的<code>/</code>切换为之前的<code>/var/lib/docker/overlay2/layer_id/merged</code>目录。</p>
<ul>
<li>打开老根的文件描述符，使用<code>umount -l</code>命令卸载老根及其子挂载点。此时，容器内只剩新建的挂载点，完成挂载。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">91 56 0:41 / / rw,relatime master:30 - overlay overlay rw,seclabel,lowerdir=/root/mount-test/overlay/lowerdir/,upperdir=/root/mount-test/overlay/upperdir/,workdir=/root/mount-test/overlay/workdir/  </span><br><span class="line">92 91 0:42 / /proc rw,relatime - proc proc rw  </span><br><span class="line">93 91 0:16 / /sys rw,relatime - sysfs sysfs rw,seclabel  </span><br><span class="line">94 91 0:13 / /dev/mqueue rw,relatime - mqueue mqueue rw,seclabel  </span><br><span class="line">95 91 0:43 / /dev rw,relatime - tmpfs tmpfs rw,seclabel  </span><br><span class="line">96 91 0:39 / /root/mount-test/run rw,relatime master:31 - tmpfs tmpfs rw,seclabel  </span><br><span class="line">97 96 0:40 / /root/mount-test/run/user/0 rw,relatime master:32 - tmpfs tmpfs rw,seclabel</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-docker-run-mount在dockerd和runc中的代码流程"><a href="#4-1-3-docker-run-mount在dockerd和runc中的代码流程" class="headerlink" title="4.1.3 docker run mount在dockerd和runc中的代码流程"></a>4.1.3 docker run mount在dockerd和runc中的代码流程</h3><p>下面对<code>docker run</code>流程中涉及到<code>mount</code>传播问题的函数进行讲解，如果读者对<code>dockerd</code>和<code>runc</code>代码实现不感兴趣，请移步下一节。</p>
<h4 id="4-1-3-1-dockerd中的函数实现"><a href="#4-1-3-1-dockerd中的函数实现" class="headerlink" title="4.1.3.1 dockerd中的函数实现"></a>4.1.3.1 dockerd中的函数实现</h4><p>首先，在<code>dockerd</code>中设置容器内根文件系统挂载传播属性。这部分内容在<code>dockerd</code>中的<code>setMounts</code>函数中实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    pFlag := mountPropagationMap[m.Propagation]</span><br><span class="line"><span class="keyword">switch</span> pFlag &#123;</span><br><span class="line"><span class="keyword">case</span> mount.SHARED, mount.RSHARED:</span><br><span class="line">    <span class="keyword">if</span> err := ensureShared(m.Source); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    rootpg := mountPropagationMap[s.Linux.RootfsPropagation]</span><br><span class="line">    <span class="keyword">if</span> rootpg != mount.SHARED &amp;&amp; rootpg != mount.RSHARED &#123;</span><br><span class="line">        s.Linux.RootfsPropagation = mountPropagationReverseMap[mount.SHARED]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> mount.SLAVE, mount.RSLAVE:</span><br><span class="line">    <span class="keyword">var</span> fallback <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> err := ensureSharedOrSlave(m.Source); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// For backwards compatability purposes, treat mounts from the daemon root</span></span><br><span class="line">        <span class="comment">// as special since we automatically add rslave propagation to these mounts</span></span><br><span class="line">        <span class="comment">// when the user did not set anything, so we should fallback to the old</span></span><br><span class="line">        <span class="comment">// behavior which is to use private propagation which is normally the</span></span><br><span class="line">        <span class="comment">// default.</span></span><br><span class="line">        <span class="keyword">if</span> !strings.HasPrefix(m.Source, daemon.root) &amp;&amp; !strings.HasPrefix(daemon.root, m.Source) &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cm, ok := c.MountPoints[m.Destination]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cm.Spec.BindOptions != <span class="literal">nil</span> &amp;&amp; cm.Spec.BindOptions.Propagation != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// This means the user explicitly set a propagation, do not fallback in that case.</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        fallback = <span class="literal">true</span></span><br><span class="line">        logrus.WithField(<span class="string">&quot;container&quot;</span>, c.ID).WithField(<span class="string">&quot;source&quot;</span>, m.Source).Warn(<span class="string">&quot;Falling back to default propagation for bind source in daemon root&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !fallback &#123;</span><br><span class="line">        rootpg := mountPropagationMap[s.Linux.RootfsPropagation]</span><br><span class="line">        <span class="keyword">if</span> rootpg != mount.SHARED &amp;&amp; rootpg != mount.RSHARED &amp;&amp; rootpg != mount.SLAVE &amp;&amp; rootpg != mount.RSLAVE &#123;</span><br><span class="line">            s.Linux.RootfsPropagation = mountPropagationReverseMap[mount.RSLAVE]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-2-runc中的函数实现"><a href="#4-1-3-2-runc中的函数实现" class="headerlink" title="4.1.3.2 runc中的函数实现"></a>4.1.3.2 runc中的函数实现</h4><p><code>runc</code>是实际上对容器内进行<code>mount</code>操作。整个<code>mount</code>流程是在<code>runc</code>的<code>setupRootfs</code>函数中实现。其中有3个关键函数</p>
<ul>
<li><p><code>prepareRoot</code>，用于将老根设置为<code>rslave/rprivate</code>，创建新根的挂载点。</p>
</li>
<li><p><code>mountToRootfs</code>，将其他挂载点挂载到新根上</p>
</li>
<li><p><code>pivotRoot</code>，将容器内的根文件系统切换到新根上，随后卸载老根及其子挂载点。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRootfs</span><span class="params">(config *configs.Config, console *linuxConsole, pipe io.ReadWriter)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := prepareRoot(config); err != <span class="literal">nil</span> &#123; <span class="comment">//将老根设置为rslave/rprivate，创建新根的挂载点。</span></span><br><span class="line">        <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;preparing rootfs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setupDev := needsSetupDev(config)</span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> config.Mounts &#123;</span><br><span class="line">        <span class="keyword">for</span> _, precmd := <span class="keyword">range</span> m.PremountCmds &#123;</span><br><span class="line">            <span class="keyword">if</span> err := mountCmd(precmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;running premount command&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := mountToRootfs(m, config.Rootfs, config.MountLabel); err != <span class="literal">nil</span> &#123; <span class="comment">//将其他挂载点挂载到新根上</span></span><br><span class="line">            <span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;mounting %q to rootfs %q at %q&quot;</span>, m.Source, config.Rootfs, m.Destination)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, postcmd := <span class="keyword">range</span> m.PostmountCmds &#123;</span><br><span class="line">            <span class="keyword">if</span> err := mountCmd(postcmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;running postmount command&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> setupDev &#123;</span><br><span class="line">        <span class="keyword">if</span> err := createDevices(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;creating device nodes&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := setupPtmx(config, console); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting up ptmx&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := setupDevSymlinks(config.Rootfs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting up /dev symlinks&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Signal the parent to run the pre-start hooks.</span></span><br><span class="line">    <span class="comment">// The hooks are run after the mounts are setup, but before we switch to the new</span></span><br><span class="line">    <span class="comment">// root, so that the old root is still available in the hooks for any mount</span></span><br><span class="line">    <span class="comment">// manipulations.</span></span><br><span class="line">    <span class="keyword">if</span> err := syncParentHooks(pipe); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := syscall.Chdir(config.Rootfs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;changing dir to %q&quot;</span>, config.Rootfs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> config.NoPivotRoot &#123;</span><br><span class="line">        err = msMoveRoot(config.Rootfs)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> config.Namespaces.Contains(configs.NEWNS) &#123;</span><br><span class="line">        err = pivotRoot(config.Rootfs) <span class="comment">//切换新根，随后umount老根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = chroot(config.Rootfs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepareRoot</code>函数用于将老根设置为<code>rslave/rprivate</code>，查找新根的父挂载点，如果新根的父挂载点是<code>rshared</code>，则将其设置为<code>rprivate</code>，防止在后面的<code>mountToRootfs</code>函数中，将其他挂载点挂载到新根的时候，传播到主机侧。创建新根的挂载点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareRoot</span><span class="params">(config *configs.Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    flag := syscall.MS_SLAVE | syscall.MS_REC</span><br><span class="line">    <span class="keyword">if</span> config.RootPropagation != <span class="number">0</span> &#123;</span><br><span class="line">        flag = config.RootPropagation</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := syscall.Mount(<span class="string">&quot;&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="type">uintptr</span>(flag), <span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123; <span class="comment">//根据/var/run/runc/id/state.json文件中的rootPropagation字段设置老根传播模式为rslave/rprivate/rshared</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make parent mount private to make sure following bind mount does</span></span><br><span class="line">    <span class="comment">// not propagate in other namespaces. Also it will help with kernel</span></span><br><span class="line">    <span class="comment">// check pass in pivot_root. (IS_SHARED(new_mnt-&gt;mnt_parent))</span></span><br><span class="line">    <span class="keyword">if</span> err := rootfsParentMountPrivate(config.Rootfs); err != <span class="literal">nil</span> &#123; <span class="comment">//如果父挂载点是rshared，则将其改为rprivate。防止在后面的mountToRootfs函数中，把其他挂载点挂载到新根的时候，传播到主机侧</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall.Mount(config.Rootfs, config.Rootfs, <span class="string">&quot;bind&quot;</span>, syscall.MS_BIND|syscall.MS_REC, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pivotRoot</code>函数执行<code>pivot_root</code>系统调用，将容器内的根文件系统切换到新根（原来的<code>/var/lib/docker/overlay2/layer_id/merged</code>目录变为容器内的<code>/</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pivotRoot will call pivot_root such that rootfs becomes the new root</span></span><br><span class="line"><span class="comment">// filesystem, and everything else is cleaned up.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotRoot</span><span class="params">(rootfs <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// While the documentation may claim otherwise, pivot_root(&quot;.&quot;, &quot;.&quot;) is</span></span><br><span class="line">    <span class="comment">// actually valid. What this results in is / being the new root but</span></span><br><span class="line">    <span class="comment">// /proc/self/cwd being the old root. Since we can play around with the cwd</span></span><br><span class="line">    <span class="comment">// with pivot_root this allows us to pivot without creating directories in</span></span><br><span class="line">    <span class="comment">// the rootfs. Shout-outs to the LXC developers for giving us this idea.</span></span><br><span class="line"></span><br><span class="line">    oldroot, err := syscall.Open(<span class="string">&quot;/&quot;</span>, syscall.O_DIRECTORY|syscall.O_RDONLY, <span class="number">0</span>) <span class="comment">//老根“/”的文件描述符，后面用于umount</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> syscall.Close(oldroot)</span><br><span class="line"></span><br><span class="line">    newroot, err := syscall.Open(rootfs, syscall.O_DIRECTORY|syscall.O_RDONLY, <span class="number">0</span>) <span class="comment">//新根“xxx/merged”的文件描述符，后面用于pivot_root系统调用</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> syscall.Close(newroot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change to the new root so that the pivot_root actually acts on it.</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Fchdir(newroot); err != <span class="literal">nil</span> &#123; <span class="comment">//切换到新根路径</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := syscall.PivotRoot(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>); err != <span class="literal">nil</span> &#123; <span class="comment">//pivot_root系统调用，将容器内的根文件系统切换到新根（原来的var/lib/docker/overlay2/layer_id/merged目录变为容器内的“/”）</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;pivot_root %s&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Currently our &quot;.&quot; is oldroot (according to the current kernel code).</span></span><br><span class="line">    <span class="comment">// However, purely for safety, we will fchdir(oldroot) since there isn&#x27;t</span></span><br><span class="line">    <span class="comment">// really any guarantee from the kernel what /proc/self/cwd will be after a</span></span><br><span class="line">    <span class="comment">// pivot_root(2).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Fchdir(oldroot); err != <span class="literal">nil</span> &#123; <span class="comment">//切换到老根路径上</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make oldroot rprivate to make sure our unmounts don&#x27;t propagate to the</span></span><br><span class="line">    <span class="comment">// host (and thus bork the machine).</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Mount(<span class="string">&quot;&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>, syscall.MS_PRIVATE|syscall.MS_REC, <span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Preform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Unmount(<span class="string">&quot;.&quot;</span>, syscall.MNT_DETACH); err != <span class="literal">nil</span> &#123; <span class="comment">//卸载当前路径挂载点及其子挂载点（即卸载老根及其自挂载点）</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch back to our shiny new root.</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Chdir(<span class="string">&quot;/&quot;</span>); err != <span class="literal">nil</span> &#123; <span class="comment">//切换到新根，完成容器内挂载点的挂载</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;chdir / %s&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-docker-cp-mount流程分析"><a href="#4-2-docker-cp-mount流程分析" class="headerlink" title="4.2 docker cp mount流程分析"></a>4.2 docker cp mount流程分析</h2><p>除去<code>docker run（docker create）</code>容器启动流程中涉及到<code>mount</code>挂载点传播问题，在<code>docker cp</code>过程中也会涉及到<code>mount</code>挂载点传播问题。下面将详细讲解<code>docker cp</code>的<code>mount</code>相关流程，如果对<code>docker</code>内部实现流程不感兴趣的读者可直接跳至4.2.3 结论小节。</p>
<h3 id="4-2-1-docker-cp在docker代码流程总览"><a href="#4-2-1-docker-cp在docker代码流程总览" class="headerlink" title="4.2.1 docker cp在docker代码流程总览"></a>4.2.1 docker cp在docker代码流程总览</h3><p>下面对<code>docker cp</code>流程中涉及到的<code>mount</code>传播问题函数进行调用关系讲解</p>
<p><strong>客户端：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp--&gt;runCopy--&gt;copyToContainer--&gt;statContainerPath--&gt;func (cli *Client) ContainerStatPath--&gt;func (cli *Client) head发送HEAD请求。参数&quot;/containers/%s/archive&quot;</span><br><span class="line"> |</span><br><span class="line"> |--&gt;func (cli *Client) CopyToContainer--&gt;func (cli *Client) putRaw发送put请求。参数&quot;/containers/%s/archive&quot;</span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">收到head请求--&gt;headContainersArchive--&gt;func (daemon *Daemon) ContainerStatPath--&gt;containerStatPath--&gt;mountVolumes--&gt;mount.Mount(src,dest,rbind)--&gt;mount.MakeRPrivate(dest)</span><br><span class="line"> |</span><br><span class="line"> |--&gt;defer container.DetachAndUnmount--&gt;detachMounted-&gt;unix.Unmount</span><br><span class="line">收到put请求--&gt;func (daemon *Daemon) ContainerExtractToDir--&gt;func (daemon *Daemon) containerExtractToDir--&gt;mountVolumes--&gt;mount.Mount(src,dest,rbind)--&gt;mount.MakeRPrivate(dest)</span><br><span class="line"> |</span><br><span class="line"> |--&gt;defer container.DetachAndUnmount--&gt;detachMounted-&gt;unix.Unmount</span><br><span class="line"> |</span><br><span class="line"> |--&gt;UntarWithRoot(真正的copy)</span><br></pre></td></tr></table></figure>

<p><code>containerStatPath</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> containerStatPath(container *container.Container, path <span class="type">string</span>) (stat *types.ContainerPathStat, err <span class="type">error</span>) &#123;</span><br><span class="line">    container.Lock()</span><br><span class="line">    <span class="keyword">defer</span> container.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mount -t overlay overlay -o lowerdir=/var/lib/docker/overlay2/id/lowerdir,upperdir=/var/lib/docker/overlay2/id/upperdir,workdir=/var/lib/docker/overlay2/id/workdir /var/lib/docker/overlay2/id/merged</span></span><br><span class="line">    <span class="keyword">if</span> err = daemon.Mount(container); err != <span class="literal">nil</span> &#123; <span class="comment">//创建容器的时候，Mount函数会在主机上把容器根目录挂载上，docker cp的时候，该函数直接返回nil，并赋值container.BaseFS = dir</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> daemon.Unmount(container) <span class="comment">//docker cp的时候，也是只返回nil，不会执行umount调用。</span></span><br><span class="line"></span><br><span class="line">    err = daemon.mountVolumes(container)                    <span class="comment">// mount操作在这里执行</span></span><br><span class="line">    <span class="keyword">defer</span> container.DetachAndUnmount(daemon.LogVolumeEvent) <span class="comment">//umount操作在这里执行</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolvedPath, absPath, err := container.ResolvePath(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container.StatPath(resolvedPath, absPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mountVolumes函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> mountVolumes(container *container.Container) <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;mountVolumes&quot;</span>)</span><br><span class="line">    mounts, err := daemon.setupMounts(container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> mounts &#123;</span><br><span class="line">        dest, err := container.GetResourcePath(m.Destination)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> stat os.FileInfo</span><br><span class="line">        stat, err = os.Stat(m.Source)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err = fileutils.CreateIfNotExists(dest, stat.IsDir()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opts := <span class="string">&quot;rbind,ro&quot;</span></span><br><span class="line">        <span class="keyword">if</span> m.Writable &#123;</span><br><span class="line">            opts = <span class="string">&quot;rbind,rw&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m.Source = -v第一个参数</span></span><br><span class="line">        <span class="comment">// dest = xxx/merged/var/run等</span></span><br><span class="line">        <span class="comment">// 进行主机侧挂载点检测，如果主机侧有xxx/merged/-v挂载，则返回，如果没有，则在该函数内进行挂载。mount --rbind /var/run xxx/merged/var/run</span></span><br><span class="line">        <span class="keyword">if</span> err := mount.Mount(m.Source, dest, bindMountType, opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mountVolumes() seems to be called for temporary mounts</span></span><br><span class="line">        <span class="comment">// outside the container. Soon these will be unmounted with</span></span><br><span class="line">        <span class="comment">// lazy unmount option and given we have mounted the rbind,</span></span><br><span class="line">        <span class="comment">// all the submounts will propagate if these are shared. If</span></span><br><span class="line">        <span class="comment">// daemon is running in host namespace and has / as shared</span></span><br><span class="line">        <span class="comment">// then these unmounts will propagate and unmount original</span></span><br><span class="line">        <span class="comment">// mount as well. So make all these mounts rprivate.</span></span><br><span class="line">        <span class="comment">// Do not use propagation property of volume as that should</span></span><br><span class="line">        <span class="comment">// apply only when mounting happen inside the container.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mount操作，修改mount属性为rprivate，mount --make-rprvate /var/run/docker/overlay2/id/merged/var/run</span></span><br><span class="line">        <span class="keyword">if</span> err := mount.MakeRPrivate(dest); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Mount</code>函数，进行主机侧挂载点检测或主机侧执行挂载。</p>
<ul>
<li><p>调用<code>Mounted</code>函数在主机侧检查挂载点，<code>/var/lib/docker/overlay2/id/merged/-v</code>。</p>
</li>
<li><p>如果主机上有该挂载点，则不再进行mount挂载，如果不存在该挂载点，则调用ForceMount函数将其挂载到主机上。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount will mount filesystem according to the specified configuration, on the</span></span><br><span class="line"><span class="comment">// condition that the target path is *not* already mounted. Options must be</span></span><br><span class="line"><span class="comment">// specified like the mount or fstab unix commands: &quot;opt1=val1,opt2=val2&quot;. See</span></span><br><span class="line"><span class="comment">// flags.go for supported option flags.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mount</span><span class="params">(device, target, mType, options <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    flag, _ := parseOptions(options) <span class="comment">// flag = MS_BIND &amp; MS_REC（bind and recursive，即rbind）</span></span><br><span class="line">    <span class="keyword">if</span> flag&amp;REMOUNT != REMOUNT &#123;</span><br><span class="line">        <span class="keyword">if</span> mounted, err := Mounted(target); err != <span class="literal">nil</span> || mounted &#123;</span><br><span class="line">            <span class="comment">// 在主机侧，读取dockerd的mountinfo文件，读取/proc/self/mountinfo。查找挂载点,如果主机上有挂载点，则不再二次挂载，直接返回，如果不存在以下挂载点，则继续往下执行ForceMount进行挂载。</span></span><br><span class="line">            <span class="comment">// 1、-v目录，例如-v /var/run:/var/run   查找/var/lib/docker/overlay2/id/merged/var/run</span></span><br><span class="line">            <span class="comment">// 2、/var/lib/docker/overlay2/id/merged/etc/resolv.conf</span></span><br><span class="line">            <span class="comment">// 3、/var/lib/docker/overlay2/id/merged/etc/hostname</span></span><br><span class="line">            <span class="comment">// 4、/var/lib/docker/overlay2/id/merged/etc/hosts</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ForceMount(device, target, mType, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ForceMount</code>函数，执行<code>mount</code>系统调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForceMount</span><span class="params">(device, target, mType, options <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    flag, data := parseOptions(options)                                       <span class="comment">// flag = MS_BIND &amp; MS_REC（bind and recursive，即rbind）</span></span><br><span class="line">    <span class="keyword">if</span> err := mount(device, target, mType, <span class="type">uintptr</span>(flag), data); err != <span class="literal">nil</span> &#123; <span class="comment">//syscall.mount</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mount</span><span class="params">(device, target, mType <span class="type">string</span>, flag <span class="type">uintptr</span>, data <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := syscall.Mount(device, target, mType, flag, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a bind mount or remount, remount...</span></span><br><span class="line">    <span class="keyword">if</span> flag&amp;syscall.MS_BIND == syscall.MS_BIND &amp;&amp; flag&amp;syscall.MS_RDONLY == syscall.MS_RDONLY &#123;</span><br><span class="line">        <span class="keyword">return</span> syscall.Mount(device, target, mType, flag|syscall.MS_REMOUNT, data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MakeRPrivate</code>函数，将挂载点及其子挂载点递归设置为<code>private</code>。</p>
<p>如果这里不设置为<code>private</code>，则在后续的<code>umount</code>操作的时候，会将主机侧的挂载点也<code>umount</code>掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeRPrivate ensures a mounted filesystem has the RPRIVATE mount option</span></span><br><span class="line"><span class="comment">// enabled. See the supported options in flags.go for further reference.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeRPrivate</span><span class="params">(mountPoint <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ensureMountedAs(mountPoint, <span class="string">&quot;rprivate&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureMountedAs</span><span class="params">(mountPoint, options <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    mounted, err := Mounted(mountPoint) <span class="comment">// 此时挂载点已经挂载在主机上，所以这里的Mounted返回true,nil</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !mounted &#123;</span><br><span class="line">        <span class="keyword">if</span> err := Mount(mountPoint, mountPoint, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;bind,rw&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = Mounted(mountPoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mount --make-rprivate xxx/merged/-v</span></span><br><span class="line">    <span class="keyword">return</span> ForceMount(<span class="string">&quot;&quot;</span>, mountPoint, <span class="string">&quot;none&quot;</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unmount</code>相关函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(container *Container)</span></span> DetachAndUnmount(volumeEventLog <span class="function"><span class="keyword">func</span><span class="params">(name, action <span class="type">string</span>, attributes <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span>) <span class="type">error</span> &#123;</span><br><span class="line">    networkMounts := container.NetworkMounts()</span><br><span class="line">    mountPaths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(container.MountPoints)+<span class="built_in">len</span>(networkMounts))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, mntPoint := <span class="keyword">range</span> container.MountPoints &#123;</span><br><span class="line">        dest, err := container.GetResourcePath(mntPoint.Destination)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logrus.Warnf(<span class="string">&quot;Failed to get volume destination path for container &#x27;%s&#x27; at &#x27;%s&#x27; while lazily unmounting: %v&quot;</span>, container.ID, mntPoint.Destination, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        mountPaths = <span class="built_in">append</span>(mountPaths, dest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> networkMounts &#123;</span><br><span class="line">        dest, err := container.GetResourcePath(m.Destination)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logrus.Warnf(<span class="string">&quot;Failed to get volume destination path for container &#x27;%s&#x27; at &#x27;%s&#x27; while lazily unmounting: %v&quot;</span>, container.ID, m.Destination, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        mountPaths = <span class="built_in">append</span>(mountPaths, dest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, mountPath := <span class="keyword">range</span> mountPaths &#123;</span><br><span class="line">        <span class="keyword">if</span> err := detachMounted(mountPath); err != <span class="literal">nil</span> &#123; <span class="comment">// 卸载卷</span></span><br><span class="line">            logrus.Warnf(<span class="string">&quot;%s unmountVolumes: Failed to do lazy umount fo volume &#x27;%s&#x27;: %v&quot;</span>, container.ID, mountPath, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> container.UnmountVolumes(volumeEventLog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detachMounted</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unix.Unmount(path, unix.MNT_DETACH)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-docker-cp在实际操作流程"><a href="#4-2-2-docker-cp在实际操作流程" class="headerlink" title="4.2.2 docker cp在实际操作流程"></a>4.2.2 docker cp在实际操作流程</h3><p>本小节将介绍<code>docker cp</code>过程中<code>mount</code>和<code>mount</code>传播的实际流程，不含<code>docker</code>代码的具体实现。</p>
<p>注意：<code>docker cp</code>执行过程是在宿主机侧完成，操作的是宿主机侧的<code>mnt</code>命名空间。</p>
<h4 id="4-2-2-1-cp前，主机及容器mount状态"><a href="#4-2-2-1-cp前，主机及容器mount状态" class="headerlink" title="4.2.2.1 cp前，主机及容器mount状态"></a>4.2.2.1 cp前，主机及容器mount状态</h4><p>起一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mount-test -v /var/run:/var/run:rslave busybox sh</span><br></pre></td></tr></table></figure>

<p>在执行<code>mount</code>前，主机侧存在一个<code>merged</code>挂载点，该挂载点是启动容器的时候挂载的容器根文件系统。<code>mount</code>共享组<code>id</code>为31，本次<code>mount</code>产生的<code>source mount id</code>为48，<code>dest mount id</code>为38（为主机侧根文件系统挂载<code>/ / rw</code>）。</p>
<p><code>48 38 0:38 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged rw,relatime shared:31 - overlay overlay rw,context=&quot;system_u:object_r:container_file_t:s0:c901,c917&quot;,lowerdir=/var/lib/docker/overlay2/l/55F3NPVAF2FEG3AYF45KBB7UH6:/var/lib/docker/overlay2/l/O5E22LECDUO27ISLIQMO4LQB74,upperdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/diff,workdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/work  </code></p>
<p>主机侧还存在<code>/var/run</code>及<code>/var/run</code>子目录的挂载点。存在<code>run/docker/netns/id</code>即<code>/run/user/0</code>。这两条挂载信息的逻辑完全一致，本文以<code>/run/user/0</code>为例，省略<code>/run/docker/netns/id</code>的分析过程，简化视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23 38 0:18 / /run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">113 23 0:3 / /run/docker/netns/205902d2764f rw,nosuid,nodev,noexec,relatime shared:5 - proc proc rw  </span><br><span class="line">47 23 0:37 / /run/user/0 rw,nosuid,nodev,relatime shared:30 - tmpfs tmpfs rw,seclabel,size=388124k,mode=700  </span><br></pre></td></tr></table></figure>

<p>容器内存在根目录挂载点</p>
<p><code>89 54 0:38 / / rw,relatime master:31 - overlay overlay rw,context=&quot;system_u:object_r:container_file_t:s0:c901,c917&quot;,lowerdir=/var/lib/docker/overlay2/l/55F3NPVAF2FEG3AYF45KBB7UH6:/var/lib/docker/overlay2/l/O5E22LECDUO27ISLIQMO4LQB74,upperdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/diff,workdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/work</code></p>
<p>这条挂载点是从属于主机侧<code>shared:31</code>组，传播模式为<code>slave</code>，只能由其父组往下传播，不能从子组往父组反向传播。</p>
<p>此时，主机侧与容器内各个挂载点之间的关系如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iIEmVX.jpeg" alt="mount-before.jpg" title="mount-before.jpg">      </p>
<h4 id="4-2-2-2-docker-cp的第一次mount"><a href="#4-2-2-2-docker-cp的第一次mount" class="headerlink" title="4.2.2.2 docker cp的第一次mount"></a>4.2.2.2 docker cp的第一次mount</h4><p>在主机侧进行第一次<code>mount</code>，对应<code>dockerd</code>中的<code>mount.Mount(src,dest,rbind)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --rbind /var/run /var/lib/docker/overlay2/id/merged/var/run</span><br></pre></td></tr></table></figure>

<p>本次挂载属性是<code>rbind</code>，<code>r</code>表示<code>recursive</code>，会将<code>/var/run</code>目录下的所有挂载点也挂载进去，即<code>/run/user/0</code>也执行一次挂载。这次挂载是在内核<code>propagation_mnt</code>函数中，以传播的形式完成，非<code>mount</code>系统调用。</p>
<p>主机侧新增挂载点</p>
<p>主机侧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">56 48 0:18 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run rw,nosuid,nodev shared:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">70 56 0:37 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run/user/0 rw,nosuid,nodev,relatime shared:30 - tmpfs tmpfs rw,seclabel,size=388124k,mode=700</span><br></pre></td></tr></table></figure>

<p>精简一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">56 48 / xxx/merged/var/run shared:23  </span><br><span class="line">70 56 / xxx/merged/var/run/user/0 shared:30</span><br></pre></td></tr></table></figure>

<p>主机侧通过<code>xxx/merged</code>的<code>slave</code>传播模式，传播至容器内，导致容器内也出现挂载点</p>
<p>容器侧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">71 89 0:18 / /var/run rw,nosuid,nodev master:23 - tmpfs tmpfs rw,seclabel,mode=755  </span><br><span class="line">73 71 0:37 / /var/run/user/0 rw,nosuid,nodev,relatime master:30 - tmpfs tmpfs rw,seclabel,size=388124k,mode=700</span><br></pre></td></tr></table></figure>

<p>精简一下 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">71 89 / /var/run master:23</span><br><span class="line">73 71 / /var/run/user/0 master:30</span><br></pre></td></tr></table></figure>

<p>此时的mount关系图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iI79rP.jpeg" alt="mount-after.jpg" title="mount-after.jpg">   </p>
<h4 id="4-2-2-3-docker-cp的第二次mount操作，修改挂载属性，无实质挂载"><a href="#4-2-2-3-docker-cp的第二次mount操作，修改挂载属性，无实质挂载" class="headerlink" title="4.2.2.3 docker cp的第二次mount操作，修改挂载属性，无实质挂载"></a>4.2.2.3 docker cp的第二次mount操作，修改挂载属性，无实质挂载</h4><p>在主机侧进行第二次<code>mount</code>，对应<code>dockerd</code>中的<code>mount.MakeRPrivate(dest)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rprivate /var/lib/docker/overlay2/id/merged/var/run</span><br></pre></td></tr></table></figure>

<p>本次修改属性为<code>rprivate</code>，<code>r</code>表示<code>recursive</code>，会将<code>xxx/merged/var/run</code>目录下的所有挂载点的属性也修改为<code>private</code>。</p>
<p>主机侧的挂载点信息变更为：</p>
<p>主机侧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">56 48 0:18 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run rw,nosuid,nodev - tmpfs tmpfs rw,seclabel,mode=755</span><br><span class="line">70 56 0:37 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run/user/0 rw,nosuid,nodev,relatime - tmpfs tmpfs rw,seclabel,size=388124k,mode=700</span><br></pre></td></tr></table></figure>

<p>精简一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">56 48 / xxx/merged/var/run</span><br><span class="line">70 56 / xxx/merged/var/run/user/0</span><br></pre></td></tr></table></figure>

<p>容器内的挂载点信息不变。</p>
<p>此时的mount关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iI7YKV.jpeg" alt="mount-private.jpg" title="mount-private.jpg"></p>
<h4 id="4-2-2-4-docker-cp的umount操作"><a href="#4-2-2-4-docker-cp的umount操作" class="headerlink" title="4.2.2.4 docker cp的umount操作"></a>4.2.2.4 docker cp的umount操作</h4><p>在主机侧进行<code>umount</code>操作，对应<code>dockerd</code>的<code>unix.Unmount(dest)</code>。传递给内核的参数是<code>MNT_DETACH</code>。</p>
<p>本次<code>umount</code>事件用命令行表达则是<code>umount -l</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount -l /var/lib/docker/overlay2/id/merged/var/run</span><br></pre></td></tr></table></figure>

<p>此时将<code>umount</code>事件传递给内核，执行<code>umount</code>操作。</p>
<h4 id="4-2-2-5-umount传播事件的流程"><a href="#4-2-2-5-umount传播事件的流程" class="headerlink" title="4.2.2.5 umount传播事件的流程"></a>4.2.2.5 umount传播事件的流程</h4><p>因为<code>umount</code>事件会在<code>umount</code>过程中传递到目标<code>mount</code>点，并通过传播属性找到需要同<code>umount</code>目标一同卸载的<code>mount</code>。下面结合<code>umount</code>内核代码（内核3.10实现）对<code>docker cp</code>过程中的<code>umount</code>过程及最终导致残留的原因进行讲解。</p>
<p>内核收到<code>docker cp</code>命令传来的<code>umount -l</code>系统调用。<code>umount</code>传播过程及各挂载点关系如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iIEXQc.jpeg" alt="umount.jpg" title="umount.jpg">   </p>
<p>内核收到<code>umount</code>系统调用，参数为<code>MNT_DETACH</code>，因此，内核执行<code>propagation_unmount</code>函数，将所有需要<code>umount</code>的挂载点，添加到链表中，等待<code>umount</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * collect all mounts that receive propagation from the mount in @list,</span></span><br><span class="line"><span class="comment"> * and return these additional mounts in the same list.</span></span><br><span class="line"><span class="comment"> * @list: the list of mounts to be unmounted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * vfsmount lock must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 入参list 表示所有待umount的子挂载</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">propagate_umount</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    LIST_HEAD(to_restore);</span><br><span class="line">    LIST_HEAD(to_umount);</span><br><span class="line">    LIST_HEAD(visited);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find candidates for unmounting */</span></span><br><span class="line">    list_for_each_entry_reverse(mnt, <span class="built_in">list</span>, mnt_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// parent 为 mount对象生成时刻的dest</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span> =</span> mnt-&gt;mnt_parent;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this mount has already been visited it is known that it&#x27;s</span></span><br><span class="line"><span class="comment">         * entire peer group and all of their slaves in the propagation</span></span><br><span class="line"><span class="comment">         * tree for the mountpoint has already been visited and there is</span></span><br><span class="line"><span class="comment">         * no need to visit them again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_umounting))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        list_add_tail(&amp;mnt-&gt;mnt_umounting, &amp;visited); <span class="comment">// 将当前mnt加入mnt—umounting成员组成的链表visited。</span></span><br><span class="line">        <span class="keyword">for</span> (m = propagation_next(parent, parent); m;</span><br><span class="line">             m = propagation_next(m, parent))</span><br><span class="line">        &#123; <span class="comment">// 以parent为初始，遍历parent的propagation tree，取出下一个mount对象</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">child</span> =</span> __lookup_mnt(&amp;m-&gt;mnt,</span><br><span class="line">                                               mnt-&gt;mnt_mountpoint); <span class="comment">// 找到m的子mount（也就是mount动作生成因为m产生的mount 对象)</span></span><br><span class="line">            <span class="keyword">if</span> (!child)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;child-&gt;mnt_umounting))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If the child has already been visited it is</span></span><br><span class="line"><span class="comment">                 * know that it&#x27;s entire peer group and all of</span></span><br><span class="line"><span class="comment">                 * their slaves in the propgation tree for the</span></span><br><span class="line"><span class="comment">                 * mountpoint has already been visited and there</span></span><br><span class="line"><span class="comment">                 * is no need to visit this subtree again.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                m = skip_propagation_subtree(m, parent);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;mnt.mnt_flags &amp; MNT_UMOUNT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * We have come accross an partially unmounted</span></span><br><span class="line"><span class="comment">                 * mount in list that has not been visited yet.</span></span><br><span class="line"><span class="comment">                 * Remember it has been visited and continue</span></span><br><span class="line"><span class="comment">                 * about our merry way.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                list_add_tail(&amp;child-&gt;mnt_umounting, &amp;visited);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Check the child and parents while progress is made */</span></span><br><span class="line">            <span class="keyword">while</span> (__propagate_umount(child,</span><br><span class="line">                                      &amp;to_umount, &amp;to_restore))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Is the parent a umount candidate? */</span></span><br><span class="line">                child = child-&gt;mnt_parent;</span><br><span class="line">                <span class="keyword">if</span> (list_empty(&amp;child-&gt;mnt_umounting))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umount_list(&amp;to_umount, &amp;to_restore);</span><br><span class="line">    restore_mounts(&amp;to_restore);</span><br><span class="line">    cleanup_umount_visitations(&amp;visited);</span><br><span class="line">    list_splice_tail(&amp;to_umount, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>umount</code>事件是在主机侧产生，因此，遍历所有主机侧需要<code>umount</code>的挂载点。</p>
<ul>
<li><p>先将主机侧需要卸载的挂载点添加进待卸载链表。<code>/var/lib/docker/overlay2/id/merged/var/run</code>。</p>
</li>
<li><p>遍历共享组内的待卸载挂载点。查找的方法是在<code>propagate_umount</code>内核函数内完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = propagation_next(m, parent)) &#123;//以parent为初始，遍历parent的propagation tree，取出下一个mount对象</span><br></pre></td></tr></table></figure>

<ul>
<li><code>m</code>表示主机侧的<code>/var/lib/docker/overlay2/id/merged/var/run</code></li>
</ul>
</li>
</ul>
<p><code>56 48 0:18 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run rw,nosuid,nodev - tmpfs tmpfs rw,seclabel,mode=755</code></p>
<ul>
<li><code>m</code>的<code>parent</code>表示父挂载点，即<code>mount id</code>为48的挂载点<code>/var/lib/docker/overlay2/id/merged</code></li>
</ul>
<p><code>48 38 0:38 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged rw,relatime shared:31 - overlay overlay rw,context=&quot;system_u:object_r:container_file_t:s0:c901,c917&quot;,lowerdir=/var/lib/docker/overlay2/l/55F3NPVAF2FEG3AYF45KBB7UH6:/var/lib/docker/overlay2/l/O5E22LECDUO27ISLIQMO4LQB74,upperdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/diff,workdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/work</code>  </p>
<ul>
<li>执行<code>propagation_next</code>函数，查找<code>xxx/merged</code>挂载点的子组。主机侧<code>xxx/merged</code>挂载点的子组是容器内的根目录挂载点。</li>
</ul>
<p><code>89 54 0:38 / / rw,relatime master:31 - overlay overlay rw,context=&quot;system_u:object_r:container_file_t:s0:c901,c917&quot;,lowerdir=/var/lib/docker/overlay2/l/55F3NPVAF2FEG3AYF45KBB7UH6:/var/lib/docker/overlay2/l/O5E22LECDUO27ISLIQMO4LQB74,upperdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/diff,workdir=/var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/work</code></p>
<ul>
<li>查找容器内的<code>var/run</code>挂载。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">71 89 0:18 / /var/run rw,nosuid,nodev master:23 - tmpfs tmpfs rw,seclabel,mode=755</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历<code>xxx/merged/var/run</code>的所有子挂载点，并将其添加进待卸载链表。再执行<code>propagate_umoun</code>内核函数。</li>
</ul>
<p>    1) 此时<code>m</code>表示主机侧的<code>/var/lib/docker/overlay2/id/merged/var/run/user/0</code></p>
<p><code>70 56 0:37 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run/user/0 rw,nosuid,nodev,relatime shared:30 - tmpfs tmpfs rw,seclabel,size=388124k,mode=700</code></p>
<p>    2) <code>m</code>的<code>parent</code>表示父挂载点，即<code>mount id</code>为56的<code>/var/lib/docker/overlay2/id/merged/var/run</code>挂载点。</p>
<p><code>56 48 0:18 / /var/lib/docker/overlay2/d19cdae0fe198d8196a49faddeb76fe18d7c8259bbd98c3115253cfde62ef0fe/merged/var/run rw,nosuid,nodev - tmpfs tmpfs rw,seclabel,mode=755</code></p>
<p>    3) 执行<code>propagate_next</code>函数，查找<code>xxx/merged/var/run</code>挂载点的子组。由于<code>xxx/merged/var/run</code>已经是<code>private</code>模式，没有子组，所以，<code>propagate_umount</code>函数结束。此时，可以看到，容器内部的<code>/var/run/user/0</code>挂载点并没有被添加到待卸载链表中，在卸载的时候，该链表不会被卸载。</p>
<ul>
<li>将待卸载链表中的挂载点全部卸载。此时，主机侧的待卸载挂载点全部卸载，卸载事件返回卸载成功，但是，容器内被添加到待卸载链表中的挂载点只有<code>/var/run</code>，没有<code>/var/run/user/0</code>，所以在卸载容器内的<code>/var/ru</code>n挂载点，由于存在子挂载点，无法卸载，导致容器内两条挂载点全部残留。</li>
</ul>
<h3 id="4-2-3-docker-cp流程总结"><a href="#4-2-3-docker-cp流程总结" class="headerlink" title="4.2.3 docker cp流程总结"></a>4.2.3 docker cp流程总结</h3><p>1、将容器内的<code>-v</code>挂载点及其子挂载点，挂载到主机的容器<code>xxx/merged/xxx</code>目录上。</p>
<p>主机上，<code>rbind</code>模式，没有设置<code>propagation</code>，默认是<code>shared</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --rbind /var/run /var/lib/docker/overlay2/xxx/merged/var/run  </span><br></pre></td></tr></table></figure>

<p>    a) 如果容器内的根目录传播模式为<code>rslave</code>，则会传播进入容器，容器内会出现这条挂载点及其子挂载点。</p>
<p>    b) 如果容器内的根目录传播模式为<code>rprivate</code>，则不会传播进入容器，容器内不会出现这条挂载点及其子挂载点。</p>
<p>2、实行真正的拷贝</p>
<p>3、将主机侧的<code>xxx/merged/</code>, <code>-v</code>挂载点设置为<code>rprivate</code>属性。(修改属性，不会进行<code>mount</code>操作，不增加<code>mount</code>挂载点)</p>
<p>如果不将属性改为<code>rprivate</code>，则会导致<code>umount</code>的时候，把主机上，该目录及其子目录全部卸载掉。具体可见<a target="_blank" rel="noopener" href="https://github.com/moby/moby/commit/cacd4007776672e918162936d8846eb51a5300e6">https://github.com/moby/moby/commit/cacd4007776672e918162936d8846eb51a5300e6</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rprivate /var/lib/docker/overlay2/xxx/merged/var/run  </span><br></pre></td></tr></table></figure>

<p>4、进行<code>umount</code>卸载挂载点。</p>
<p>由于改为了<code>rprivate</code>，导致容器内残留。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount -l /var/lib/docker/overlay2/xxx/merged/var/run  </span><br></pre></td></tr></table></figure>

<h2 id="4-3-讨论"><a href="#4-3-讨论" class="headerlink" title="4.3 讨论"></a>4.3 讨论</h2><h3 id="4-3-1-docker-cp-为何要设置为rprivate"><a href="#4-3-1-docker-cp-为何要设置为rprivate" class="headerlink" title="4.3.1 docker cp 为何要设置为rprivate"></a>4.3.1 docker cp 为何要设置为rprivate</h3><p>如果不将属性改为<code>rprivate</code>，则会导致在主机侧进行<code>umount</code>系统调用的时候，把主机上，该目录及其子目录全部卸载掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /var/run:/var/run:rslave busybox sh  </span><br></pre></td></tr></table></figure>

<p><code>docker cp</code>命令在执行了第一次<code>mount</code>系统调用以后（见5.2.2），此时的<code>mount</code>关系图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.328888.xyz/2023/04/06/iI79rP.jpeg" alt="mount.after"></p>
<p>如果不再进行一次<code>mount</code>调用，设置传播属性为<code>rprivate</code>，则会导致主机侧<code>56 48 / xxx/merged/var/run shared:23</code>保持shared传播组，此时如果对这一条挂载点进行卸载，则会在<code>shared:23</code>组内传播<code>/run</code>挂载点的umount事件。会导致主机上的<code>23 38 / /run shared:23</code>及其子挂载点全部被卸载，导致系统错误。如果其他容器也挂载了该目录，同时也连在<code>shared:23</code>组内，那么其他容器也会收到本次<code>umount</code>事件，导致<code>umount</code>事件大量传播，所有收到<code>umoun</code>t事件的容器全部卸载<code>/run</code>目录。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>1、<code>docker cp</code>命令操作过于繁重，涉及大量<code>mount</code>、<code>umount</code>系统调用，生产环境使用中应当限制<code>docker cp</code>的大规模使用，只让<code>docker cp</code>作为一个调测手段由开发人员使用。因为作为调测手段而言，人为操作后即便泄露的<code>mount</code>挂载点总量也可控。</p>
<p>2、限制容器<code>-v</code>的使用也是一种方法，如果能保证所有<code>-v</code>都是<code>rprivat</code>且不包含<code>docker</code>根目录的父子目录，那么也不会有问题。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" title="kernel官方文档--mount">kernel官方文档–mount</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hu1610552336/article/details/109560411#t15" title="CSDN--linux内核mount过程超复杂的do_mount()、do_loopback()、attach_recursive_mnt()、propagate_mnt()函数详解">CSDN–linux内核mount过程超复杂的do_mount()、do_loopback()、attach_recursive_mnt()、propagate_mnt()函数详解</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/')">docker cp mount挂载属性传播</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=docker cp mount挂载属性传播&amp;url=https://shippomx.github.io/2023/07/15/containers/docker%20cp%E4%B8%8Emount%E6%8C%82%E8%BD%BD%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B6%85%E9%99%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/container/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>container<span class="tagsPageCount">26</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/14/containers/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%20-%20I_O%20%E8%99%9A%E6%8B%9F%E5%8C%96/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">容器安全-IO虚拟化</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/linux/%E5%BC%80%E6%BA%90%E6%97%A5%E5%BF%97%E5%BA%93log_c%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">开源日志库log_c的简单使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2021/12/21/containers/Docker%20%E7%9A%84%E7%BD%91%E7%BB%9C%20%E5%B0%86%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%A4%96%E9%83%A8%E4%B8%96%E7%95%8C%E8%BF%9E%E6%8E%A5/" title="docker中的网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-12-21</div><div class="title">docker中的网络</div></div></a></div><div><a href="/2023/10/04/containers/Calico%20%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/" title="Calico网络通信简略原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-04</div><div class="title">Calico网络通信简略原理</div></div></a></div><div><a href="/2021/12/21/containers/Docker%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" title="docker中的网络模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-12-21</div><div class="title">docker中的网络模式</div></div></a></div><div><a href="/2023/10/07/containers/Docker%E5%AE%B9%E5%99%A8%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Docker与虚拟化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-07</div><div class="title">Docker与虚拟化</div></div></a></div><div><a href="/2020/12/20/containers/Kata%20Containers%202.0%20%E4%BB%8B%E7%BB%8D/" title="Kata Containers 2.0"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-12-20</div><div class="title">Kata Containers 2.0</div></div></a></div><div><a href="/2023/10/06/containers/Kubernetes%20CNI%20%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/" title="Kubernetes CNI 网络插件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-06</div><div class="title">Kubernetes CNI 网络插件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E7%BB%93%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1 问题结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">2 问题现象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94linux-mount%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">3 问题背景知识——linux mount机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-mnt%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 mnt命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9F%A5%E7%9C%8Bmount%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 查看mount点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-cat-proc-self-mountinfo"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 cat &#x2F;proc&#x2F;self&#x2F;mountinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-findmnt"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 findmnt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%88%B6%E5%AD%90%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 父子挂载点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%88%B6%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 如何判断父挂载点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%85%B1%E4%BA%AB%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 共享组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-shared%E4%BC%A0%E6%92%AD"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 shared传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-slave%E4%BC%A0%E6%92%AD"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 slave传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BB%84%E5%B1%9E"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 如何确定组属</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-mount%E7%9A%84%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 mount的内核结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-docker%E5%AE%B9%E5%99%A8%E4%B8%8B%E7%9A%84mount"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 docker容器下的mount</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-docker%E4%B8%AD%E7%9A%84mount%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">4 docker中的mount传播属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-docker-run%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 docker run过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%AE%B9%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%BC%8F%E4%B8%8E-v%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%85%B6%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 容器根目录传播模式与-v目录及其传播模式的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-docker-run%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E7%9A%84mount%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 docker run启动容器的mount流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-docker-run-mount%E5%9C%A8dockerd%E5%92%8Crunc%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 docker run mount在dockerd和runc中的代码流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-1-dockerd%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">4.1.3.1 dockerd中的函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-2-runc%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">4.1.3.2 runc中的函数实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-docker-cp-mount%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 docker cp mount流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-docker-cp%E5%9C%A8docker%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E6%80%BB%E8%A7%88"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 docker cp在docker代码流程总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-docker-cp%E5%9C%A8%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 docker cp在实际操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-1-cp%E5%89%8D%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%8F%8A%E5%AE%B9%E5%99%A8mount%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">4.2.2.1 cp前，主机及容器mount状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2-docker-cp%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1mount"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">4.2.2.2 docker cp的第一次mount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-3-docker-cp%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1mount%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BF%AE%E6%94%B9%E6%8C%82%E8%BD%BD%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%97%A0%E5%AE%9E%E8%B4%A8%E6%8C%82%E8%BD%BD"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">4.2.2.3 docker cp的第二次mount操作，修改挂载属性，无实质挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4-docker-cp%E7%9A%84umount%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">4.2.2.4 docker cp的umount操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-5-umount%E4%BC%A0%E6%92%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">4.2.2.5 umount传播事件的流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-docker-cp%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 docker cp流程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%AE%A8%E8%AE%BA"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-docker-cp-%E4%B8%BA%E4%BD%95%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BArprivate"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 docker cp 为何要设置为rprivate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">5 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">6.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/" title="加权轮询算法">加权轮询算法</a><time datetime="2023-12-10T05:29:00.000Z" title="发表于 2023-12-10 13:29:00">2023-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/02/sdn/Using%20ONOS%20as%20a%20robust%20SDN%20controller%20with%20Mininet/" title="using onos as a robust sdn controller with mininet">using onos as a robust sdn controller with mininet</a><time datetime="2023-11-02T03:12:32.000Z" title="发表于 2023-11-02 11:12:32">2023-11-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/10/golang/%E8%B0%88%E8%B0%88%20go.mod%E3%80%81go.sum%E3%80%81go.work/" title="go modules">go modules</a><time datetime="2023-10-10T02:13:22.000Z" title="发表于 2023-10-10 10:13:22">2023-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/cmake%20starter/" title="cmake starters">cmake starters</a><time datetime="2023-10-08T03:25:56.000Z" title="发表于 2023-10-08 11:25:56">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/07/containers/Docker%E5%AE%B9%E5%99%A8%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Docker与虚拟化">Docker与虚拟化</a><time datetime="2023-10-07T06:44:56.000Z" title="发表于 2023-10-07 14:44:56">2023-10-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 0.88rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 0.88rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 0.88rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>41</sup></a><a href="/tags/network/" style="font-size: 0.88rem;">network<sup>9</sup></a><a href="/tags/pppoe/" style="font-size: 0.88rem;">pppoe<sup>1</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 0.88rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>