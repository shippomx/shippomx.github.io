<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>远辰 | 远辰</title><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="远辰"><meta name="application-name" content="远辰"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="远辰"><meta property="og:url" content="https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="1 概述ring buffer 称作环形缓冲区，也称作环形队列（circular queue），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。如下为环形缓冲区（ring buffer） 的概念示意图。 在任务间的通信、串口数据收发、log 缓存、网卡处理网络数据包、音频 &amp;amp;"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1 概述ring buffer 称作环形缓冲区，也称作环形队列（circular queue），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。如下为环形缓冲区（ring buffer） 的概念示意图。 在任务间的通信、串口数据收发、log 缓存、网卡处理网络数据包、音频 &amp;amp;"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: '远辰',
  postAI: '',
  pageFillDescription: '1 概述, 2 原理, 2.1 一个简单例子, 2.2 具体怎样做, 2.2.1 在缓冲区满的时候写数据有两种策略可以使用, 2.2.2 读数据时一定要读出缓冲区中最老的数据, 2.2.3 怎样来判断缓冲区是满的, 2.2.4 如何实现一个线性地址空间的循环读写, 3 实现, 3.1 RT-Thread 中实现的 ring buffer, 3.1.2 环形缓冲区结构体, 3.1.3 缓冲区初始化操作, 3.1.4 写操作和读操作, 3.1.5 判断缓冲区是否为空或满, 3.1.6 小结, 3.2 Linux 中实现的 ring buffer, 3.2.1 缓冲区结构体, 3.2.2 缓冲区初始化, 3.2.3 读操作和写操作, 3.2.4 判断缓冲区是否为空或满, 3.2.5 小结, 3.3 Linux 最新版本中的 ring buffer(5.17+), 4 总结概述称作环形缓冲区也称作环形队列是一种用于表示一个固定尺寸头尾相连的缓冲区的数据结构适合缓存数据流如下为环形缓冲区的概念示意图在任务间的通信串口数据收发缓存网卡处理网络数据包音频视频流处理中均有环形缓冲区的应用在的和文件中内核文件和中也有环形缓冲区的代码实现环形缓冲区的一些使用特点如下当一个数据元素被读取出后其余数据元素不需要移动其存储位置适合于事先明确了缓冲区的最大容量的情形缓冲区的容量长度一般固定可以用一个静态数组来充当缓冲区无需重复申请内存如果缓冲区的大小需要经常调整就不适合用环形缓冲区因为在扩展缓冲区大小时需要搬移其中的数据这种场合使用链表更加合适因为缓冲区成头尾相连的环形写操作可能会覆盖未及时读取的数据有的场景允许这种情况发生有的场景又严格限制这种情况发生选择何种策略和具体应用场景相关原理由于计算机内存是线性地址空间因此环形缓冲区需要特别的算法设计才可以从逻辑上实现一个简单例子先不要想环形缓冲区的具体实现细节来看一个简单的例子如下是一个空间大小为的环形缓冲区其中底部的单线箭头表示头尾相连形成一个环形地址空间假定被写入缓冲区中部对于环形缓冲区来说最初的写入位置在哪里是无关紧要的再写入两个元素分别是和这两个元素被追加到之后如果读出两个元素那么环形缓冲区中最老的两个元素将被读出先进先出原则在本例中和被读出缓冲区中剩下紧接着向缓冲区中写入六个元素这时缓冲区会被装满如果缓冲区是满的又要写入新的数据这时有两种策略一种是覆盖掉最老的数据也就是将老数据丢掉另一种是返回错误码或者抛出异常来看策略一例如这时写入两个元素和就会覆盖掉和再看这时如果读出两个元素就不是和而是和和这时最老和已经被和覆盖掉通过这个简单的例子可以总结出要实现环形缓冲区需要注意到几个问题点在缓冲区满的时候写数据有两种策略可以使用第一覆盖掉老数据第二抛出异常读数据时一定要读出缓冲区中最老的数据缓冲区中数据满足特性怎样来判断缓冲区是满的如何实现一个线性地址空间的循环读写具体怎样做一般的对一个环形缓冲区进行读写操作最少需要个信息在内存中的实际开始位置例如一片内存的头指针数组的第一个元素指针在内存中的实际结束位置也可以是缓冲区实际空间大小结合开始位置可以算出结束位置在缓冲区中进行写操作时的写索引值在缓冲区中进行读操作时的读索引值缓冲区开始位置和缓冲区结束位置或空间大小实际上定义了环形缓冲区的实际逻辑空间和大小读索引和写索引标记了缓冲区进行读操作和写操作时的具体位置如下图所示为环形缓冲区的典型读写过程当环形缓冲区为空时读索引和写索引指向相同的位置因为是环形缓冲区可以出现在任何位置当向缓冲区写入一个元素时元素被写入写索引当前所指向位置然后写索引加指向下一个位置当再写如一个元素时元素继续被写入写索引当前所指向位置然后写索引加指向下一个位置当接着写入五个元素后缓冲区就满了这时写索引和写索引指向同一个位置和缓冲区为空时一样当从缓冲区中读出一个元素时读索引当前所在位置的元素被读出然后读索引加指向下一个位置继续读出元素时还是读索引当前所在位置的元素被读出然后读索引加指向下一个位置下面来探讨具体怎样做在节中提出了四个问题点本节将会对这四个问题点进行回答在回答完这四个问题点后对于如何实现环形缓冲区的脉络应该会清晰起来在缓冲区满的时候写数据有两种策略可以使用缓冲区变满在环形缓冲区中会实际发生一般会有两种处理策略第一覆盖掉老数据第二抛出异常这两种策略该如何选择要结合具体的应用场景如音视频流中丢掉一些数据不要紧可以选择第一种策略在任务间通信的时候要严格保证数据正确传输这个时候就要选择第二种策略读数据时一定要读出缓冲区中最老的数据环形缓冲区也是类型的数据结构需要满足先进先出的原则写就相当于进读就相当于出所以读数据时一定要保证读最老的数据一般的情况下不会有问题但有一种场景需要小心如下图所示环形缓冲区的大小为七缓冲区中已经存储了五个元素如果再向缓冲区中写入三个元素因为剩余空间为了所以要想写入这三个元素肯定会覆盖掉一个元素此时读写索引变为如下图所示读索引不再停留在元素处而是在元素处因为元素已经被覆盖掉而元素变为最老的元素这个例子说明当缓冲区是满的时候继续写入元素覆盖除了写索引要变读索引也要跟着变保证读索引一定是指向缓冲区中最老的元素怎样来判断缓冲区是满的如下图缓冲区是满或是空都有可能出现读索引与写索引指向同一位置判断缓冲区是满还是空在环形缓冲区中是一个重点问题在维基百科中讲解了五种判断方法感兴趣可以看一下在平衡各方优缺点后本节重点讲解镜像指示位方法在和实现的环形缓冲区中也都是用的该策略或者说是该策略的扩展镜像指示位缓冲区的长度如果是逻辑地址空间则为至那么规定至为镜像逻辑地址空间本策略规定读写指针的地址空间为至其中低半部分对应于常规的逻辑地址空间高半部分对应于镜像逻辑地址空间当指针值大于等于时使其折返到使用一位表示写指针或读指针是否进入了虚拟的镜像存储区置位表示进入不置位表示没进入还在基本存储区在读写指针的值相同情况下如果二者的指示位相同说明缓冲区为空如果二者的指示位不同说明缓冲区为满这种方法优点是测试缓冲区满空很简单不需要做取余数操作读写线程可以分别设计专用算法策略能实现精致的并发控制缺点是读写指针各需要额外的一位作为指示位如果缓冲区长度是的幂则本方法可以省略镜像指示位如果读写指针的值相等则缓冲区为空如果读写指针相差则缓冲区为满这可以用条件表达式写指针读指针异或缓冲区长度来判断维基百科上面是维基百科中对镜像指示位的整体描述但是单凭上面这一个描述去理解镜像指示位方法还是有一定困难下面来进行一些讨论上面描述中提到了读写指针的概念注意这个读写指针和上文提到的读索引和写索引不是一回事读写指针的范围是而读索引和写索引的范围是其必须和缓冲区的实际逻辑空间一致但是读写指针和读索引和写索引有一个转换关系读索引读指针缓冲区长度写索引写指针缓冲区长度其中号是求余运算符但是如果缓冲区长度是的幂那么求余运算可以等价的转换为如下的按位与运算读索引读指针缓冲区长度写索引写指针缓冲区长度按位与的运算效率要比求余运算高的多在内核中将缓冲区长度扩展为的幂长度随处可见都是为了用按位与操作代替求余操作为了判断缓冲区是否为空或者满镜像指示位策略引入了两个布尔变量指示位来分别标记读指针或写指针是否进入了镜像区间在读写指针的值相同情况下如果二者的指示位相同说明缓冲区为空如果二者的指示位不同说明缓冲区为满但如果缓冲区的长度是的幂则可以省略镜像指示位如果读写指针的值相等则缓冲区为空如果读写指针相差则缓冲区为满如何实现一个线性地址空间的循环读写理解了节的描述再来理解用一个线性地址空间来实现循环读写就比较容易如一个环形缓冲区的长度为七则其读写索引的区间为当写索引的值为再向缓冲区中写入一个元素时写索引应该要回到缓冲区的起始索引位置读索引在碰到这种情况也是类似处理总结为一句话就是当写索引或读索引已经到了环形缓冲区的结束位置时进行下一步操作时其应该要回到环形缓冲区的开始位置实现对于环形缓冲区的代码实现本文会分析的和文件内核中的和文件中实现的下面分析的实现主要会讨论环形缓冲区结构体缓冲区初始化操作写操作读操作判断缓冲区是否为空或满环形缓冲区结构体中定义了结构体其中和节中介绍的个信息是完全对应的为了判断缓冲区是空还是满还定义了两个布尔型变量和其是通过位域的定义方式来实现缓冲区初始化操作初始化操作很容易理解就是将申请好的内存地址赋值给环形缓冲区缓冲区实际逻辑大小也传入进去和全部初始化为零写操作和读操作写操作有两个接口和当缓冲区满的时候前一个不会写入后一个会强制写入覆盖读操作有一个接口这里先说明一下的实现虽然借鉴了上一章讲的镜像指示位策略但其并没有使用读写指针而是直接用的写索引和读索引也就是说结构体中的和就是写索引和读索引无需进行转换直接可以用来操作缓冲区这一点和的实现方式不同在下面的章节中会看到但和是和镜像指示位策略中讲的一样用来标记是否进入了镜像区间先来看的实现该函数的返回值是实际写入大小就是如果传入的大于缓冲区的剩余空间则只有部分会被写入缓冲区通过条件将写操作分成了如下两种情形当为真时其对应的是情形一就是说从写索引到缓冲区结束位置这一段空间能容纳全部所写入数据在图片情形一中开始缓冲区中有两个元素接着继续写入三个元素可以看出从写索引到缓冲区结束位置还可以容纳个元素所以三个元素可以一次性写入缓冲区写索引无需回环对应的代码就是当为假时其对应的是情形二就是说从写索引到缓冲区结束位置这一段空间无法全部容纳所写入数据写索引需要回环到缓冲区开头写入剩下的数据在图片情形二中开始缓冲区中有两个元素接着继续写入三个元素可以看出从写索引到缓冲区结束位置还可以容纳个元素也就是说两个元素可以写入从写索引到缓冲区结束位置这一段而只能回环到缓冲区的开头位置对应代码就是因为写索引已经回环了所以要将做一下取反操作写操作接口和上面介绍的基本一样其实就是多了当传入的大于缓冲区的剩余空间时会将已有的元素覆盖掉如果发生了元素覆盖那缓冲区一定会变满和回相等对应语句也即节中讨论的问题读索引要指向最老元素因为会操作元素也要考虑其是否发生了回环发生了回环后需要取反对应语句图中对应的情形三描述了该过程开始缓冲区中有两个元素接着继续写入六个元素此时元素被覆盖掉写索引和读索引都指向元素读接口和写接口的操作逻辑基本一致也是通过条件将读操作分成了两种情形过程和写操作接口没有差异判断缓冲区是否为空或满判断缓冲区是否为空或满通过函数来实现其逻辑就是在节中介绍的在读写指针的值相同情况下如果二者的指示位相同说明缓冲区为空如果二者的指示位不同说明缓冲区为满注意这里的读写指针已经在读写和过程中转换为了读写索引小结在多线程中对同一个环形缓冲区进行读写操作时需要加上锁不然存在访问不安全问题当只有一个读线程和一个写线程时用和进行读写操作缓冲区是线程安全的无需加锁但是不行因为其可能对读写索引都进行操作的场景这个时候再进行读操作就是不安全访问读写指针已经在读写和过程中转换为了读写索引所以读索引和写索引可以直接用来操作缓冲区无需转换和的大小区间为为缓冲区大小的环形缓冲区不需要大小为的幂中实现的在内核中就是的经典实现方式本文将介绍版本中的实现方式主要介绍缓冲区结构体缓冲区初始化读操作写操作判断缓冲区是否为空或满缓冲区结构体的结构体定义如下其中和节中介绍的环形缓冲区个信息是一一对应的但其中分别是写指针和读指针而不是写索引和读索引它们之间的转换关系就是节介绍的转化公式参数是自旋锁在多进程线程对同一个环形缓冲区进行读写操作时需要进行锁保护和对比可以看到其并没有读写的镜像指示位判断缓冲区是否为空或满呢在下一节会进行分析缓冲区初始化在的初始化中可以看出其会对所传入的大小进行扩展使其满足为的幂这样就可以使用节中介绍的性质如果缓冲区的长度是的幂则可以省略镜像指示位如果读写指针的值相等则缓冲区为空如果读写指针相差缓冲区大小则缓冲区为满所以在传入的大小时最好开始就将其确定为的幂读操作和写操作可以看到对读操作和写操作的实现非常简洁在进行读操作和写操作时其充分利用了无符号整型的性质在写操作和读操作时写指针和读指针都是正向增加的当达到最大值时产生溢出使得从开始进行循环使用写指针和读指针会恒定的保持如下关系读指针缓冲区已存储数据长度写指针读指针缓冲区已存储数据长度写指针其中读指针是写指针是读指针永远不会超过写指针的大小最多两者相等相等就是缓冲区为空的时候再结合在节中介绍的转换关系读索引读指针缓冲区长度读索引读指针缓冲区长度写索引写指针缓冲区长度写索引写指针缓冲区长度就可以对环形缓冲区进行读写操作了下面来看源码先看的源码中表达的意思就是实际写入的长度一定要小于缓冲区的可用空间大小防止发生覆盖已有元素的场景来看这一句其中就是将写指针转换为写索引整体表达的意思是从写索引到缓冲区结束位置这一段所能写入数据的大小这一段写入操作的代码为如果这一段还不够需要折返到缓冲区的开始位置将剩下的部分写入到缓冲区中其代码为而且因为取的是较小值因为取的是较小值因为取的是较小值当就说明第一段已经可以容纳所写入大小缓冲区无需折返第二个拷贝了零个字节相当于什么也没有发生再看的源码其思路基本和一致了解了上面的转换关系就比较好理解判断缓冲区是否为空或满中没有专门的函数判断缓冲区是否为空或满但可以通过函数获取缓冲区已存储数据长度如果其值等于零就说明缓冲区为空如果其值等于缓冲区大小就说明缓冲区满小结中环形缓冲区的实现其实是对节介绍的镜像指示位策略的扩展读指针和写指针区间范围不再局限在镜像区间而是整个大小的空间对于位机器读指针和写指针的区间范围是进行扩展后还能维持如下的关系是因为缓冲区大小会被扩展为的幂那么肯定是扩展后的整数倍所以还是能够满足如下关系读索引读指针缓冲区长度读索引读指针缓冲区长度写索引写指针缓冲区长度写索引写指针缓冲区长度读索引和写索引的区间范围仍然是在多进程线程中对同一个环形缓冲区进行读写操作时需要加上锁不然存在访问不安全问题当只有一个读进程线程和一个写进程线程时无需加锁也能保证访问安全最新版本中的在最新版本的和中其源码实现已经和版本有很大的不同但是最新版本的核心思想和版本并没有不同如下是最新文件中定义的结构体其中依然是写指针和读指针是缓冲区大小减做操作更方便的将读写指针转换为读写索引缓冲区单个存储元素的字节大小在版本中一个元素就是一个字节大小最新版本将其进行了扩展缓冲区的逻辑起始地址指针类型不再是字节其它的初始化接口读接口写接口判断缓冲区是否为空或满接口逻辑和节介绍的大致差不多可以对照源码看一下总结环形缓冲区适合于事先明确了缓冲区的最大容量的情形缓冲区的容量长度一般固定可以用一个静态数组来充当缓冲区无需重复申请内存如果缓冲区的大小需要经常调整就不适合用环形缓存区因为在扩展缓冲区大小时需要搬移其中的数据这种场合使用链表更加合适因为缓冲区成头尾相连的环形写操作可能会覆盖未及时读取的数据有的场景允许这种情况发生有的场景又严格限制这种情况发生选择何种策略和具体应用场景相关环形缓冲区特别适合于通信双方循环发送数据的场景镜像指示位是一种高效判断缓冲区是否为空或满的策略在和中都使用了该策略或者是该策略的扩展其能够保证在只有一个读线程或进程和一个写线程或进程中无需锁也能做到线程安全注意区分写指针和写索引读指针和读索引最终对缓冲区进行操作还是需要写索引和读索引如果自己嵌入式项目中需要使用环形缓冲区可以借鉴版本的实现很容易改写而且非常高效',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 17:43:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-30T08:55:27.430Z" title="发表于 2023-11-30 16:55:27">2023-11-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-30T09:43:46.412Z" title="更新于 2023-11-30 17:43:46">2023-11-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2023-11-30T08:55:27.430Z" title="发表于 2023-11-30 16:55:27">2023-11-30</time><time itemprop="dateCreated datePublished" datetime="2023-11-30T09:43:46.412Z" title="更新于 2023-11-30 17:43:46">2023-11-30</time></header><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><strong>ring buffer</strong> 称作<strong>环形缓冲区</strong>，也称作环形队列（circular queue），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。如下为<strong>环形缓冲区（ring buffer）</strong> 的概念示意图。</p>
<p>在任务间的通信、串口数据收发、log 缓存、网卡处理网络数据包、音频 &#x2F; 视频流处理中均有<strong>环形缓冲区（ring buffer）</strong> 的应用。在 <strong>RT-Thread</strong> 的<code>ringbuffer.c</code>和<code>ringbuffer.h</code>文件中，<strong>Linux</strong> 内核文件<code>kfifo.h</code>和<code>kfifo.c</code>中也有<strong>环形缓冲区（ring buffer）</strong>的代码实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-846878d6005f23f9f15afde8fe0ae028_b.gif"></p>
<p>环形缓冲区的一些使用特点如下：</p>
<ul>
<li>当一个数据元素被读取出后，其余数据元素不需要移动其存储位置；</li>
<li>适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；</li>
<li>如果缓冲区的大小需要经常调整，就不适合用环形缓冲区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；</li>
<li>因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关。</li>
</ul>
<h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h1><p>由于计算机内存是线性地址空间，因此<strong>环形缓冲区（ring buffer）</strong>需要特别的算法设计才可以从逻辑上实现。</p>
<h3 id="2-1-一个简单例子"><a href="#2-1-一个简单例子" class="headerlink" title="2.1 一个简单例子"></a>2.1 一个简单例子</h3><p>先不要想<strong>环形缓冲区（ring buffer）</strong>的具体实现细节，来看一个简单的例子。如下是一个空间大小为 <strong>7</strong> 的环形缓冲区，其中底部的单线箭头表示 “头尾相连” 形成一个环形地址空间：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-3c708766d94d38cf4200178999dd7599_r.jpg"></p>
<p>假定<code>1</code>被写入缓冲区中部（对于环形缓冲区来说，最初的写入位置在哪里是无关紧要的）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-3a8ce87ad6a58e055b539be393b27e18_r.jpg"></p>
<p>再<strong>写入两个</strong>元素，分别是<code>2</code>和<code>3</code>，这两个元素被追加到<code>1</code>之后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-eabe9ec4a3b9f9e0baf9f00694ca86ff_r.jpg"></p>
<p>如果<strong>读出两个</strong>元素，那么环形缓冲区中最老的两个元素将被读出（先进先出原则）。在本例中<code>1</code>和<code>2</code>被读出，缓冲区中剩下<code>3</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-64d494cde67e724293a94d4e0ab7bbfd_r.jpg"></p>
<p>紧接着，向缓冲区中<strong>写入六个</strong>元素<code>4、5、6、7、8、9</code>，这时缓冲区会被装满：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-7926b90699fc686536533549dea6f1e5_r.jpg"></p>
<p>如果缓冲区是满的，又要写入新的数据，这时有两种策略：一种是覆盖掉最老的数据，也就是将老数据丢掉；另一种是返回错误码或者抛出异常。来看策略一，例如，这时<strong>写入两个</strong>元素<code>A</code>和<code>B</code>，就会覆盖掉<code>3</code>和<code>4</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b16ea940dd23d91c3438b608afd465d8_r.jpg"></p>
<p>再看，这时如果<strong>读出两个</strong>元素，就不是<code>3</code>和<code>4</code>而是<code>5</code>和<code>6</code>（<code>5</code>和<code>6</code>这时最老），<code>3</code>和<code>4</code>已经被<code>A</code>和<code>B</code>覆盖掉。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-cccac7c12e03b751d7e5f34edda10b56_r.jpg"></p>
<p>通过这个简单的例子，可以总结出要实现<strong>环形缓冲区（ring buffer）</strong>需要注意到几个问题点：</p>
<ol>
<li>在缓冲区满的时候写数据，有两种策略可以使用：第一覆盖掉老数据；第二抛出异常；</li>
<li>读数据时，一定要读出缓冲区中最老的数据（缓冲区中数据满足 FIFO 特性）；</li>
<li>怎样来判断缓冲区是满的；</li>
<li>如何实现一个线性地址空间的循环读写。</li>
</ol>
<h2 id="2-2-具体怎样做"><a href="#2-2-具体怎样做" class="headerlink" title="2.2 具体怎样做"></a>2.2 具体怎样做</h2><p>一般的，对一个环形缓冲区进行读写操作，最少需要 <strong>4</strong> 个信息：</p>
<ul>
<li>在内存中的实际<strong>开始位置</strong>（例如：一片内存的头指针，数组的第一个元素指针）；</li>
<li>在内存中的实际<strong>结束位置</strong>（也可以是缓冲区实际空间大小，结合开始位置，可以算出结束位置）；</li>
<li>在缓冲区中进行写操作时的<strong>写索引</strong>值；</li>
<li>在缓冲区中进行读操作时的<strong>读索引</strong>值。</li>
</ul>
<p><strong>缓冲区开始位置</strong>和<strong>缓冲区结束位置（或空间大小）</strong> 实际上定义了环形缓冲区的实际逻辑空间和大小。<strong>读索引</strong>和<strong>写索引</strong>标记了缓冲区进行读操作和写操作时的具体位置。如下图所示，为环形缓冲区的典型读写过程：</p>
<ol>
<li>当环形缓冲区为空时，读索引和写索引指向相同的位置（因为是环形缓冲区，可以出现在任何位置）；</li>
<li>当向缓冲区写入一个元素时，元素<code>A</code>被写入<strong>写索引</strong>当前所指向位置，然后写索引加 1，指向下一个位置；</li>
<li>当再写如一个元素<code>B</code>时，元素<code>B</code>继续被写入<strong>写索引</strong>当前所指向位置，然后写索引加 1，指向下一个位置；</li>
<li>当接着写入<code>C</code>、<code>D</code>、<code>E</code>、<code>F</code>、<code>G</code>五个元素后，缓冲区就满了，这时<strong>写索引</strong>和<strong>写索引</strong>指向同一个位置 (和缓冲区为空时一样)；</li>
<li>当从缓冲区中读出一个元素<code>A</code>时，<strong>读索引</strong>当前所在位置的元素被读出，然后<strong>读索引</strong>加 1，指向下一个位置；</li>
<li>继续读出元素<code>B</code>时，还是<strong>读索引</strong>当前所在位置的元素被读出，然后<strong>读索引</strong>加 1，指向下一个位置。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-67987366b04587ac940c666c4f83a860_r.jpg"></p>
<p>下面来探讨具体怎样做？在 <strong>2.1 节</strong>中提出了四个问题点，本节将会对这四个问题点进行回答，在回答完这四个问题点后，对于如何实现<strong>环形缓冲区（ring buffer）</strong>的脉络应该会清晰起来。</p>
<h3 id="2-2-1-在缓冲区满的时候写数据，有两种策略可以使用"><a href="#2-2-1-在缓冲区满的时候写数据，有两种策略可以使用" class="headerlink" title="2.2.1 在缓冲区满的时候写数据，有两种策略可以使用"></a>2.2.1 在缓冲区满的时候写数据，有两种策略可以使用</h3><p>缓冲区变满在<strong>环形缓冲区（ring buffer）</strong>中会实际发生，一般会有两种处理策略，第一覆盖掉老数据；第二抛出 “异常”。这两种策略该如何选择要结合具体的应用场景。如音 &#x2F; 视频流中，丢掉一些数据不要紧，可以选择第一种策略；在任务间通信的时候，要严格保证数据正确传输，这个时候就要选择第二种策略。</p>
<h3 id="2-2-2-读数据时，一定要读出缓冲区中最老的数据"><a href="#2-2-2-读数据时，一定要读出缓冲区中最老的数据" class="headerlink" title="2.2.2 读数据时，一定要读出缓冲区中最老的数据"></a>2.2.2 读数据时，一定要读出缓冲区中最老的数据</h3><p><strong>环形缓冲区（ring buffer）</strong>也是<code>FIFO</code>类型的数据结构，需要满足先进先出的原则。<strong>写</strong>就相当于进，<strong>读</strong>就相当于出。所以读数据时，一定要保证读最老的数据。一般的情况下不会有问题，但有一种场景需要小心。如下图所示环形缓冲区的大小为 <strong>七</strong>，缓冲区中已经存储了<code>7</code>，<code>8</code>，<code>9</code>，<code>3</code>，<code>4</code>五个元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-1af2a1bf448a43cbbcf70b9afdf4a482_r.jpg"></p>
<p>如果再向缓冲区中写入三个元素<code>A</code>，<code>B</code>，<code>C</code>，因为剩余空间为 <strong>2</strong> 了，所以要想写入这三个元素肯定会覆盖掉一个元素。此时，读 &#x2F; 写索引变为如下图所示。读索引不再停留在元素<code>7</code>处，而是在元素<code>8</code>处，因为元素<code>7</code>已经被覆盖掉，而元素<code>8</code>变为最老的元素。这个例子说明，当缓冲区是满的时候，继续写入元素（覆盖），除了<strong>写索引</strong>要变，<strong>读索引</strong>也要跟着变，保证<strong>读索引</strong>一定是指向缓冲区中最老的元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-476b7cc48e208abcd634c9c5222bed38_r.jpg"></p>
<h3 id="2-2-3-怎样来判断缓冲区是满的"><a href="#2-2-3-怎样来判断缓冲区是满的" class="headerlink" title="2.2.3 怎样来判断缓冲区是满的"></a>2.2.3 怎样来判断缓冲区是满的</h3><p>如下图，缓冲区是满、或是空，都有可能出现读索引与写索引指向同一位置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-d1c9c30ea0e1338d15a21005ae1b0ebd_r.jpg"></p>
<p>判断缓冲区是满还是空，在<strong>环形缓冲区 ring buffer</strong> 中是一个重点问题，在维基百科 (<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Circular_buffer">http://en.wikipedia.org/wiki/Circular_buffer</a>) 中，讲解了五种判断方法，感兴趣可以看一下。在平衡各方优缺点后，本节重点讲解 <strong>镜像指示位</strong>方法，在<code>linux</code>和<code>RT-Thread</code>实现的环形缓冲区中，也都是用的该策略（或者说是该策略的扩展）。</p>
<blockquote>
<p><strong>镜像指示位</strong>：缓冲区的长度如果是 n，逻辑地址空间则为 0 至 n-1；那么，规定 n 至 2n-1 为镜像逻辑地址空间。本策略规定读写指针的地址空间为 0 至 2n-1，其中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于 2n 时，使其折返（wrapped）到 ptr-2n。使用一位表示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。  </p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-22cba7a9b8ff0746184d752a63621981_r.jpg"></p>
<p>在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。这种方法优点是测试缓冲区满 &#x2F; 空很简单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。 缺点是读写指针各需要额外的一位作为指示位。<br>如果缓冲区长度是 2 的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 n，则缓冲区为满，这可以用条件表达式（写指针 &#x3D;&#x3D; (读指针 异或 缓冲区长度)）来判断。—— 维基百科  </p>
<p>上面是维基百科中对<strong>镜像指示位</strong>的整体描述，但是单凭上面这一个描述，去理解<strong>镜像指示位</strong>方法还是有一定困难，下面来进行一些讨论。<br>上面描述中提到了<strong>读 &#x2F; 写指针</strong>的概念，注意这个读 &#x2F; 写指针和上文提到的<strong>读索引</strong>和<strong>写索引</strong>不是一回事。读写指针的范围是$[0，2n-1]$[0，2n-1]，而<strong>读索引</strong>和<strong>写索引</strong>的范围是$[0，n-1]$[0，n-1]，其必须和缓冲区的实际逻辑空间一致。但是<strong>读 &#x2F; 写指针</strong>和<strong>读索引</strong>和<strong>写索引</strong>有一个转换关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$读索引 = 读指针 \% 缓冲区长度 </span><br><span class="line"></span><br><span class="line">$$写索引 = 写指针 \% 缓冲区长度</span><br></pre></td></tr></table></figure>

<p>其中$%$% 号，是求余运算符。但是如果缓冲区长度是 2 的幂，那么求余运算可以等价的转换为如下的<strong>按位与</strong>运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$读索引 = 读指针 \&amp; (缓冲区长度-1)</span><br><span class="line"></span><br><span class="line">$$写索引 = 写指针 \&amp; (缓冲区长度-1)</span><br></pre></td></tr></table></figure>

<p>按位与的运算效率要比求余运算高的多，在<code>linux</code>内核中将缓冲区长度扩展为 2 的幂长度随处可见，都是为了用按位与操作代替求余操作。为了判断缓冲区是否为<strong>空或者满</strong>，镜像指示位策略引入了两个布尔变量（指示位），来分别标记读指针或写指针是否进入了镜像区间$[n，2n-1]$[n，2n-1]，在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区<strong>为空</strong>；如果二者的指示位不同，说明缓冲区<strong>为满</strong>。但如果缓冲区的长度是 2 的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 n，则缓冲区为满。</p>
<h3 id="2-2-4-如何实现一个线性地址空间的循环读写"><a href="#2-2-4-如何实现一个线性地址空间的循环读写" class="headerlink" title="2.2.4 如何实现一个线性地址空间的循环读写"></a>2.2.4 如何实现一个线性地址空间的循环读写</h3><p>理解了 <strong>2.2.3 节</strong>的描述，再来理解用一个线性地址空间来实现循环读写就比较容易。如一个环形缓冲区的长度为<strong>七</strong>，则其读写索引的区间为$[0，6]$[0，6]。当写索引的值为<code>6</code>，再向缓冲区中写入一个元素时，写索引应该要回到缓冲区的起始索引位置<code>0</code>，读索引在碰到这种情况也是类似处理。总结为一句话就是，当写索引或读索引已经到了环形缓冲区的结束位置时，进行下一步操作时，其应该要回到环形缓冲区的开始位置。</p>
<h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h1><p>对于环形缓冲区的代码实现，本文会分析 <strong>RT-Thread</strong> 的<code>ringbuffer.c</code>和<code>ringbuffer.h</code>文件，<strong>Linux</strong> 内核中的<code>kfifo.h</code>和<code>kfifo.c</code>文件。</p>
<h2 id="3-1-RT-Thread-中实现的-ring-buffer"><a href="#3-1-RT-Thread-中实现的-ring-buffer" class="headerlink" title="3.1 RT-Thread 中实现的 ring buffer"></a>3.1 RT-Thread 中实现的 ring buffer</h2><p>下面分析 <strong>RT-Thread</strong> 的 <strong>ring buffer</strong> 实现，主要会讨论<strong>环形缓冲区结构体</strong>、<strong>缓冲区初始化操作</strong>、<strong>写操作</strong>、<strong>读操作</strong>、<strong>判断缓冲区是否为空或满</strong>。</p>
<h3 id="3-1-2-环形缓冲区结构体"><a href="#3-1-2-环形缓冲区结构体" class="headerlink" title="3.1.2 环形缓冲区结构体"></a>3.1.2 环形缓冲区结构体</h3><p><code>RT-Thread</code>中定义了结构体<code>rt_ringbuffer</code>，其中<code>buffer_ptr</code>、<code>buffer_size</code>、<code>read_index</code>、<code>write_index</code>和 <strong>2.2 节</strong>中介绍的 <strong>4</strong> 个信息是完全对应的。为了判断缓冲区是空还是满，还定义了两个布尔型变量<code>read_mirror</code>和<code>write_mirror</code>，其是通过位域的定义方式来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_ringbuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_uint8_t</span> *buffer_ptr;</span><br><span class="line">    <span class="type">rt_uint16_t</span> read_mirror : <span class="number">1</span>;</span><br><span class="line">    <span class="type">rt_uint16_t</span> read_index : <span class="number">15</span>;</span><br><span class="line">    <span class="type">rt_uint16_t</span> write_mirror : <span class="number">1</span>;</span><br><span class="line">    <span class="type">rt_uint16_t</span> write_index : <span class="number">15</span>;</span><br><span class="line">    <span class="type">rt_int16_t</span> buffer_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-缓冲区初始化操作"><a href="#3-1-3-缓冲区初始化操作" class="headerlink" title="3.1.3 缓冲区初始化操作"></a>3.1.3 缓冲区初始化操作</h3><p>初始化操作<code>rt_ringbuffer_init</code>很容易理解，就是将申请好的内存地址赋值给环形缓冲区，缓冲区实际逻辑大小也传入进去。<code>read_index</code>、<code>write_index</code>、<code>read_mirror</code>和<code>write_mirror</code>全部初始化为零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_ringbuffer_init</span><span class="params">(<span class="keyword">struct</span> rt_ringbuffer *rb,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span>           *pool,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_int16_t</span>            size)</span></span><br><span class="line">&#123;</span><br><span class="line">    RT_ASSERT(rb != RT_NULL);</span><br><span class="line">    RT_ASSERT(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize read and write index */</span></span><br><span class="line">    rb-&gt;read_mirror = rb-&gt;read_index = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;write_mirror = rb-&gt;write_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set buffer pool and size */</span></span><br><span class="line">    rb-&gt;buffer_ptr = pool;</span><br><span class="line">    rb-&gt;buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-写操作和读操作"><a href="#3-1-4-写操作和读操作" class="headerlink" title="3.1.4 写操作和读操作"></a>3.1.4 写操作和读操作</h3><p>写操作有两个接口<code>rt_ringbuffer_put</code>和<code>rt_ringbuffer_put_force</code>，当缓冲区满的时候，前一个不会写入，后一个会强制写入（覆盖）；读操作有一个接口<code>rt_ringbuffer_get</code>。<br>这里先说明一下，<strong>RT-Thread</strong> 的 <strong>ring buffer</strong> 实现虽然借鉴了上一章讲的<strong>镜像指示位</strong>策略，但其并没有使用读写指针，而是直接用的<strong>写索引</strong>和<strong>读索引</strong>，也就是说结构体中的<code>read_index</code>和<code>write_index</code>就是<strong>写索引</strong>和<strong>读索引</strong>，无需进行转换，直接可以用来操作缓冲区。这一点和<code>linux</code>的实现方式不同，在下面的<code>linux</code>章节中会看到。但<code>read_mirror</code>和<code>write_mirror</code>是和<strong>镜像指示位</strong>策略中讲的一样，用来标记是否进入了镜像区间。<br>先来看<code>rt_ringbuffer_put</code>的实现，该函数的返回值是实际写入大小，就是如果传入的<code>length</code>大于缓冲区的剩余空间，则<code>length</code>只有部分会被写入缓冲区。通过条件<code>if (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</code>将写操作分成了如下两种情形：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-63929e833dfa2be0a5c0359458efe69e_r.jpg"></p>
<p>当<code>if (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</code>为<strong>真</strong>时，其对应的是<strong>情形一</strong>。就是说从<strong>写索引</strong>到缓冲区结束位置这一段空间能容纳全部所写入数据。在图片情形一中，开始缓冲区中有两个元素<code>1</code>、<code>2</code>，接着继续写入<code>A</code>、<code>B</code>、<code>C</code>三个元素。可以看出从<strong>写索引</strong>到缓冲区结束位置还可以容纳 <strong>4</strong> 个元素，所以<code>A</code>、<code>B</code>、<code>C</code>三个元素可以一次性写入缓冲区，<strong>写索引</strong>无需回环。对应的代码就是</p>
<p><code>rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index], ptr, length);</code>。<br>当<code>if (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</code>为<strong>假</strong>时，其对应的是<strong>情形二</strong>。就是说从<strong>写索引</strong>到缓冲区结束位置这一段空间无法全部容纳所写入数据，<strong>写索引</strong>需要回环到缓冲区开头，写入剩下的数据。在图片情形二中，开始缓冲区中有两个元素<code>1</code>、<code>2</code>，接着继续写入<code>A</code>、<code>B</code>、<code>C</code>三个元素。可以看出从<strong>写索引</strong>到缓冲区结束位置还可以容纳 <strong>2</strong> 个元素，也就是说<code>A</code>、<code>B</code>两个元素可以写入从<strong>写索引</strong>到缓冲区结束位置这一段，而<code>C</code>只能回环到缓冲区的开头位置。对应代码就是<code>rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index],&amp;ptr[0],rb-&gt;buffer_size - rb-&gt;write_index);rt_memcpy(&amp;rb-&gt;buffer_ptr[0],&amp;ptr[rb-&gt;buffer_size - rb-&gt;write_index],length - (rb-&gt;buffer_size - rb-&gt;write_index));</code>。因为写索引已经回环了，所以要将<code>write_mirror</code>做一下取反操作：<code>rb-&gt;write_mirror = ~rb-&gt;write_mirror;</code>。<br>写操作接口<code>rt_ringbuffer_put_force</code>和上面介绍的基本一样，其实就是多了当传入的<code>length</code>大于缓冲区的剩余空间时，会将已有的元素覆盖掉。如果发生了元素覆盖，那缓冲区一定会变满，read_index 和 write_index 回相等，对应语句<code>if (length &gt; space_length) rb-&gt;read_index = rb-&gt;write_index;</code>（也即 2.1 节中讨论的问题 2，读索引要指向最老元素）。因为会操作<code>read_index</code>元素，也要考虑其是否发生了回环，发生了回环后<code>read_mirror</code>需要取反，对应语句<code>rb-&gt;read_mirror = ~rb-&gt;read_mirror;</code>。图中对应的<strong>情形三</strong>描述了该过程，开始缓冲区中有两个元素<code>1</code>、<code>2</code>，接着继续写入<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>、<code>F</code>六个元素。此时元素<code>1</code>被覆盖掉，<strong>写索引</strong>和<strong>读索引</strong>都指向元素<code>2</code>。<br>读接口<code>rt_ringbuffer_get</code>和写接口的操作逻辑基本一致，也是通过条件<code>if (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</code>将读操作分成了两种情形，过程和写操作接口<code>rt_ringbuffer_put</code>没有差异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will discard out-of-range data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rb            A pointer to the ring buffer object.</span></span><br><span class="line"><span class="comment"> * @param ptr           A pointer to the data buffer.</span></span><br><span class="line"><span class="comment"> * @param length        The size of data in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Return the data size we put into the ring buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">rt_size_t</span> <span class="title function_">rt_ringbuffer_put</span><span class="params">(<span class="keyword">struct</span> rt_ringbuffer *rb,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">rt_uint8_t</span>     *ptr,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint16_t</span>           length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint16_t</span> size;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(rb != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* whether has enough space */</span></span><br><span class="line">    size = rt_ringbuffer_space_len(rb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no space */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* drop some data */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; length)</span><br><span class="line">        length = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* read_index - write_index = empty space */</span></span><br><span class="line">        rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index], ptr, length);</span><br><span class="line">        <span class="comment">/* this should not cause overflow because there is enough space for</span></span><br><span class="line"><span class="comment">         * length of data in current mirror */</span></span><br><span class="line">        rb-&gt;write_index += length;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index],</span><br><span class="line">           &amp;ptr[<span class="number">0</span>],</span><br><span class="line">           rb-&gt;buffer_size - rb-&gt;write_index);</span><br><span class="line">    rt_memcpy(&amp;rb-&gt;buffer_ptr[<span class="number">0</span>],</span><br><span class="line">           &amp;ptr[rb-&gt;buffer_size - rb-&gt;write_index],</span><br><span class="line">           length - (rb-&gt;buffer_size - rb-&gt;write_index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are going into the other side of the mirror */</span></span><br><span class="line">    rb-&gt;write_mirror = ~rb-&gt;write_mirror;</span><br><span class="line">    rb-&gt;write_index = length - (rb-&gt;buffer_size - rb-&gt;write_index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line">RTM_EXPORT(rt_ringbuffer_put);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will overwrite the existing data in the ring buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rb            A pointer to the ring buffer object.</span></span><br><span class="line"><span class="comment"> * @param ptr           A pointer to the data buffer.</span></span><br><span class="line"><span class="comment"> * @param length        The size of data in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Return the data size we put into the ring buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">rt_size_t</span> <span class="title function_">rt_ringbuffer_put_force</span><span class="params">(<span class="keyword">struct</span> rt_ringbuffer *rb,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">rt_uint8_t</span>     *ptr,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint16_t</span>           length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint16_t</span> space_length;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(rb != RT_NULL);</span><br><span class="line"></span><br><span class="line">    space_length = rt_ringbuffer_space_len(rb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; rb-&gt;buffer_size)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = &amp;ptr[length - rb-&gt;buffer_size];</span><br><span class="line">        length = rb-&gt;buffer_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;buffer_size - rb-&gt;write_index &gt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* read_index - write_index = empty space */</span></span><br><span class="line">        rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index], ptr, length);</span><br><span class="line">        <span class="comment">/* this should not cause overflow because there is enough space for</span></span><br><span class="line"><span class="comment">         * length of data in current mirror */</span></span><br><span class="line">        rb-&gt;write_index += length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length &gt; space_length)</span><br><span class="line">            rb-&gt;read_index = rb-&gt;write_index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_memcpy(&amp;rb-&gt;buffer_ptr[rb-&gt;write_index],</span><br><span class="line">           &amp;ptr[<span class="number">0</span>],</span><br><span class="line">           rb-&gt;buffer_size - rb-&gt;write_index);</span><br><span class="line">    rt_memcpy(&amp;rb-&gt;buffer_ptr[<span class="number">0</span>],</span><br><span class="line">           &amp;ptr[rb-&gt;buffer_size - rb-&gt;write_index],</span><br><span class="line">           length - (rb-&gt;buffer_size - rb-&gt;write_index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are going into the other side of the mirror */</span></span><br><span class="line">    rb-&gt;write_mirror = ~rb-&gt;write_mirror;</span><br><span class="line">    rb-&gt;write_index = length - (rb-&gt;buffer_size - rb-&gt;write_index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; space_length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rb-&gt;write_index &lt;= rb-&gt;read_index)</span><br><span class="line">            rb-&gt;read_mirror = ~rb-&gt;read_mirror;</span><br><span class="line">        rb-&gt;read_index = rb-&gt;write_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line">RTM_EXPORT(rt_ringbuffer_put_force);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get data from the ring buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rb            A pointer to the ring buffer.</span></span><br><span class="line"><span class="comment"> * @param ptr           A pointer to the data buffer.</span></span><br><span class="line"><span class="comment"> * @param length        The size of the data we want to read from the ring buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Return the data size we read from the ring buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">rt_size_t</span> <span class="title function_">rt_ringbuffer_get</span><span class="params">(<span class="keyword">struct</span> rt_ringbuffer *rb,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint8_t</span>           *ptr,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint16_t</span>           length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_size_t</span> size;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(rb != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* whether has enough data  */</span></span><br><span class="line">    size = rt_ringbuffer_data_len(rb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no data */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* less data */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; length)</span><br><span class="line">        length = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;buffer_size - rb-&gt;read_index &gt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* copy all of data */</span></span><br><span class="line">        rt_memcpy(ptr, &amp;rb-&gt;buffer_ptr[rb-&gt;read_index], length);</span><br><span class="line">        <span class="comment">/* this should not cause overflow because there is enough space for</span></span><br><span class="line"><span class="comment">         * length of data in current mirror */</span></span><br><span class="line">        rb-&gt;read_index += length;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_memcpy(&amp;ptr[<span class="number">0</span>],</span><br><span class="line">           &amp;rb-&gt;buffer_ptr[rb-&gt;read_index],</span><br><span class="line">           rb-&gt;buffer_size - rb-&gt;read_index);</span><br><span class="line">    rt_memcpy(&amp;ptr[rb-&gt;buffer_size - rb-&gt;read_index],</span><br><span class="line">           &amp;rb-&gt;buffer_ptr[<span class="number">0</span>],</span><br><span class="line">           length - (rb-&gt;buffer_size - rb-&gt;read_index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are going into the other side of the mirror */</span></span><br><span class="line">    rb-&gt;read_mirror = ~rb-&gt;read_mirror;</span><br><span class="line">    rb-&gt;read_index = length - (rb-&gt;buffer_size - rb-&gt;read_index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line">RTM_EXPORT(rt_ringbuffer_get);</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5-判断缓冲区是否为空或满"><a href="#3-1-5-判断缓冲区是否为空或满" class="headerlink" title="3.1.5 判断缓冲区是否为空或满"></a>3.1.5 判断缓冲区是否为空或满</h3><p>判断缓冲区是否为空或满，通过函数<code>rt_ringbuffer_status</code>来实现。其逻辑就是在 <strong>2.2.3 节</strong>中介绍的：在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区<strong>为空</strong>；如果二者的指示位不同，说明缓冲区<strong>为满</strong>。注意这里的<strong>读写指针</strong>已经在读写 (<code>rt_ringbuffer_get</code>和<code>rt_ringbuffer_put</code>) 过程中转换为了<strong>读写索引</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rt_inline <span class="keyword">enum</span> rt_ringbuffer_state <span class="title function_">rt_ringbuffer_status</span><span class="params">(<span class="keyword">struct</span> rt_ringbuffer *rb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;read_index == rb-&gt;write_index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rb-&gt;read_mirror == rb-&gt;write_mirror)</span><br><span class="line">            <span class="keyword">return</span> RT_RINGBUFFER_EMPTY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> RT_RINGBUFFER_FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RT_RINGBUFFER_HALFFULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-小结"><a href="#3-1-6-小结" class="headerlink" title="3.1.6 小结"></a>3.1.6 小结</h3><ul>
<li>在多线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；</li>
<li>当只有一个读线程和一个写线程时，用<code>rt_ringbuffer_put</code>和<code>rt_ringbuffer_get</code>进行读写操作缓冲区是线程安全的，无需加锁；但是<code>rt_ringbuffer_put_force</code>不行，因为其可能对<strong>读写索引</strong>都进行操作的场景，这个时候再进行<code>rt_ringbuffer_get</code>读操作，就是不安全访问；</li>
<li><strong>读写指针</strong>已经在读写 (<code>rt_ringbuffer_get</code>和<code>rt_ringbuffer_put</code>) 过程中转换为了<strong>读写索引</strong>。所以<code>read_index</code>(读索引) 和<code>write_index</code>(写索引) 可以直接用来操作缓冲区，无需转换；</li>
<li><code>read_index</code>和<code>write_index</code>的大小区间为$[0, n-1]$[0, n-1]，$n$n 为缓冲区大小；</li>
<li><strong>RT-Thread</strong> 的环形缓冲区不需要<code>buffer</code>大小为 <strong>2 的幂</strong>。</li>
</ul>
<h2 id="3-2-Linux-中实现的-ring-buffer"><a href="#3-2-Linux-中实现的-ring-buffer" class="headerlink" title="3.2 Linux 中实现的 ring buffer"></a>3.2 Linux 中实现的 ring buffer</h2><p>在 linux 内核中，kfifo 就是 <strong>ring buffer</strong> 的经典实现方式，本文将介绍<code>linux 2.6</code>版本中的 <strong>ring buffer</strong> 实现方式，主要介绍<strong>缓冲区结构体</strong>、<strong>缓冲区初始化</strong>、<strong>读操作</strong>、<strong>写操作</strong>、<strong>判断缓冲区是否为空或满</strong>。</p>
<h3 id="3-2-1-缓冲区结构体"><a href="#3-2-1-缓冲区结构体" class="headerlink" title="3.2.1 缓冲区结构体"></a>3.2.1 缓冲区结构体</h3><p><code>kfifo</code>的 <strong>ring buffer</strong> 结构体定义如下，其中<code>buffer</code>、<code>size</code>、<code>in</code>、<code>out</code>和 <strong>2.2 节</strong>中介绍的环形缓冲区 <strong>4</strong> 个信息是一一对应的。但其中<code>in</code>、<code>out</code>分别是<strong>写指针</strong>和<strong>读指针</strong>，而不是<strong>写索引</strong>和<strong>读索引</strong>。它们之间的转换关系就是 <strong>2.2.3 节</strong>介绍的转化公式。参数<code>lock</code>是自旋锁，在多进程 &#x2F; 线程对同一个环形缓冲区进行读写操作时，需要进行锁保护。和<code>RT-Thread</code>对比，可以看到其并没有读写的镜像指示位，判断缓冲区是否为空或满呢？在下一节会进行分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer; <span class="comment">/* the buffer holding the data */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">/* the size of the allocated buffer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> in; <span class="comment">/* data is added at offset (in % size) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> out; <span class="comment">/* data is extracted from off. (out % size) */</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lock; <span class="comment">/* protects concurrent modifications */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-缓冲区初始化"><a href="#3-2-2-缓冲区初始化" class="headerlink" title="3.2.2 缓冲区初始化"></a>3.2.2 缓冲区初始化</h3><p>在<code>kfifo</code>的初始化<code>kfifo_init</code>中可以看出，其会对所传入的<code>size</code>大小进行扩展，使其满足<code>size</code>为 <strong>2 的幂</strong>。这样就可以使用 <strong>2.2.3 节</strong>中介绍的性质，<strong>如果缓冲区的长度是 2 的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 n(缓冲区大小)，则缓冲区为满</strong>。所以在传入<code>buffer</code>的<code>size</code>大小时，最好开始就将其确定为 <strong>2 的幂</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kfifo *<span class="title function_">kfifo_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> gfp_mask, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">    BUG_ON(size &amp; (size - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    fifo = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kfifo), gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!fifo)</span><br><span class="line">         <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">     fifo-&gt;buffer = buffer;</span><br><span class="line">     fifo-&gt;size = size;</span><br><span class="line">     fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">    fifo-&gt;lock = lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-读操作和写操作"><a href="#3-2-3-读操作和写操作" class="headerlink" title="3.2.3 读操作和写操作"></a>3.2.3 读操作和写操作</h3><p>可以看到<code>kfifo</code>对读操作和写操作的实现非常简洁。在进行读操作和写操作时，其充分利用了无符号整型的性质。在<code>__kfifo_put</code>(写操作) 和<code>__kfifo_get</code>(读操作) 时，in(写指针) 和 out(读指针) 都是正向增加的，当达到最大值时，产生溢出，使得从 0 开始，进行循环使用。<strong>in(写指针)</strong> 和 <strong>out(读指针)</strong> 会恒定的保持如下关系：</p>
<p>$$读指针 + 缓冲区已存储数据长度 &#x3D; 写指针 \$$</p>
<p>读指针 + 缓冲区已存储数据长度 &#x3D; 写指针 \</p>
<p>其中读指针是<code>out</code>，写指针是<code>in</code>。<strong>out(读指针)</strong> 永远不会超过 <strong>in(写指针)</strong> 的大小，最多两者相等，相等就是缓冲区为空的时候。再结合在 <strong>2.2.3 节</strong>中介绍的转换关系：</p>
<p>$$读索引&#x3D; 读指针 &amp; (缓冲区长度-1)\$$</p>
<p>读索引 &#x3D; 读指针 &amp; (缓冲区长度 - 1)\</p>
<p>$$写索引&#x3D; 写指针 &amp; (缓冲区长度-1) \$$</p>
<p>写索引 &#x3D; 写指针 &amp; (缓冲区长度 - 1) \</p>
<p>就可以对环形缓冲区进行读写操作了，下面来看源码。<br>先看<code>__kfifo_put</code>的源码。</p>
<p><code>len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</code>中表达的意思就是实际写入的长度一定要小于缓冲区的可用空间大小，防止发生覆盖已有元素的场景。</p>
<p>来看这一句<code>l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - 1)));</code>，其中<code>(fifo-&gt;in &amp; (fifo-&gt;size - 1))</code>就是将 <strong>in(写指针)</strong> 转换为<strong>写索引</strong>，整体表达的意思是从<strong>写索引</strong>到缓冲区结束位置这一段所能写入数据的大小，这一段写入操作的代码为<code>memcpy(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - 1)), buffer, l);</code>。如果这一段还不够，需要折返到缓冲区的开始位置，将剩下的部分写入到缓冲区中，其代码为<code>memcpy(fifo-&gt;buffer, buffer + l, len - l);</code>。而且&#x3D; l(因为l取的是较小值))”&gt;$len &gt;&#x3D; l(因为l取的是较小值))$len &gt;&#x3D; l(因为 l 取的是较小值))，当$len &#x3D; l$len &#x3D; l 就说明第一段已经可以容纳所写入大小，缓冲区无需折返，第二个<code>memcpy</code>拷贝了零个字节，相当于什么也没有发生。<br>再看<code>__kfifo_get</code>的源码。其思路基本和<code>__kfifo_put</code>一致，了解了上面的转换关系，就比较好理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __kfifo_put - puts some data into the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most &#x27;len&#x27; bytes from the &#x27;buffer&#x27; into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don&#x27;t need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_put(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">    len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line"></span><br><span class="line">    fifo-&gt;in += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_put);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">    len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line"></span><br><span class="line">    fifo-&gt;out += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_get);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-判断缓冲区是否为空或满"><a href="#3-2-4-判断缓冲区是否为空或满" class="headerlink" title="3.2.4 判断缓冲区是否为空或满"></a>3.2.4 判断缓冲区是否为空或满</h3><p><code>kfifo</code>中没有专门的函数判断缓冲区是否为空或满，但可以通过<code>__kfifo_len</code>函数获取<strong>缓冲区已存储数据长度</strong>。如果其值等于零就说明缓冲区为空，如果其值等于缓冲区大小，就说明缓冲区满。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __kfifo_len(<span class="keyword">struct</span> kfifo *fifo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fifo-&gt;in - fifo-&gt;out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-小结"><a href="#3-2-5-小结" class="headerlink" title="3.2.5 小结"></a>3.2.5 小结</h3><ul>
<li><code>linux</code>中环形缓冲区（ring buffer）的实现，其实是对 <strong>2.2.3 节</strong>介绍的<strong>镜像指示位</strong>策略的扩展，读指针和写指针区间范围不再局限在镜像区间$[0,2n-1]$[0,2n-1]，而是整个<code>unsigned int</code>大小的空间，对于 32 位机器，读指针和写指针的区间范围是$[0，2^{32}-1]$[0，2^{32}-1]；</li>
<li>进行扩展后，还能维持如下的关系，是因为缓冲区大小<code>n</code>会被扩展为 <strong>2 的幂</strong>，那么$2^{32}$2^{32} 肯定是<code>n</code>扩展后的整数倍，所以还是能够满足如下关系；</li>
</ul>
<p>$$读索引&#x3D; 读指针 &amp; (缓冲区长度-1)\$$</p>
<p>读索引 &#x3D; 读指针 &amp; (缓冲区长度 - 1)\</p>
<p>$$写索引&#x3D; 写指针 &amp; (缓冲区长度-1) \$$</p>
<p>写索引 &#x3D; 写指针 &amp; (缓冲区长度 - 1) \</p>
<ul>
<li>读索引和写索引的区间范围仍然是$[0, n-1]$[0, n-1]；</li>
<li>在多进程 &#x2F; 线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；</li>
<li>当只有一个读进程 &#x2F; 线程和一个写进程 &#x2F; 线程时，无需加锁，也能保证访问安全。</li>
</ul>
<h2 id="3-3-Linux-最新版本中的-ring-buffer-5-17"><a href="#3-3-Linux-最新版本中的-ring-buffer-5-17" class="headerlink" title="3.3 Linux 最新版本中的 ring buffer(5.17+)"></a>3.3 Linux 最新版本中的 ring buffer(5.17+)</h2><p>在<code>linux</code>最新版本 (5.17+) 的<code>kfifo.c</code>(<a href="https://link.zhihu.com/?target=https://github.com/torvalds/linux/blob/master/lib/kfifo.c">https://github.com/torvalds/linux/blob/master/lib/kfifo.c</a>) 和<code>kfifo.h</code>(<a href="https://link.zhihu.com/?target=https://github.com/torvalds/linux/blob/master/include/linux/kfifo.h">https://github.com/torvalds/linux/blob/master/include/linux/kfifo.h</a>) 中，其源码实现已经和<code>linux 2.6</code>版本有很大的不同，但是最新版本的 <strong>ring buffer 核心思想</strong>和<code>linux 2.6</code>版本并没有不同。<br>如下是最新<code>kfifo.h</code>文件中定义的 ring buffer 结构体，其中<code>in</code>、<code>out</code>依然是<strong>写指针</strong>和<strong>读指针</strong>，<code>mask</code>是缓冲区大小减 1（做 &amp; 操作，更方便的将读写指针转换为<strong>读写索引</strong>），<code>esize</code>缓冲区单个存储元素的字节大小 (在<code>linux 2.6</code>版本中，一个元素就是一个字节大小，最新版本将其进行了扩展)，<code>data</code>缓冲区的逻辑起始地址（指针类型不再是字节）。其它的<strong>初始化接口</strong>、<strong>读接口</strong>、<strong>写接口</strong>、<strong>判断缓冲区是否为空或满接口</strong>逻辑和 <strong>3.2 节</strong>介绍的大致差不多，可以对照源码看一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> in;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> out;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> esize;</span><br><span class="line">    <span class="type">void</span>  *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul>
<li>环形缓冲区（ring buffer）适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；</li>
<li>如果缓冲区的大小需要经常调整，就不适合用环形缓存区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；</li>
<li>因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关；</li>
<li>环形缓冲区（ring buffer）特别适合于通信双方循环发送数据的场景；</li>
<li>镜像指示位是一种高效判断缓冲区是否为空或满的策略，在 <strong>RT-Thread</strong> 和 <strong>linux</strong> 中都使用了该策略（或者是该策略的扩展），其能够保证在只有一个读线程（或进程）和一个写线程（或进程）中无需锁也能做到线程安全；</li>
<li>注意区分写指针和写索引，读指针和读索引，最终对缓冲区进行操作还是需要写索引和读索引；</li>
<li>如果自己嵌入式项目中需要使用环形缓冲区（ring buffer），可以借鉴<code>linux 2.6</code>版本的<code>kfifo</code>实现，很容易改写，而且非常高效。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/')">远辰</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=远辰&amp;url=https://shippomx.github.io/2023/11/30/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/30/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/11/30/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1 一个简单例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%B7%E4%BD%93%E6%80%8E%E6%A0%B7%E5%81%9A"><span class="toc-number">2.1.</span> <span class="toc-text">2.2 具体怎样做</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%9C%A8%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E7%9A%84%E6%97%B6%E5%80%99%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%A7%8D%E7%AD%96%E7%95%A5%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.2.1 在缓冲区满的时候写数据，有两种策略可以使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AF%BB%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E6%9C%80%E8%80%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.2.2 读数据时，一定要读出缓冲区中最老的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%80%8E%E6%A0%B7%E6%9D%A5%E5%88%A4%E6%96%AD%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E6%BB%A1%E7%9A%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.2.3 怎样来判断缓冲区是满的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%86%99"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.2.4 如何实现一个线性地址空间的循环读写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">3 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-RT-Thread-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84-ring-buffer"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 RT-Thread 中实现的 ring buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.2 环形缓冲区结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.3 缓冲区初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%86%99%E6%93%8D%E4%BD%9C%E5%92%8C%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.4 写操作和读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E5%88%A4%E6%96%AD%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E6%88%96%E6%BB%A1"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.5 判断缓冲区是否为空或满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.1.6 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Linux-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84-ring-buffer"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Linux 中实现的 ring buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 缓冲区结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 缓冲区初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%92%8C%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 读操作和写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E5%88%A4%E6%96%AD%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E6%88%96%E6%BB%A1"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 判断缓冲区是否为空或满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Linux-%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84-ring-buffer-5-17"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Linux 最新版本中的 ring buffer(5.17+)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">4 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/IEEE%20802.1Q%20%E5%B0%81%E8%A3%85%E7%9A%84%20VLAN%20%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F%20/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/Linux%20%E4%B8%8B%20Pcap%20%E5%8C%85%E9%87%8D%E6%94%BE%E5%B7%A5%E5%85%B7%20Tcpreplay%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/OpenFlow%20%E6%B5%81%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F%E3%80%81IP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E3%80%81TCPUDP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/02/sdn/netperf%20%E7%9A%84%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-02T05:58:53.067Z" title="发表于 2023-12-02 13:58:53">2023-12-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>