<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>tcpdump 使用与数据分析 | 远辰</title><meta name="keywords" content="kidgets"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="tcpdump 使用与数据分析"><meta name="application-name" content="tcpdump 使用与数据分析"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="tcpdump 使用与数据分析"><meta property="og:url" content="https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="tcpdump 使用与数据分析文章目录  tcpdump 使用与数据分析 一. 语法 二. 选项 三. 实用命令实例  3.1. 默认启动 3.2. 监视指定网络接口的数据包 3.3. 监视指定主机的数据包 3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包 3.5. 截获主"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="tcpdump 使用与数据分析文章目录  tcpdump 使用与数据分析 一. 语法 二. 选项 三. 实用命令实例  3.1. 默认启动 3.2. 监视指定网络接口的数据包 3.3. 监视指定主机的数据包 3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包 3.5. 截获主"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: 'tcpdump 使用与数据分析',
  postAI: '',
  pageFillDescription: 'tcpdump 使用与数据分析, 文章目录, 一. 语法, 二. 选项, 三. 实用命令实例, 3.1. 默认启动, 3.2. 监视指定网络接口的数据包, 3.3. 监视指定主机的数据包, 3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包, 3.5. 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信, 3.6. 打印 ace 与任何其他主机之间通信的 IP 数据包 但不包括与 helios 之间的数据包., 3.7. 截获主机 hostname 发送的所有数据, 3.8. 监视所有送到主机 hostname 的数据包, 3.9. 监视指定主机和端口的数据包, 3.10. 监视指定网络的数据包, 3.11. 监视指定协议的数据包, 四. tcpdump 与 wireshark, 4.1. 使用 tcpdump 抓取 HTTP 包, 五. 输出信息含义, 5.1. ARPx2FRARP 数据包, 5.2. TCP 数据包, 5.3. UDP 数据包, 5.3.1. UDP 名称服务请求, 5.3.2. UDP 名称服务应答, 5.4. NFS 请求和回应, 5.4.1. AFS 请求和回应, 5.5. KIP AppleTalk 协议, 5.6. IP 数据包破碎使用与数据分析文章目录使用与数据分析一语法二选项三实用命令实例默认启动监视指定网络接口的数据包监视指定主机的数据包打印与或者与之间通信的数据包截获主机和主机或的通信打印与任何其他主机之间通信的数据包但不包括与之间的数据包截获主机发送的所有数据监视所有送到主机的数据包监视指定主机和端口的数据包监视指定网络的数据包监视指定协议的数据包四与使用抓取包五输出信息含义数据包数据包数据包名称服务请求名称服务应答请求和回应请求和回应协议数据包破碎一语法选项二选项以码方式显示每一个数据包不会显示数据包中链路层头部信息在抓取包含网页数据的数据包时可方便查看数据即将在接受到个数据包后退出此选项用于配合选项使用该选项使得在把原始数据包直接保存到文件中之前检查此文件大小是否超过如果超过了将关闭此文件另创一个文件继续用于原始数据包的记录新创建的文件名与选项指定的文件名一致但文件名后多了一个数字该数字会从开始随着新创建文件的增多而增加的单位是百万字节这里指个字节并非个字节后者是以字节为字节为计算所得即以容易阅读的形式在标准输出上打印出编排过的包匹配码随后停止容易阅读的通常是指以码来打印一些信息编排过的包匹配码含义未知需补充以语言的形式打印出包匹配码以十进制数的形式打印出包匹配码会在包匹配码之前有一个附加的前缀打印系统中所有可以在其上进行抓包的网络接口每一个接口会打印出数字编号相应的接口名字以及可能的一个网络接口描述其中网络接口名字和数字编号可以用在的选项把名字或数字代替来指定要在其上抓包的网络接口此选项在不支持接口列表命令的系统上很有用比如系统或缺乏的系统接口的数字编号在或其后的系统中很有用因为这些系统上的接口名字比较复杂而不易使用如果编译时所依赖的库太老选项不会被支持因为其中缺乏函数每行的打印输出中将包括数据包的数据链路层头部信息可通过来解密包封装安全负载可理解为一整套对数据包的加密协议为整个数据包或其中上层协议部分被加密后的数据前者的工作模式称为隧道模式后者的工作模式称为传输模式工作原理另需补充需要注意的是在终端启动时可以为设置密钥可用于加密的算法包括或者没有默认的是数据加密标准加密算法未知另需补充为用于的密钥使用字符串方式表达如果以开头该密钥将以进制方式读入该选项中的定义遵循而不是并且此选项只是用来调试的不推荐以真实密钥来使用该选项因为这样不安全在命令行中输入的可以被其他人通过等命令查看到除了以上的语法格式指还可以在后面添加一个语法输入文件名字供使用即把中换成一个语法文件名此文件在接受到第一个包时会打开此文件所以最好此时把赋予的一些特权取消可理解为这样防范之后当该文件为恶意编写时不至于造成过大损害显示外部的地址时可理解为非本机地址采用数字方式而不是名字此选项是用来对付公司的服务器的缺陷网络信息服务显示外部地址的名字时会用到她提供的名称服务此服务器在查询非本地地址名字时常常会陷入无尽的查询循环由于对外部地址的测试需要用到本地网络接口抓包时用到的接口及其地址和网络掩码如果此地址或网络掩码不可用或者此接口根本就没有设置相应网络地址和网络掩码下的网络接口就不需要设置地址和掩码不过此接口可以收到系统中所有接口的数据包该选项不能正常工作使用文件作为过滤条件表达式的输入此时命令行上的输入将被忽略指定需要监听的接口如果没有指定会从系统接口列表中搜寻编号最小的已配置好的接口不包括接口一但找到第一个符合条件的接口搜寻马上结束在采用版本或之后版本内核的操作系统上这个虚拟网络接口可被用来接收所有网络接口上的数据包这会包括目的是该网络接口的也包括目的不是该网络接口的需要注意的是如果真实网络接口不能工作在混杂模式下则无法在这个虚拟的网络接口上抓取其数据包如果标志被指定会打印系统中的接口编号而该编号就可用于此处的参数对标准输出进行行缓冲使标准输出设备遇到一个换行符就马上把这行的内容打印出来在需要同时观察抓包打印以及保存抓包记录的时候很有用比如可通过以下命令组合来达到此目的或者前者使用来把的输出同时放到文件和标准输出中而后者通过重定向操作把的输出放到文件中同时通过把文件中的内容放到标准输出中列出指定网络接口所支持的数据链路层的类型后退出指定接口通过来指定通过指定的装载模块管理信息结构管理信息库可理解为这两者用于协议数据包的抓取具体的工作原理未知另需补充此选项可多次使用从而为装载不同的模块如果数据包有选项在有相关描述则为其摘要的验证指定一个公共的密钥不对地址比如主机地址端口号进行数字表示到名字表示的转换不打印出的域名部分比如如果设置了此选现将会打印而不是不启用进行包匹配时所用的优化代码当怀疑某些是由优化代码引起的此选项将很有用一般情况下把网络接口设置为非混杂模式但必须注意在特殊情况下此网络接口还是会以混杂模式来工作从而的设与不设不能当做以下选现的代名词或前者表示只匹配以太网地址为的包后者表示匹配以太网地址为广播地址的数据包快速也许用安静更好打印输出即打印很少的协议相关信息从而输出行都比较简短设定对数据包的解析按照而不是认证头安全负载封装这两者会用在包的安全传输机制中如果此选项被设置将不会打印出禁止中继域另外由于规范中没有规定数据包必须拥有协议版本号域所以不能从收到的数据包中推导出协议版本号从文件中读取包数据如果字段为符号则会从标准输入中读取包数据打印数据包的顺序号时使用绝对的顺序号而不是相对的顺序号相对顺序号可理解为相对第一个包顺序号的差距比如接受方收到第一个数据包的绝对顺序号为对于后来接收到的第个第个数据包会打印其序列号为分别表示与第一个数据包的差距为和而如果此时选项被设置对于后来接收到的第个第个数据包会打印出其绝对顺序号设置的数据包抓取长度为如果不设置默认将会是字节而支持网络接口分接头上文已有描述可搜索网络接口分接头关键字找到那里的系列操作系统中默认的也是最小值是字节对于因特网控制报文协议以及协议的报文已足够但对于名称服务可理解为等服务服务相关的数据包会产生包截短如果产生包截短这种情况的相应打印输出行中会出现的标志实际会显示为被截短的数据包的相关协议层次需要注意的是采用长的抓取长度比较大会增加包的处理时间并且会减少可缓存的数据包的数量从而会导致数据包的丢失所以在能抓取我们想要的包的前提下抓取长度越小越好把设置为意味着让自动选择合适的长度来抓取数据包强制按指定的协议所描述的包结构来分析收到的数据包目前已知的可取的协议为按需距离向量路由协议在点对点模式网络中使用碎文件协议可用于在上进行电视电话会议的应用层协议以及可用于网络会议的应用层协议在每行输出中不打印时间戳不对每行输出的时间进行格式处理这种格式一眼可能看不出其含义如时间戳打印成输出时每两行打印之间会延迟一个段时间以毫秒为单位在每行打印的时间戳之前添加日期的打印打印出未加密的句柄可理解为中使用的文件句柄这将包括文件夹和文件夹中的文件使得当在使用选项时其文件写入与包的保存同步即当每个数据包被保存时它将及时被写入文件中而不是等文件的输出缓冲已满时才真正写入此文件标志在老版本的库所依赖的报文捕获库上不起作用因为其中缺乏函数当分析和打印的时候产生详细的输出比如包的生存时间标识总长度以及包的一些选项这也会打开一些附加的包完整性检测比如对或包头部的校验和产生比更详细的输出比如回应包中的附加域将会被打印数据包也会被完全解码产生比更详细的输出比如时所使用的选项将会被打印如果同时使用的是图形界面其相应的图形选项将会以进制的方式打印出来的选项含义未知另需补充把包数据直接写入文件而不进行分析和打印输出这些包数据可在随后通过选项来重新读入并进行分析和打印此选项与选项配合使用这将限制可打开的文件数目并且当文件数据超过这里设置的限制时依次循环替代之前的文件这相当于一个拥有个文件的文件缓冲池同时该选项会使得每个文件名的开头会出现足够多并用来占位的这可以方便这些文件被正确的排序当分析和打印时会打印每个包的头部数据同时会以进制打印出每个包的数据但不包括连接层的头部总共打印的数据大小不会超过整个数据包的大小与中的最小值必须要注意的是如果高层协议数据没有这么长并且数据链路层比如层有填充数据则这些填充数据也会被打印未能衔接理解和翻译需补充会打印每个包的头部数据同时会以进制打印出每个包的数据其中包括数据链路层的头部当分析和打印时会打印每个包的头部数据同时会以进制和码形式打印出每个包的数据但不包括连接层的头部这对于分析一些新协议的数据包很方便当分析和打印时会打印每个包的头部数据同时会以进制和码形式打印出每个包的数据其中包括数据链路层的头部这对于分析一些新协议的数据包很方便设置只捕获数据链路层协议类型是的数据包使放弃自己的超级权限如果以用户启动将会有超级用户权限并把当前的用户设置为组设置为首要所属组的此处可理解为运行之后对应的进程三实用命令实例默认启动普通情况下直接启动将监视第一个网络接口上所有流过的数据包监视指定网络接口的数据包如果不指定网卡默认只会监视第一个网络接口一般是下面的例子都没有指定网络接口监视指定主机的数据包打印所有进入或离开的数据包也可以指定例如截获所有的主机收到的和发出的所有的数据包打印与或者与之间通信的数据包截获主机和主机或的通信打印与任何其他主机之间通信的数据包但不包括与之间的数据包如果想要获取主机除了和主机之外所有主机通信的包使用命令截获主机发送的所有数据监视所有送到主机的数据包监视指定主机和端口的数据包如果想要获取主机接收或发出的包使用如下命令对本机的端口进行监视为的服务端口监视指定网络的数据包打印本地主机与网络上的主机之间的所有通信数据包此处可理解为网络的网络地址此表达式最原始的含义可表达为打印网络地址为的所有数据包打印所有通过网关的数据包注意表达式被单引号括起来了这可以防止对其中的括号进行错误解析打印所有源地址或目标地址是本地主机的数据包如果本地网络通过网关连到了另一网络则另一网络并不能算作本地网络此句翻译曲折需补充实际使用时要真正替换成本地网络的名字监视指定协议的数据包打印会话中的的开始和结束数据包并且数据包的源或目的不是本地网络上的主机实际使用时要真正替换成本地网络的名字打印所有源或目的端口是网络层协议为并且含有数据而不是以及等不含数据的数据包的版本的表达式可做练习可理解为表示整个数据包的长度表示数据包包头的长度代表包中的域而此域的单位为要换算成字节数需要乘以即左移表示头的长度此域的单位也是换算成比特数为即表示整个数据包的长度减去头的长度再减去头的长度不为这就意味着数据包中确实是有数据对于版本只需考虑头中的与头的长度的差值并且其中表达方式需换成打印长度超过字节并且网关地址是的数据包打印所有层广播或多播的数据包但不是物理以太网层的广播或多播数据报打印除或者类型以外的数据包比如需要打印所有非程序产生的数据包时可用到此表达式与这两种类型的数据包通常由程序产生四与是下非常简单易用的抓包工具但在下很难找到一个好用的图形化抓包工具还好有我们可以用的完美组合实现在里抓包然后在里分析包和这些选项等都要放到第一个参数的位置用来过滤数据报的类型只抓经过接口的包不显示时间戳抓取数据包时默认抓取长度为字节加上后可以抓到完整的数据包只抓取个数据包不抓取目标端口是的数据包数据包的源网络地址为保存成文件方便用即分析使用抓取包为前两个字母为前两个字母对截获的数据并没有进行彻底解码数据包内的大部分内容是使用十六进制的形式直接打印输出的显然这不利于分析网络故障通常的解决办法是先使用带参数的截获数据并保存到文件中然后再使用其他程序如进行解码分析当然也应该定义过滤规则以避免捕获的数据包填满整个硬盘五输出信息含义首先我们注意一下基本上总的的输出格式为系统时间来源主机端口目标主机端口数据包参数的输出格式与协议有关以下简要描述了大部分常用的格式及相关例子链路层头对于网络使打印出指定数据包的域源和目的地址以及包的长度域控制对包中其他域的解析一般的包比如那些都是带有异步标志的数据包并且有取值到的优先级比如就代表此包为异步数据包并且优先级别为通常认为这些包们会内含一个包逻辑链路控制包这时如果此包不是一个或所谓的包其头部将会被打印应该是指此包内含的包的包头对于网络令牌环网络使打印出指定数据包的和域以及源和目的地址外加包的长度与网络类似此数据包通常内含数据包不管是否有选项对于此网络上的类型数据包意译为源地址被追踪的数据包具体含义未知需补充其包的源路由信息总会被打印对于网络即使打印出指定数据包的域包头中包含的所有地址以及包的长度与网络类似此数据包通常内含数据包注意以下的描述会假设你熟悉压缩算法为这个算法可以在中找到相关的蛛丝马迹对于网络可理解为一个网络即通过串行线路建立的连接而一个简单的连接也可看成一个网络数据包的方向指示标志表示入表示出类型以及压缩信息将会被打印包类型会被首先打印类型分为以及未知需补充对于包连接信息将不被打印连接上包的连接信息可能无用或没有定义对于数据包连接标识紧接着类型表示被打印如果此包被压缩其被编码过的头部将被打印此时对于特殊的压缩包会如下显示或者其中代表包的顺序号或顺序号和应答号增加或减少的数目拗口需再译对于非特殊的压缩包个或更多的改变将会被打印改变被打印时格式如下标志包数据的长度压缩的头部长度其中标志可以取以下值代表紧急指针指缓冲窗口应答序列号包而增量表达表示被赋予新的值表示增加或减少比如以下显示了对一个外发压缩数据包的打印这个数据包隐含一个连接标识应答号增加了顺序号增加了包号增加了包数据长度为字节压缩头部为字节如此看来这应该不是一个特殊的压缩数据包数据包对包的输出信息中会包含请求类型及该请求对应的参数显示格式简洁明了以下是从主机到主机的远程登录过程开始阶段的数据包样例第一行表示发送了一个数据包向全网段发送数据包以询问的以太网地址可从下文看出来是以她自己的以太网地址做了回应在这个例子中以太网地址以大写的名字标识而地址即地址以全部的小写名字标识如果使用可以清晰看到以太网以及地址而不是名字标识如果我们使用则可以清晰的看到第一个数据包是全网广播的而第二个数据包是点对点的第一个数据包表明以包的源以太地址是目标地址是全以太网段域的值为进制表示包的类型标识包的总长度为字节数据包注意以下将会假定你对所描述的熟悉如果不熟以下描述以及程序可能对你帮助不大警告可忽略只需继续看不熟悉的地方可回头再看通常对数据包的显示格式如下和是源和目的地址以及相应的端口标志由未知需补充或者未知需补充组成单独一个表示没有标识数据段顺序号描述了此包中数据所对应序列号空间中的一个位置整个数据被分段每段有一个顺序号所有的顺序号构成一个序列号空间可参考以下例子描述的是同一个连接同一个方向下一个本端应该接收的对方应该发送的数据片段的顺序号是本端可用的数据接收缓冲区的大小也是对方发送数据时需根据这个大小来组织数据表示数据包中有紧急的数据描述了的一些选项这些选项都用尖括号来表示如和这三个域总是会被显示其他域的显示与否依赖于协议头里的信息这是一个从到的一个应用登录的开始阶段第一行表示有一个数据包从主机的端口发送到了主机的端口上协议的端口和协议的端口是分别的两个空间虽然取值范围一致表示设置了标志包的顺序号是并且没有包含数据表示格式为其含义是此包中数据的顺序号从开始直到结束不包括并且总共包含的用户数据没有捎带应答从下文来看第二行才是有捎带应答的数据包可用的接受窗口的大小为并且请求端的最大可接受的数据段大小是字节这个信息作为请求发向应答端以便双方进一步的协商向回复了基本相同的数据包其区别只是多了一个捎带回的应答针对的数据包同样针对的数据包回复了一数据包作为应答的含义就是此包中没有标志被设置由于此应答包中不含有数据所以包中也没有数据段序列号提醒此数据包的顺序号只是一个小整数有如下解释对于一个连接上的会话只打印会话两端的初始数据包的序列号其后相应数据包只打印出与初始包序列号的差异即初始序列号之后的序列号可被看作此会话上当前所传数据片段在整个要传输的数据中的相对字节位置双方的第一个位置都是即相对字节的开始编号将覆盖这个功能使数据包的原始顺序号被打印出来第六行的含义为向发送了字节的数据字节的编号为到传送方向为到包中设置了标志在第行喊到她已经从中收到了以下的字节但不包括编号的字节这些字节存放在的的接收缓冲中相应地的接收缓冲窗口大小会减少字节可以从第行和第行属性值的变化看出来在第行这个包中也向发送了一个字节在第行和第行继续向分别发送了两个只包含一个字节的数据包并且这个数据包带标志如果所抓到的包即这里的太小了以至无法完整得到其头部数据这时会尽量解析这个不完整的头并把剩下不能解析的部分显示为如果头部含有虚假的属性信息比如其长度属性其实比头部实际长度长或短会为该头部显示如果头部的长度告诉我们某些选项从下文来看指包的头部中针对包的一些选项回头再翻会在此包中而真正的数据包的长度又不够容纳这些选项会显示抓取带有特殊标志的的包如标志标志等在的头部中有比特用作控制位区域其取值为从表达方式上可推断这个位是用或的方式来组合的可回头再翻现假设我们想要监控建立一个连接整个过程中所产生的数据包可回忆如下使用次握手协议来建立一个新的连接其与此三次握手连接顺序对应并带有相应控制标志的数据包如下连接发起方发送标志的数据包接收方用带有和标志的数据包进行回应发起方收到接收方回应后再发送带有标志的数据包进行回应一个头部在不包含选项数据的情况下通常占用个字节理解为选项数据需回译第一行包含到编号的字节第二行包含编号的字节如果编号从开始算控制标志位于字节第四行左半部分让我们仔细看看编号的字节这里有我们感兴趣的控制标志位从右往左这些位被依次编号为到从而位在号而位在号提醒一下自己我们只是要得到包含标志的数据包让我们看看在一个包的包头中如果位被设置到底在号字节发生了什么在控制段的数据中只有比特被置位假设编号为的字节是一个位的无符号字符型并且按照网络字节号排序对于一个字节来说网络字节序等同于主机字节序其二进制值如下所示并且其进制值为表示乘以的次方也许这样更清楚些即把原来表达中的指数挪到了下面来表达接近目标了因为我们已经知道如果数据包头部中的被置位那么头部中的第个字节的值为按照网络序即大头方式最重要的字节在前面在前面即该字节实际内存地址比较小最重要的字节指数学表示中数的高位如中的表达为能理解的关系式就是从而我们可以把此关系式当作的过滤条件目标就是监控只含有标志的数据包指网络接口如这个表达式是说让数据包的第个字节拥有值吧这也是我们想要的结果现在假设我们需要抓取带标志的数据包而忽略它是否包含其他标志只要带就是我们想要的让我们来看看当一个含有的数据包和标志都有来到时发生了什么号字节的号和号位被置位其二进制的值为转换成十进制就是表示乘以的次方也许这样更清楚些即把原来表达中的指数挪到了下面来表达现在却不能只用作为的过滤表达式因为这将导致只选择含有标志的数据包其他的都被丢弃提醒一下自己我们的目标是只要包的标志被设置就行其他的标志我们不理会为了达到我们的目标我们需要把号字节的二进制值与其他的一个数做操作逻辑与来得到比特位的值目标是只要被设置就行于是我们就把她与上号字节的值我们可以发现不管包的或其他标志是否被设置以上的操作都会给我们相同的值其进制表达就是进制表达就是从而我们知道对于带有标志的数据包以下的表达式的结果总是真即号字节的值灵感随之而来我们于是得到了如下的的过滤表达式注意单引号或反斜杆这里用的是单引号不能省略这可以防止对的解释或替换数据包数据包的显示格式可通过这个具体应用所产生的数据包来说明其含义为主机上的端口向主机上的端口发送了一个数据包和都是指地址这个数据包承载的用户数据为个字节一些服务可从数据包的源或目的端口来识别也可从所显示的更高层协议信息来识别比如请求在中和对服务器所发起的远程调用即在中有对远程调用的描述名称服务请求注意以下的描述假设你对在中有所描述否则你会发现以下描述就是天书希腊文天书不必理会吓吓你的接着看就行名称服务请求有如下的格式从下文来看格式应该是比如有一个实际显示为主机向上运行的名称服务器查询的地址记录等于此查询本身的号为符号意味着递归查询标志被设置服务器可向更高层服务器查询本服务器不包含的地址记录这个最终通过包发送的查询请求数据长度为字节其中不包括和协议的头数据因为此查询操作为默认值的理解字段被省略如果字段没被省略会被显示在和之间同样也是默认值从而也没被显示如果没被忽略她会被显示在之后异常检查会在方括中显示出附加的域如果一个查询同时包含一个回应可理解为对之前其他一个请求的回应并且此回应包含权威或附加记录段具体字段含义需补充将被显示为其中代表合适的计数如果包中以下回应位比如位位位或者字节或中任何一个必须为的位被置位设置为将被显示其中表示头部字节与字节进行与操作后的值名称服务应答对名称服务应答的数据包会有如下的显示格式比如具体显示如下第一行表示对所发送的号查询请求回应了条回答记录条名称服务器记录以及条附加的记录第一个回答记录个回答记录中的第一个类型为表示地址其数据为地址此回应数据包包含字节的数据不包含和的头部数据字段和字段被忽略的实际值为即的实际值为同样被忽略的字段还有字段其值为这也是类型记录默认取值第二行表示对所发送的号查询请求做了回应回应中编码为表示不存在的域没有回答记录但包含一个名称服务器记录不包含权威服务器记录从上文来看此处的就是上文中对应的表示权威服务器回答标志被设置从而就表示的是由于没有回答记录字段都被忽略字段还有可能出现其他一些字符比如表示可递归地查询即标志没有被设置表示被截断的消息即标志被置位如果应答可理解为包含名称服务应答的数据包知道这类数据包该怎样解析其数据的段一个条目都不包含每个条目的含义需补充会被打印出来要注意的是名称服务器的请求和应答数据量比较大而默认的字节的抓取长度可理解为的一个设置选项可能不足以抓取数据包的全部内容如果你真的需要仔细查看名称服务器的负载可以通过的选项来扩大值解码已可以对相关应用的数据包内容进行解码分别为在上实现的网络协议的简称这几个服务通常使用的以及的端口原来的对和数据包的解码能力依然可以被使用为的增强版本默认只按照最简约模式对相应数据包进行解码如果我们想要详尽的解码信息可以使用其启动选现要注意的是会产生非常详细的信息比如对单一的一个数据包将产生一屏幕或更多的信息所以此选项确有需要才使用关于数据包格式的信息以及每个域的含义可以参看或者镜像站点的目录上的补丁由提供请求和回应对网络文件系统请求和回应的数据包有如下格式的打印输出以下是一组具体的输出数据第一行输出表明主机向主机发送了一个交换请求此请求的为注意主机名字后是交换请求号而不是源端口号此请求数据为字节其中不包括和头部的长度操作类型为即此操作为读符号链接操作操作参数为可按实际运行环境解析如下表示描述的为文件句柄表示此句柄所对应设备的主从设备号对表示此句柄所对应的节点编号每个文件都会在操作系统中对应一个节点限于类系统中是一个编号可理解为标识此请求的一个随机数具体含义需补充第二行中做了的回应并且在字段中返回了想要读的符号连接的真实目录即要求读的符号连接其实是一个目录第三行表明再次请求在所描述的目录中查找文件需要注意的是每行所显示的数据含义依赖于其中字段的类型不同所对应含义不相同其格式遵循协议追求简洁明了如果的选项详细打印选项被设置附加的信息将被显示比如选项一般还会打印出头部的以及域但在此例中都略过了可理解为简洁起见做了删减在第一行请求从文件格式在上面有描述中自偏移字节处开始读取字节数据回应读取成功由于第二行只是回应请求的开头片段所以只包含字节其他的数据将在接着的片段中到来但这些数据包不会再有头甚至头信息也为空源和目的应该要有这将导致这些片段不能满足过滤条件从而没有被打印选项除了显示文件数据信息还会显示附加显示文件属性信息文件类型表示普通文件文件存取模式进制表示的和文件属主和组属主文件大小如果标志被多次重复给出如会显示更加详细的信息必须要注意的是请求包中数据比较多如果的抓取长度取太短将不能显示其详细信息可使用来增加这可用以监测应用的网络负载的回应包并不严格的紧随之前相应的请求包从而会跟踪最近收到的一系列请求包再通过其交换序号与相应请求包相匹配这可能产生一个问题如果回应包来得太迟超出对相应请求包的跟踪范围该回应包将不能被分析请求和回应文件系统未知需补充请求和回应有如下的答应在第一行主机向发送了一个数据包这是一个对于文件服务的请求数据包发送数据包可理解为发送包过去从而请求对方的服务这也是一个调用的开始此请求执行重命名操作并指定了相关的参数原目录描述符为原文件名为新目录描述符为新文件名为主机对此操作的请求作了回应回应表示操作成功因为回应的是包含数据内容的包而不是异常包一般来说所有的请求被显示时会被冠以一个名字即解码这个名字往往就是请求的操作名并且这些请求的部分参数在显示时也会被冠以一个名字即解码一般来说也是取名也很直接比如一个参数显示的时候就会直接是含义拗口需再翻这种显示格式的设计初衷为一看就懂但对于不熟悉和工作原理的人可能不是很有用还是不用管书面吓吓你的往下看就行如果详细标志被重复给出如会打印出确认包可理解为与应答包有区别的包以及附加头部信息可理解为所有包而不仅仅是确认包的附加头部信息比如请求包中请求调用的请求调用的编号包顺序号可理解为与包中数据相关的另一个顺信号具体含义需补充请求包的标识接下来一段为重复描述所以略去了此外确认包中的协商信息也会被打印出来确认包为相对于请求包的确认包最大传输单元如果选项被重复了三次如那么应用类型数据包的安全索引以及服务索引将会被打印对于表示异常的数据包可理解为此包就是用来通知接受者某种异常已发生会打印出错误号但对于灯塔指示包可理解为特殊的通信协议灯塔数据包可理解为指明通信中关键信息的一些数据包错误号不会被打印因为对于协议异常数据包不是表示错误相反却是表示一种肯定应答即请求数据量大参数也多所以要求的比较大一般可通过启动时设置选项来增大以监测应用通信负载回应包并不显示标识属于何种远程调用从而会跟踪最近一段时间内的请求包并通过调用编号服务索引来匹配收到的回应包如果回应包不是针对最近一段时间内的请求包将无法解析该包协议可理解为相当于支持协议栈的网络层协议而本身又是通过来传输的即在上实现的用于其他网络的网络层是苹果公司开发的整套网络协议栈数据包被封装在数据包中其解封装相当于解码和相应信息的转储也遵循包规则封装相当于编码解封装相当于解码转储通常就是指对其信息进行打印文件中包含了网络和节点的数字标识到名称的对应关系其文件格式通常如下所示头两行表示有两个网络第三行给出了特定网络上的主机一个主机会用个字节来标识而一个网络的标识通常只有两个字节这也是两者标识的主要区别可理解为网络上的主机标识与其对应的名字之间必须要用空白分开除了以上内容中还包含空行以及注释行以开始的行完整网络地址将以如下格式显示以下为一段具体显示如果文件不存在或者没有相应主机网络的条目数据包的网络地址将以数字形式显示在第一行中网络上的节点通过端口向网络上监听在端口的节点发送了一个应用数据包名称绑定协议从数据来看服务器会在端口提供此服务可理解为对应传输层的端口本身没有端口的概念这点未确定需补充第二行与第一行类似只是源的全部地址可用进行标识第三行表示网络上的节点通过向网络上的所有节点的端口端口发送了数据包需要注意的是在网络中如果地址中没有节点则表示广播地址从而节点标识和网络标识最好在有所区别否则一个标识无法确定是指一个网络上所有主机的口还是指定主机的口可解析名称绑定协议传输协议数据包对于其他应用层的协议只会打印出相应协议名字如果此协议没有注册一个通用名字只会打印其协议号以及数据包的大小数据包会按照如下格式显示第一行表示网络中的节点通过端口向网络中所有节点的端口发送了对的名称查询请求此处名称可理解为一个资源的名称比如打印机此查询请求的序列号为第二行表示网络中的节点通过端口向节点的端口进行了回应我有资源其资源名称为并且在端口上提供改资源的服务此回应的序列号为对应之前查询的序列号第三行也是对第一行请求的回应节点通过端口向节点的端口进行了回应我有资源其资源名称为并且在端口上提供改资源的服务此回应的序列号为对应之前查询的序列号数据包的显示格式如下第一行表示节点向节点发送了一个会话编号为的请求包请求回应个数据包这个数据包的顺序号为顺序号与会话编号不同后者为一次完整传输的编号前者为该传输中每个数据包的编号会话通常也被叫做传输行尾的进制数字表示该请求包中域的值从下文来看这并没有把所有用户数据都打印出来回应了个字节的数据包跟在会话编号后的数字表示该数据包在该会话中的顺序号括号中的数字表示该数据包中数据的大小这不包括的头部在顺序号为数据包第行外带了一个号表示该数据包的标志被设置了可理解为表示一次会话的数据回应完毕接下来的第行表示又向提出了请求顺序号为以及的数据包请重新传送收到这个请求后重新发送了这个两个数据包再次收到这两个数据包之后主动结束了此会话在最后一行向发送了开始下一次会话的请求包请求包中的表示该包的标志没有被设置可理解为在该会话中数据包在接受方只被精确地处理一次就算对方重复传送了该数据包接收方也只会处理一次这需要用到特别设计的数据包接收和处理机制数据包破碎指把一个数据包分成多个数据包碎片数据包即一个大的数据包破碎后生成的小数据包有如下两种显示格式第一种格式表示此碎片之后还有后续碎片第二种格式表示此碎片为最后一个碎片表示破碎编号从下文来看会为每个要破碎的大包分配一个破碎编号以便区分每个小碎片是否由同一数据包破碎而来表示此碎片的大小不包含碎片头部数据表示此碎片所含数据在原始整个包中的偏移从下文来看一个数据包是作为一个整体被破碎的包括头和数据而不只是数据被分割每个碎片都会使产生相应的输出打印第一个碎片包含了高层协议的头数据从下文来看被破碎数据包中相应头以及头都放在了第一个碎片中从而会针对第一个碎片显示这些信息并接着显示此碎片本身的信息其后的一些碎片并不包含高层协议头信息从而只会在显示源和目的之后显示碎片本身的信息以下有一个例子这是一个从到途经网络可理解为建立在网络上的连接的应用通信片段有几点值得注意第一第二行的打印中地址后面没有端口号这是因为协议信息都放到了第一个碎片中当显示第二个碎片时我们无法知道此碎片所对应包的顺序号第二从第一行的信息中可以发现需要向发送字节的用户数据而事实是相应包经破碎后会总共产生字节数据第一个碎片包含字节的数据第二个碎片包含个字节的数据这超过了字节如果你在查找数据包的顺序号空间中的一些空洞空洞指数据包之间的顺序号没有上下衔接上这个数据就足够使你迷茫一阵其实只要关注就行不必关注破碎后的数据总量一个数据包指数据包如果带有非破碎标志则显示时会在最后显示意味着此包没有被破碎过转自',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 16:22:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>23</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/kidgets/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>kidgets</span></a></span></div></div><h1 class="post-title" itemprop="name headline">tcpdump 使用与数据分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-05-14T12:41:56.000Z" title="发表于 2021-05-14 20:41:56">2021-05-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.103Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/"><header><a href="/tags/kidgets/" tabindex="-1" itemprop="url">kidgets</a><h1 id="CrawlerTitle" itemprop="name headline">tcpdump 使用与数据分析</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2021-05-14T12:41:56.000Z" title="发表于 2021-05-14 20:41:56">2021-05-14</time><time itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.103Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></header><h2 id="tcpdump-使用与数据分析"><a href="#tcpdump-使用与数据分析" class="headerlink" title="tcpdump 使用与数据分析"></a>tcpdump 使用与数据分析</h2><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li><ul>
<li><a href="#tcpdump_0">tcpdump 使用与数据分析</a></li>
<li><a href="#__3">一. 语法</a></li>
<li><a href="#__7">二. 选项</a></li>
<li><a href="#__85">三. 实用命令实例</a></li>
<li><ul>
<li><a href="#31__87">3.1. 默认启动</a></li>
<li><a href="#32__93">3.2. 监视指定网络接口的数据包</a></li>
<li><a href="#33__99">3.3. 监视指定主机的数据包</a></li>
<li><a href="#34_helios__hot__ace__108">3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包</a></li>
<li><a href="#35_21027481_21027482_21027483_112">3.5. 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信</a></li>
<li><a href="#36_aceIP__helios_116">3.6. 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包.</a></li>
<li><a href="#37_hostname_124">3.7. 截获主机 hostname 发送的所有数据</a></li>
<li><a href="#38_hostname_128">3.8. 监视所有送到主机 hostname 的数据包</a></li>
<li><a href="#39__132">3.9. 监视指定主机和端口的数据包</a></li>
<li><a href="#310__141">3.10. 监视指定网络的数据包</a></li>
<li><a href="#311__158">3.11. 监视指定协议的数据包</a></li>
</ul>
</li>
<li><a href="#_tcpdump_wireshark_195">四. tcpdump 与 wireshark</a></li>
<li><ul>
<li><a href="#41_tcpdumpHTTP_211">4.1. 使用 tcpdump 抓取 HTTP 包</a></li>
</ul>
</li>
<li><a href="#__220">五. 输出信息含义</a></li>
<li><ul>
<li><a href="#51_ARPRARP__258">5.1. ARP&#x2F;RARP 数据包</a></li>
<li><a href="#52_TCP__280">5.2. TCP 数据包</a></li>
<li><a href="#53_UDP__468">5.3. UDP 数据包</a></li>
<li><ul>
<li><a href="#531_UDP__480">5.3.1. UDP 名称服务请求</a></li>
<li><a href="#532_UDP__503">5.3.2. UDP 名称服务应答</a></li>
</ul>
</li>
<li><a href="#54_NFS__544">5.4. NFS 请求和回应</a></li>
<li><ul>
<li><a href="#541_AFS__593">5.4.1. AFS 请求和回应</a></li>
</ul>
</li>
<li><a href="#55_KIP_AppleTalk_638">5.5. KIP AppleTalk 协议</a></li>
<li><a href="#56_IP__730">5.6. IP 数据包破碎</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一-语法"><a href="#一-语法" class="headerlink" title="一. 语法"></a>一. 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump (选项)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二-选项"><a href="#二-选项" class="headerlink" title="二. 选项"></a>二. 选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-A  以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据(nt: 即Handy for capturing web pages).</span><br><span class="line">-c  count</span><br><span class="line">    tcpdump将在接受到count个数据包后退出.</span><br><span class="line">-C  file-size (nt: 此选项用于配合-w file 选项使用)</span><br><span class="line">    该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节(nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024 ＊ 1024 ＝ 1,048,576)</span><br><span class="line">-d   以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充)</span><br><span class="line">-dd  以C语言的形式打印出包匹配码.</span><br><span class="line">-ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的&#x27;count&#x27;前缀).</span><br><span class="line">-D  打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络接口.</span><br><span class="line">    此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用.</span><br><span class="line">    如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数.</span><br><span class="line">-e  每行的打印输出中将包括数据包的数据链路层头部信息</span><br><span class="line">-E  spi@ipaddr algo:secret,...</span><br><span class="line">    可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt | rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充).</span><br><span class="line">    需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）.</span><br><span class="line">    可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none).默认的是des-cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充).secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入.</span><br><span class="line">    该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到.</span><br><span class="line">    除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用(nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名). 此文件在接受到第一个ESP　包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害).</span><br><span class="line">-f  显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字.(此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环).</span><br><span class="line">    由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 &#x27;any&#x27; 网络接口就不需要设置地址和掩码, 不过此&#x27;any&#x27;接口可以收到系统中所有接口的数据包), 该选项不能正常工作.</span><br><span class="line">-F  file</span><br><span class="line">    使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.</span><br><span class="line">-i  interface</span><br><span class="line">    指定tcpdump 需要监听的接口.  如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口).一但找到第一个符合条件的接口, 搜寻马上结束.</span><br><span class="line">    在采用2.2版本或之后版本内核的Linux 操作系统上, &#x27;any&#x27; 这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在&#x27;混杂&#x27;模式(promiscuous)下,则无法在&#x27;any&#x27;这个虚拟的网络接口上抓取其数据包.</span><br><span class="line">    如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.</span><br><span class="line">-l  对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来).在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的:</span><br><span class="line">    ``tcpdump  -l  |  tee dat&#x27;&#x27; 或者 ``tcpdump  -l   &gt; dat  &amp;  tail  -f  dat&#x27;&#x27;.(nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作&#x27;&gt;&#x27;, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中)</span><br><span class="line">-L  列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定)</span><br><span class="line">-m  module</span><br><span class="line">    通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充).</span><br><span class="line">    此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.</span><br><span class="line">-M  secret  如果TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret.</span><br><span class="line">-n  不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换.</span><br><span class="line">-N  不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印&#x27;nic&#x27; 而不是 &#x27;nic.ddn.mil&#x27;.</span><br><span class="line">-O  不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用.</span><br><span class="line">-p  一般情况下, 把网络接口设置为非&#x27;混杂&#x27;模式. 但必须注意 , 在特殊情况下此网络接口还是会以&#x27;混杂&#x27;模式来工作； 从而, &#x27;-p&#x27; 的设与不设, 不能当做以下选现的代名词:&#x27;ether host &#123;local-hw-add&#125;&#x27; 或  &#x27;ether broadcast&#x27;(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包).</span><br><span class="line">-q  快速(也许用&#x27;安静&#x27;更好?)打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短.</span><br><span class="line">-R  设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出&#x27;禁止中继&#x27;域(nt: relay prevention field). 另外,由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号.</span><br><span class="line">-r  file</span><br><span class="line">    从文件file 中读取包数据. 如果file 字段为 &#x27;-&#x27; 符号, 则tcpdump 会从标准输入中读取包数据.</span><br><span class="line">-S  打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325).</span><br><span class="line">-s  snaplen</span><br><span class="line">    设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节(而支持网络接口分接头(nt: NIT, 上文已有描述,可搜索&#x27;网络接口分接头&#x27;关键字找到那里)的SunOS系列操作系统中默认的也是最小值是96).68字节对于IP, ICMP(nt: Internet Control Message Protocol,因特网控制报文协议), TCP 以及 UDP 协议的报文已足够, 但对于名称服务(nt: 可理解为dns, nis等服务), NFS服务相关的数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现&#x27;&#x27;[|proto]&#x27;&#x27;的标志（proto 实际会显示为被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好.把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包.</span><br><span class="line">-T  type</span><br><span class="line">    强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包.  目前已知的type 可取的协议为:</span><br><span class="line">    aodv (Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用),</span><br><span class="line">    cnfp (Cisco  NetFlow  protocol),  rpc(Remote Procedure Call), rtp (Real-Time Applications protocol),</span><br><span class="line">    rtcp (Real-Time Applications con-trol protocol), snmp (Simple Network Management Protocol),</span><br><span class="line">    tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电</span><br><span class="line">    视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议).</span><br><span class="line">-t     	在每行输出中不打印时间戳</span><br><span class="line">-tt    	不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)</span><br><span class="line">-ttt   	tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位)</span><br><span class="line">-tttt  	在每行打印的时间戳之前添加日期的打印</span><br><span class="line">-u     	打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件)</span><br><span class="line">-U   	使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件)</span><br><span class="line">		-U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数.</span><br><span class="line">-v    当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和.</span><br><span class="line">-vv   产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.</span><br><span class="line">-vvv  产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面,</span><br><span class="line">      其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充).</span><br><span class="line">-w    把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印.</span><br><span class="line">-W    filecount</span><br><span class="line">      此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序.</span><br><span class="line">-x    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部).总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so for link  layers  that pad, 未能衔接理解和翻译, 需补充 )</span><br><span class="line">-xx   tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.</span><br><span class="line">-X    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部).这对于分析一些新协议的数据包很方便.</span><br><span class="line">-XX   当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便.</span><br><span class="line">-y    datalinktype</span><br><span class="line">      设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包</span><br><span class="line">-Z    user</span><br><span class="line">      使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三-实用命令实例"><a href="#三-实用命令实例" class="headerlink" title="三. 实用命令实例"></a>三. 实用命令实例</h2><h3 id="3-1-默认启动"><a href="#3-1-默认启动" class="headerlink" title="3.1. 默认启动"></a>3.1. 默认启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>普通情况下，直接启动 tcpdump 将监视第一个网络接口上所有流过的数据包。</p>
<h3 id="3-2-监视指定网络接口的数据包"><a href="#3-2-监视指定网络接口的数据包" class="headerlink" title="3.2. 监视指定网络接口的数据包"></a>3.2. 监视指定网络接口的数据包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0，下面的例子都没有指定网络接口。</p>
<h3 id="3-3-监视指定主机的数据包"><a href="#3-3-监视指定主机的数据包" class="headerlink" title="3.3. 监视指定主机的数据包"></a>3.3. 监视指定主机的数据包</h3><p>打印所有进入或离开 sundown 的数据包.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host sundown</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以指定 ip, 例如截获所有 210.27.48.1 的主机收到的和发出的所有的数据包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-打印-helios-与-hot-或者与-ace-之间通信的数据包"><a href="#3-4-打印-helios-与-hot-或者与-ace-之间通信的数据包" class="headerlink" title="3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包"></a>3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host helios and \( hot or ace \)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-5-截获主机-210-27-48-1-和主机-210-27-48-2-或-210-27-48-3-的通信"><a href="#3-5-截获主机-210-27-48-1-和主机-210-27-48-2-或-210-27-48-3-的通信" class="headerlink" title="3.5. 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信"></a>3.5. 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.1 and \(210.27.48.2 or 210.27.48.3 \)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-6-打印-ace-与任何其他主机之间通信的-IP-数据包-但不包括与-helios-之间的数据包"><a href="#3-6-打印-ace-与任何其他主机之间通信的-IP-数据包-但不包括与-helios-之间的数据包" class="headerlink" title="3.6. 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包."></a>3.6. 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ip host ace and not helios</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想要获取主机 210.27.48.1 除了和主机 210.27.48.2 之外所有主机通信的 ip 包，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ip host 210.27.48.1 and ! 210.27.48.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-7-截获主机-hostname-发送的所有数据"><a href="#3-7-截获主机-hostname-发送的所有数据" class="headerlink" title="3.7. 截获主机 hostname 发送的所有数据"></a>3.7. 截获主机 hostname 发送的所有数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host hostname</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-8-监视所有送到主机-hostname-的数据包"><a href="#3-8-监视所有送到主机-hostname-的数据包" class="headerlink" title="3.8. 监视所有送到主机 hostname 的数据包"></a>3.8. 监视所有送到主机 hostname 的数据包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 dst host hostname</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-9-监视指定主机和端口的数据包"><a href="#3-9-监视指定主机和端口的数据包" class="headerlink" title="3.9. 监视指定主机和端口的数据包"></a>3.9. 监视指定主机和端口的数据包</h3><p>如果想要获取主机 210.27.48.1 接收或发出的 telnet 包，使用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp port 23 and host 210.27.48.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对本机的 udp 123 端口进行监视 123 为 ntp 的服务端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 123</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-10-监视指定网络的数据包"><a href="#3-10-监视指定网络的数据包" class="headerlink" title="3.10. 监视指定网络的数据包"></a>3.10. 监视指定网络的数据包</h3><p>打印本地主机与 Berkeley 网络上的主机之间的所有通信数据包 (nt: ucb-ether, 此处可理解为’Berkeley 网络’的网络地址, 此表达式最原始的含义可表达为: 打印网络地址为 ucb-ether 的所有数据包)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump net ucb-ether</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印所有通过网关 snup 的 ftp 数据包 (注意, 表达式被单引号括起来了, 这可以防止 shell 对其中的括号进行错误解析)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;gateway snup and (port ftp or ftp-data)&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印所有源地址或目标地址是本地主机的 IP 数据包<br>(如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折, 需补充).localnet 实际使用时要真正替换成本地网络的名字)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ip and not net localnet</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-11-监视指定协议的数据包"><a href="#3-11-监视指定协议的数据包" class="headerlink" title="3.11. 监视指定协议的数据包"></a>3.11. 监视指定协议的数据包</h3><p>打印 TCP 会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.(nt: localnet, 实际使用时要真正替换成本地网络的名字))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印所有源或目的端口是 80, 网络层协议为 IPv4, 并且含有数据, 而不是 SYN,FIN 以及 ACK-only 等不含数据的数据包.(ipv6 的版本的表达式可做练习)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(nt: 可理解为, ip[2:2] 表示整个 ip 数据包的长度, <strong>(ip[0]&amp;0xf)&lt;&lt;2**)<br>表示 ip 数据包包头的长度<br>(<br>**ip[0]&amp;0xf** 代表包中的 IHL 域, 而此域的单位为 32bit, 要换算成字节数需要乘以 4, 即左移 2.<br>**(tcp[12]&amp;0xf0)&gt;&gt;4</strong> 表示 tcp 头的长度, 此域的单位也是 32bit,<br>换算成比特数为 **((tcp[12]&amp;0xf0) &gt;&gt; 4) &lt;&lt; ２**,　<br>即 **((tcp[12]&amp;0xf0)&gt;&gt;2)**。<br><strong>((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) !&#x3D; 0</strong><br>表示: 整个 ip 数据包的长度减去 ip 头的长度, 再减去 tcp 头的长度不为 0, 这就意味着, ip 数据包中确实是有数据. 对于 ipv6 版本只需考虑 ipv6 头中的’Payload Length’ 与’tcp 头的长度’的差值, 并且其中表达方式’ip[]‘需换成’ip6[]’.<br>)</p>
<p>打印长度超过 576 字节, 并且网关地址是 snup 的 IP 数据包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;gateway snup and ip[2:2] &gt; 576&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印所有 IP 层广播或多播的数据包， 但不是物理以太网层的广播或多播数据报</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;ether[0] &amp; 1 = 0 and ip[16] &gt;= 224&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印除’echo request’或者’echo reply’类型以外的 ICMP 数据包 ( 比如, 需要打印所有非 ping 程序产生的数据包时可用到此表达式 .<br>(nt: ‘echo reuqest’ 与 ‘echo reply’ 这两种类型的 ICMP 数据包通常由 ping 程序产生))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四-tcpdump-与-wireshark"><a href="#四-tcpdump-与-wireshark" class="headerlink" title="四. tcpdump 与 wireshark"></a>四. tcpdump 与 wireshark</h2><p>Wireshark 是 Windows 下非常简单易用的抓包工具。<br>但在 Linux 下很难找到一个好用的图形化抓包工具。<br>还好有 Tcpdump。我们可以用 Tcpdump + Wireshark 的完美组合实现：在 Linux 里抓包，然后在 Windows 里分析包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp 这些选项等都要放到第一个参数的位置，用来过滤数据报的类型</strong><br><strong>(2)-i eth1 : 只抓经过接口 eth1 的包</strong><br><strong>(3)-t : 不显示时间戳</strong><br><strong>(4)-s 0 : 抓取数据包时默认抓取长度为 68 字节。加上 - S 0 后可以抓到完整的数据包</strong><br><strong>(5)-c 100 : 只抓取 100 个数据包</strong><br><strong>(6)dst port ! 22 : 不抓取目标端口是 22 的数据包</strong><br><strong>(7)src net 192.168.1.0&#x2F;24 : 数据包的源网络地址为 192.168.1.0&#x2F;24</strong><br><strong>(8)-w .&#x2F;target.cap : 保存成 cap 文件，方便用 ethereal(即 wireshark) 分析</strong></p>
<h3 id="4-1-使用-tcpdump-抓取-HTTP-包"><a href="#4-1-使用-tcpdump-抓取-HTTP-包" class="headerlink" title="4.1. 使用 tcpdump 抓取 HTTP 包"></a>4.1. 使用 tcpdump 抓取 HTTP 包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>0x4745 为 “GET” 前两个字母 “GE”,0x4854 为 “HTTP” 前两个字母 “HT”。</p>
<p>tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。<br>显然这不利于分析网络故障，通常的解决办法是先使用带 - w 参数的 tcpdump 截获数据并保存到文件中，然后再使用其他程序 (如 Wireshark) 进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</p>
<h2 id="五-输出信息含义"><a href="#五-输出信息含义" class="headerlink" title="五. 输出信息含义"></a>五. 输出信息含义</h2><p>首先我们注意一下，基本上 tcpdump 总的的输出格式为：<br><strong>系统时间 来源主机. 端口 &gt; 目标主机. 端口 数据包参数</strong></p>
<p>tcpdump 的输出格式与协议有关. 以下简要描述了大部分常用的格式及相关例子.<br>链路层头</p>
<p>对于 FDDI 网络, ‘-e’ 使 tcpdump 打印出指定数据包的’frame control’ 域, 源和目的地址, 以及包的长度.(frame control 域<br>控制对包中其他域的解析). 一般的包 (比如那些 IP datagrams) 都是带有’async’(异步标志)的数据包，并且有取值 0 到 7 的优先级;<br>比如’async4’就代表此包为异步数据包，并且优先级别为 4. 通常认为, 这些包们会内含一个 LLC 包 (逻辑链路控制包); 这时, 如果此包<br>不是一个 ISO datagram 或所谓的 SNAP 包，其 LLC 头部将会被打印 (nt: 应该是指此包内含的 LLC 包的包头).</p>
<p>对于 Token Ring 网络 (令牌环网络), ‘-e’ 使 tcpdump 打印出指定数据包的’frame control’和’access control’域, 以及源和目的地址,<br>外加包的长度. 与 FDDI 网络类似, 此数据包通常内含 LLC 数据包. 不管 是否有’-e’选项. 对于此网络上的’source-routed’类型数据包 (nt:<br>意译为: 源地址被追踪的数据包, 具体含义未知, 需补充), 其包的源路由信息总会被打印.</p>
<p>对于 802.11 网络 (WLAN, 即 wireless local area network), ‘-e’ 使 tcpdump 打印出指定数据包的’frame control 域,<br>包头中包含的所有地址, 以及包的长度. 与 FDDI 网络类似, 此数据包通常内含 LLC 数据包.</p>
<p>(注意: 以下的描述会假设你熟悉 SLIP 压缩算法 (nt:SLIP 为 Serial Line Internet Protocol.), 这个算法可以在<br>RFC-1144 中找到相关的蛛丝马迹.)</p>
<p>对于 SLIP 网络 (nt:SLIP links, 可理解为一个网络, 即通过串行线路建立的连接, 而一个简单的连接也可看成一个网络),<br>数据包的’direction indicator’(‘方向指示标志’)(“I” 表示入, “O” 表示出), 类型以及压缩信息将会被打印. 包类型会被首先打印.</p>
<p>类型分为 ip, utcp 以及 ctcp(nt: 未知, 需补充). 对于 ip 包, 连接信息将不被打印 (nt:SLIP 连接上, ip 包的连接信息可能无用或没有定义.<br>reconfirm). 对于 TCP 数据包, 连接标识紧接着类型表示被打印. 如果此包被压缩, 其被编码过的头部将被打印.<br>此时对于特殊的压缩包, 会如下显示:<br>*S+n 或者 *SA+n, 其中 n 代表包的 (顺序号或(顺序号和应答号)) 增加或减少的数目(nt | rt:S,SA 拗口, 需再译).<br>对于非特殊的压缩包, 0 个或更多的’改变’将会被打印.‘改变’被打印时格式如下:<br>‘标志’+&#x2F;-&#x2F;&#x3D;n 包数据的长度 压缩的头部长度.<br>其中’标志’可以取以下值:<br>U(代表紧急指针), W(指缓冲窗口), A(应答), S(序列号), I(包 ID), 而增量表达’&#x3D;n’表示被赋予新的值, +&#x2F;- 表示增加或减少.</p>
<p>比如, 以下显示了对一个外发压缩 TCP 数据包的打印, 这个数据包隐含一个连接标识 (connection identifier); 应答号增加了 6,<br>顺序号增加了 49, 包 ID 号增加了 6; 包数据长度为 3 字节 (octect), 压缩头部为 6 字节.(nt: 如此看来这应该不是一个特殊的压缩数据包).</p>
<h3 id="5-1-ARP-x2F-RARP-数据包"><a href="#5-1-ARP-x2F-RARP-数据包" class="headerlink" title="5.1. ARP&#x2F;RARP 数据包"></a>5.1. ARP&#x2F;RARP 数据包</h3><p>tcpdump 对 Arp&#x2F;rarp 包的输出信息中会包含请求类型及该请求对应的参数. 显示格式简洁明了. 以下是从主机 rtsg 到主机 csam 的’rlogin’<br>(远程登录) 过程开始阶段的数据包样例:<br>arp who-has csam tell rtsg<br>arp reply csam is-at CSAM<br>第一行表示: rtsg 发送了一个 arp 数据包 (nt: 向全网段发送, arp 数据包）以询问 csam 的以太网地址<br>Csam（nt: 可从下文看出来, 是 Csam）以她自己的以太网地址做了回应 (在这个例子中, 以太网地址以大写的名字标识, 而 internet<br>地址 (即 ip 地址) 以全部的小写名字标识).</p>
<p>如果使用 tcpdump -n, 可以清晰看到以太网以及 ip 地址而不是名字标识:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp who-has 128.3.254.6 tell 128.3.254.68</span><br><span class="line">arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们使用 tcpdump -e, 则可以清晰的看到第一个数据包是全网广播的, 而第二个数据包是点对点的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTSG Broadcast 0806 64: arp who-has csam tell rtsg</span><br><span class="line">CSAM RTSG 0806 64: arp reply csam is-at CSAM</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个数据包表明: 以 arp 包的源以太地址是 RTSG, 目标地址是全以太网段, type 域的值为 16 进制 0806(表示 ETHER_ARP(nt:arp 包的类型标识)),<br>包的总长度为 64 字节.</p>
<h3 id="5-2-TCP-数据包"><a href="#5-2-TCP-数据包" class="headerlink" title="5.2. TCP 数据包"></a>5.2. TCP 数据包</h3><p>(注意: 以下将会假定你对 RFC-793 所描述的 TCP 熟悉. 如果不熟, 以下描述以及 tcpdump 程序可能对你帮助不大.(nt: 警告可忽略,<br>只需继续看, 不熟悉的地方可回头再看.).</p>
<p>通常 tcpdump 对 tcp 数据包的显示格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src &gt; dst: flags data-seqno ack window urgent options</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>src 和 dst 是源和目的 IP 地址以及相应的端口.<br>flags 标志由 S(SYN), F(FIN), P(PUSH, R(RST),W(ECN CWT(nt | rep: 未知, 需补充)) 或者 E(ECN-Echo(nt | rep: 未知,　需补充)) 组成,<br>单独一个’.’表示没有 flags 标识.<br>数据段顺序号 (Data-seqno) 描述了此包中数据所对应序列号空间中的一个位置(nt: 整个数据被分段, 每段有一个顺序号, 所有的顺序号构成一个序列号空间)<br>(可参考以下例子). Ack 描述的是同一个连接, 同一个方向, 下一个本端应该接收的 (对方应该发送的) 数据片段的顺序号.<br>Window 是本端可用的数据接收缓冲区的大小 (也是对方发送数据时需根据这个大小来组织数据).<br>Urg(urgent) 表示数据包中有紧急的数据. options 描述了 tcp 的一些选项, 这些选项都用尖括号来表示 (如 &lt;mss 1024&gt;).</p>
<p>src, dst 和 flags 这三个域总是会被显示.<br>其他域的显示与否依赖于 tcp 协议头里的信息.</p>
<p>这是一个从 trsg 到 csam 的一个 rlogin 应用登录的开始阶段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;</span><br><span class="line">csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;</span><br><span class="line">rtsg.1023 &gt; csam.login: . ack 1 win 4096</span><br><span class="line">rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096</span><br><span class="line">csam.login &gt; rtsg.1023: . ack 2 win 4096</span><br><span class="line">rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096</span><br><span class="line">csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077</span><br><span class="line">csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1</span><br><span class="line">csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行表示有一个数据包从 rtsg 主机的 tcp 端口 1023 发送到了 csam 主机的 tcp 端口 login 上<br>(nt:udp 协议的端口和 tcp 协议的端口是分别的两个空间, 虽然取值范围一致).<br>S 表示设置了 SYN 标志. 包的顺序号是 768512, 并且没有包含数据.<br>(表示格式为:‘first:last(nbytes)’, 其含义是’此包中数据的顺序号从 first 开始直到 last 结束，不包括 last. 并且总共包含 nbytes 的用户数据’.) 没有捎带应答 (nt: 从下文来看，第二行才是有捎带应答的数据包), 可用的接受窗口的大小为 4096bytes, 并且请求端(rtsg) 的最大可接受的数据段大小是 1024 字节(nt: 这个信息作为请求发向应答端 csam, 以便双方进一步的协商).</p>
<p>Csam 向 rtsg 回复了基本相同的 SYN 数据包, 其区别只是多了一个<br><strong>‘piggy-backed ack’</strong>(nt: 捎带回的 ack 应答, 针对 rtsg 的 SYN 数据包).</p>
<p>rtsg 同样针对 csam 的 SYN 数据包回复了一 ACK 数据包作为应答.<br>‘.’的含义就是此包中没有标志被设置.<br>由于此应答包中不含有数据, 所以包中也没有数据段序列号.<br>提醒! 此 ACK 数据包的顺序号只是一个小整数 1. 有如下解释: tcpdump 对于一个 tcp 连接上的会话, 只打印会话两端的初始数据包的序列号,<br>其后相应数据包只打印出与初始包序列号的差异.<br>即初始序列号之后的序列号, 可被看作此会话上当前所传数据片段在整个<br>要传输的数据中的’相对字节’位置<br>(nt: 双方的第一个位置都是 1, 即’相对字节’的开始编号).<br>‘-Ｓ’将覆盖这个功能, 使数据包的原始顺序号被打印出来.</p>
<p>第六行的含义为: rtsg 向 csam 发送了 19 字节的数据 (字节的编号为 2 到 20，传送方向为 rtsg 到 csam). 包中设置了 PUSH 标志. 在第 7 行,<br>csam 喊到， 她已经从 rtsg 中收到了 21 以下的字节, 但不包括 21 编号的字节. 这些字节存放在 csam 的 socket 的接收缓冲中, 相应地,<br>csam 的接收缓冲窗口大小会减少 19 字节 (nt: 可以从第 5 行和第 7 行 win 属性值的变化看出来). csam 在第 7 行这个包中也向 rtsg 发送了一个<br>字节. 在第 8 行和第 9 行, csam 继续向 rtsg 分别发送了两个只包含一个字节的数据包, 并且这个数据包带 PUSH 标志.</p>
<p>如果所抓到的 tcp 包 (nt: 即这里的 snapshot) 太小了，以至 tcpdump 无法完整得到其头部数据, 这时, tcpdump 会尽量解析这个不完整的头,<br>并把剩下不能解析的部分显示为’[|tcp]‘. 如果头部含有虚假的属性信息 (比如其长度属性其实比头部实际长度长或短), tcpdump 会为该头部<br>显示’[bad opt]‘. 如果头部的长度告诉我们某些选项 (nt | rt: 从下文来看， 指 tcp 包的头部中针对 ip 包的一些选项, 回头再翻) 会在此包中,<br>而真正的 IP(数据包的长度又不够容纳这些选项, tcpdump 会显示’[bad hdr length]’.</p>
<p>抓取带有特殊标志的的 TCP 包 (如 SYN-ACK 标志, URG-ACK 标志等).</p>
<p>在 TCP 的头部中, 有 8 比特 (bit) 用作控制位区域, 其取值为:<br>CWR | ECE | URG | ACK | PSH | RST | SYN | FIN<br>(nt | rt: 从表达方式上可推断: 这 8 个位是用或的方式来组合的, 可回头再翻)</p>
<p>现假设我们想要监控建立一个 TCP 连接整个过程中所产生的数据包. 可回忆如下: TCP 使用 3 次握手协议来建立一个新的连接; 其与此三次握手<br>连接顺序对应，并带有相应 TCP 控制标志的数据包如下:</p>
<ol>
<li>连接发起方 (nt:Caller) 发送 SYN 标志的数据包</li>
<li>接收方 (nt:Recipient) 用带有 SYN 和 ACK 标志的数据包进行回应</li>
<li>发起方收到接收方回应后再发送带有 ACK 标志的数据包进行回应</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 15 31</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">| source port | destination port |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">| sequence number |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">| acknowledgment number |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">| HL | rsvd |C|E|U|A|P|R|S|F| window size |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">| TCP checksum | urgent pointer |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个 TCP 头部, 在不包含选项数据的情况下通常占用 20 个字节 (nt | rt:options 理解为选项数据，需回译). 第一行包含 0 到 3 编号的字节,<br>第二行包含编号 4-7 的字节.</p>
<p>如果编号从 0 开始算, TCP 控制标志位于 13 字节 (nt: 第四行左半部分).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 7| 15| 23| 31</span><br><span class="line">----------------|---------------|---------------|----------------</span><br><span class="line">| HL | rsvd |C|E|U|A|P|R|S|F| window size |</span><br><span class="line">----------------|---------------|---------------|----------------</span><br><span class="line">| | 13th octet | | |</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们仔细看看编号 13 的字节:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| |</span><br><span class="line">|---------------|</span><br><span class="line">|C|E|U|A|P|R|S|F|</span><br><span class="line">|---------------|</span><br><span class="line">|7 5 3 0|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有我们感兴趣的控制标志位. 从右往左这些位被依次编号为 0 到 7, 从而 PSH 位在 3 号, 而 URG 位在 5 号.</p>
<p>提醒一下自己, 我们只是要得到包含 SYN 标志的数据包. 让我们看看在一个包的包头中, 如果 SYN 位被设置, 到底<br>在 13 号字节发生了什么:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|C|E|U|A|P|R|S|F|</span><br><span class="line">|---------------|</span><br><span class="line">|0 0 0 0 0 0 1 0|</span><br><span class="line">|---------------|</span><br><span class="line">|7 6 5 4 3 2 1 0|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在控制段的数据中, 只有比特 1(bit number 1) 被置位.</p>
<p>假设编号为 13 的字节是一个 8 位的无符号字符型, 并且按照网络字节号排序 (nt: 对于一个字节来说，网络字节序等同于主机字节序), 其二进制值<br>如下所示:<br>00000010</p>
<p>并且其 10 进制值为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0*2^7 + 0*2^6 + 0*2^5 + 0*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(nt: 1 * 2^6 表示 1 乘以 2 的 6 次方, 也许这样更<br>清楚些, 即把原来表达中的指数 7 6 … 0 挪到了下面来表达)</p>
<p>接近目标了, 因为我们已经知道, 如果数据包头部中的 SYN 被置位, 那么头部中的第 13 个字节的值为 2(nt: 按照网络序, 即大头方式, 最重要的字节<br>在前面 (在前面, 即该字节实际内存地址比较小, 最重要的字节, 指数学表示中数的高位, 如 356 中的 3) ).</p>
<p>表达为 tcpdump 能理解的关系式就是:<br>tcp[13] 2</p>
<p>从而我们可以把此关系式当作 tcpdump 的过滤条件, 目标就是监控只含有 SYN 标志的数据包:<br>tcpdump -i xl0 tcp[13] 2 (nt: xl0 指网络接口, 如 eth0)</p>
<p>这个表达式是说 “让 TCP 数据包的第 13 个字节拥有值 2 吧”, 这也是我们想要的结果.</p>
<p>现在, 假设我们需要抓取带 SYN 标志的数据包, 而忽略它是否包含其他标志.(nt: 只要带 SYN 就是我们想要的). 让我们来看看当一个含有<br>SYN-ACK 的数据包 (nt:SYN 和 ACK 标志都有), 来到时发生了什么:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|C|E|U|A|P|R|S|F|</span><br><span class="line">|---------------|</span><br><span class="line">|0 0 0 1 0 0 1 0|</span><br><span class="line">|---------------|</span><br><span class="line">|7 6 5 4 3 2 1 0|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>13 号字节的 1 号和 4 号位被置位, 其二进制的值为:<br>00010010</p>
<p>转换成十进制就是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 0*2 = 18</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(nt: 1 * 2^6 表示 1 乘以 2 的 6 次方, 也许这样更<br>清楚些, 即把原来表达中的指数 7 6 … 0 挪到了下面来表达)</p>
<p>现在, 却不能只用’tcp[13] 18’作为 tcpdump 的过滤表达式, 因为这将导致只选择含有 SYN-ACK 标志的数据包, 其他的都被丢弃.<br>提醒一下自己, 我们的目标是: 只要包的 SYN 标志被设置就行, 其他的标志我们不理会.</p>
<p>为了达到我们的目标, 我们需要把 13 号字节的二进制值与其他的一个数做 AND 操作 (nt: 逻辑与) 来得到 SYN 比特位的值. 目标是: 只要 SYN 被设置<br>就行, 于是我们就把她与上 13 号字节的 SYN 值 (nt: 00000010).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00010010 SYN-ACK 00000010 SYN</span><br><span class="line">AND 00000010 (we want SYN) AND 00000010 (we want SYN)</span><br><span class="line">-------- --------</span><br><span class="line">= 00000010 = 00000010</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以发现, 不管包的 ACK 或其他标志是否被设置, 以上的 AND 操作都会给我们相同的值, 其 10 进制表达就是 2(2 进制表达就是 00000010).<br>从而我们知道, 对于带有 SYN 标志的数据包, 以下的表达式的结果总是真 (true):</p>
<p>(( value of octet 13) AND ( 2 ) ) ( 2 ) (nt: value of octet 13, 即 13 号字节的值)</p>
<p>灵感随之而来, 我们于是得到了如下的 tcpdump 的过滤表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i xl0 &#x27;tcp[13] &amp; 2 2&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意, 单引号或反斜杆 (nt: 这里用的是单引号) 不能省略, 这可以防止 shell 对 &amp; 的解释或替换.</p>
<h3 id="5-3-UDP-数据包"><a href="#5-3-UDP-数据包" class="headerlink" title="5.3. UDP 数据包"></a>5.3. UDP 数据包</h3><p>UDP 数据包的显示格式，可通过 rwho 这个具体应用所产生的数据包来说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actinide.who &gt; broadcast.who: udp 84</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其含义为: actinide 主机上的端口 who 向 broadcast 主机上的端口 who 发送了一个 udp 数据包 (nt: actinide 和 broadcast 都是指 Internet 地址).<br>这个数据包承载的用户数据为 84 个字节.</p>
<p>一些 UDP 服务可从数据包的源或目的端口来识别，也可从所显示的更高层协议信息来识别. 比如, Domain Name service requests(DNS 请求,<br>在 RFC-1034&#x2F;1035 中), 和 Sun RPC calls to NFS(对 NFS 服务器所发起的远程调用 (nt: 即 Sun RPC)，在 RFC-1050 中有对远程调用的描述).</p>
<h4 id="5-3-1-UDP-名称服务请求"><a href="#5-3-1-UDP-名称服务请求" class="headerlink" title="5.3.1. UDP 名称服务请求"></a>5.3.1. UDP 名称服务请求</h4><p>(注意: 以下的描述假设你对 Domain Service protoco(nt: 在 RFC-103 中有所描述), 否则你会发现以下描述就是天书 (nt: 希腊文天书,<br>不必理会, 吓吓你的, 接着看就行))</p>
<p>名称服务请求有如下的格式:<br>src &gt; dst: id op? flags qtype qclass name (len)<br>(nt: 从下文来看, 格式应该是 src&gt; dst: id op flags qtype qclass? name (len))<br>比如有一个实际显示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主机 h2opolo 向 helios 上运行的名称服务器查询 ucbvax.berkeley.edu 的地址记录 (nt: qtype 等于 A). 此查询本身的 id 号为’3’.<br>符号’+‘意味着递归查询标志被设置<br>(nt: dns 服务器可向更高层 dns 服务器查询本服务器不包含的地址记录). 这个最终通过 IP 包发送的查询请求<br>数据长度为 37 字节, 其中不包括 UDP 和 IP 协议的头数据. 因为此查询操作为默认值 (nt | rt: normal one 的理解), op 字段被省略.<br>如果 op 字段没被省略, 会被显示在’3’ 和’+’之间. 同样, qclass 也是默认值, C_IN, 从而也没被显示, 如果没被忽略, 她会被显示在’A’之后.</p>
<p>异常检查会在方括中显示出附加的域:　如果一个查询同时包含一个回应 (nt: 可理解为, 对之前其他一个请求的回应), 并且此回应包含权威或附加记录段,　<br>ancount, nscout, arcount(nt: 具体字段含义需补充) 将被显示为’[na]’, ‘[nn]’, ‘[nau]’, 其中 n 代表合适的计数. 如果包中以下<br>回应位 (比如 AA 位, RA 位, rcode 位), 或者字节 2 或 3 中任何一个’必须为 0’的位被置位 (nt: 设置为 1), ‘[b2&amp;3]&#x3D;x’ 将被显示, 其中 x 表示<br>头部字节 2 与字节 3 进行与操作后的值.</p>
<h4 id="5-3-2-UDP-名称服务应答"><a href="#5-3-2-UDP-名称服务应答" class="headerlink" title="5.3.2. UDP 名称服务应答"></a>5.3.2. UDP 名称服务应答</h4><p>对名称服务应答的数据包，tcpdump 会有如下的显示格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src &gt; dst: id op rcode flags a/n/au type class data (len)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如具体显示如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)</span><br><span class="line">helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行表示: helios 对 h2opolo 所发送的 3 号查询请求回应了 3 条回答记录 (nt | rt: answer records), 3 条名称服务器记录,<br>以及 7 条附加的记录. 第一个回答记录 (nt: 3 个回答记录中的第一个) 类型为 A(nt: 表示地址), 其数据为 internet 地址 128.32.137.3.<br>此回应 UDP 数据包, 包含 273 字节的数据 (不包含 UPD 和 IP 的头部数据). op 字段和 rcode 字段被忽略 (nt: op 的实际值为 Query, rcode, 即<br>response code 的实际值为 NoError), 同样被忽略的字段还有 class 字段 (nt | rt: 其值为 C_IN, 这也是 A 类型记录默认取值)</p>
<p>第二行表示: helios 对 h2opolo 所发送的 2 号查询请求做了回应. 回应中, rcode 编码为 NXDomain(nt: 表示不存在的域)), 没有回答记录,<br>但包含一个名称服务器记录, 不包含权威服务器记录 (nt | ck: 从上文来看, 此处的 authority records 就是上文中对应的 additional<br>records). ‘*’表示权威服务器回答标志被设置 (nt: 从而 additional records 就表示的是 authority records).<br>由于没有回答记录, type, class, data 字段都被忽略.</p>
<p>flag 字段还有可能出现其他一些字符, 比如’-‘(nt: 表示可递归地查询, 即 RA 标志没有被设置), ‘|’(nt: 表示被截断的消息, 即 TC 标志<br>被置位). 如果应答 (nt | ct: 可理解为, 包含名称服务应答的 UDP 数据包, tcpdump 知道这类数据包该怎样解析其数据) 的’question’段一个条<br>目 (entry) 都不包含(nt: 每个条目的含义, 需补充),’[nq]’ 会被打印出来.</p>
<p>要注意的是: 名称服务器的请求和应答数据量比较大, 而默认的 68 字节的抓取长度 (nt: snaplen, 可理解为 tcpdump 的一个设置选项) 可能不足以抓取<br>数据包的全部内容. 如果你真的需要仔细查看名称服务器的负载, 可以通过 tcpdump 的 - s 选项来扩大 snaplen 值.<br>SMB&#x2F;CIFS 解码</p>
<p>tcpdump 已可以对 SMB&#x2F;CIFS&#x2F;NBT 相关应用的数据包内容进行解码 (nt: 分别为’Server Message Block Common’, ‘Internet File System’<br>‘在 TCP&#x2F;IP 上实现的网络协议 NETBIOS 的简称’. 这几个服务通常使用 UDP 的 137&#x2F;138 以及 TCP 的 139 端口). 原来的对 IPX 和 NetBEUI SMB 数据包的<br>解码能力依然可以被使用 (nt: NetBEUI 为 NETBIOS 的增强版本).</p>
<p>tcpdump 默认只按照最简约模式对相应数据包进行解码, 如果我们想要详尽的解码信息可以使用其 - v 启动选现. 要注意的是, -v 会产生非常详细的信息,<br>比如对单一的一个 SMB 数据包, 将产生一屏幕或更多的信息, 所以此选项, 确有需要才使用.</p>
<p>关于 SMB 数据包格式的信息, 以及每个域的含义可以参看 <a target="_blank" rel="noopener" href="http://www.cifs.org/">www.cifs.org</a> 或者 samba.org 镜像站点的 pub&#x2F;samba&#x2F;specs&#x2F; 目录. linux 上的 SMB 补丁<br>(nt | rt: patch) 由 Andrew Tridgell (<a href="mailto:&#x74;&#x72;&#105;&#x64;&#103;&#101;&#x40;&#x73;&#97;&#109;&#98;&#x61;&#46;&#x6f;&#x72;&#103;">&#x74;&#x72;&#105;&#x64;&#103;&#101;&#x40;&#x73;&#97;&#109;&#98;&#x61;&#46;&#x6f;&#x72;&#103;</a>) 提供.</p>
<h3 id="5-4-NFS-请求和回应"><a href="#5-4-NFS-请求和回应" class="headerlink" title="5.4. NFS 请求和回应"></a>5.4. NFS 请求和回应</h3><p>tcpdump 对 Sun NFS(网络文件系统) 请求和回应的 UDP 数据包有如下格式的打印输出:<br>src.xid &gt; dst.nfs: len op args<br>src.nfs &gt; dst.xid: reply stat len op results</p>
<p>以下是一组具体的输出数据<br>sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24&#x2F;10.73165<br>wrl.nfs &gt; sushi.6709: reply ok 40 readlink “…&#x2F;var”<br>sushi.201b &gt; wrl.nfs:<br>144 lookup fh 9,74&#x2F;4096.6878 “xcolors”<br>wrl.nfs &gt; sushi.201b:<br>reply ok 128 lookup fh 9,74&#x2F;4134.3150</p>
<p>第一行输出表明: 主机 sushi 向主机 wrl 发送了一个’交换请求’(nt: transaction), 此请求的 id 为 6709(注意, 主机名字后是交换<br>请求 id 号, 而不是源端口号). 此请求数据为 112 字节, 其中不包括 UDP 和 IP 头部的长度. 操作类型为 readlink(nt: 即此操作为读符号链接操作),<br>操作参数为 fh 21,24&#x2F;10.73165(nt: 可按实际运行环境, 解析如下, fd 表示描述的为文件句柄, 21,24 表示此句柄所对应设<br>备的主 &#x2F; 从设备号对, 10 表示此句柄所对应的 i 节点编号 (nt: 每个文件都会在操作系统中对应一个 i 节点, 限于 unix 类系统中),<br>73165 是一个编号 (nt: 可理解为标识此请求的一个随机数, 具体含义需补充)).</p>
<p>第二行中, wrl 做了’ok’的回应, 并且在 results 字段中返回了 sushi 想要读的符号连接的真实目录 (nt: 即 sushi 要求读的符号连接其实是一个目录).</p>
<p>第三行表明: sushi 再次请求 wrl 在’fh 9,74&#x2F;4096.6878’所描述的目录中查找’xcolors’文件. 需要注意的是, 每行所显示的数据含义依赖于其中 op 字段的<br>类型 (nt: 不同 op 所对应 args 含义不相同), 其格式遵循 NFS 协议, 追求简洁明了.</p>
<p>如果 tcpdump 的 - v 选项 (详细打印选项) 被设置, 附加的信息将被显示. 比如:<br>sushi.1372a &gt; wrl.nfs:<br>148 read fh 21,11&#x2F;12.195 8192 bytes @ 24576<br>wrl.nfs &gt; sushi.1372a:<br>reply ok 1472 read REG 100664 ids 417&#x2F;0 sz 29388</p>
<p>(-v 选项一般还会打印出 IP 头部的 TTL, ID， length, 以及 fragmentation 域, 但在此例中, 都略过了 (nt: 可理解为, 简洁起见, 做了删减))<br>在第一行, sushi 请求 wrl 从文件 21,11&#x2F;12.195(nt: 格式在上面有描述) 中, 自偏移 24576 字节处开始, 读取 8192 字节数据.<br>Wrl 回应读取成功; 由于第二行只是回应请求的开头片段, 所以只包含 1472 字节 (其他的数据将在接着的 reply 片段中到来, 但这些数据包不会再有 NFS<br>头, 甚至 UDP 头信息也为空 (nt: 源和目的应该要有), 这将导致这些片段不能满足过滤条件, 从而没有被打印). -v 选项除了显示文件数据信息, 还会显示<br>附加显示文件属性信息: file type(文件类型, ‘‘REG’’ 表示普通文件), file mode(文件存取模式, 8 进制表示的), uid 和 gid(nt: 文件属主和<br>组属主), file size (文件大小).</p>
<p>如果 - v 标志被多次重复给出 (nt: 如 - vv)， tcpdump 会显示更加详细的信息.</p>
<p>必须要注意的是, NFS 请求包中数据比较多, 如果 tcpdump 的 snaplen(nt: 抓取长度) 取太短将不能显示其详细信息. 可使用<br>‘-s 192’来增加 snaplen, 这可用以监测 NFS 应用的网络负载 (nt: traffic).</p>
<p>NFS 的回应包并不严格的紧随之前相应的请求包 (nt: RPC operation). 从而, tcpdump 会跟踪最近收到的一系列请求包, 再通过其<br>交换序号 (nt: transaction ID) 与相应请求包相匹配. 这可能产生一个问题， 如果回应包来得太迟, 超出 tcpdump 对相应请求包的跟踪范围,<br>该回应包将不能被分析.</p>
<h4 id="5-4-1-AFS-请求和回应"><a href="#5-4-1-AFS-请求和回应" class="headerlink" title="5.4.1. AFS 请求和回应"></a>5.4.1. AFS 请求和回应</h4><p>AFS(nt: Andrew 文件系统, Transarc , 未知, 需补充) 请求和回应有如下的答应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src.sport &gt; dst.dport: rx packet-type</span><br><span class="line">src.sport &gt; dst.dport: rx packet-type service call call-name args</span><br><span class="line">src.sport &gt; dst.dport: rx packet-type service reply call-name args</span><br><span class="line"></span><br><span class="line">elvis.7001 &gt; pike.afsfs:</span><br><span class="line">rx data fs call rename old fid 536876964/1/1 &quot;.newsrc.new&quot;</span><br><span class="line">new fid 536876964/1/1 &quot;.newsrc&quot;</span><br><span class="line">pike.afsfs &gt; elvis.7001: rx data fs reply rename</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在第一行, 主机 elvis 向 pike 发送了一个 RX 数据包.<br>这是一个对于文件服务的请求数据包 (nt: RX data packet, 发送数据包 , 可理解为发送包过去, 从而请求对方的服务), 这也是一个 RPC<br>调用的开始 (nt: RPC, remote procedure call). 此 RPC 请求 pike 执行 rename(nt: 重命名) 操作, 并指定了相关的参数:<br>原目录描述符为 536876964&#x2F;1&#x2F;1, 原文件名为 ‘.newsrc.new’, 新目录描述符为 536876964&#x2F;1&#x2F;1, 新文件名为 ‘.newsrc’.<br>主机 pike 对此 rename 操作的 RPC 请求作了回应 (回应表示 rename 操作成功, 因为回应的是包含数据内容的包而不是异常包).</p>
<p>一般来说, 所有的’AFS RPC’请求被显示时, 会被冠以一个名字 (nt: 即 decode, 解码), 这个名字往往就是 RPC 请求的操作名.<br>并且, 这些 RPC 请求的部分参数在显示时, 也会被冠以一个名字 (nt | rt: 即 decode, 解码, 一般来说也是取名也很直接, 比如,<br>一个 interesting 参数, 显示的时候就会直接是’interesting’, 含义拗口, 需再翻).</p>
<p>这种显示格式的设计初衷为’一看就懂’, 但对于不熟悉 AFS 和 RX 工作原理的人可能不是很<br>有用 (nt: 还是不用管, 书面吓吓你的, 往下看就行).</p>
<p>如果 -v(详细)标志被重复给出 (nt: 如 - vv), tcpdump 会打印出确认包(nt: 可理解为, 与应答包有区别的包) 以及附加头部信息<br>(nt: 可理解为, 所有包, 而不仅仅是确认包的附加头部信息), 比如, RX call ID(请求包中’请求调用’的 ID),<br>call number(‘请求调用’的编号), sequence number(nt: 包顺序号),<br>serial number(nt | rt: 可理解为与包中数据相关的另一个顺信号, 具体含义需补充), 请求包的标识. (nt: 接下来一段为重复描述,<br>所以略去了), 此外确认包中的 MTU 协商信息也会被打印出来 (nt: 确认包为相对于请求包的确认包, Maximum Transmission Unit, 最大传输单元).</p>
<p>如果 -v 选项被重复了三次 (nt: 如 - vvv), 那么 AFS 应用类型数据包的’安全索引’(‘security index’) 以及’服务索引’(‘service id’)将会<br>被打印.</p>
<p>对于表示异常的数据包 (nt: abort packet, 可理解为, 此包就是用来通知接受者某种异常已发生), tcpdump 会打印出错误号 (error codes).<br>但对于 Ubik beacon packets(nt: Ubik 灯塔指示包, Ubik 可理解为特殊的通信协议, beacon packets, 灯塔数据包, 可理解为指明通信中<br>关键信息的一些数据包), 错误号不会被打印, 因为对于 Ubik 协议, 异常数据包不是表示错误, 相反却是表示一种肯定应答 (nt: 即, yes vote).</p>
<p>AFS 请求数据量大, 参数也多, 所以要求 tcpdump 的 snaplen 比较大, 一般可通过启动 tcpdump 时设置选项’-s 256’ 来增大 snaplen, 以<br>监测 AFS 应用通信负载.</p>
<p>AFS 回应包并不显示标识 RPC 属于何种远程调用. 从而, tcpdump 会跟踪最近一段时间内的请求包, 并通过 call number(调用编号), service ID<br>(服务索引) 来匹配收到的回应包. 如果回应包不是针对最近一段时间内的请求包, tcpdump 将无法解析该包.</p>
<h3 id="5-5-KIP-AppleTalk-协议"><a href="#5-5-KIP-AppleTalk-协议" class="headerlink" title="5.5. KIP AppleTalk 协议"></a>5.5. KIP AppleTalk 协议</h3><p>(nt | rt: DDP in UDP 可理解为, DDP, The AppleTalk Data Delivery Protocol,<br>相当于支持 KIP AppleTalk 协议栈的网络层协议, 而 DDP 本身又是通过 UDP 来传输的,<br>即在 UDP 上实现的用于其他网络的网络层，KIP AppleTalk 是苹果公司开发的整套网络协议栈).</p>
<p>AppleTalk DDP 数据包被封装在 UDP 数据包中, 其解封装 (nt: 相当于解码) 和相应信息的转储也遵循 DDP 包规则.<br>(nt:encapsulate, 封装, 相当于编码, de-encapsulate, 解封装, 相当于解码, dump, 转储, 通常就是指对其信息进行打印).</p>
<p>&#x2F;etc&#x2F;atalk.names 文件中包含了 AppleTalk 网络和节点的数字标识到名称的对应关系. 其文件格式通常如下所示:<br>number name</p>
<p>1.254 ether<br>16.1 icsd-net<br>1.254.110 ace</p>
<p>头两行表示有两个 AppleTalk 网络. 第三行给出了特定网络上的主机 (一个主机会用 3 个字节来标识,<br>而一个网络的标识通常只有两个字节, 这也是两者标识的主要区别)(nt: 1.254.110 可理解为 ether 网络上的 ace 主机).<br>标识与其对应的名字之间必须要用空白分开. 除了以上内容, &#x2F;etc&#x2F;atalk.names 中还包含空行以及注释行 (以’#’开始的行).</p>
<p>AppleTalk 完整网络地址将以如下格式显示:<br>net.host.port</p>
<p>以下为一段具体显示:<br>144.1.209.2 &gt; icsd-net.112.220<br>office.2 &gt; icsd-net.112.220<br>jssmag.149.235 &gt; icsd-net.2</p>
<p>(如果 &#x2F; etc&#x2F;atalk.names 文件不存在, 或者没有相应 AppleTalk 主机 &#x2F; 网络的条目, 数据包的网络地址将以数字形式显示).</p>
<p>在第一行中, 网络 144.1 上的节点 209 通过 2 端口, 向网络 icsd-net 上监听在 220 端口的 112 节点发送了一个 NBP 应用数据包<br>(nt | rt: NBP, name binding protocol, 名称绑定协议, 从数据来看, NBP 服务器会在端口 2 提供此服务.<br>‘DDP port 2’ 可理解为’DDP 对应传输层的端口 2’, DDP 本身没有端口的概念, 这点未确定, 需补充).</p>
<p>第二行与第一行类似, 只是源的全部地址可用’office’进行标识.<br>第三行表示: jssmag 网络上的 149 节点通过 235 向 icsd-net 网络上的所有节点的 2 端口 (NBP 端口) 发送了数据包.(需要注意的是,<br>在 AppleTalk 网络中如果地址中没有节点, 则表示广播地址, 从而节点标识和网络标识最好在 &#x2F; etc&#x2F;atalk.names 有所区别.<br>nt: 否则一个标识 x.port 无法确定 x 是指一个网络上所有主机的 port 口还是指定主机 x 的 port 口).</p>
<p>tcpdump 可解析 NBP (名称绑定协议) and ATP (AppleTalk 传输协议) 数据包, 对于其他应用层的协议, 只会打印出相应协议名字 (<br>如果此协议没有注册一个通用名字, 只会打印其协议号) 以及数据包的大小.</p>
<p>NBP 数据包会按照如下格式显示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot;</span><br><span class="line">jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;RM1140:LaserWriter@*&quot; 250</span><br><span class="line">techpit.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;techpit:LaserWriter@*&quot; 186</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行表示: 网络 icsd-net 中的节点 112 通过 220 端口向网络 jssmag 中所有节点的端口 2 发送了对’LaserWriter’的名称查询请求 (nt:<br>此处名称可理解为一个资源的名称, 比如打印机). 此查询请求的序列号为 190.</p>
<p>第二行表示: 网络 jssmag 中的节点 209 通过 2 端口向 icsd-net.112 节点的端口 220 进行了回应: 我有’LaserWriter’资源, 其资源名称<br>为’RM1140’, 并且在端口 250 上提供改资源的服务. 此回应的序列号为 190, 对应之前查询的序列号.</p>
<p>第三行也是对第一行请求的回应: 节点 techpit 通过 2 端口向 icsd-net.112 节点的端口 220 进行了回应: 我有’LaserWriter’资源, 其资源名称<br>为’techpit’, 并且在端口 186 上提供改资源的服务. 此回应的序列号为 190, 对应之前查询的序列号.</p>
<p>ATP 数据包的显示格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jssmag.209.165 &gt; helios.132: atp-req 12266&lt;0-7&gt; 0xae030001</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000</span><br><span class="line">jssmag.209.165 &gt; helios.132: atp-req 12266&lt;3,5&gt; 0xae030001</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000</span><br><span class="line">helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000</span><br><span class="line">jssmag.209.165 &gt; helios.132: atp-rel 12266&lt;0-7&gt; 0xae030001</span><br><span class="line">jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行表示节点 Jssmag.209 向节点 helios 发送了一个会话编号为 12266 的请求包, 请求 helios<br>回应 8 个数据包 (这 8 个数据包的顺序号为 0-7(nt: 顺序号与会话编号不同, 后者为一次完整传输的编号,<br>前者为该传输中每个数据包的编号. transaction, 会话, 通常也被叫做传输)). 行尾的 16 进制数字表示<br>该请求包中’userdata’域的值 (nt: 从下文来看, 这并没有把所有用户数据都打印出来).</p>
<p>Helios 回应了 8 个 512 字节的数据包. 跟在会话编号 (nt: 12266) 后的数字表示该数据包在该会话中的顺序号.<br>括号中的数字表示该数据包中数据的大小, 这不包括 atp 的头部. 在顺序号为 7 数据包 (第 8 行) 外带了一个’*’号,<br>表示该数据包的 EOM 标志被设置了.(nt: EOM, End Of Media, 可理解为, 表示一次会话的数据回应完毕).</p>
<p>接下来的第 9 行表示, Jssmag.209 又向 helios 提出了请求: 顺序号为 3 以及 5 的数据包请重新传送. Helios 收到这个<br>请求后重新发送了这个两个数据包, jssmag.209 再次收到这两个数据包之后, 主动结束 (release) 了此会话.</p>
<p>在最后一行, jssmag.209 向 helios 发送了开始下一次会话的请求包. 请求包中的’*’表示该包的 XO 标志没有被设置.<br>(nt: XO, exactly once, 可理解为在该会话中, 数据包在接受方只被精确地处理一次, 就算对方重复传送了该数据包,<br>接收方也只会处理一次, 这需要用到特别设计的数据包接收和处理机制).</p>
<h3 id="5-6-IP-数据包破碎"><a href="#5-6-IP-数据包破碎" class="headerlink" title="5.6. IP 数据包破碎"></a>5.6. IP 数据包破碎</h3><p>(nt: 指把一个 IP 数据包分成多个 IP 数据包)</p>
<p>碎片 IP 数据包 (nt: 即一个大的 IP 数据包破碎后生成的小 IP 数据包) 有如下两种显示格式.<br>(frag id:size@offset+)<br>(frag id:size@offset)<br>(第一种格式表示, 此碎片之后还有后续碎片. 第二种格式表示, 此碎片为最后一个碎片.)</p>
<p>id 表示破碎编号 (nt: 从下文来看, 会为每个要破碎的大 IP 包分配一个破碎编号, 以便区分每个小碎片是否由同一数据包破碎而来).<br>size 表示此碎片的大小 , 不包含碎片头部数据. offset 表示此碎片所含数据在原始整个 IP 包中的偏移 ((nt: 从下文来看,<br>一个 IP 数据包是作为一个整体被破碎的, 包括头和数据, 而不只是数据被分割).</p>
<p>每个碎片都会使 tcpdump 产生相应的输出打印. 第一个碎片包含了高层协议的头数据 (nt: 从下文来看, 被破碎 IP 数据包中相应 tcp 头以及<br>IP 头都放在了第一个碎片中 ), 从而 tcpdump 会针对第一个碎片显示这些信息, 并接着显示此碎片本身的信息. 其后的一些碎片并不包含<br>高层协议头信息, 从而只会在显示源和目的之后显示碎片本身的信息. 以下有一个例子: 这是一个从 arizona.edu 到 lbl-rtsg.arpa<br>途经 CSNET 网络 (nt: CSNET connection 可理解为建立在 CSNET 网络上的连接) 的 ftp 应用通信片段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)</span><br><span class="line">arizona &gt; rtsg: (frag 595a:204@328)</span><br><span class="line">rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有几点值得注意:<br>第一, 第二行的打印中, 地址后面没有端口号.<br>这是因为 TCP 协议信息都放到了第一个碎片中, 当显示第二个碎片时, 我们无法知道此碎片所对应 TCP 包的顺序号.</p>
<p>第二, 从第一行的信息中, 可以发现 arizona 需要向 rtsg 发送 308 字节的用户数据, 而事实是, 相应 IP 包经破碎后会总共产生 512 字节<br>数据 (第一个碎片包含 308 字节的数据, 第二个碎片包含 204 个字节的数据, 这超过了 308 字节). 如果你在查找数据包的顺序号空间中的<br>一些空洞 (nt: hole, 空洞, 指数据包之间的顺序号没有上下衔接上), 512 这个数据就足够使你迷茫一阵 (nt: 其实只要关注 308 就行,<br>不必关注破碎后的数据总量).</p>
<p>一个数据包 (nt | rt: 指 IP 数据包) 如果带有非 IP 破碎标志, 则显示时会在最后显示’(DF)’.(nt: 意味着此 IP 包没有被破碎过).</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">转自</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/')">tcpdump 使用与数据分析</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=tcpdump 使用与数据分析&amp;url=https://shippomx.github.io/2021/05/14/kidgets/tcpdump%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/kidgets/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>kidgets<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/20/containers/Kata%20Containers%202.0%20%E4%BB%8B%E7%BB%8D/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kata Containers 2.0</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/17/containers/%E6%8B%89%E5%8F%96%20google%20kubernetes%20%E9%95%9C%E5%83%8F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用镜像仓库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2021/09/11/kidgets/jq%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="jq命令详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-09-11</div><div class="title">jq命令详解</div></div></a></div><div><a href="/2019/12/20/kidgets/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/" title="后端架构师傅技术图谱"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2019-12-20</div><div class="title">后端架构师傅技术图谱</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">tcpdump 使用与数据分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.</span> <span class="toc-text">文章目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">一. 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%80%89%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">二. 选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">三. 实用命令实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.</span> <span class="toc-text">3.1. 默认启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%9B%91%E8%A7%86%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.2.</span> <span class="toc-text">3.2. 监视指定网络接口的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%9B%91%E8%A7%86%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.3.</span> <span class="toc-text">3.3. 监视指定主机的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%89%93%E5%8D%B0-helios-%E4%B8%8E-hot-%E6%88%96%E8%80%85%E4%B8%8E-ace-%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.4.</span> <span class="toc-text">3.4. 打印 helios 与 hot 或者与 ace 之间通信的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%88%AA%E8%8E%B7%E4%B8%BB%E6%9C%BA-210-27-48-1-%E5%92%8C%E4%B8%BB%E6%9C%BA-210-27-48-2-%E6%88%96-210-27-48-3-%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">4.5.</span> <span class="toc-text">3.5. 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%89%93%E5%8D%B0-ace-%E4%B8%8E%E4%BB%BB%E4%BD%95%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84-IP-%E6%95%B0%E6%8D%AE%E5%8C%85-%E4%BD%86%E4%B8%8D%E5%8C%85%E6%8B%AC%E4%B8%8E-helios-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.6.</span> <span class="toc-text">3.6. 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%88%AA%E8%8E%B7%E4%B8%BB%E6%9C%BA-hostname-%E5%8F%91%E9%80%81%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">4.7.</span> <span class="toc-text">3.7. 截获主机 hostname 发送的所有数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E7%9B%91%E8%A7%86%E6%89%80%E6%9C%89%E9%80%81%E5%88%B0%E4%B8%BB%E6%9C%BA-hostname-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.8.</span> <span class="toc-text">3.8. 监视所有送到主机 hostname 的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E7%9B%91%E8%A7%86%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.9.</span> <span class="toc-text">3.9. 监视指定主机和端口的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E7%9B%91%E8%A7%86%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.10.</span> <span class="toc-text">3.10. 监视指定网络的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E7%9B%91%E8%A7%86%E6%8C%87%E5%AE%9A%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.11.</span> <span class="toc-text">3.11. 监视指定协议的数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-tcpdump-%E4%B8%8E-wireshark"><span class="toc-number">5.</span> <span class="toc-text">四. tcpdump 与 wireshark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BD%BF%E7%94%A8-tcpdump-%E6%8A%93%E5%8F%96-HTTP-%E5%8C%85"><span class="toc-number">5.1.</span> <span class="toc-text">4.1. 使用 tcpdump 抓取 HTTP 包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89"><span class="toc-number">6.</span> <span class="toc-text">五. 输出信息含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-ARP-x2F-RARP-%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.1.</span> <span class="toc-text">5.1. ARP&#x2F;RARP 数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-TCP-%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.2.</span> <span class="toc-text">5.2. TCP 数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-UDP-%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.3.</span> <span class="toc-text">5.3. UDP 数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-UDP-%E5%90%8D%E7%A7%B0%E6%9C%8D%E5%8A%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1. UDP 名称服务请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-UDP-%E5%90%8D%E7%A7%B0%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%AD%94"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2. UDP 名称服务应答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-NFS-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%9B%9E%E5%BA%94"><span class="toc-number">6.4.</span> <span class="toc-text">5.4. NFS 请求和回应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-AFS-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%9B%9E%E5%BA%94"><span class="toc-number">6.4.1.</span> <span class="toc-text">5.4.1. AFS 请求和回应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-KIP-AppleTalk-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.5.</span> <span class="toc-text">5.5. KIP AppleTalk 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-IP-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%A0%B4%E7%A2%8E"><span class="toc-number">6.6.</span> <span class="toc-text">5.6. IP 数据包破碎</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/22/tcpdump%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="无题">无题</a><time datetime="2023-12-22T03:37:22.140Z" title="发表于 2023-12-22 11:37:22">2023-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/" title="加权轮询算法">加权轮询算法</a><time datetime="2023-12-10T05:29:00.000Z" title="发表于 2023-12-10 13:29:00">2023-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/IEEE%20802.1Q%20%E5%B0%81%E8%A3%85%E7%9A%84%20VLAN%20%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F%20/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/Linux%20%E4%B8%8B%20Pcap%20%E5%8C%85%E9%87%8D%E6%94%BE%E5%B7%A5%E5%85%B7%20Tcpreplay%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/OpenFlow%20%E6%B5%81%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>23</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>