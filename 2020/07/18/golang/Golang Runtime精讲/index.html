<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>go runtime 精讲 | 远辰</title><meta name="keywords" content="go"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="go runtime 精讲"><meta name="application-name" content="go runtime 精讲"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="go runtime 精讲"><meta property="og:url" content="https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="[TOC] 0 介绍本文主要内容如下:  Golang Runtime 是个什么? Golang Runtime 的发展历程, 每个版本的改进 Go 调度: 协程结构体, 上下文切换, 调度队列, 大致调度流程, 同步执行流又不阻塞线程的网络实现等 Go 内存: 内存结构, mspan 结构, 全景"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="[TOC] 0 介绍本文主要内容如下:  Golang Runtime 是个什么? Golang Runtime 的发展历程, 每个版本的改进 Go 调度: 协程结构体, 上下文切换, 调度队列, 大致调度流程, 同步执行流又不阻塞线程的网络实现等 Go 内存: 内存结构, mspan 结构, 全景"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: 'go runtime 精讲',
  postAI: '',
  pageFillDescription: '0 介绍, 1 序, 1.1 为什么去了解 runtime 呢?, 2 Runtime 简介及发展, 2.1 Runtime 简介, 3调度, 3.1调度简述, 3.2 goroutine 实现, 3.3 协程结构体和切换函数, 3.4 GM 模型及 GPM 模型, 3.5 协程状态及流转, 3.6 go routine调度, 3.7 sysmon 协程, 3.8 协作式抢占, 3.9 同步执行流不阻塞线程的网络的实现, 3.10 调度相关结构体, 3.11 调度总结, 3.12 未涉及到的点, 4 内存分配, 4.1 内存分配简介, 4.2 内存空间结构, 4.3 span 机制, 4.4 内存分配全景, 4.5 几种特殊的分配器, 4.6 内存分配总结, 5 GC, 5.1 Golang GC 简述, 5.2 GC 简介, 5.3  GC相关术语, 5.4  GC关心什么？, 5.5  Golang GC 发展, 5.5 三色标记, 5.5.1 写屏障, 5.5.2 三色状态, 5.5.3 扫描和元信息, 5.6 GC 流程, 5.7 Golang GC Pacer, 5.8 未涉及到的点, 6 实践与总结, 6.1 观察调度, 6.2 观察 GC, 6.3 优化, 6.4 问题排查的一点思路, 6.5 一次有意思的问题排查, 7 Runtime 的一点个人总结, 参考文档介绍本文主要内容如下是个什么的发展历程每个版本的改进调度协程结构体上下文切换调度队列大致调度流程同步执行流又不阻塞线程的网络实现等内存内存结构结构全景图及分配策略等停顿大致的一个发展历程三色标记实现的一些细节写屏障三色状态扫描及元信息版本相对版本的改进点等实践观察调度信息一些优化的方式几点问题排查的思路几个有意思的问题排查总结贯穿的思想总结序运行时到底是个什么东西的调度为什么说是轻量的调度都发生了啥的网络和锁会不会阻塞线程什么时候会阻塞线程的对象在内存中是怎样的的内存分配是怎样的栈的内存是怎么分配的是怎样的怎么帮我们回收对象的会不会漏掉对象或者回收还在用的对象什么时候开始啥时候结束会不会太慢跟不上内存分配的速度会不会暂停我们的应用暂停多久影不影响我的请求为什么去了解呢可以解决一些棘手的问题在写这个的时候就有一位朋友在群里发了个图说同事写的代码有问题利用率很高找不出来问题在哪我看了下图说让他找找是不是有这样用的一查的确是的平时也帮同事解决了一些和并发调度有关的问题好奇心大家写久了惊叹于它的简洁高性能外必然对它是怎么实现的有很多好奇协程怎么实现怎么能并发对象在内存里是怎么存在的等等技术深度的一种简介及发展简介是语言运行所需要的基础设施的代码在的目录下主要有所述的块功能协程调度内存分配操作系统及相关的操作的封装信号处理系统调用寄存器操作原子操作等检测的支持等内置类型及反射的实现特点与不同并没有虚拟机的概念也直接被编译成的与用户代码一起打包在一个可执行文件中用户代码与代码在执行的时候并没有明显的界限都是函数调用对系统调用的指令进行了封装可不依赖于一些的关键字被编译器编译成包下的函数关键字函数调度调度简述模型调度模型调度在计算机中是分配工作所需资源的方法的调度为找到可运行的线程而的调度是为线程找到内存执行票据和可运行的轻量级协程栈初始调度不涉及系统调用用户函数调用前会检查栈空间是否足够不够的话会进行栈扩容用户代码中的协程同步造成的阻塞仅仅是切换协程而不阻塞线程网络操作封装了为模式未切换协程不阻塞线程每个均有大多数时间仅与无锁交互实现用户协程无优先级基本遵循支持协作的抢占调度还不支持非协作的抢占调度实现一种不断共享不断减少切换成本实现有栈协程代表协程这种执行流的结构体保护和恢复上下文的函数运行队列编译器将关键字编译为生成一个协程结构体并放入运行队列解决网络阻塞问题协程级别的同步结构调度我们去看调度的一个进化从进程到线程再到协程其实是一个不断共享不断减少切换成本的过程实现的协程为有栈协程协程的用法和线程的用法基本类似很多人会疑问协程到底是个什么东西用户态的调度感觉很陌生很抽象到底是个什么东西我觉得要理解调度要理解两个概念运行和阻塞特别是在协程中这两个概念不容易被正确理解我们理解概念时往往会代入自身感受觉得线程或协程运行就是像我们吭哧吭哧的处理事情线程或协程阻塞就是做事情时我们需要等待其他人然后就在这等着了要是其他人搞好了那我们就继续做当前的事下的线程其实是结构线程其实并不是真正运行的实体线程只是代表一个执行流和其状态真正运行驱动流程往前的其实是在时钟的驱动下根据寄存器从程序中取指令和操作数从中取数据进行计算处理跳转驱动执行流往前并不关注处理的是线程还是协程只需要设置寄存器设置栈指针等这些称为上下文那么就可以欢快的运行这个线程或者这个协程了线程的运行其实是被运行其阻塞其实是切换出调度队列不再去调度执行这个执行流其他执行流满足其条件便会把被移出调度队列的执行流重新放回调度队列协程同理协程其实也是一个数据结构记录了要运行什么函数运行到哪里了在用户态实现调度所以要有代表协程这种执行流的结构体也要有保存和恢复上下文的函数运行队列理解了阻塞的真正含义也就知道能够比较容易理解为什么的锁这些不阻塞线程对于实现的同步执行流效果又不阻塞线程的网络接下来也会介绍协程结构体和切换函数我们一个时一般这样写一个协程代表了一个执行流执行流有需要执行的函数对应上面的有函数的入参有当前执行流的状态和进度对应的寄存器和寄存器当然也需要有保存状态的地方用于执行流恢复真正代表协程的是结构体每个都会编译成函数最终有一个对象放入调度队列上面的函数的指针设置在的字段参数会在函数里拷贝到中用于保存协程切换时的位置和栈位置协程切换出去和恢复回来需要保存上下文恢复上下文这些由以下两个汇编函数实现以上就能实现协程这种执行流并能进行切换和恢复下图中的和函数都做了精简模型及模型有了协程的这种执行流形式那待运行的协程放在哪呢在的时候调度队列是全局的对该队列的操作均需要竞争同一把锁导致伸缩性不好新生成的协程也会放入全局的队列大概率是被其他可以理解为底层线程的一个表示运行了内存亲和性不好当前协程新生成了协程然后协程比较大概率会结束或者阻塞这样直接去执行协程内存的亲和性也会好很多因为与绑定在一些应用中比如文件操作或其他可能会阻塞线程的系统调用比较多的个数可能会远超过活跃的个数导致比较大的内存浪费那是不是可以给分配一个队列把阻塞的的给执行代码的使用及以后就是这样做的在中调度模型更改为模型引入逻辑的概念表示执行代码所需要的资源同时也是执行代码的最大的并行度这个概念可能很多人不知道怎么理解涉及到几点队列和还有的个数的选取首先为什么把全局队列打散以及为什么跟随这个在模型那一页就讲的比较清楚了然后为什么的个数默认是核数尽量提升性能那么在一个核机器上如何能够最大利用性能呢当然是同时有个线程在并行运行中把喂饱即所有核上一直都有代码在运行在里面一个协程运行到阻塞系统调用那么这个协程和运行它的线程自然是不再需要的也不需要分配层面的内存只有一直在并行运行的代码才需要这些资源即同时有个协程在并行执行那么就能最大的利用这个时候需要的的个数就是核数注意并行和并发的区别协程状态及流转协程的状态其实和线程状态类似状态转换和发生状态转换的时机如图所示还是需要注意协程只是一个执行流并不是运行实体调度并没有一个一直在运行调度的调度器实体当一个协程切换出去或新生成的的运行时从中恢复等情况时那么接下来就需要发生调度的调度是通过线程执行函数来完成的协程在内核中有一些执行定时任务的线程比如定时写回脏页的定期回收内存的以及每个上都有一个负责负载均衡的线程等在运行时中也有类似的协程功能比较多定时从中获取的协程进行抢占定时打印调度信息归还内存等定时任务协作式抢占调用将被抢占的的设为被设置抢占标记的进行下一次函数调用时检查栈空间失败进而触发汇编代码位于中然后进行一连串的函数调用主要的调用过程如下汇编代码还没有实现非协作的抢占基本流程是协程标记某个协程运行过久需要切换出去该协程在运行函数时会检查栈标记然后进行切换同步执行流不阻塞线程的网络的实现写后台最舒服的就是能够以同步写代码的方式操作网络但是网络操作不阻塞线程主要是结合了非阻塞的以及协程的切换和恢复提供了网络的非阻塞模式对于没有的非阻塞执行网络操作时内核不阻塞线程会直接返回这个时候将协程状态设置为然后去调度其他协程在初始化一个网络的时候就会把这个使用加入到全局的节点中同时放入中的还有的指针在中函数中中等情况下会执行调用系统调用把的网络事件从中取出来每个网络事件可以通过前面传入的获取到阻塞在其上的协程以此恢复协程为调度相关结构体调度总结轻量级的协程栈初始调度不涉及系统调用调度在计算机中是分配工作所需资源的方法的调度为找到可运行的线程而的调度是为线程找到内存执行票据和可运行的用户函数调用前会检查栈空间是否足够不够的话会进行栈扩容最大栈超出用户代码中的协程同步造成的阻塞仅仅是切换协程而不阻塞线程和仍结合去寻找新的可执行的每个均有大多数时间仅与无锁交互新生成的放入到中调度时会随机从全局取然后均没有的话从其他中取对于运行过久的设置抢占标识对于过久的进行和的分离防止被占用过久影响调度封装了网络会设置成模式网络的操作会以模式操作返回则当前协程在调度中等阶段均会出的协程进行运行或者添加到全局中目前还不支持非协作的抢占调度在密集运算时可能会导致调度延迟官方已在解决未涉及到的点状态流转具体调度流程栈扩容合作式抢占状态流转的与内存分配内存分配简介类似于的结构使用机制来减少碎片每个至少为一个页中的一个为每一种用于一个范围的内存分配需求比如使用分配的使用分配的一共有个范围每个有两种类型和表示分配的对象是否会包含指针多层次来减少分配的冲突无锁的全局个对应不同的的后备全局个的中以的结构维护空闲连续归还内存到时连续地址会进行合并分配也是多层次和多的对象由进行回收会定时把空余的内存归还给操作系统的分配采用了类似的结构特点使用一小块一小块的连续内存页进行分配某个范围大小的内存需求比如某个连续专门用于分配字节以此减少内存碎片线程拥有一定的可用于无锁分配同时对于后回收的内存页并不是马上归还给操作系统而是会延迟归还用于满足未来的内存需求内存空间结构在以前的堆地址空间是线性连续扩展的比如在中最大可扩展到因为在的时候会根据拿到的指针地址来判断是否位于的的以及找到其对应的其判断机制需要是连续的但是连续扩展有个问题中的代码尤其是位系统上可能会占用未来会用于的内存这样在扩展时出现不连续的地址导致运行时在中改用了稀疏索引的方式来管理整体的内存可以超过内存也可以允许内存空间扩展时不连续在全局的中有个二阶数组在上一阶只有一个二阶有个每个指向一个结构每个结构可以管理内存所以在新的版本中可以管理内存即目前位机器中的寻址总线全部内存机制前面提到了的内存分配类似于采用了机制来减少内存碎片每个管理整数倍的内存用于分配一定范围的内存需求内存分配全景多层次的分配每个上有一个会为每个最多缓存一个用于无锁分配全局每个的都有一个锁的粒度相对于全局的小很多每个可以看成是每个的的一个全局后备在完成后会把中的都到中用于清扫后再分配有需要时从对应的获取获取不到再上升到全局的几种特殊的分配器对于很小的对象分配做了个优化把小对象合并以移动指针的方式分配对于栈内存有分配也有多个层次的分配同时也有多个不同用于分配的内存也是位于用管理不过这个的状态和用于分配对象的状态不太一样为我们可以思考一个问题的对象是分配在中并由这些结构管理那么这些结构又是哪里管理和分配的呢肯定不是自己管理自己这些都是由特殊的分配分配的每种类型有一个大致原理就是通过从进程空间获取一小块内存百的样子然后用来分配这个固定大小的结构内存分配总结类似于的结构使用机制来减少碎片每个至少为一个页中的一个为每一种用于一个范围的内存分配需求比如使用分配的使用分配的一共有个范围每个有两种类型和表示分配的对象是否会包含指针多阶来减少分配的冲突无锁的对应不同的全局全局的代码分配内存优先从当前的对应的中获取有的话再从对应的中获取一个还没有的话从中一个不出来则从中空闲块找到对应大小的内存中如果还没有则从系统申请内存从无锁到全局粒度的锁再到全局锁再到系统调用的分配也是多层次和多的减少分配的锁争抢减少栈浪费中以的结构维护空闲连续归还内存到时连续地址会进行合并之前采用类似伙伴系统维护的连续维护的连续对象由进行释放会定时把空余的内存归还给操作系统未涉及的点和具体流程逃逸分析简述是一种自动内存管理方式三大基础算法这三个基础算法时需要一直算法是一个综合的考虑程序吞吐量吞吐量时间的频率压缩分配性能并发伸缩调优复杂度等等当前特征三色标记并发标记和清扫非分代非紧缩混合写屏障之后的是基于三色标记法的并发标记清扫算法生产上基本没什么问题之后中调整最多的就是的部分之后的可以比较稳定在的并不是完美的简介对象是否存活是由整体应用其他部分是否对其有引用决定的是一个全局性的信息而手动管理内存只能由开发人员根据当前上下文的局部信息来判断是一种自动管理内存的方式支持的语言无需手动管理内存程序后台自动判断对象是否存活并回收其内存空间使开发人员从内存管理上解脱出来年由发明用于简化中的手动内存管理到现在很多语言都提供了不过的原理和基本算法都没有太大的改变哪些语言提供基本上年代后的语言都提供等大多数函数式编程语言等动态类型语言等面向对象语言并不是个新事物使得大放光彩的是语言调用者需要自己并负责释放注意对象被回收时间即发生时间是不可知的垃圾回收不是析构函数垃圾回收只与内存有关不会回收连接资源文件资源时自动调用对象的某个方法来关闭一些资源是否可行相关术语并发和并行通常在领域中并发收集器则指垃圾回收的同时应用程序也在执行并行收集器指垃圾回收采取多个线程利用多个一起进行不过一般我们说并发回收器就包含了这两层意思安全点是收集器能够识别出线程执行栈上的所有引用的一点或一段时间某些垃圾回收算法或者某个阶段进行时需要将应用程序完全暂停准确式和保守式准确式或指能够知道一块内存区域是引用还是非引用如一个位的区域可以是一个整形数字也可以是一个对象引用当一个对象进行执行时需要修改指向这个内存的引用的指非准确式也就是保守式不能完成这个任务从对象开始扫描标记出其引用的对象及这些对象引用的对象如此循环标记所有可达的对象清除阶段扫描堆区域回收在标记阶段标记为的对象通常通过空闲链表的方式需要的工作量和堆大小成正比压缩的方式是将存活对象移动到一起来获得一段连续的空闲空间也叫做重定位这样需要将所有对象的引用指向新的位置工作量和存活对象量成正比复制算法将所有存活对象从一个区域移动到一个区域然后回收区域之后和交换角色由于和是对等的所以需要两块大小相同的区域而同一时间只能利用其中一块来存放对象工作量和存活对象量成正比关心什么程序吞吐量回收算法会在多大程度上拖慢程序可以通过占用的与其他时间的百分比描述吞吐量在给定的时间内回收器可以回收多少垃圾堆内存开销回收器最少需要多少额外的内存开销停顿时间回收器会造成多大的停顿停顿频率回收器造成的停顿频率是怎样的停顿分布停顿有时候很长有时候很短还是选择长一点但保持一致的停顿时间分配性能新内存的分配是快慢还是无法预测压缩当堆内存里还有小块碎片化的内存可用时回收器是否仍然抛出内存不足的错误如果不是那么你是否发现程序越来越慢并最终死掉尽管仍然还有足够的内存可用并发回收器是如何利用多核机器的伸缩当堆内存变大时回收器该如何工作调优回收器的默认使用或在进行调优时它的配置有多复杂预热时间回收算法是否会根据已发生的行为进行自我调节如果是需要多长时间页释放回收算法会把未使用的内存释放回给操作系统吗如果会会在什么时候发生发展早期版本可能问题比较多但每一个版本的发布都伴随着的改进版本之后的已经能满足大部分大部分生产环境使用要求通过使得降到了下面列出一些方面比较重大的改动版本发布时间时间见备注数据百几百级别并行百级别三色标记法并发标记清除级别整体来说用起来是很舒心的几乎不用你关心三色标记采用的是并发三色标记清除法图展示的是一个简单的原理有几个问题可以思考一下并发情况下会不会漏标记对象对象的三色状态存放在哪如何根据一个对象来找到它引用的对象写屏障最基本的就是正确性不漏标记对象程序还在用的对象都被清除了那程序就错误了有一点浮动垃圾是允许的在并发情况下如果没有一些措施来保障那可能会有什么问题呢看左边的代码和图示第步标记完对象又没有引用对象那变成黑色对象在第步的时候程序运行把对象从转到了第步继续标记扫描此时没有引用对象变成了黑色对象我们会发现对象被漏标记了如何解决这个问题使用了写屏障这里的写屏障是指由编译器生成的一小段代码在时对指针操作前执行的一小段代码和中维护内存一致性的写屏障不太一样哈所以有了写屏障后第步时会把加入写屏障最终还是会被扫描的这里感受一下写屏障具体生成的代码我们可以看到在写入指针时对写屏障是否开启做了判断如果开启了会跳转到写屏障函数执行加入写屏障的逻辑中写屏障由写屏障改成了混合式写屏障使得停顿达到了以下三色状态并没有这样一个集合把不同状态对象放到对应集合中只是一个逻辑上的意义扫描和元信息拿到一个指针如何把这个指针指向的对象其引用的子对象都加到扫描队列呢而且还允许内部指针似乎更麻烦了我们分析一下要知道对象引用的子对象从对象开始到对象结尾把对象那一块内存上是指针的放到扫描队列就好了那我们是不是得知道对象有多大从哪开始到哪结束同时要知道内存上的个字节哪里是指针哪里是普通的数据首先的对象是管理的我们如果能知道对象属于哪个就知道对象多大从哪开始到哪结束了前面我们讲到了结构可以通过指针加上一定得偏移量就知道属于哪个块再通过对求余结合数组即可知道属于哪个了结合的和每个字节在中的偏移就可知道对象每个字节是指针还是普通数据这里的是在分配对象时根据信息就设置了信息来源于编译器生成流程和的大致流程相同上图是官方的里的图下图是我根据源码绘制的从最坏可能会有百的停顿到能够稳定在以下这之间做了很多改进右边是我根据官方整理的一些比较重要的改进的分布式检测将栈收缩放到了并发扫描阶段的混合写屏障更改了检测算法移除出等等大家对并发除了怎么保证不漏指针有疑问外可能还会疑问并发如何保证能够跟得上应用程序的分配速度会不会分配太快了完全跟不上然后这个就是的作用的是一种比例下一次结束时的堆大小和上一次存活堆大小成比例由控制默认即倍的关系就是倍以此类推假如上一次完成时存活对象默认那么下次会在比较接近但小于的时候比如开始争取在堆大小达到的时候结束这之间留有一定的裕度会计算待扫描对象大小根据历史数据计算与可分配的裕度的比例应用程序分配内存根据该比例进行辅助如果应用程序分配太快了导致不够那么会被阻塞直到后台的跟上来了该比例会随着进行不断调整结束后会根据这一次的情况来进行负反馈计算计算下一次开始的阈值如何保证按时完成呢完了后所有的都需要类似于的比例从结束到下一次开始之间有一定的堆分配裕度会根据还有多少的内存需要清扫来计算分配内存时需要清扫的数这样的一个比例未涉及到的点栈分配逃逸分析内存归还清扫与辅助清扫任务分配辅助标记流程计算计算实践与总结观察调度通过来开启一个进程加上观察其状态加上观察更详细信息用来调用输出观察一下调度加一些请求我们可以看到虽然有个连接但是只用了几个线程就能处理了表明的网络的确是由管理的表示的是全局队列待运行协程数量后面的数字表示每个上的待运行协程数可以看到待处理的任务并没有增加表示虽然请求很多但完全能住同时可以看到不同上有的时候可能任务不均衡但是一会后任务又均衡了表示的是有效的观察其中一些数据的含义在分享的时候没有怎么解释不过网上的解释几乎没有能完全解释正确我这里敲一下其实一般关注堆大小和两个的即可第次在程序运行的第所有消耗的历史累计比例所以其实这个数据没太大意义第一个的并发的第二个的第一个消耗的时间用户程序辅助扫描消耗的时间分配用于的消耗的时间空闲的用于的时间第个的时间开始时的堆大小结束的堆大小结束时的存活堆大小本次预计结束的堆大小个优化个人建议没事不要总想着优化好好就好一些优化写业务时用不到就算了涉及文件较多的程序可以将增大几个协程池的重要性远没有中线程池那么重要协程的生成不涉及系统调用需要的栈资源也很少同时和全局都做了的缓存协程池实现的不好反而因为协程池里的一把锁影响了扩展性至于并发控制保护其他资源可以选用其他方式什么时候需要协程池主要还是隔离减少栈扩容和缩容有些场景下栈扩容和缩容消耗可结合查看的确比较多比如长连接大量维持连接的协程可以不用扩容栈复杂任务交给任务协程处理此类协程的数量比较少或更多会根据情况和参数来计算增大可降低频率注意会增加触发的堆大小对于频繁分配的对象可以使用减少分配频次进而降低频率对进行了优化全局缓存对象有大量的的情况少用指针并发需要存活的对象如果里指针多导致消耗的很大使用一个内嵌数据消除指针一点点拷贝胜过传指针对象在栈上分配减少频率慎用和的仅用在不会修改的地方和的容量初始化减少不断加元素时的扩容替换等等框架或模板集成及默认开启往往有问题才想起没引入无法查看又需要保留现场服务模板代码默认引入一个库开启集成到服务列表页有问题点一点通过一个直接获取机器上服务的图服务模板默认引入一个库封装版和占用的端口根据服务端口我们将的开启集成到模板中并自动选择端口并集成了工具方便查询信息同时在浏览器上可直接点击生成火焰图图非常的方便也不需要使用者关心问题排查的一点思路内存慢慢增长结合的和加上源码流程即可定位出一直把新对象放到全局对象或者长生命周期对象中比如长连接连接池应用或者忘记等内存突增如果多次分配才可使用方法排查对于一次就的比较难抓可结合无法分配内存时输出的协程栈排查比如没有校验参数调用者填错或恶意使用传过来的来进行用于编解码性能问题结合火焰图查看影响性能的热点部分进行优化频繁编解码效率低等一次有意思的问题排查负载依赖服务都很正常利用率也不高请求也不多就是有很多超时该服务在线上打印了日志因为早期的服务模板开启了框架把重定向到一个文件了而输出时本来是到的输出到文件了而磁盘跟不上导致日志被阻塞了这里更正一下中的内容并不是因为没完成而导致其他协程不能运行而是后续无法开启导致实质上的打印日志时已经了其他协程可以开始运行了但是在打印日志时还保持着开启需要的锁所以打印日志一直没完成而又比较频繁比如一次这样会导致下一次开始时无法获取锁每一个进入检查的阻塞实际上就造成了的一点个人总结思想作用示例并行减少操作的和阻塞并发阶段的逐个等纵向多层次尽量减少锁竞争和冲突无锁粒度范围比较小的锁最后才全局和系统调用调度内存分配分配等横向多个找到最适配的减少内存浪费和碎片内存分配机制多个的分配等缓存减少重新申请的的等延缓释放归还给的缓冲放入队列减少阻塞操作异步化写屏障的标记队列均衡负载均衡不会因为太多的而成为瓶颈调度时从全局获取从其他进行标记工作的本地和全局之间的和参考文档描述并发正确性和规则模型转为模型支持对运行代码的协程进行协作式抢占调度将之前的分裂栈改为连续栈大大减少链式栈的创建和带来的性能消耗调度器源码分析也谈调度器内存管理状态检测由集中式改为分布到多个协程复盘算法的发展历程及现状消除栈重新扫描进入服务的不同版本时间对比源码探索三的实现原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 16:22:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>23</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">February 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">January 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/go/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>go</span></a></span></div></div><h1 class="post-title" itemprop="name headline">go runtime 精讲</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2020-07-18T12:54:56.000Z" title="发表于 2020-07-18 20:54:56">2020-07-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.099Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/"><header><a href="/tags/go/" tabindex="-1" itemprop="url">go</a><h1 id="CrawlerTitle" itemprop="name headline">go runtime 精讲</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2020-07-18T12:54:56.000Z" title="发表于 2020-07-18 20:54:56">2020-07-18</time><time itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.099Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></header><p>[TOC]</p>
<h2 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0 介绍"></a>0 介绍</h2><p>本文主要内容如下:</p>
<ol>
<li>Golang Runtime 是个什么? Golang Runtime 的发展历程, 每个版本的改进</li>
<li>Go 调度: 协程结构体, 上下文切换, 调度队列, 大致调度流程, 同步执行流又不阻塞线程的网络实现等</li>
<li>Go 内存: 内存结构, mspan 结构, 全景图及分配策略等</li>
<li>Go GC: Golang GC 停顿大致的一个发展历程, 三色标记实现的一些细节, 写屏障, 三色状态, 扫描及元信息, 1.12 版本相对 1.5 版本的改进点, GC Pacer 等</li>
<li>实践: 观察调度, GC 信息, 一些优化的方式, 几点问题排查的思路, 几个有意思的问题排查</li>
<li>总结: 贯穿 Runtime 的思想总结</li>
</ol>
<h2 id="1-序"><a href="#1-序" class="headerlink" title="1 序"></a>1 序</h2><p>运行时到底是个什么东西?<br>Go的调度为什么说是轻量的?<br>Go调度都发生了啥?<br>Go的网络和锁会不会阻塞线程?<br>什么时候会阻塞线程?<br>Go的对象在内存中是怎样的?<br>Go的内存分配是怎样的?<br>栈的内存是怎么分配的?<br>GC是怎样的?<br>GC怎么帮我们回收对象?<br>Go的GC会不会漏掉对象或者回收还在用的对象?<br>Go GC什么时候开始?<br>Go GC啥时候结束?<br>Go GC会不会太慢, 跟不上内存分配的速度?<br>Go GC会不会暂停我们的应用? 暂停多久? 影不影响我的请求?</p>
<h3 id="1-1-为什么去了解-runtime-呢"><a href="#1-1-为什么去了解-runtime-呢" class="headerlink" title="1.1 为什么去了解 runtime 呢?"></a>1.1 为什么去了解 runtime 呢?</h3><ol>
<li>可以解决一些棘手的问题: 在写这个 PPT 的时候, 就有一位朋友在群里发了个 pprof 图, 说同事写的代码有问题, CPU 利用率很高., 找不出来问题在哪, 我看了下 pprof 图, 说让他找找是不是有这样用 select 的, 一查的确是的. 平时也帮同事解决了一些和并发, 调度, GC 有关的问题</li>
<li>好奇心: 大家写久了 go, 惊叹于它的简洁, 高性能外, 必然对它是怎么实现的有很多好奇. 协程怎么实现, GC 怎么能并发, 对象在内存里是怎么存在的? 等等</li>
<li>技术深度的一种</li>
</ol>
<h2 id="2-Runtime-简介及发展"><a href="#2-Runtime-简介及发展" class="headerlink" title="2 Runtime 简介及发展"></a>2 Runtime 简介及发展</h2><h3 id="2-1-Runtime-简介"><a href="#2-1-Runtime-简介" class="headerlink" title="2.1 Runtime 简介"></a>2.1 Runtime 简介</h3><p> Golang Runtime是go语言运行所需要的基础设施. go 的 runtime 代码在 go sdk 的 runtime 目录下, 主要有所述的 4 块功能：</p>
<ol>
<li>协程调度, 内存分配, GC; </li>
<li>操作系统及CPU相关的操作的封装(信号处理, 系统调用, 寄存器操作, 原子操作等), CGO; </li>
<li>pprof, trace, race检测的支持; </li>
<li>map, channel, string等内置类型及反射的实现.</li>
</ol>
<p>特点:</p>
<ol>
<li><p>与Java, Python不同, Go并没有虚拟机的概念, Runtime也直接被编译 成native code. </p>
</li>
<li><p>Go的Runtime与用户代码一起打包在一个可执行文件中 </p>
</li>
<li><p>用户代码与Runtime代码在执行的时候并没有明显的界限, 都是函数调 用 </p>
</li>
<li><p>go对系统调用的指令进行了封装, 可不依赖于glibc </p>
</li>
<li><p>一些go的关键字被编译器编译成runtime包下的函数.</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>go</td>
<td>newproc new newobject</td>
</tr>
<tr>
<td>make</td>
<td>makeslice, makechan, makemap, makemap_small</td>
</tr>
<tr>
<td></td>
<td>gcStart</td>
</tr>
<tr>
<td>&lt;- -&gt;</td>
<td>chansend1, chanrecv1</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="3调度"><a href="#3调度" class="headerlink" title="3调度"></a>3调度</h2><h3 id="3-1调度简述"><a href="#3-1调度简述" class="headerlink" title="3.1调度简述"></a>3.1调度简述</h3><ul>
<li>PMG模型, M:N调度模型. </li>
<li>调度在计算机中是分配工作所需资源的方法. linux的调度为CPU找到可运行的线程. 而Go的调度是为 M(线程)找到P(内存, 执行票据)和可运行的G. </li>
<li>轻量级协程G, 栈初始2KB, 调度不涉及系统调用. </li>
<li>用户函数调用前会检查栈空间是否足够, 不够的话, 会进行栈扩容. </li>
<li>用户代码中的协程同步造成的阻塞, 仅仅是切换协程, 而不阻塞线程.</li>
<li>网络操作封装了epoll, 为NonBlocking模式, 未ready, 切换协程, 不阻塞线程. </li>
<li>每个p均有local runq, 大多数时间仅与local runq无锁交互. 实现work stealing. </li>
<li>用户协程无优先级, 基本遵循FIFO. </li>
<li>go1.12支持协作的抢占调度, 还不支持非协作的抢占调度.</li>
</ul>
<h3 id="3-2-goroutine-实现"><a href="#3-2-goroutine-实现" class="headerlink" title="3.2 goroutine 实现"></a>3.2 goroutine 实现</h3><p>Process -&gt; Thread(LWP, lightweight process) -&gt; Goroutine (一种lightweight userspace thread) </p>
<p>不断共享, 不断减少切换成本 </p>
<blockquote>
<p>Go实现有栈协程<br>代表协程这种执行流的结构体<br>保护和恢复上下文的函数<br>运行队列<br>编译器将go关键字编译为生成一个协程结构体, 并放入运行队列<br>解决网络IO阻塞问题<br>协程级别的同步结构<br>调度: findrunnable</p>
</blockquote>
<p>我们去看调度的一个进化, 从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程. go 实现的协程为有栈协程, go 协程的用法和线程的用法基本类似. 很多人会疑问, 协程到底是个什么东西? 用户态的调度感觉很陌生, 很抽象, 到底是个什么东西?</p>
<p>我觉得要理解调度, 要理解两个概念: 运行和阻塞. 特别是在协程中, 这两个概念不容易被正确理解. 我们理解概念时往往会代入自身感受, 觉得线程或协程运行就是像我们吭哧吭哧的处理事情, 线程或协程阻塞就是做事情时我们需要等待其他人. 然后就在这等着了. 要是其他人搞好了, 那我们就继续做当前的事.</p>
<p> linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态. 真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等 (这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.</p>
<p>线程的运行, 其实是被运行. 其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列. 协程同理, 协程其实也是一个数据结构, 记录了要运行什么函数, 运行到哪里了. </p>
<p>go 在用户态实现调度, 所以 go 要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列. 理解了阻塞的真正含义, 也就知道能够比较容易理解, 为什么 go 的锁, channel 这些不阻塞线程.</p>
<p>对于实现的同步执行流效果, 又不阻塞线程的网络, 接下来也会介绍.</p>
<h3 id="3-3-协程结构体和切换函数"><a href="#3-3-协程结构体和切换函数" class="headerlink" title="3.3 协程结构体和切换函数"></a>3.3 协程结构体和切换函数</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-85a56b6e215d2b427ac4f5252ce3c619_r.jpg"></p>
<p>我们 go 一个 func 时一般这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func1(arg1 type1,arg2 type2)&#123;....&#125;(a1,a2)</span><br></pre></td></tr></table></figure>

<p>一个协程代表了一个执行流, 执行流有需要执行的函数 (对应上面的 func1), 有函数的入参 (a1, a2), 有当前执行流的状态和进度 (对应 CPU 的 PC 寄存器和 SP 寄存器), 当然也需要有保存状态的地方, 用于执行流恢复.</p>
<p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列. 上面的 func1 函数的指针设置在 runtime.g 的 startfunc 字段, 参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置.</p>
<p>协程切换出去和恢复回来需要保存上下文, 恢复上下文, 这些由以下两个汇编函数实现. 以上就能实现协程这种执行流, 并能进行切换和恢复.(下图中的 struct 和函数都做了精简)</p>
<h3 id="3-4-GM-模型及-GPM-模型"><a href="#3-4-GM-模型及-GPM-模型" class="headerlink" title="3.4 GM 模型及 GPM 模型"></a>3.4 GM 模型及 GPM 模型</h3><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-836e26770ed9489f835605529e608c37_r.jpg"></p>
<p>有了协程的这种执行流形式, 那待运行的协程放在哪呢?<br>在 Go1.0 的时候:</p>
<ol>
<li>调度队列 schedt 是全局的, 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.</li>
<li>新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示) 运行了, 内存亲和性不好. 当前协程 A 新生成了协程 B, 然后协程 A 比较大概率会结束或者阻塞, 这样 m 直接去执行协程 B, 内存的亲和性也会好很多.</li>
<li>因为 mcache 与 m 绑定, 在一些应用中 (比如文件操作或其他可能会阻塞线程的系统调用比较多), m 的个数可能会远超过活跃的 m 个数, 导致比较大的内存浪费.</li>
</ol>
<p>那是不是可以给 m 分配一个队列, 把阻塞的 m 的 mcache 给执行 go 代码的 m 使用? Go 1.1 及以后就是这样做的.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-a06db1f245421b17c64d7bc4f338b71e_r.jpg"></p>
<p>在 1.1 中调度模型更改为 GPM 模型, 引入逻辑 Process 的概念, 表示执行 Go 代码所需要的资源, 同时也是执行 Go 代码的最大的并行度.</p>
<p>这个概念可能很多人不知道怎么理解. P 涉及到几点, 队列和 mcache, 还有 P 的个数的选取.</p>
<p>首先为什么把全局队列打散, 以及 mcache 为什么跟随 P, 这个在 GM 模型那一页就讲的比较清楚了. 然后为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.</p>
<p>在 go 里面, 一个协程运行到阻塞系统调用, 那么这个协程和运行它的线程 m, 自然是不再需要 CPU 的, 也不需要分配 go 层面的内存. 只有一直在并行运行的 go 代码才需要这些资源, 即同时有 n 个 go 协程在并行执行, 那么就能最大的利用 CPU, 这个时候需要的 P 的个数就是 CPU 核数. (注意并行和并发的区别)</p>
<h3 id="3-5-协程状态及流转"><a href="#3-5-协程状态及流转" class="headerlink" title="3.5 协程状态及流转"></a>3.5 协程状态及流转</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-95c62d2ff20b8a75e0ec2eddddaf4bd2_r.jpg"></p>
<p>协程的状态其实和线程状态类似, 状态转换和发生状态转换的时机如图所示. 还是需要注意: 协程只是一个执行流, 并不是运行实体.</p>
<h3 id="3-6-go-routine调度"><a href="#3-6-go-routine调度" class="headerlink" title="3.6 go routine调度"></a>3.6 go routine调度</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-0328b09cc3dd5537bd463e10ef17db6e_r.jpg"></p>
<p>并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程 (m) 执行 runtime.schedule 函数来完成的.</p>
<h3 id="3-7-sysmon-协程"><a href="#3-7-sysmon-协程" class="headerlink" title="3.7 sysmon 协程"></a>3.7 sysmon 协程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-28f751cb1c56fcc275bc545d7f82d869_r.jpg"></p>
<p>在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等. 在 go 运行时中也有类似的协程, sysmon. 功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC, 打印调度信息, 归还内存等定时任务.</p>
<h3 id="3-8-协作式抢占"><a href="#3-8-协作式抢占" class="headerlink" title="3.8 协作式抢占"></a>3.8 协作式抢占</h3><p>retake()调用preemptone()将被抢占的G的<code>stackguard0</code>设为<code>stackPreempt</code>, 被设置抢占标记的G进行下一次函数调用时, 检查栈空间失败. 进而触发morestack()（汇编代码，位于 asm_XXX.s中）然后进行一连串的函数调用，主要的调用过程如下： </p>
<p>morestack()（汇编代码）-&gt; newstack() -&gt; gopreempt_m() -&gt; goschedImpl() -&gt; schedule()</p>
<p>go1.12 还没有实现非协作的抢占. 基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.</p>
<h3 id="3-9-同步执行流不阻塞线程的网络的实现"><a href="#3-9-同步执行流不阻塞线程的网络的实现" class="headerlink" title="3.9 同步执行流不阻塞线程的网络的实现"></a>3.9 同步执行流不阻塞线程的网络的实现</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-7bed4181eb6bbcba7be4a6b43a604c3e_r.jpg"><br>go 写后台最舒服的就是能够以同步写代码的方式操作网络, 但是网络操作不阻塞线程. 主要是结合了非阻塞的 fd, epoll 以及协程的切换和恢复. linux 提供了网络 fd 的非阻塞模式, 对于没有 ready 的非阻塞 fd 执行网络操作时, linux 内核不阻塞线程, 会直接返回 EAGAIN, 这个时候将协程状态设置为 wait, 然后 m 去调度其他协程.</p>
<p>go 在初始化一个网络 fd 的时候, 就会把这个 fd 使用 epollctl 加入到全局的 epoll 节点中. 同时放入 epoll 中的还有 polldesc 的指针.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func netpollopen(fd uintptr, pd *pollDesc) int32 &#123;</span><br><span class="line">    var ev epollevent</span><br><span class="line">    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sysmon 中, schedule 函数中, start the world 中等情况下, 会执行 netpoll 调用 epollwait 系统调用, 把 ready 的网络事件从 epoll 中取出来, 每个网络事件可以通过前面传入的 polldesc 获取到阻塞在其上的协程, 以此恢复协程为 runnable.</p>
<h3 id="3-10-调度相关结构体"><a href="#3-10-调度相关结构体" class="headerlink" title="3.10 调度相关结构体"></a>3.10 调度相关结构体</h3><hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-85359486219d4ce31b93fa450b592083_r.jpg"></p>
<h3 id="3-11-调度总结"><a href="#3-11-调度总结" class="headerlink" title="3.11 调度总结"></a>3.11 调度总结</h3><ul>
<li>轻量级的协程, 栈初始2KB, 调度不涉及系统调用. </li>
<li>调度在计算机中是分配工作所需资源的方法. linux的调度为CPU找到可运行的线程. 而Go的调度是为M(线程)找到P(内存, 执行 票据)和可运行的G. </li>
<li>用户函数调用前会检查栈空间是否足够, 不够的话, 会进行*2 栈扩容. 最大栈1Gb, 超出panic. </li>
<li>用户代码中的协程同步造成的阻塞, 仅仅是切换(gopark)协程, 而不阻塞线程, m和p仍结合, 去寻找新的可执行的g. </li>
<li>每个P均有local runq, 大多数时间仅与local runq无锁交互. 新生成的g, 放入到local runq中. </li>
<li>调度时会随机从全局runq取g. 然后local runq, global runq… 均没有g的话, work stealing从其他P中取. </li>
<li>sysmon: 对于运行过久的g设置抢占标识; 对于过久syscall的p, 进行m和p的分离. 防止p被占用过久影响调度. </li>
<li>封装了epoll, 网络fd会设置成NonBlocking模式, 网络fd的read, write, accept操作, 会以NonBlocking模式操作, 返回 EAGAIN则gopark当前协程. 在m调度, sysmon中, gc start the world等阶段均会poll出ready的协程进行运行或者添加到全 局runq中 </li>
<li>目前(1.12), go还不支持非协作的抢占调度, 在密集CPU运算时, 可能会导致调度延迟. 官方已在解决.</li>
</ul>
<h3 id="3-12-未涉及到的点"><a href="#3-12-未涉及到的点" class="headerlink" title="3.12 未涉及到的点"></a>3.12 未涉及到的点</h3><ul>
<li>G状态流转 </li>
<li>具体调度流程</li>
<li>栈扩容 </li>
<li>合作式抢占</li>
<li>sysmon </li>
<li>P状态流转 </li>
<li>M的spin与unspin </li>
<li>LockOSThread</li>
</ul>
<h2 id="4-内存分配"><a href="#4-内存分配" class="headerlink" title="4 内存分配"></a>4 内存分配</h2><h3 id="4-1-内存分配简介"><a href="#4-1-内存分配简介" class="headerlink" title="4.1 内存分配简介"></a>4.1 内存分配简介</h3><ul>
<li>类似于TCMalloc的结构 </li>
<li>使用span机制来减少碎片. 每个span至少为一个页(go中的一个page为8KB). 每一种span用于一个范围的内存分配需求. 比 如16-32byte使用分配32byte的span, 112-128使用分配128byte的span.</li>
<li>一共有67个size范围, 8byte-32KB, 每个size有两种类型(scan和noscan, 表示分配的对象是否会包含指针)</li>
<li>多层次Cache来减少分配的冲突. per-P无锁的mcache, 全局67*2个对应不同size的span的后备mcentral, 全局1个的mheap.</li>
<li>mheap中以treap的结构维护空闲连续page. 归还内存到heap时, 连续地址会进行合并. </li>
<li>stack分配也是多层次和多class的.</li>
<li>对象由GC进行回收. sysmon会定时把空余的内存归还给操作系统</li>
</ul>
<p>Go 的分配采用了类似 tcmalloc 的结构. 特点: 使用一小块一小块的连续内存页, 进行分配某个范围大小的内存需求. 比如某个连续 8KB 专门用于分配 17-24 字节, 以此减少内存碎片. 线程拥有一定的 cache, 可用于无锁分配.</p>
<p>同时 Go 对于 GC 后回收的内存页, 并不是马上归还给操作系统, 而是会延迟归还, 用于满足未来的内存需求.</p>
<h3 id="4-2-内存空间结构"><a href="#4-2-内存空间结构" class="headerlink" title="4.2 内存空间结构"></a>4.2 内存空间结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-c1b2977bf1d33669bb9c2774c7b6d8d8_r.jpg"></p>
<p>在 1.10 以前 go 的堆地址空间是线性连续扩展的, 比如在 1.10(linux amd64)中, 最大可扩展到 512GB. 因为 go 在 gc 的时候会根据拿到的指针地址来判断是否位于 go 的 heap 的, 以及找到其对应的 span, 其判断机制需要 gc heap 是连续的. 但是连续扩展有个问题, cgo 中的代码 (尤其是 32 位系统上) 可能会占用未来会用于 go heap 的内存. 这样在扩展 go heap 时, mmap 出现不连续的地址, 导致运行时 throw.</p>
<p>在 1.11 中, 改用了稀疏索引的方式来管理整体的内存. 可以超过 512G 内存, 也可以允许内存空间扩展时不连续. 在全局的 mheap struct 中有个 arenas 二阶数组, 在 linux amd64 上, 一阶只有一个 slot, 二阶有 4M 个 slot, 每个 slot 指向一个 heapArena 结构, 每个 heapArena 结构可以管理 64M 内存, 所以在新的版本中, go 可以管理 4M*64M&#x3D;256TB 内存, 即目前 64 位机器中 48bit 的寻址总线全部 256TB 内存.</p>
<h3 id="4-3-span-机制"><a href="#4-3-span-机制" class="headerlink" title="4.3 span 机制"></a>4.3 span 机制</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-84e72feda2d2cd49aaad59bb6f72837c_r.jpg"></p>
<p>前面提到了 go 的内存分配类似于 tcmalloc, 采用了 span 机制来减少内存碎片. 每个 span 管理 8KB 整数倍的内存, 用于分配一定范围的内存需求.</p>
<h3 id="4-4-内存分配全景"><a href="#4-4-内存分配全景" class="headerlink" title="4.4 内存分配全景"></a>4.4 内存分配全景</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-11756712c78ee841873eb9aa22198f3c_r.jpg"></p>
<p>多层次的分配 Cache, 每个 P 上有一个 mcache, mcache 会为每个 size 最多缓存一个 span, 用于无锁分配. 全局每个 size 的 span 都有一个 mcentral, 锁的粒度相对于全局的 heap 小很多, 每个 mcentral 可以看成是每个 size 的 span 的一个全局后备 cache.</p>
<p>在 gc 完成后, 会把 P 中的 span 都 flush 到 mcentral 中, 用于清扫后再分配. P 有需要 span 时, 从对应 size 的 mcentral 获取. 获取不到再上升到全局的 heap.</p>
<h3 id="4-5-几种特殊的分配器"><a href="#4-5-几种特殊的分配器" class="headerlink" title="4.5 几种特殊的分配器"></a>4.5 几种特殊的分配器</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-e35ffea692133cbe86898cdf3eb55352_r.jpg"></p>
<p>对于很小的对象分配, go 做了个优化, 把小对象合并, 以移动指针的方式分配. 对于栈内存有 stackcache 分配, 也有多个层次的分配, 同时 stack 也有多个不同 size. 用于分配 stack 的内存也是位于 go gc heap, 用 mspan 管理, 不过这个 span 的状态和用于分配对象的 mspan 状态不太一样, 为 mSpanManual.</p>
<p>我们可以思考一个问题, go 的对象是分配在 go gc heap 中, 并由 mcache, mspan, mcentral 这些结构管理, 那么 mcache, mspan, mcentral 这些结构又是哪里管理和分配的呢? 肯定不是自己管理自己. 这些都是由特殊的分配 fixalloc 分配的, 每种类型有一个 fixalloc, 大致原理就是通过 mmap 从进程空间获取一小块内存 (百 KB 的样子), 然后用来分配这个固定大小的结构.</p>
<h3 id="4-6-内存分配总结"><a href="#4-6-内存分配总结" class="headerlink" title="4.6 内存分配总结"></a>4.6 内存分配总结</h3><ul>
<li>类似于TCMalloc的结构</li>
<li>使用span机制来减少碎片. 每个span至少为一个页(go中的一个page为8KB). 每一种span用于一个范围的内存分配需求. 比如16-32byte使用分配32byte的span, 112-128使用分配128byte的span.</li>
<li>一共有67个size范围, 8byte-32KB, 每个size有两种类型(scan和noscan, 表示分配的对象是否会包含指针)</li>
<li>多阶Cache来减少分配的冲突. per-P无锁的mcache, 对应不同size(67*2)的全局mcentral, 全局的mheap.</li>
<li>go代码分配内存优先从当前p的mcache对应size的span中获取; 有的话, 再从对应size的mcentral中获取一个span; 还没有的话, 从mheap中sweep一个span; sweep不出来, 则从mheap中空闲块找到对应span大小的内存. mheap中如果还没有, 则从系统申请内存. 从无锁到全局1&#x2F;(67*2)粒度的锁, 再到全局锁, 再到系统调用. </li>
<li>stack的分配也是多层次和多class的. 减少分配的锁争抢, 减少栈浪费. </li>
<li>mheap中以treap的结构维护空闲连续page. 归还内存到mheap时, 连续地址会进行合并. (1.11之前采用类似伙伴系统维护&lt;1MB的连续page, treap维护&gt;1MB的连续page)</li>
<li>对象由GC进行释放. sysmon会定时把mheap空余的内存归还给操作系统</li>
</ul>
<p>未涉及的点:<br>    fixalloc和persistentalloc具体流程, scav treap, 逃逸分析</p>
<h2 id="5-GC"><a href="#5-GC" class="headerlink" title="5 GC"></a>5 GC</h2><h3 id="5-1-Golang-GC-简述"><a href="#5-1-Golang-GC-简述" class="headerlink" title="5.1 Golang GC 简述"></a>5.1 Golang GC 简述</h3><p>GC是一种自动内存管理方式</p>
<ul>
<li>GC三大基础算法: Mark-Sweep, Mark-Sweep-Compact, Mark-Copy. 这三个基础算法GC时需要一直STW(stop theworld)</li>
<li>GC算法是一个综合的考虑: 程序吞吐量, GC吞吐量, STW时间, STW的频率, 压缩, 分配性能, 并发, 伸缩, 调优复杂度等等. </li>
<li>当前Go GC特征: 三色标记, 并发标记和清扫, 非分代, 非紧缩, 混合写屏障. </li>
<li>1.5之后Go的GC是基于三色标记法的Concurrent Mark-Sweep(并发标记-清扫)算法. 生产上基本没什么问题. </li>
<li>1.5之后Golang Runtime中调整最多的就是GC的部分. </li>
<li>1.8之后Go的GC STW可以比较稳定在sub ms</li>
<li>Go的GC并不是完美的</li>
</ul>
<h3 id="5-2-GC-简介"><a href="#5-2-GC-简介" class="headerlink" title="5.2 GC 简介"></a>5.2 GC 简介</h3><p>对象是否存活是由整体应用其他部分是否对其有引用决定的, 是一个全局性的信息, 而手动管理内存只能由开发人员根据当前上下文的局部信息来判断.<br>Garbage Collection (GC)是一种自动管理内存的方式. 支持GC的语言无需手动管理内存, 程序后台自动判断对象是否存活并回收其内存空间, 使开发人员从内存管理上解脱出来. 1959年, GC由 John McCarthy发明, 用于简化Lisp中的手动内存管理. 到现在很多语言都提供了GC. 不过GC的原理和基本算法都没有太大的改变.<br>哪些语言提供GC(基本上90年代后的语言都提供GC):</p>
<ul>
<li>ML, Haskell, Lisp等大多数函数式编程语言</li>
<li>Python, Ruby, JS等动态类型语言</li>
<li>Smalltalk, Java, C#等面向对象语言</li>
</ul>
<p>GC 并不是个新事物, 使得 GC 大放光彩的是 Java 语言.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Person * p = <span class="keyword">new</span> <span class="built_in">Person</span>(); </span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者需要自己new Person并负责释放</span></span><br><span class="line"><span class="built_in">test</span>(p *Person) &#123;</span><br><span class="line">    p-&gt;name=<span class="string">&quot;OfferGet&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    o := <span class="built_in">new</span>(Person)</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> *Person &#123;</span><br><span class="line">    p := <span class="built_in">new</span>(Person)</span><br><span class="line">    p.Name = <span class="string">&quot;OfferGet&quot;</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li>对象被回收时间即GC发生时间是不可知的</li>
<li>垃圾回收不是析构函数. </li>
<li>垃圾回收只与内存有关, 不会回收连接资源, 文件资源. </li>
<li>GC时自动调用对象的某个方法, 来关闭一些资源, 是否可行?</li>
</ul>
<h3 id="5-3-GC相关术语"><a href="#5-3-GC相关术语" class="headerlink" title="5.3  GC相关术语"></a>5.3  GC相关术语</h3><ul>
<li><strong>并发和并行</strong>: 通常在GC领域中, 并发收集器则指垃圾回收的同时应用程序也在执行; 并行收集器指垃圾回收采取多个线程利用多个CPU一起进行GC. 不过一般我们说并发回收器, 就包含了这两层意思.</li>
<li><strong>Safepoint</strong>: 安全点(Safepoint)是收集器能够识别出线程执行栈上的所有引用的一点或一段时间.</li>
<li><strong>Stop The World(STW)</strong>: 某些垃圾回收算法或者某个阶段进行时需要将应用程序完全暂停.</li>
<li><strong>准确式GC和保守式GC</strong>: 准确式(precise或exact) GC指GC能够知道一块内存区域是引用还是非引用, 如一个64位的区域可以是一个int64整形数字也可以是一个对象引用, 当一个对象进行执行时, 需要修改指向这个内存的引用的指, 非准确式GC也就是保守式GC不能完成这个任务. </li>
<li><strong>Mark</strong>: 从Root对象开始扫描, 标记出其引用的对象, 及这些对象引用的对象, 如此循环, 标记所有可达的对象. </li>
<li><strong>Sweep</strong>: Sweep清除阶段扫描堆区域, 回收在标记阶段标记为Dead的对象, 通常通过空闲链表(free list)的方式.需要的工作量和堆大小成正比. </li>
<li><strong>Compact</strong>: 压缩的方式是将存活对象移动到一起来获得一段连续的空闲空间, 也叫做重定位.这样需要将所有对象的引用指向新的位置.工作量和存活对象量成正比. </li>
<li><strong>Copy</strong>: 复制算法将所有存活对象从一个From区域移动到一个To区域, 然后回收From区域. 之后From和To交换角色, 由于From和To是对等的, 所以需要两块大小相同的区域, 而同一时间只能利用其中一块来存放对象.工作量和存活对象量成正比</li>
</ul>
<h3 id="5-4-GC关心什么？"><a href="#5-4-GC关心什么？" class="headerlink" title="5.4  GC关心什么？"></a>5.4  GC关心什么？</h3><ul>
<li><strong>程序吞吐量</strong>: 回收算法会在多大程度上拖慢程序? 可以通过GC占用的CPU与其他CPU时间的百分比描述</li>
<li><strong>GC吞吐量</strong>: 在给定的CPU时间内, 回收器可以回收多少垃圾?</li>
<li><strong>堆内存开销</strong>: 回收器最少需要多少额外的内存开销?</li>
<li><strong>停顿时间</strong>: 回收器会造成多大的停顿?</li>
<li><strong>停顿频率</strong>: 回收器造成的停顿频率是怎样的?</li>
<li><strong>停顿分布</strong>: 停顿有时候很长, 有时候很短? 还是选择长一点但保持一致的停顿时间?</li>
<li><strong>分配性能</strong>: 新内存的分配是快, 慢还是无法预测?</li>
<li><strong>压缩</strong>: 当堆内存里还有小块碎片化的内存可用时, 回收器是否仍然抛出内存不足（OOM）的错误？如果不是, 那么你是否发现程序越来越慢, 并最终死掉, 尽管仍然还有足够的内存可用？</li>
<li><strong>并发</strong>: 回收器是如何利用多核机器的？</li>
<li><strong>伸缩</strong>: 当堆内存变大时, 回收器该如何工作？</li>
<li><strong>调优</strong>: 回收器的默认使用或在进行调优时, 它的配置有多复杂？</li>
<li><strong>预热时间</strong>: 回收算法是否会根据已发生的行为进行自我调节？如果是, 需要多长时间？</li>
<li><strong>页释放</strong>: 回收算法会把未使用的内存释放回给操作系统吗？如果会, 会在什么时候发生？</li>
</ul>
<h3 id="5-5-Golang-GC-发展"><a href="#5-5-Golang-GC-发展" class="headerlink" title="5.5  Golang GC 发展"></a>5.5  Golang GC 发展</h3><p>Golang早期版本GC可能问题比较多 . 但每一个版本的发布都伴随着 GC 的改进. 1.5版本之后, Go的GC已经能满足大部分大部分生产环境使用要求. 1.8通过hybrid write barrier, 使得STW降到了sub ms.<br>下面列出一些GC方面比较重大的改动:</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th>GC</th>
<th>STW时间(见备注twitter数据)</th>
</tr>
</thead>
<tbody><tr>
<td>v1.1</td>
<td>2013&#x2F;5</td>
<td>STW</td>
<td>百ms-几百ms级别</td>
</tr>
<tr>
<td>v1.3</td>
<td>2014&#x2F;6</td>
<td>Mark STW , Sweep 并行</td>
<td>百ms级别</td>
</tr>
<tr>
<td>v1.5</td>
<td>2015&#x2F;8</td>
<td>三色标记法, 并发标记清除</td>
<td>10ms级别</td>
</tr>
<tr>
<td>v1.8</td>
<td>2017&#x2F;2</td>
<td>hybrid write barrier</td>
<td>sub ms</td>
</tr>
</tbody></table>
<p>整体来说 golang gc 用起来是很舒心的, 几乎不用你关心.</p>
<h3 id="5-5-三色标记"><a href="#5-5-三色标记" class="headerlink" title="5.5 三色标记"></a>5.5 三色标记</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-652acc8ca5d0f04c455c68d1084cd309_r.jpg"></p>
<p>go 采用的是并发三色标记清除法. 图展示的是一个简单的原理. 有几个问题可以思考一下:</p>
<ul>
<li>并发情况下, 会不会漏标记对象?</li>
<li>对象的三色状态存放在哪?</li>
<li>如何根据一个对象来找到它引用的对象?</li>
</ul>
<h4 id="5-5-1-写屏障"><a href="#5-5-1-写屏障" class="headerlink" title="5.5.1 写屏障"></a>5.5.1 写屏障</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-8c43a67a0eba214a81f56c873504c884_r.jpg"></p>
<p>GC 最基本的就是正确性: 不漏标记对象, 程序还在用的对象都被清除了, 那程序就错误了. 有一点浮动垃圾是允许的.<br>在并发情况下, 如果没有一些措施来保障, 那可能会有什么问题呢?</p>
<p>看左边的代码和图示, 第 2 步标记完 A 对象, A 又没有引用对象, 那 A 变成黑色对象. 在第 3 步的时候, muator(程序) 运行, 把对象 C 从 B 转到了 A, 第 4 步, GC 继续标记, 扫描 B, 此时 B 没有引用对象, 变成了黑色对象. 我们会发现 C 对象被漏标记了.</p>
<p>如何解决这个问题? go 使用了写屏障, 这里的写屏障是指由编译器生成的一小段代码. 在 gc 时对指针操作前执行的一小段代码, 和 CPU 中维护内存一致性的写屏障不太一样哈. 所以有了写屏障后, 第 3 步, A.obj&#x3D;C 时, 会把 C 加入写屏障 buf. 最终还是会被扫描的.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-69b05d315557f599251e091a0d4a00d9_r.jpg"></p>
<p>这里感受一下写屏障具体生成的代码. 我们可以看到在写入指针 slot 时, 对写屏障是否开启做了判断, 如果开启了, 会跳转到写屏障函数, 执行加入写屏障 buf 的逻辑. 1.8 中写屏障由 Dijkstra 写屏障改成了混合式写屏障, 使得 GC 停顿达到了 1ms 以下.</p>
<h4 id="5-5-2-三色状态"><a href="#5-5-2-三色状态" class="headerlink" title="5.5.2 三色状态"></a>5.5.2 三色状态</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-4dd9c75a72c82eaf3690386dcf286cdb_r.jpg"></p>
<p>并没有这样一个集合把不同状态对象放到对应集合中. 只是一个逻辑上的意义.</p>
<h4 id="5-5-3-扫描和元信息"><a href="#5-5-3-扫描和元信息" class="headerlink" title="5.5.3 扫描和元信息"></a>5.5.3 扫描和元信息</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-ee14e9737cbb929bc95ec3af883e5474_r.jpg"></p>
<p>gc 拿到一个指针, 如何把这个指针指向的对象其引用的子对象都加到扫描队列呢? 而且 go 还允许内部指针, 似乎更麻烦了. 我们分析一下, 要知道对象引用的子对象, 从对象开始到对象结尾, 把对象那一块内存上是指针的放到扫描队列就好了. 那我们是不是得知道对象有多大, 从哪开始到哪结束, 同时要知道内存上的 8 个字节, 哪里是指针, 哪里是普通的数据.</p>
<p>首先 go 的对象是 mspan 管理的, 我们如果能知道对象属于哪个 mspan, 就知道对象多大, 从哪开始, 到哪结束了. 前面我们讲到了 areans 结构, 可以通过指针加上一定得偏移量, 就知道属于哪个 heap arean 64M 块. 再通过对 64M 求余, 结合 spans 数组, 即可知道属于哪个 mspan 了.</p>
<p>结合 heapArean 的 bitmap 和每 8 个字节在 heapArean 中的偏移, 就可知道对象每 8 个字节是指针还是普通数据 (这里的 bitmap 是在分配对象时根据 type 信息就设置了, type 信息来源于编译器生成)</p>
<h3 id="5-6-GC-流程"><a href="#5-6-GC-流程" class="headerlink" title="5.6 GC 流程"></a>5.6 GC 流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-e0eef1afbfa873db4b0faa21a4741c5f_r.jpg"></p>
<p>1.5 和 1.12 的 GC 大致流程相同. 上图是 golang 官方的 ppt 里的图, 下图是我根据 1.12 源码绘制的. 从最坏可能会有百 ms 的 gc 停顿到能够稳定在 1ms 以下, 这之间 GC 做了很多改进. 右边是我根据官方 issues 整理的一些比较重要的改进. 1.6 的分布式检测, 1.7 将栈收缩放到了并发扫描阶段, 1.8 的混合写屏障, 1.12 更改了 mark termination 检测算法, mcache flush 移除出 mark termination 等等.</p>
<h3 id="5-7-Golang-GC-Pacer"><a href="#5-7-Golang-GC-Pacer" class="headerlink" title="5.7 Golang GC Pacer"></a>5.7 Golang GC Pacer</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-e5d325ee3dbdf9b2911520651798a872_r.jpg"></p>
<p>大家对并发 GC 除了怎么保证不漏指针有疑问外, 可能还会疑问, 并发 GC 如何保证能够跟得上应用程序的分配速度? 会不会分配太快了, GC 完全跟不上, 然后 OOM?</p>
<p>这个就是 Golang GC Pacer 的作用.</p>
<p>Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 以此类推.</p>
<p>假如上一次 GC 完成时, 存活对象 1000M, 默认 GOGC 100, 那么下次 GC 会在比较接近但小于 2000M 的时候 (比如 1900M) 开始, 争取在堆大小达到 2000M 的时候结束. 这之间留有一定的裕度, 会计算待扫描对象大小 (根据历史数据计算) 与可分配的裕度的比例, 应用程序分配内存根据该比例进行辅助 GC, 如果应用程序分配太快了, 导致 credit 不够, 那么会被阻塞, 直到后台的 mark 跟上来了, 该比例会随着 GC 进行不断调整.</p>
<p>GC 结束后, 会根据这一次 GC 的情况来进行负反馈计算, 计算下一次 GC 开始的阈值.</p>
<p>如何保证按时完成 GC 呢? GC 完了后, 所有的 mspan 都需要 sweep, 类似于 GC 的比例, 从 GC 结束到下一次 GC 开始之间有一定的堆分配裕度, 会根据还有多少的内存需要清扫, 来计算分配内存时需要清扫的 span 数这样的一个比例.</p>
<h3 id="5-8-未涉及到的点"><a href="#5-8-未涉及到的点" class="headerlink" title="5.8 未涉及到的点"></a>5.8 未涉及到的点</h3><ul>
<li>栈分配</li>
<li>fixalloc, tinyalloc</li>
<li>逃逸分析</li>
<li>内存归还</li>
<li>清扫与辅助清扫</li>
<li>go gc mark任务分配</li>
<li>辅助标记</li>
<li>revise</li>
<li>mark termination流程</li>
<li>GC Pacer, trigger计算, goal计算</li>
</ul>
<h2 id="6-实践与总结"><a href="#6-实践与总结" class="headerlink" title="6 实践与总结"></a>6 实践与总结</h2><h3 id="6-1-观察调度"><a href="#6-1-观察调度" class="headerlink" title="6.1 观察调度"></a>6.1 观察调度</h3><p>通过godoc来开启一个go进程, 加上debug trace观察其状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加上scheddetail=1观察更详细信息</span></span><br><span class="line">$ GOMAXPROCS=8 GODEBUG=schedtrace=500 godoc -http=:6060</span><br></pre></td></tr></table></figure>

<p>用ab来调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c 1000 -n 100000 <span class="string">&#x27;http://localhost:6060/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>godoc输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SCHED 40440ms: gomaxprocs=8 idleprocs=8 threads=19 spinningthreads=0 idlethreads=15 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 40946ms: gomaxprocs=8 idleprocs=6 threads=19 spinningthreads=1 idlethreads=14 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 41452ms: gomaxprocs=8 idleprocs=7 threads=19 spinningthreads=0 idlethreads=14 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 41962ms: gomaxprocs=8 idleprocs=6 threads=19 spinningthreads=0 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 42470ms: gomaxprocs=8 idleprocs=6 threads=19 spinningthreads=1 idlethreads=12 runqueue=0 [0 0 0 0 5 0 0 0]</span><br><span class="line">SCHED 42973ms: gomaxprocs=8 idleprocs=7 threads=19 spinningthreads=1 idlethreads=14 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 43483ms: gomaxprocs=8 idleprocs=6 threads=19 spinningthreads=0 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 43991ms: gomaxprocs=8 idleprocs=5 threads=19 spinningthreads=2 idlethreads=13 runqueue=0 [0 0 0 0 0 0 6 0]</span><br><span class="line">SCHED 44492ms: gomaxprocs=8 idleprocs=0 threads=19 spinningthreads=2 idlethreads=8 runqueue=1 [5 0 0 0 0 0 4 0]</span><br><span class="line">SCHED 45002ms: gomaxprocs=8 idleprocs=0 threads=19 spinningthreads=4 idlethreads=8 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 45507ms: gomaxprocs=8 idleprocs=0 threads=19 spinningthreads=0 idlethreads=8 runqueue=84 [18 43 16 1 0 4 4 1]</span><br><span class="line">SCHED 46014ms: gomaxprocs=8 idleprocs=2 threads=19 spinningthreads=2 idlethreads=9 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 46514ms: gomaxprocs=8 idleprocs=6 threads=19 spinningthreads=1 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 47021ms: gomaxprocs=8 idleprocs=0 threads=19 spinningthreads=3 idlethreads=8 runqueue=0 [0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>

<p>观察一下调度, 加一些请求. 我们可以看到虽然有 1000 个连接, 但是 go 只用了几个线程就能处理了, 表明 go 的网络的确是由 epoll 管理的. runqueue 表示的是全局队列待运行协程数量, 后面的数字表示每个 P 上的待运行协程数. 可以看到待处理的任务并没有增加, 表示虽然请求很多, 但完全能 hold 住.</p>
<p>同时可以看到, 不同 P 上有的时候可能任务不均衡, 但是一会后, 任务又均衡了, 表示 go 的 work stealing 是有效的.</p>
<h3 id="6-2-观察-GC"><a href="#6-2-观察-GC" class="headerlink" title="6.2 观察 GC"></a>6.2 观察 GC</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-596836ab3923ed21c32a4a961264d7d8_r.jpg"></p>
<p>其中一些数据的含义, 在分享的时候没有怎么解释, 不过网上的解释几乎没有能完全解释正确. 我这里敲一下.<br>其实一般关注堆大小和两个 stw 的 wall time 即可.</p>
<blockquote>
<p>gc 8913(第 8913 次 gc)<br>@2163.341s(在程序运行的第 2163s)<br>1%(gc 所有 work 消耗的历史累计 CPU 比例, 所以其实这个数据没太大意义)<br>0.13(第一个 stw 的 wall time)<br>+14(并发 mark 的 wall time)<br>+0.20(第二个 stw 的 wall time) ms clock,<br>1.1(第一个 stw 消耗的 CPU 时间)<br>+21(用户程序辅助扫描消耗的 cpu 时间)<br>&#x2F;22(分配用于 mark 的 P 消耗的 cpu 时间)<br>&#x2F;0(空闲的 P 用于 mark 的 cpu 时间<br>)+1.6ms(第 2 个 stw 的 cpu 时间)<br>cpu, 147(gc 开始时的堆大小)<br>-&gt;149(gc 结束的堆大小)<br>-&gt;75MB(gc 结束时的存活堆大小)<br>151 MB goal(本次 gc 预计结束的堆大小)<br>8P(8 个 P).</p>
</blockquote>
<h3 id="6-3-优化"><a href="#6-3-优化" class="headerlink" title="6.3 优化"></a>6.3 优化</h3><p>个人建议, 没事不要总想着优化, 好好 curd 就好.</p>
<p>一些优化(写业务时用不到就算了)<br><strong>GODEBUG, GOMAXPROCS, GOGC</strong></p>
<p><strong>涉及文件, CGO较多的程序</strong><br>可以将P增大几个.<br>runtime.GOMAXPROCS(GOMAXPROCS(0)+1)</p>
<p><strong>协程池的重要性远没有Java, CPP中线程池那么重要.</strong><br>协程的生成不涉及系统调用, 需要的栈资源也很少. 同时P和全局都做了dead G的缓存. 协程池实现的不好, 反而因为协程池里的一把锁影响了扩展性. 至于并发控制, 保护其他资源, 可以选用其他方式. </p>
<p><strong>什么时候需要协程池?</strong><br>主要还是隔离减少栈扩容和缩容. 有些场景下栈扩容和缩容消耗CPU(可结合pprof查看morestack)的确比较多. 比如长连接, 大量维持连接的协程可以不用扩容栈, 复杂任务交给任务协程处理, 此类协程的数量比较少.</p>
<p><strong>GOGC&#x3D;200或更多</strong><br>GC Pacer会根据GC情况和GOGC参数来计算gc trigger, 增大GOGC, 可降低GC频率, 注意, 会增加触发GC的堆大小.</p>
<p><strong>sync.Pool</strong><br>对于频繁分配的对象, 可以使用sync.Pool, 减少分配频次, 进而降低GC频率 (1.13对sync.Pool进行了优化)</p>
<p><strong>全局缓存对象有大量的key的情况</strong><br>value少用指针GC并发Mark需要mark存活的对象, 如果value里指针多, 导致mark消耗的CPU很大, 使用一个struct内嵌数据消除指针. </p>
<p><strong>一点点拷贝胜过传指针</strong><br>对象在栈上分配, 减少GC频率.</p>
<p><strong>慎用[]byte和string的magic</strong><br>仅用在不会修改的地方</p>
<p><strong>slice和map的容量初始化</strong><br>减少不断加元素时的扩容</p>
<p><strong>json-iterator替换encoding&#x2F;json</strong><br>等等</p>
<p><strong>框架或模板集成gops及默认开启pprof</strong><br>往往有问题才想起没引入pprof, 无法查看stack, 又需要保留现场. 服务模板代码默认引入一个库开启pprof, 集成到服务列表页. 有问题, 点一点, 通过一个agent, 直接获取idc机器上服务的pprof图.<br><strong>服务模板默认引入一个库封装gops</strong><br>gops:&#x3D;golang版( jps + jstack + jstat + jinfo )<br><a target="_blank" rel="noopener" href="https://github.com/google/gops">https://github.com/google/gops</a><br>gops和pprof占用的端口根据服务端口+1, +2.<br>我们将 pprof 的开启集成到模板中, 并自动选择端口, 并集成了 gops 工具, 方便查询 runtime 信息, 同时在浏览器上可直接点击生成火焰图, pprof 图, 非常的方便, 也不需要使用者关心.</p>
<h3 id="6-4-问题排查的一点思路"><a href="#6-4-问题排查的一点思路" class="headerlink" title="6.4 问题排查的一点思路"></a>6.4 问题排查的一点思路</h3><ol>
<li>内存慢慢增长OOM<br>结合memory inuse_space的pprof和list, 加上源码流程即可定位出. 一直把新对象放到全局对象或者长生命周期对象中. 比如长连接, 连接池应用或者忘记closehttp resp body, sql Stmt等. </li>
<li>内存突增OOM<br>如果多次分配才OOM, 可使用方法1排查. 对于一次就OOM的, 比较难抓, 可结合go无法分配内存时<br>throw输出的协程栈排查. 比如没有校验参数, 调用者填错或恶意, 使用传过来的length<br>来进行make([]byte, length)用于编解码</li>
<li>性能问题<br>结合火焰图, 查看影响性能的热点部分, 进行优化,GC频繁, 编解码效率低等.</li>
</ol>
<h3 id="6-5-一次有意思的问题排查"><a href="#6-5-一次有意思的问题排查" class="headerlink" title="6.5 一次有意思的问题排查"></a>6.5 一次有意思的问题排查</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-8360b4e634560ca5ac314b7b76181b98_r.jpg"></p>
<p>负载, 依赖服务都很正常, CPU 利用率也不高, 请求也不多, 就是有很多超时.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-8a0e06b128b6f2316d8462b9dbc30e0b_r.jpg"></p>
<p>该服务在线上打印了 debug 日志, 因为早期的服务模板开启了 gctrace, 框架把 stdout 重定向到一个文件了. 而输出 gctrace 时本来是到 console 的, 输出到文件了, 而磁盘跟不上, 导致 gctrace 日志被阻塞了.</p>
<p>这里更正一下 ppt 中的内容, 并不是因为 gc 没完成而导致其他协程不能运行, 而是后续 gc 无法开启, 导致实质上的 stw.  打印 gc trace 日志时, 已经 start the world 了, 其他协程可以开始运行了. 但是在打印 gctrace 日志时, 还保持着开启 gc 需要的锁, 所以, 打印 gc trace 日志一直没完成, 而 gc 又比较频繁, 比如 0.1s 一次, 这样会导致下一次 gc 开始时无法获取锁, 每一个进入 gc 检查的 p 阻塞, 实际上就造成了 stw.</p>
<h2 id="7-Runtime-的一点个人总结"><a href="#7-Runtime-的一点个人总结" class="headerlink" title="7 Runtime 的一点个人总结"></a>7 Runtime 的一点个人总结</h2><table>
<thead>
<tr>
<th>思想</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>并行</td>
<td>减少操作的wall time和阻塞</td>
<td>stw mark -&gt; concurrent mark, stw stack scan, shrink-&gt; 并发mark阶 段的逐个g 等</td>
</tr>
<tr>
<td>纵向多层次</td>
<td>尽量减少锁竞争和冲突.<br /> Per-P无锁 -&gt; 粒度范围比较小的锁-&gt;最后 才全局和系统调用</td>
<td>调度findrunnable, 内存分配mallocgc, stack分配等</td>
</tr>
<tr>
<td>横向多个class</td>
<td>找到最适配的, 减少内存浪费和碎片</td>
<td>tinyalloc, 内存分配span机制, 多个 class的stack分配等</td>
</tr>
<tr>
<td>缓存</td>
<td>减少重新申请</td>
<td>sync.Pool, per-P的mcache, deadg的 free list等, 延缓释放归还给mheap的 pages</td>
</tr>
<tr>
<td>缓冲</td>
<td>放入队列, 减少阻塞, 操作异步化</td>
<td>写屏障的wbBuf, GC标记队列</td>
</tr>
<tr>
<td>均衡</td>
<td>负载均衡, 不会因为work太多的而成为瓶颈</td>
<td>调度时从全局runq获取, 从其他P进行 work stealing; GC标记工作的本地和全 局之间的flush和get.</td>
</tr>
</tbody></table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>描述并发正确性和happens before规则 <a target="_blank" rel="noopener" href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> </li>
<li>Scalable Go Scheduler Design Doc GM模型转为GPM模型 <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw</a> </li>
<li>Go Preemptive Scheduler Design Doc Golang支持对运行Go代码的协程进行协作式抢占调度 <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h">https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h</a> </li>
<li>Contiguous stacks 将之前的分裂栈改为连续栈, 大大减少链式栈的创建和destory带来的性能消耗. <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub">https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub</a> </li>
<li>Golang调度器源码分析 <a target="_blank" rel="noopener" href="https://colobu.com/2017/05/04/golang-runtime-scheduler/">https://colobu.com/2017/05/04/golang-runtime-scheduler/</a> </li>
<li>也谈goroutine调度器 <a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a> </li>
<li>Golang 内存管理 <a target="_blank" rel="noopener" href="http://legendtkl.com/2017/04/02/golang-alloc/">http://legendtkl.com/2017/04/02/golang-alloc/</a> </li>
<li>runtime: decentralize concurrent sweep termination GC状态检测由集中式改为分布到多个协程 <a target="_blank" rel="noopener" href="https://go-review.googlesource.com/c/go/+/16391/8">https://go-review.googlesource.com/c/go/+/16391/8</a> </li>
<li>Getting to Go: The Journey of Go’s Garbage Collector <a target="_blank" rel="noopener" href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a> </li>
<li>复盘 GC 算法的发展历程及现状 <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/development-history-and-current-situation-of-gc-algorithm">https://www.infoq.cn/article/development-history-and-current-situation-of-gc-algorithm</a> </li>
<li>Go 1.5 concurrent garbage collector pacing <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU3EQBI6BK6KgtiFArkG47XK73xIQ/edit#">https://docs.google.com/document/d/1wmjrocXIWTr1JxU3EQBI6BK6KgtiFArkG47XK73xIQ/edit#</a> </li>
<li>Proposal: Eliminate STW stack re-scanning 1.8消除栈重新扫描, 进入sub ms <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a> </li>
<li>twitter golang服务的不同版本golang gc时间对比 <a target="_blank" rel="noopener" href="https://twitter.com/brianhatfield/status/634166123605331968">https://twitter.com/brianhatfield/status/634166123605331968</a> </li>
<li>Golang源码探索(三) GC的实现原理 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/7880099.html">https://www.cnblogs.com/zkweb/p/7880099.html</a></li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/')">go runtime 精讲</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=go runtime 精讲&amp;url=https://shippomx.github.io/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/go/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>go<span class="tagsPageCount">11</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/12/golang/Go%20package%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go package的组织方式</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/01/linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%BB%8B%E7%BB%8D/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程间通信IPC简介</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2020/09/01/golang/20%E5%BC%A0%E5%8A%A8%E5%9B%BE%E4%B8%BA%E4%BD%A0%E6%BC%94%E7%A4%BAGo%E5%B9%B6%E5%8F%91/" title="20 张动图演示 Go 并发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-09-01</div><div class="title">20 张动图演示 Go 并发</div></div></a></div><div><a href="/2020/07/11/golang/GO%20delve(dlv)%20%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" title="go dlv使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-07-11</div><div class="title">go dlv使用</div></div></a></div><div><a href="/2020/07/12/golang/Go%20package%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/" title="Go package的组织方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-07-12</div><div class="title">Go package的组织方式</div></div></a></div><div><a href="/2018/07/06/golang/Golang%20%E9%A2%98%E7%9B%AE/" title="一些go的笔试题目"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2018-07-06</div><div class="title">一些go的笔试题目</div></div></a></div><div><a href="/2019/05/28/golang/golang-tls-%E5%AE%9E%E7%8E%B0/" title="GolangTLS的实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2019-05-28</div><div class="title">GolangTLS的实现</div></div></a></div><div><a href="/2020/02/23/golang/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" title="Go语言常见内存泄露"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-02-23</div><div class="title">Go语言常见内存泄露</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">0 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">1 序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8E%BB%E4%BA%86%E8%A7%A3-runtime-%E5%91%A2"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 为什么去了解 runtime 呢?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Runtime-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%8F%91%E5%B1%95"><span class="toc-number">3.</span> <span class="toc-text">2 Runtime 简介及发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Runtime-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Runtime 简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">3调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%B0%83%E5%BA%A6%E7%AE%80%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3.1调度简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-goroutine-%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 goroutine 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8D%8F%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%88%87%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 协程结构体和切换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-GM-%E6%A8%A1%E5%9E%8B%E5%8F%8A-GPM-%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 GM 模型及 GPM 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%8D%8F%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E6%B5%81%E8%BD%AC"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 协程状态及流转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-go-routine%E8%B0%83%E5%BA%A6"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 go routine调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-sysmon-%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 sysmon 协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%8D%8F%E4%BD%9C%E5%BC%8F%E6%8A%A2%E5%8D%A0"><span class="toc-number">4.8.</span> <span class="toc-text">3.8 协作式抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.</span> <span class="toc-text">3.9 同步执行流不阻塞线程的网络的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.10.</span> <span class="toc-text">3.10 调度相关结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E8%B0%83%E5%BA%A6%E6%80%BB%E7%BB%93"><span class="toc-number">4.11.</span> <span class="toc-text">3.11 调度总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E6%9C%AA%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%82%B9"><span class="toc-number">4.12.</span> <span class="toc-text">3.12 未涉及到的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.</span> <span class="toc-text">4 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 内存分配简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 内存空间结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-span-%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 span 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%85%A8%E6%99%AF"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 内存分配全景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 几种特殊的分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%80%BB%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 内存分配总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-GC"><span class="toc-number">6.</span> <span class="toc-text">5 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Golang-GC-%E7%AE%80%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Golang GC 简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-GC-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 GC 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-GC%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">6.3.</span> <span class="toc-text">5.3  GC相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-GC%E5%85%B3%E5%BF%83%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">5.4  GC关心什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Golang-GC-%E5%8F%91%E5%B1%95"><span class="toc-number">6.5.</span> <span class="toc-text">5.5  Golang GC 发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-number">6.6.</span> <span class="toc-text">5.5 三色标记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.5.1 写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-%E4%B8%89%E8%89%B2%E7%8A%B6%E6%80%81"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.5.2 三色状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-%E6%89%AB%E6%8F%8F%E5%92%8C%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.5.3 扫描和元信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-GC-%E6%B5%81%E7%A8%8B"><span class="toc-number">6.7.</span> <span class="toc-text">5.6 GC 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Golang-GC-Pacer"><span class="toc-number">6.8.</span> <span class="toc-text">5.7 Golang GC Pacer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E6%9C%AA%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%82%B9"><span class="toc-number">6.9.</span> <span class="toc-text">5.8 未涉及到的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">6 实践与总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%A7%82%E5%AF%9F%E8%B0%83%E5%BA%A6"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 观察调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%A7%82%E5%AF%9F-GC"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 观察 GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 问题排查的一点思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E4%B8%80%E6%AC%A1%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 一次有意思的问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Runtime-%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">7 Runtime 的一点个人总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">9.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/06/linux/systemtap/systemtap%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E8%B0%83%E8%AF%95/" title="无题">无题</a><time datetime="2024-02-06T07:02:06.421Z" title="发表于 2024-02-06 15:02:06">2024-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/05/linux/systemtap/systemtap%E8%BF%BD%E8%B8%AA%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E7%9A%84%E6%A8%A1%E5%9D%97/" title="无题">无题</a><time datetime="2024-02-05T07:43:59.587Z" title="发表于 2024-02-05 15:43:59">2024-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/02/linux/systemtap/systemtap%E7%9B%B8%E5%85%B3/" title="无题">无题</a><time datetime="2024-02-02T08:46:10.322Z" title="发表于 2024-02-02 16:46:10">2024-02-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/03/C-C++%EF%BC%9AUDP%20IPv4%20IPv6%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20&amp;%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%20%E7%AE%80%E4%BE%8B_c++%20%E5%AE%89%E5%8D%93%20ipv6%20nativefd%20=%20socket(af_inet6,%20sock_dgram-CSDN%20%E5%8D%9A%E5%AE%A2%20/" title="无题">无题</a><time datetime="2024-01-03T02:16:23.591Z" title="发表于 2024-01-03 10:16:23">2024-01-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/02/golang/Go%20GC%20%E6%BC%94%E8%BF%9B%E5%8F%B2%20/" title="无题">无题</a><time datetime="2024-01-02T05:38:04.946Z" title="发表于 2024-01-02 13:38:04">2024-01-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>23</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>