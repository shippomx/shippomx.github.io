<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>远辰 | 远辰</title><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="远辰"><meta name="application-name" content="远辰"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="远辰"><meta property="og:url" content="https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="Linux 内核内存管理子系统源码解析  从本文开始我们就正式开启了 Linux 内核内存管理子系统源码解析系列，笔者还是会秉承之前系列文章的风格，采用一步一图的方式先是详细介绍相关原理，在保证大家清晰理解原理的基础上，我们再来一步一步的解析相关内核源码的实现。有了源码的辅证，这样大家看得也安心，理"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Linux 内核内存管理子系统源码解析  从本文开始我们就正式开启了 Linux 内核内存管理子系统源码解析系列，笔者还是会秉承之前系列文章的风格，采用一步一图的方式先是详细介绍相关原理，在保证大家清晰理解原理的基础上，我们再来一步一步的解析相关内核源码的实现。有了源码的辅证，这样大家看得也安心，理"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: '远辰',
  postAI: '',
  pageFillDescription: '4.1 32 位机器上进程虚拟内存空间分布, 4.2 64 位机器上进程虚拟内存空间分布, 5.1 内核如何划分用户态和内核态虚拟内存空间, 5.2 内核如何布局进程虚拟内存空间, 5.3 内核如何管理虚拟内存区域, 5.4 定义虚拟内存区域的访问权限和行为规范, 5.5 关联内存映射中的映射关系, 5.6 针对虚拟内存区域的相关操作, 5.7 虚拟内存区域在内核中是如何被组织的, 7.1 32 位体系内核虚拟内存空间布局, 7.1.1 直接映射区, 7.1.2  ZONE_HIGHMEM 高端内存, 7.1.3 vmalloc 动态映射区, 7.1.4 永久映射区, 8.1.5 固定映射区, 7.1.6  临时映射区, 7.1.7 32 位体系结构下 Linux 虚拟内存空间整体布局, 7.2 64 位体系内核虚拟内存空间布局, 7.2.1 64 位体系结构下 Linux 虚拟内存空间整体布局, 8.1 DRAM 芯片的访问, 8.2 CPU 如何读写主存, 8.3 CPU 从内存读取数据过程, 8.4 如何根据物理内存地址从主存中读取数据, 8.5 CPU 向内存写入数据过程, 总结内核内存管理子系统源码解析从本文开始我们就正式开启了内核内存管理子系统源码解析系列笔者还是会秉承之前系列文章的风格采用一步一图的方式先是详细介绍相关原理在保证大家清晰理解原理的基础上我们再来一步一步的解析相关内核源码的实现有了源码的辅证这样大家看得也安心理解起来也放心最起码可以证明笔者没有胡编乱造骗大家哈哈内存管理子系统可谓是内核众多子系统中最为复杂最为庞大的一个其中包含了众多繁杂的概念和原理通过内存管理这条主线我们把可以把操作系统的众多核心系统给拎出来比如进程管理子系统网络子系统文件子系统等由于内存管理子系统过于复杂庞大其中涉及到的众多繁杂的概念又是一环套一环层层递进如何把这些繁杂的概念具有层次感地并且清晰地给大家梳理呈现出来真是一件比较有难度的事情因此关于这个问题笔者在动笔写这个内存管理源码解析系列之前也是思考了很久万事开头难那么到底什么内容适合作为这个系列的开篇呢笔者还是觉得从大家日常开发工作中接触最多最为熟悉的部分开始比较好比如在我们日常开发中创建的类调用的函数在函数中定义的局部变量以及出来的数据容器等都需要存储在物理内存中的某个角落而我们在程序中编写业务逻辑代码的时候往往需要引用这些创建出来的数据结构并通过这些引用对相关数据结构进行业务处理当程序运行起来之后就变成了进程而这些业务数据结构的引用在进程的视角里全都都是虚拟内存地址因为进程无论是在用户态还是在内核态能够看到的都是虚拟内存空间物理内存空间被操作系统所屏蔽进程是看不到的进程通过虚拟内存地址访问这些数据结构的时候虚拟内存地址会在内存管理子系统中被转换成物理内存地址通过物理内存地址就可以访问到真正存储这些数据结构的物理内存了随后就可以对这块物理内存进行各种业务操作从而完成业务逻辑那么到底什么是虚拟内存地址内核为啥要引入虚拟内存而不直接使用物理内存虚拟内存空间到底长啥样内核如何管理虚拟内存什么又是物理内存地址如何访问物理内存本文笔者就来为大家详细一一解答上述几个问题让我们马上开始吧本文概要到底什么是虚拟内存地址首先人们提出地址这个概念的目的就是用来方便定位现实世界中某一个具体事物的真实地理位置它是一种用于定位的概念模型举一个生活中的例子比如大家在日常生活中给亲朋好友邮寄一些本地特产时都会填写收件人地址以及寄件人地址以及在日常网上购物时都会在相应电商中填写自己的收获地址随后快递小哥就会根据我们填写的收货地址找到我们的真实住所将我们网购的商品送达到我们的手里收货地址是用来定位我们在现实世界中真实住所地理位置的而现实世界中我们所在的城市街道小区房屋都是一砖一瓦一草一木真实存在的但收货地址这个概念模型在现实世界中并不真实存在它只是人们提出的一个虚拟概念通过收货地址这个虚拟概念将它和现实世界真实存在的城市小区街道的地理位置一一映射起来这样我们就可以通过这个虚拟概念来找到现实世界中的具体地理位置综上所述收货地址是一个虚拟地址它是人为定义的而我们的城市小区街道是真实存在的他们的地理位置就是物理地址比如现在的广东省深圳市在过去叫宝安县河北省的石家庄过去叫常山安徽省的合肥过去叫泸州不管是常山也好石家庄也好又或是合肥也好泸州也罢这些都是人为定义的名字而已但是地方还是那个地方它所在的地理位置是不变的也就说虚拟地址可以人为的变来变去但是物理地址永远是不变的现在让我们把视角在切换到计算机的世界在计算机的世界里内存地址用来定义数据在内存中的存储位置的内存地址也分为虚拟地址和物理地址而虚拟地址也是人为设计的一个概念类比我们现实世界中的收货地址而物理地址则是数据在物理内存中的真实存储位置类比现实世界中的城市街道小区的真实地理位置说了这么多那么到底虚拟内存地址长什么样子呢我们还是以日常生活中的收货地址为例做出类比我们都很熟悉收货地址的格式省市区街道小区室它是按照地区层次递进的同样在计算机世界中的虚拟内存地址也有这样的递进关系这里我们以处理器为例位虚拟地址的格式为全局页目录项位上层页目录项位中间页目录项位页表项位页内偏移位共位组成的虚拟内存地址虚拟内存地址中的全局页目录项就类比我们日常生活中收获地址里的省上层页目录项就类比市中间层页目录项类比区县页表项类比街道小区页内偏移类比我们所在的楼栋和几层几号这里大家只需要大体明白虚拟内存地址到底长什么样子它的格式是什么能够和日常生活中的收货地址对比理解起来就可以了至于页目录项页表项以及页内偏移这些计算机世界中的概念大家暂时先不用管后续文章中笔者会慢慢给大家解释清楚位虚拟地址的格式为页目录项位页表项位页内偏移位共位组成的虚拟内存地址进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节为什么要使用虚拟地址访问内存经过第一小节的介绍我们现在明白了计算机世界中的虚拟内存地址的含义及其展现形式那么大家可能会问了既然物理内存地址可以直接定位到数据在内存中的存储位置那为什么我们不直接使用物理内存地址去访问内存而是选择用虚拟内存地址去访问内存呢在回答大家的这个疑问之前让我们先来看下如果在程序中直接使用物理内存地址会发生什么情况假设现在没有虚拟内存地址我们在程序中对内存的操作全都都是使用物理内存地址在这种情况下程序员就需要精确的知道每一个变量在内存中的具体位置我们需要手动对物理内存进行布局明确哪些数据存储在内存的哪些位置除此之外我们还需要考虑为每个进程究竟要分配多少内存内存紧张的时候该怎么办如何避免进程与进程之间的地址冲突等等一系列复杂且琐碎的细节如果我们在单进程系统中比如嵌入式设备上开发应用程序系统中只有一个进程这单个进程独享所有的物理资源包括内存资源在这种情况下上述提到的这些直接使用物理内存的问题可能还好处理一些但是仍然具有很高的开发门槛然而在现代操作系统中往往支持多个进程需要处理多进程之间的协同问题在多进程系统中直接使用物理内存地址操作内存所带来的上述问题就变得非常复杂了这里笔者为大家举一个简单的例子来说明在多进程系统中直接使用物理内存地址的复杂性比如我们现在有这样一个简单的程序在程序代码相同的情况下我们用这份代码同时启动三个进程我们暂时将进程依次命名为这三个进程用到的代码是一样的都是我们提前写好的可以被多次运行由于我们是直接操作物理内存地址假设变量保存在这个物理地址上这三个进程运行起来之后同时操作这个物理地址这样这个变量的值不就混乱了吗三个进程就会出现变量的地址冲突所以在直接操作物理内存的情况下我们需要知道每一个变量的位置都被安排在了哪里而且还要注意和多个进程同时运行的时候不能共用同一个地址否则就会造成地址冲突现实中一个程序会有很多的变量和函数这样一来我们给它们都需要计算一个合理的位置还不能与其他进程冲突这就很复杂了那么我们该如何解决这个问题呢程序的局部性原理再一次救了我们程序局部性原理表现为时间局部性和空间局部性时间局部性是指如果程序中的某条指令一旦执行则不久之后该指令可能再次被执行如果某块数据被访问则不久之后该数据可能再次被访问空间局部性是指一旦程序访问了某个存储单元则不久之后其附近的存储单元也将被访问从程序局部性原理的描述中我们可以得出这样一个结论进程在运行之后对于内存的访问不会一下子就要访问全部的内存相反进程对于内存的访问会表现出明显的倾向性更加倾向于访问最近访问过的数据以及热点数据附近的数据根据这个结论我们就清楚了无论一个进程实际可以占用的内存资源有多大根据程序局部性原理在某一段时间内进程真正需要的物理内存其实是很少的一部分我们只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转而虚拟内存的引入正是要解决上述的问题虚拟内存引入之后进程的视角就会变得非常开阔每个进程都拥有自己独立的虚拟地址空间进程与进程之间的虚拟内存地址空间是相互隔离互不干扰的每个进程都认为自己独占所有内存空间自己想干什么就干什么系统上还运行了哪些进程和我没有任何关系这样一来我们就可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理极大地解放了程序员的心智负担这一切都是因为虚拟内存能够提供内存地址空间的隔离极大地扩展了可用空间这样进程就以为自己独占了整个内存空间资源给进程产生了所有内存资源都属于它自己的幻觉这其实是和操作系统使用的一个障眼法罢了任何一个虚拟内存里所存储的数据本质上还是保存在真实的物理内存里的只不过内核帮我们做了虚拟内存到物理内存的这一层映射将不同进程的虚拟地址和不同内存的物理地址映射起来当访问进程的虚拟地址时经过地址翻译硬件将虚拟地址转换成不同的物理地址这样不同的进程运行的时候虽然操作的是同一虚拟地址但其实背后写入的是不同的物理地址这样就不会冲突了进程虚拟内存空间上小节中我们介绍了为了防止多进程运行时造成的内存地址冲突内核引入了虚拟内存地址为每个进程提供了一个独立的虚拟内存空间使得进程以为自己独占全部内存资源那么这个进程独占的虚拟内存空间到底是什么样子呢在本小节中笔者就为大家揭开这层神秘的面纱在本小节内容开始之前我们先想象一下如果我们是内核的设计人员我们该从哪些方面来规划进程的虚拟内存空间呢本小节我们只讨论进程用户态虚拟内存空间的布局我们先把内核态的虚拟内存空间当做一个黑盒来看待在后面的小节中笔者再来详细介绍内核态相关内容首先我们会想到的是一个进程运行起来是为了执行我们交代给进程的工作执行这些工作的步骤我们通过程序代码事先编写好然后编译成二进制文件存放在磁盘中会执行二进制文件中的机器码来驱动进程的运行所以在进程运行之前这些存放在二进制文件中的机器码需要被加载进内存中而用于存放这些机器码的虚拟内存空间叫做代码段在程序运行起来之后总要操作变量吧在程序代码中我们通常会定义大量的全局变量和静态变量这些全局变量在程序编译之后也会存储在二进制文件中在程序运行之前这些全局变量也需要被加载进内存中供程序访问所以在虚拟内存空间中也需要一段区域来存储这些全局变量那些在代码中被我们指定了初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做数据段那些没有指定初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做段这些未初始化的全局变量被加载进内存之后会被初始化为值上面介绍的这些全局变量和静态变量都是在编译期间就确定的但是我们程序在运行期间往往需要动态的申请内存所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存这块区域就叫做堆注意这里的堆指的是堆并不是中的堆除此之外我们的程序在运行过程中还需要依赖动态链接库这些动态链接库以文件的形式存放在磁盘中比如程序中的里边对系统调用进行了封装库里提供的用于动态申请堆内存的函数就是对系统调用和的封装这些动态链接库也有自己的对应的代码段数据段段也需要一起被加载进内存中还有用于内存文件映射的系统调用会将文件与内存进行映射那么映射的这块内存虚拟内存也需要在虚拟地址空间中有一块区域存储这些动态链接库中的代码段数据段段以及通过系统调用映射的共享内存区在虚拟内存空间的存储区域叫做文件映射与匿名映射区最后我们在程序运行的时候总该要调用各种函数吧那么调用函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存这一块区域在虚拟内存空间中叫做栈现在进程的虚拟内存空间所包含的主要区域笔者就为大家介绍完了我们看到内核根据进程运行的过程中所需要不同种类的数据而为其开辟了对应的地址空间分别为用于存放进程程序二进制文件中的机器指令的代码段用于存放程序二进制文件中定义的全局变量和静态变量的数据段和段用于在程序运行过程中动态申请内存的堆用于存放动态链接库以及内存映射区域的文件映射与匿名映射区用于存放函数调用过程中的局部变量和函数参数的栈以上就是我们通过一个程序在运行过程中所需要的数据所规划出的虚拟内存空间的分布这些只是一个大概的规划那么在真实的系统中进程的虚拟内存空间的具体规划又是如何的呢我们接着往下看进程虚拟内存空间在上小节中我们介绍了进程虚拟内存空间中各个内存区域的一个大概分布在此基础之上本小节笔者就带大家分别从位和位机器上看下在系统中进程虚拟内存空间的真实分布情况位机器上进程虚拟内存空间分布在位机器上指针的寻址范围为所能表达的虚拟内存空间为所以在位机器上进程的虚拟内存地址范围为其中用户态虚拟内存空间为虚拟内存地址范围为内核态虚拟内存空间为虚拟内存地址范围为但是用户态虚拟内存空间中的代码段并不是从地址开始的而是从地址开始到这段虚拟内存地址是一段不可访问的保留区因为在大多数操作系统中数值比较小的地址通常被认为不是一个合法的地址这块小地址是不允许访问的比如在语言中我们通常会将一些无效的指针设置为指向这块不允许访问的地址保留区的上边就是代码段和数据段它们是从程序的二进制文件中直接加载进内存中的段中的数据也存在于二进制文件中因为内核知道这些数据是没有初值的所以在二进制文件中只会记录段的大小在加载进内存时会生成一段填充的内存空间紧挨着段的上边就是我们经常使用到的堆空间从图中的红色箭头我们可以知道在堆空间中地址的增长方向是从低地址到高地址增长内核中使用标识堆的起始位置标识堆当前的结束位置当堆申请新的内存空间时只需要将指针增加对应的大小回收地址时减少对应的大小即可比如当我们通过向内核申请很小的一块内存时之内就是通过改变位置实现的堆空间的上边是一段待分配区域用于扩展堆空间的使用接下来就来到了文件映射与匿名映射区域进程运行时所依赖的动态链接库中的代码段数据段段就加载在这里还有我们调用映射出来的一段虚拟内存空间也保存在这个区域注意在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长接下来用户态虚拟内存空间的最后一块区域就是栈空间了在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息栈空间中的地址增长方向是从高地址向低地址增长每次进程申请新的栈地址时其地址值是在减少的在内核中使用标识栈的起始位置寄存器中保存栈顶指针寄存器中保存的是栈基地址在栈空间的下边也有一段待分配区域用于扩展栈空间在栈空间的上边就是内核空间了进程虽然可以看到这段内核空间地址但是就是不能访问这就好比我们在饭店里虽然可以看到厨房在哪里但是厨房门上写着厨房重地闲人免进我们就是进不去位机器上进程虚拟内存空间分布上小节中介绍的位虚拟内存空间布局和本小节即将要介绍的位虚拟内存空间布局都可以通过或者来查看某个进程的实际虚拟内存布局我们知道在位机器上指针的寻址范围为所能表达的虚拟内存空间为那么我们理所应当的会认为在位机器上指针的寻址范围为所能表达的虚拟内存空间为虚拟内存地址范围为好家伙的内存空间笔者都没见过这么大的磁盘在现实情况中根本不会用到这么大范围的内存空间事实上在目前的位系统下只使用了位来描述虚拟内存空间寻址范围为所能表达的虚拟内存空间为其中低表示用户态虚拟内存空间虚拟内存地址范围为高表示内核态虚拟内存空间虚拟内存地址范围为这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段的地址空洞我们把这个空洞叫做空洞那么这个空洞是如何形成的呢我们都知道在位机器上的指针寻址范围为但是在实际使用中我们只使用了其中的低位来表示虚拟内存地址那么这多出的高位就形成了这个地址空洞大家注意到在低的用户态地址空间范围中所以虚拟内存地址的高位全部为如果一个虚拟内存地址的高位全部为那么我们就可以直接判断出这是一个用户空间的虚拟内存地址同样的道理在高的内核态虚拟内存空间范围中所以虚拟内存地址的高位全部为也就是说内核态的虚拟内存地址的高位全部为如果一个试图访问内核的虚拟地址的高位不全为则可以快速判断这个访问是非法的这个高位的空闲地址被称为如果虚拟内存地址中的高位全部为表示用户空间虚拟内存地址或者全部为表示内核空间虚拟内存地址这种地址的形式我们叫做对应的地址我们称作那么处于空洞范围内的地址的高位不全为也不全为如果某个虚拟地址落在这段空洞区域中那就是既不在用户空间也不在内核空间肯定是非法访问了未来我们也可以利用这块空洞来扩展虚拟内存地址的范围比如扩展到位在我们理解了这个概念之后我们再来看下位系统下的真实虚拟内存空间布局情况从上图中我们可以看出位系统中的虚拟内存布局和位系统中的虚拟内存布局大体上是差不多的主要不同的地方有三点就是前边提到的由高位空闲地址造成的空洞在这段范围内的虚拟内存地址是不合法的因为它的高位既不全为也不全为不是一个所以称之为空洞在代码段跟数据段的中间还有一段不可以读写的保护段它的作用是防止程序在读写数据段的时候越界访问到代码段这个保护段可以让越界访问行为直接崩溃防止它继续往下运行用户态虚拟内存空间与内核态虚拟内存空间分别占用其中低分配给用户态虚拟内存空间高分配给内核态虚拟内存空间进程虚拟内存空间的管理在上一小节中笔者为大家介绍了操作系统在位机器上和位机器上进程虚拟内存空间的布局分布我们发现无论是在位机器上还是在位机器上进程虚拟内存空间的核心区域分布的相对位置是不变的它们都包含下图所示的这几个核心内存区域唯一不同的是这些核心内存区域在位机器和位机器上的绝对位置分布会有所不同那么在此基础之上内核如何为进程管理这些虚拟内存区域呢这将是本小节重点为大家介绍的内容既然我们要介绍进程的虚拟内存空间管理那就离不开进程在内核中的描述符结构进程用于标识线程所属的进程进程打开的文件信息内存描述符表示进程虚拟地址空间省略在进程描述符结构中有一个专门描述进程虚拟地址空间的内存描述符结构这个结构体中包含了前边几个小节中介绍的进程虚拟内存空间的全部信息每个进程都有唯一的结构体也就是前边提到的每个进程的虚拟地址空间都是独立互不干扰的当我们调用函数创建进程的时候表示进程地址空间的结构会随着进程描述符的创建而创建省略省略为进程创建结构用父进程的资源填充信息省略随后会在函数中创建结构并拷贝父进程的相关资源到新进程的结构里其中就包括拷贝父进程的虚拟内存空间结构这里可以看出子进程在新创建出来之后它的虚拟内存空间是和父进程的虚拟内存空间一模一样的直接拷贝过来创建结构初始化子进程开始继承拷贝父进程资源继承父进程打开的文件描述符继承父进程所属的文件系统继承父进程注册的信号以及信号处理函数继承父进程的虚拟内存空间继承父进程的继承父进程的信息省略分配分配省略这里我们重点关注函数正是在这里完成了子进程虚拟内存空间结构的的创建以及初始化子进程虚拟内存空间父进程虚拟内存空间省略获取父进程虚拟内存空间省略通过或者系统调用创建出的子进程线程和父进程共享虚拟内存空间增加父进程虚拟地址空间的引用计数直接将父进程的虚拟内存空间赋值给子进程线程线程共享其所属进程的虚拟内存空间如果是系统调用创建出的子进程则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的结构中将拷贝出来的父进程虚拟内存空间赋值给子进程省略由于本小节中我们举的示例是通过函数创建子进程的情形所以这里大家先占时忽略这个条件判断逻辑我们先跳过往后看函数首先会将父进程的虚拟内存空间赋值给指针然后通过函数将父进程的虚拟内存空间以及相关页表拷贝到子进程的结构中最后将拷贝出来的赋值给子进程的结构通过函数创建出的子进程它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝直接从父进程中拷贝到子进程中而当我们通过或者系统调用创建出的子进程首先会设置标识这样来到函数中就会进入条件中在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程这样一来父进程和子进程的虚拟内存空间就变成共享的了也就是说父子进程之间使用的虚拟内存空间是一样的并不是一份拷贝子进程共享了父进程的虚拟内存空间这样子进程就变成了我们熟悉的线程是否共享地址空间几乎是进程和线程之间的本质区别内核并不区别对待它们线程对于内核来说仅仅是一个共享特定资源的进程而已内核线程和用户态线程的区别就是内核线程没有相关的内存描述符内核线程对应的结构中的域指向所以内核线程之间调度是不涉及地址空间切换的当一个内核线程被调度时它会发现自己的虚拟地址空间为虽然它不会访问用户态的内存但是它会访问内核内存聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间直接赋值给内核线程因为内核线程不会访问用户空间的内存它仅仅只会访问内核空间的内存所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配和相关页表的开销以及避免内核线程之间调度时地址空间的切换开销父进程与子进程的区别进程与线程的区别以及内核线程与用户态线程的区别其实都是围绕着这个展开的现在我们知道了表示进程虚拟内存空间的结构是如何被创建出来的相关背景那么接下来笔者就带大家深入结构内部来看一下内核如何通过这么一个结构体来管理进程的虚拟内存空间的内核如何划分用户态和内核态虚拟内存空间通过进程虚拟内存空间小节的介绍我们知道进程的虚拟内存空间分为两个部分一部分是用户态虚拟内存空间另一部分是内核态虚拟内存空间那么用户态的地址空间和内核态的地址空间在内核中是如何被划分的呢这就用到了进程的内存描述符结构体中的变量定义了用户态地址空间与内核态地址空间之间的分界线通过前边小节的内容介绍我们知道在位系统中用户态虚拟内存空间为虚拟内存地址范围为内核态虚拟内存空间为虚拟内存地址范围为位地址空间位系统中用户地址空间和内核地址空间的分界线在地址处那么自然进程的结构中的为我们来看下内核在文件中关于的定义如下图所示的值在位系统下为而在位系统中只使用了其中的低位来表示虚拟内存地址其中用户态虚拟内存空间为低虚拟内存地址范围为内核态虚拟内存空间为高虚拟内存地址范围为位地址空间位系统中用户地址空间和内核地址空间的分界线在地址处那么自然进程的结构中的为我们来看下内核在文件中关于的定义我们来看下在位系统中内核如何来计算在的计算逻辑中左移位得到的地址是然后减去一个默认为就是共所以在位系统中的为这里我们可以看出位虚拟内存空间的布局是和物理内存页的大小有关的物理内存页默认大小为定义在文件中而内核空间的起始地址是在之间的内存区域就是我们在位机器上进程虚拟内存空间分布小节中介绍的空洞内核如何布局进程虚拟内存空间在我们理解了内核是如何划分进程虚拟内存空间和内核虚拟内存空间之后那么在进程虚拟内存空间小节中介绍的那些虚拟内存区域在内核中又是如何划分的呢接下来笔者就为大家介绍下内核是如何划分进程虚拟内存空间中的这些内存区域的本小节的示例图中笔者只保留了进程虚拟内存空间中的核心区域方便大家理解前边我们提到内核中采用了一个叫做内存描述符的结构体来表示进程虚拟内存空间的全部信息在本小节中笔者就带大家到结构体内部去寻找下相关的线索省略内核中用结构体中的上述属性来定义上图中虚拟内存空间里的不同内存区域和定义代码段的起始和结束位置程序编译后的二进制文件中的机器码被加载进内存之后就存放在这里和定义数据段的起始和结束位置二进制文件中存放的全局变量和静态变量被加载进内存中就存放在这里后面紧挨着的是段用于存放未被初始化的全局变量和静态变量这些变量在加载进内存时会生成一段填充的内存区域段段的大小是固定的下面就是堆了在堆中内存地址的增长方向是由低地址向高地址增长定义堆的起始位置定义堆当前的结束位置我们使用申请小块内存时低于就是通过改变位置调整堆大小实现的接下来就是内存映射区在内存映射区内存地址的增长方向是由高地址向低地址增长定义内存映射区的起始地址进程运行时所依赖的动态链接库中的代码段数据段段以及我们调用映射出来的一段虚拟内存空间就保存在这个区域是栈的起始位置在寄存器中存储栈的结束位置也就是栈顶指针在寄存器中存储在栈中内存地址的增长方向也是由高地址向低地址增长和是参数列表的位置和是环境变量的位置它们都位于栈中的最高地址处在结构体中除了上述用于划分虚拟内存区域的变量之外还定义了一些虚拟内存与物理内存映射内容相关的统计变量操作系统会把物理内存划分成一页一页的区域来进行管理所以物理内存到虚拟内存之间的映射也是按照页为单位进行的这部分内容笔者会在后续的文章中详细介绍大家这里只需要有个概念就行结构体中的表示在进程虚拟内存空间中总共与物理内存映射的页的总数注意映射这个概念它表示只是将虚拟内存与物理内存建立关联关系并不代表真正的分配物理内存当内存吃紧的时候有些页可以换出到硬盘上而有些页因为比较重要不能换出就是被锁定不能换出的内存页总数表示既不能换出也不能移动的内存页总数表示数据段中映射的内存页数目是代码段中存放可执行文件的内存页数目是栈中所映射的内存页数目这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况现在关于内核如何对进程虚拟内存空间进行布局的内容我们已经清楚了那么布局之后划分出的这些虚拟内存区域在内核中又是如何被管理的呢我们接着往下看内核如何管理虚拟内存区域在上小节的介绍中我们知道内核是通过一个结构的内存描述符来表示进程的虚拟内存空间的并通过域来划分用户态虚拟内存空间和内核态虚拟内存空间而在划分出的这些虚拟内存空间中如上图所示里边又包含了许多特定的虚拟内存区域比如代码段数据段堆内存映射区栈那么这些虚拟内存区域在内核中又是如何表示的呢本小节中笔者将为大家介绍一个新的结构体正是这个结构体描述了这些虚拟内存区域每个结构对应于虚拟内存空间中的唯一虚拟内存区域指向了这块虚拟内存区域的起始地址最低地址本身包含在这块虚拟内存区域内指向了这块虚拟内存区域的结束地址最高地址而本身包含在这块虚拟内存区域之外所以结构描述的是这样一段左闭右开的虚拟内存区域定义虚拟内存区域的访问权限和行为规范和都是用来标记结构表示的这块虚拟内存区域的访问权限和行为规范上边小节中我们也提到内核会将整块物理内存划分为一页一页大小的区域以页为单位来管理这些物理内存每页大小默认而虚拟内存最终也是要和物理内存一一映射起来的所以在虚拟内存空间中也有虚拟页的概念与之对应虚拟内存中的虚拟页映射到物理内存中的物理页无论是在虚拟内存空间中还是在物理内存中内核管理内存的最小单位都是页偏向于定义底层内存管理架构中页这一级别的访问控制权限它可以直接应用在底层页表中它是一个具体的概念页表用于管理虚拟内存到物理内存之间的映射关系这部分内容笔者后续会详细讲解这里大家有个初步的概念就行虚拟内存区域由许多的虚拟页组成每个虚拟页需要经过页表的转换才能找到对应的物理页面页表中关于内存页的访问权限就是由决定的则偏向于定于整个虚拟内存区域的访问权限以及行为规范描述的是虚拟内存区域中的整体信息而不是虚拟内存区域中具体的某个独立页面它是一个抽象的概念可以通过实现到具体页面访问权限的转换下面笔者列举一些常用到的方便大家有一个直观的感受访问权限可读可写可执行可多进程之间共享可映射至设备空间内存区域不可被换出内存区域可能被顺序访问内存区域可能被随机访问定义了虚拟内存区域是否可以被读取写入执行等权限比如代码段这块内存区域的权限是可读可执行但是不可写数据段具有可读可写的权限但是不可执行堆则具有可读可写可执行的权限中的字节码存储在堆中所以需要可执行权限栈一般是可读可写的权限一般很少有可执行权限而文件映射与匿名映射区存放了共享链接库所以也需要可执行的权限用于指定这块虚拟内存区域映射的物理内存是否可以在多进程之间共享以便完成进程间通讯设置这个值即为的共享映射不设置的话则为私有映射这个等后面我们讲到的相关实现时还会再次提起的设置表示这块虚拟内存区域可以映射至设备空间中通常在设备驱动程序执行进行空间映射时才会被设置的设置表示在内存紧张的时候这块虚拟内存区域非常重要不能被换出到磁盘中的设置用来暗示内核应用程序对这块虚拟内存区域的读取是会采用顺序读的方式进行内核会根据实际情况决定预读后续的内存页数以便加快下次顺序访问速度的设置会暗示内核应用程序会对这块虚拟内存区域进行随机读取内核则会根据实际情况减少预读的内存页数甚至停止预读我们可以通过系统调用来暗示内核是否对相关内存区域进行顺序读取或者随机读取相关的详细内容大家可以看下笔者上篇文章从内核角度探秘文件读写本质中的第小节文件页预读部分通过这一系列的介绍我们可以看到就是定义整个虚拟内存区域的访问权限以及行为规范而内存区域中内存的最小单位为页虚拟内存区域中包含了很多这样的虚拟页对于虚拟内存区域设置的访问权限也会全部复制到区域中包含的内存页中关联内存映射中的映射关系接下来的三个属性分别和虚拟内存映射相关虚拟内存区域可以映射到物理内存上也可以映射到文件中映射到物理内存上我们称之为匿名映射映射到文件中我们称之为文件映射那么这个映射关系在内核中该如何表示呢这就用到了结构体中的上述三个属性当我们调用申请内存时如果申请的是小块内存低于则会使用系统调用通过调整堆中的指针大小来增加或者回收堆内存如果申请的是比较大块的内存超过时则会调用在上图虚拟内存空间中的文件映射与匿名映射区创建出一块内存区域这里是匿名映射这块匿名映射区域就用结构表示当调用进行文件映射时属性就用来关联被映射的文件这样一来虚拟内存区域就与映射文件关联了起来则表示映射进虚拟内存中的文件内容在文件中的偏移当然在匿名映射中结构中的就为也就没有了意义则用于存储中的私有数据具体的存储内容和内存映射的类型有关我们暂不展开论述针对虚拟内存区域的相关操作结构中还有一个用来指向针对虚拟内存区域的相关操作的函数指针省略当指定的虚拟内存区域被加入到进程虚拟内存空间中时函数会被调用当虚拟内存区域从进程虚拟内存空间中被删除时函数会被调用当进程访问虚拟内存时访问的页面不在物理内存中可能是未分配物理内存也可能是被置换到磁盘中这时就会产生缺页异常函数就会被调用当一个只读的页面将要变为可写时函数会被调用结构中定义的都是对虚拟内存区域的相关操作函数指针内核中这种类似的用法其实有很多在内核中每个特定领域的描述符都会定义相关的操作比如在前边的文章从内核角度探秘文件读写本质中我们介绍到内核中的文件描述符中定义的里面定义了内核针对文件操作的函数指针具体的实现根据不同的文件类型有所不同针对文件类型这里的指向的是进程中管理文件列表结构在文件系统中管理的文件对应的指向专门用于操作文件系统中的文件还有针对页高速缓存相关操作定义的还有我们在从内核角度看模型的演变一文中介绍到相关的操作接口定义在函数集合中负责对上给用户提供接口而与内核协议栈之间的操作接口定义在中的指针上这里指向协议操作函数集合系统调用结构对发起的系统调用时在内核中首先会调用的文件结构中的文件操作集合然后调用中的指向的操作函数最终调用到中指针指向的内核协议栈操作函数接口集合虚拟内存区域在内核中是如何被组织的在上一小节中我们介绍了内核中用来表示虚拟内存区域的结构体并详细为大家剖析了中的一些重要的关键属性现在我们已经熟悉了这些虚拟内存区域那么接下来的问题就是在内核中这些虚拟内存区域是如何被组织的呢我们继续来到结构中来看一下与组织结构相关的一些属性在内核中其实是通过一个结构的双向链表将虚拟内存空间中的这些虚拟内存区域串联起来的结构中的指针分别指向节点所在双向链表中的后继节点和前驱节点内核中的这个双向链表是有顺序的所有节点按照低地址到高地址的增长方向排序双向链表中的最后一个节点的指针指向双向链表的头指针存储在内存描述符结构中的中正是这个串联起了整个虚拟内存空间中的虚拟内存区域在每个虚拟内存区域中又通过中的指针指向了所属的虚拟内存空间我们可以通过或者查看进程的虚拟内存空间布局以及其中包含的所有内存区域这两个命令背后的实现原理就是通过遍历内核中的这个双向链表获取的内核中关于这些虚拟内存区域的操作除了遍历之外还有许多需要根据特定虚拟内存地址在虚拟内存空间中查找特定的虚拟内存区域尤其在进程虚拟内存空间中包含的内存区域比较多的情况下使用红黑树查找特定虚拟内存区域的时间复杂度是可以显著减少查找所需的时间所以在内核中同样的内存区域会有两种组织形式一种是双向链表用于高效的遍历另一种就是红黑树用于高效的查找每个区域都是红黑树中的一个节点通过结构中的将自己连接到红黑树中而红黑树中的根节点存储在内存描述符中的中程序编译后的二进制文件如何映射到虚拟内存空间中经过前边这么多小节的内容介绍现在我们已经熟悉了进程虚拟内存空间的布局以及内核如何管理这些虚拟内存区域并对进程的虚拟内存空间有了一个完整全面的认识现在我们再来回到最初的起点进程的虚拟内存空间以及这些虚拟内存区域是如何被创建并初始化的呢在进程虚拟内存空间小节中我们介绍进程的虚拟内存空间时提到我们写的程序代码编译之后会生成一个格式的二进制文件这个二进制文件中包含了程序运行时所需要的元信息比如程序的机器码程序中的全局变量以及静态变量等这个格式的二进制文件中的布局和我们前边讲的虚拟内存空间中的布局类似也是一段一段的每一段包含了不同的元数据磁盘文件中的段我们叫做内存中的段我们叫做也就是内存区域磁盘文件中的这些会在进程运行之前加载到内存中并映射到内存中的通常是多个映射到一个比如磁盘文件中的等一些只读的会被映射到内存的一个只读可执行的里代码段而等一些可读写的则会被映射到内存的一个具有读写权限的里数据段段那么这些格式的二进制文件中的是如何加载并映射进虚拟内存空间的呢内核中完成这个映射过程的函数是这个函数的作用很大加载内核的是它启动第一个用户态进程的是它完了以后调用运行一个二进制程序的也是它当运行一个二进制程序的时候除了解析的格式之外另外一个重要的事情就是建立上述提到的内存映射省略设置虚拟内存空间中的内存映射区域起始地址省略创建并初始化栈对应的结构设置就是栈的起始地址也就是栈底并将是指向栈底的省略将二进制文件中的代码部分映射到虚拟内存空间中省略创建并初始化堆对应的的结构设置设置堆的起始地址结束地址起初两者相等表示堆是空的省略将进程依赖的动态链接库文件映射到虚拟内存空间中的内存映射区域省略初始化内存描述符省略设置虚拟内存空间中的内存映射区域起始地址创建并初始化栈对应的结构置就是栈的起始地址也就是栈底并将是指向栈底的将格式的二进制文件中部分映射到虚拟内存空间中的代码段数据段段中创建并初始化堆对应的的结构设置设置堆的起始地址结束地址起初两者相等表示堆是空的将进程依赖的动态链接库文件映射到虚拟内存空间中的内存映射区域初始化内存描述符内核虚拟内存空间现在我们已经知道了进程虚拟内存空间在内核中的布局以及管理那么内核态的虚拟内存空间又是什么样子的呢本小节笔者就带大家来一层一层地拆开这个黑盒子之前在介绍进程虚拟内存空间的时候笔者提到不同进程之间的虚拟内存空间是相互隔离的彼此之间相互独立相互感知不到其他进程的存在使得进程以为自己拥有所有的内存资源而内核态虚拟内存空间是所有进程共享的不同进程进入内核态之后看到的虚拟内存空间全部是一样的什么意思呢比如上图中的进程进程进程分别在各自的用户态虚拟内存空间中访问虚拟地址由于进程之间的用户态虚拟内存空间是相互隔离相互独立的虽然在进程进程进程访问的都是虚拟地址但是看到的内容却是不一样的背后可能映射到不同的物理内存中但是当进程进程进程进入到内核态之后情况就不一样了由于内核虚拟内存空间是各个进程共享的所以它们在内核空间中看到的内容全部是一样的比如进程进程进程在内核态都去访问虚拟地址这时它们看到的内容就是一样的了这里笔者和大家澄清一个经常被误解的概念由于内核会涉及到物理内存的管理所以很多人会想当然地认为只要进入了内核态就开始使用物理地址了这就大错特错了千万不要这样理解进程进入内核态之后使用的仍然是虚拟内存地址只不过在内核中使用的虚拟内存地址被限制在了内核态虚拟内存空间范围中这也是本小节笔者要为大家介绍的主题在清楚了这个基本概念之后下面笔者分别从位体系和位体系下为大家介绍内核态虚拟内存空间的布局位体系内核虚拟内存空间布局在前边内核如何划分用户态和内核态虚拟内存空间小节中我们提到内核在文件中通过将进程虚拟内存空间和内核虚拟内存空间分割开来的值在位系统下为在位体系结构下进程用户态虚拟内存空间为虚拟内存地址范围为内核态虚拟内存空间为虚拟内存地址范围为本小节我们主要关注这段虚拟内存地址区域也就是内核虚拟内存空间的布局情况直接映射区在总共大小的内核虚拟内存空间中位于最前边有一块大小的区域我们称之为直接映射区或者线性映射区地址范围为之所以这块大小的区域称为直接映射区或者线性映射区是因为这块连续的虚拟内存地址会映射到这块连续的物理内存上也就是说这块大小的虚拟内存会直接映射到这块大小的物理内存上这块区域中的虚拟内存地址直接减去就得到了物理内存地址所以我们称这块区域为直接映射区为了方便为大家解释我们假设现在机器上的物理内存为大小虽然这块区域中的虚拟地址是直接映射到物理地址上但是内核在访问这段区域的时候还是走的虚拟内存地址内核也会为这块空间建立映射页表关于页表的概念笔者后续会为大家详细讲解这里大家只需要简单理解为页表保存了虚拟地址到物理地址的映射关系即可大家这里只需要记得内核态虚拟内存空间的前区域是直接映射到物理内存中的前区域中的直接映射区中的映射关系是一比一映射映射关系是固定的不会改变明白了这个关系之后我们接下来就看一下这块直接映射区域在物理内存中究竟存的是什么内容在这段大小的物理内存中前已经在系统启动的时候被系统占用之后的物理内存存放的是内核代码段数据段段这些信息起初存放在格式的二进制文件中在系统启动的时候被加载进内存我们可以通过命令查看具体物理内存布局情况当我们使用系统调用创建进程的时候内核会创建一系列进程相关的描述符比如之前提到的进程的核心数据结构进程的内存空间描述符以及虚拟内存区域描述符等这些进程相关的数据结构也会存放在物理内存前的这段区域中当然也会被直接映射至内核态虚拟内存空间中的这段直接映射区域中当进程被创建完毕之后在内核运行的过程中会涉及内核栈的分配内核会为每个进程分配一个固定大小的内核栈一般是两个页大小依赖具体的体系结构每个进程的整个调用链必须放在自己的内核栈中内核栈也是分配在直接映射区与进程用户空间中的栈不同的是内核栈容量小而且是固定的用户空间中的栈容量大而且可以动态扩展内核栈的溢出危害非常巨大它会直接悄无声息的覆盖相邻内存区域中的数据破坏数据通过以上内容的介绍我们了解到内核虚拟内存空间最前边的这段大小的直接映射区如何与物理内存进行映射关联并且清楚了直接映射区主要用来存放哪些内容写到这里笔者觉得还是有必要再次从功能划分的角度为大家介绍下这块直接映射区域我们都知道内核对物理内存的管理都是以页为最小单位来管理的每页默认大小理想状况下任何种类的数据页都可以存放在任何页框中没有什么限制比如存放内核数据用户数据缓冲磁盘数据等但是实际的计算机体系结构受到硬件方面的限制制约间接导致限制了页框的使用方式比如在体系结构下总线的直接内存存取控制器只能对内存的前进行寻址这就导致了设备不能在整个位地址空间中执行只能使用物理内存的前进行操作因此直接映射区的前专门让内核用来为分配内存这块大小的内存区域我们称之为用于的内存必须从区域中分配而直接映射区中剩下的部分也就是从到不包含这段区域我们称之为从字面意义上我们可以了解到这块区域包含的就是正常的页框使用没有任何限制由于也是属于直接映射区的一部分对应的物理内存到这段区域也是被直接映射至内核态虚拟内存空间中的到这段虚拟内存上注意这里的和是内核针对物理内存区域的划分现在物理内存中的前的区域也就是前边介绍的和区域到内核虚拟内存空间的映射笔者就为大家介绍完了它们都是采用直接映射的方式一比一就行映射高端内存而物理内存以上的区域被内核划分为区域我们称之为高端内存本例中我们的物理内存假设为高端内存区域为那么这块大小的区域该如何映射到内核虚拟内存空间中呢由于内核虚拟内存空间中的前虚拟内存已经被直接映射区所占用而在体系结构下内核虚拟内存空间总共也就的大小这样一来内核剩余可用的虚拟内存空间就变为了显然物理内存中大小的区域无法继续通过直接映射的方式映射到这大小的虚拟内存空间中这样一来物理内存中的区域就只能采用动态映射的方式映射到大小的内核虚拟内存空间中也就是说只能动态的一部分一部分的分批映射先映射正在使用的这部分使用完毕解除映射接着映射其他部分知道了区域的映射原理我们接着往下看这大小的内核虚拟内存空间究竟是如何布局的内核虚拟内存空间中的这块地址在内核中定义为往上有一段大小的内存空洞空洞范围为到定义在内核源码文件中动态映射区接下来到之间的这块区域成为动态映射区采用动态映射的方式映射物理内存中的高端内存和用户态进程使用申请内存一样在这块动态映射区内核是使用进行内存分配由于之前介绍的动态映射的原因分配的内存在虚拟内存上是连续的但是物理内存是不连续的通过页表来建立物理内存与虚拟内存之间的映射关系从而可以将不连续的物理内存映射到连续的虚拟内存上由于获得的物理内存页是不连续的因此它只能将这些物理内存页一个一个地进行映射在性能开销上会比直接映射大得多关于分配内存的相关实现原理笔者会在后面的文章中为大家讲解这里大家只需要明白它在哪块虚拟内存区域中活动即可永久映射区而在到之间的这段空间称为永久映射区在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系比如内核通过函数在物理内存的高端内存中申请获取到的物理内存页这些物理内存页可以通过调用映射到永久映射区中表示永久映射区可以映射的页数限制固定映射区内核虚拟内存空间中的下一个区域为固定映射区区域范围为到和定义在内核源码文件中在内核虚拟内存空间的直接映射区中直接映射区中的虚拟内存地址与物理内存前的空间的映射关系都是预设好的一比一映射在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上但是与动态映射区以及永久映射区不同的是在固定映射区中虚拟地址是固定的而被映射的物理地址是可以改变的也就是说有些虚拟地址在编译的时候就固定下来了是在内核启动过程中被确定的而这些虚拟地址对应的物理地址不是固定的采用固定虚拟地址的好处是它相当于一个指针常量常量的值在编译时确定指向物理地址如果虚拟地址不固定则相当于一个指针变量那为什么会有固定映射这个概念呢比如在内核的启动过程中有些模块需要使用虚拟内存并映射到指定的物理地址上而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射因此内核固定分配了一些虚拟地址这些地址有固定的用途使用该地址的模块在初始化的时候将这些固定分配的虚拟地址映射到指定的物理地址上去临时映射区在内核虚拟内存空间中的最后一块区域为临时映射区那么这块临时映射区是用来干什么的呢笔者在之前文章从内核角度探秘文件读写本质的小节中介绍在模式下进行文件写入的时候在下图中的第四步内核会调用函数将用户空间缓冲区中的待写入数据拷贝到中但是内核又不能直接进行拷贝因为此时从中取出的缓存页是物理地址而在内核中是不能够直接操作物理地址的只能操作虚拟地址那怎么办呢所以就需要使用将缓存页临时映射到内核空间的一段虚拟地址上这段虚拟地址就位于内核虚拟内存空间中的临时映射区上然后将用户空间缓存区中的待写入数据通过这段映射的虚拟地址拷贝到中的相应缓存页中这时文件的写入操作就已经完成了由于是临时映射所以在拷贝完成之后调用将这段映射再解除掉将缓存页临时映射到内核虚拟地址空间的临时映射区中将用户缓存区中的待写入数据拷贝到文件缓存页中解除内核虚拟地址空间与缓存页之间的临时映射这里映射只是为了临时拷贝数据用位体系结构下虚拟内存空间整体布局到现在为止整个内核虚拟内存空间在位体系下的布局笔者就为大家详细介绍完毕了我们再次结合前边位机器上进程虚拟内存空间分布小节中介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下位体系结构的整个虚拟内存空间的布局位体系内核虚拟内存空间布局内核虚拟内存空间在位体系下只有大小实在太小了因此需要精细化的管理于是按照功能分类划分除了很多内核虚拟内存区域这样就显得非常复杂到了位体系下内核虚拟内存空间的布局和管理就变得容易多了因为进程虚拟内存空间和内核虚拟内存空间各自占用的虚拟内存实在是太大了我们可以在这里边随意翱翔随意挥霍因此在位体系下的内核虚拟内存空间与物理内存的映射就变得非常简单由于虚拟内存空间足够的大即便是内核要访问全部的物理内存直接映射就可以了不在需要用到高端内存小节中介绍的高端内存那种动态映射方式在前边内核如何划分用户态和内核态虚拟内存空间小节中我们提到内核在文件中通过将进程虚拟内存空间和内核虚拟内存空间分割开来位系统中的为位地址空间在位系统中只使用了其中的低位来表示虚拟内存地址其中用户态虚拟内存空间为低虚拟内存地址范围为内核态虚拟内存空间为高虚拟内存地址范围为本小节我们主要关注这段内核虚拟内存空间的布局情况位内核虚拟内存空间从开始到这段地址空间是一个大小的内存空洞区域紧着着大小的内存空洞下一个区域就是大小的直接映射区这个区域中的虚拟内存地址减去就直接得到了物理内存地址变量定义在文件中从图中到的这段区域是大小的映射区这里类似用户空间中的堆内核在这里使用系统调用申请内存和变量定义在文件中从开始是大小的虚拟内存映射区用于存放物理页面的描述符结构用来表示物理内存页变量定义在文件中从开始是大小为的区域用于存放内核代码段全局变量等这里对应到物理内存开始的位置减去就能得到物理内存的地址这里和直接映射区有点像但是不矛盾因为直接映射区之前有的空洞区域早就过了内核代码在物理内存中加载的位置变量定义在文件中位体系结构下虚拟内存空间整体布局到现在为止整个内核虚拟内存空间在位体系下的布局笔者就为大家详细介绍完毕了我们再次结合前边位机器上进程虚拟内存空间分布小节介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下位体系结构的整个虚拟内存空间的布局到底什么是物理内存地址聊完了虚拟内存我们接着聊一下物理内存我们平时所称的内存也叫随机访问存储器也叫而分为两类一类是静态这类用于高速缓存其特点是访问速度快访问速度为个时钟周期但是容量小造价高缓存结构另一类则是动态这类用于我们常说的主存上其特点的是访问速度慢相对高速缓存访问速度为个时钟周期但是容量大造价便宜些相对高速缓存内存由一个一个的存储器模块组成它们插在主板的扩展槽上常见的存储器模块通常以位为单位个字节传输数据到存储控制器上或者从存储控制器传出数据如图所示内存条上黑色的元器件就是存储器模块多个存储器模块连接到存储控制器上就聚合成了主存内存结构而芯片就包装在存储器模块中每个存储器模块中包含个芯片依次编号为存储器模块而每一个芯片的存储结构是一个二维矩阵二维矩阵中存储的元素我们称为超单元每个大小为一个字节每个都由一个坐标地址表示二维矩阵中的行地址在计算机中行地址称为行访问选通脉冲表示二维矩阵中的列地址在计算机中列地址称为列访问选通脉冲下图中的的结构芯片中的信息通过引脚流入流出芯片每个引脚携带的信号图中芯片包含了两个地址引脚因为我们要通过来定位要获取的还有个数据引脚因为芯片的单位为一个字节所以需要个引脚从芯片传入传出数据注意这里只是为了解释地址引脚和数据引脚的概念实际硬件中的引脚数量是不一定的芯片的访问我们现在就以读取上图中坐标地址为的为例来说明访问芯片的过程芯片访问首先存储控制器将行地址通过地址引脚发送给芯片芯片根据将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中接下来存储控制器会通过地址引脚发送到芯片中芯片从内部行缓冲区中根据拷贝出第二列的并通过数据引脚发送给存储控制器芯片的单位为一个也就是一个字节如何读写主存前边我们介绍了内存的物理结构以及如何访问内存中的芯片获取中存储的数据一个字节本小节我们来介绍下是如何访问内存的与内存之间的总线结构与内存之间的数据交互是通过总线完成的而数据在总线上的传送是通过一系列的步骤完成的这些步骤称为总线事务其中数据从内存传送到称之为读事务数据从传送到内存称之为写事务总线上传输的信号包括地址信号数据信号控制信号其中控制总线上传输的控制信号可以同步事务并能够标识出当前正在被执行的事务信息当前这个事务是到内存的还是到磁盘的或者是到其他设备的这个事务是读还是写总线上传输的地址信号物理内存地址还是数据信号数据这里大家需要注意总线上传输的地址均为物理内存地址比如在缓存一致性协议中当修改字段的值时其他核心会在总线上嗅探字段的物理内存地址如果嗅探到总线上出现字段的物理内存地址说明有人在修改字段这样其他核心就会失效字段所在的如上图所示其中系统总线是连接与的存储总线是来连接和主存的负责将系统总线上的电子信号转换成存储总线上的电子信号也会将系统总线和存储总线连接到总线磁盘等设备上这里我们看到其实起的作用就是转换不同总线上的电子信号从内存读取数据过程假设现在需要将物理内存地址为的内容加载到寄存器中进行运算大家需要注意的是只会访问虚拟内存在操作总线之前需要把虚拟内存地址转换为物理内存地址总线上传输的都是物理内存地址这里省略了虚拟内存地址到物理内存地址的转换过程这部分内容笔者会在后续文章的相关章节详细为大家讲解这里我们聚焦如果通过物理内存地址读取内存数据读取内存首先芯片中的总线接口会在总线上发起读事务该读事务分为以下步骤进行将物理内存地址放到系统总线上随后将信号传递到存储总线上主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址读取出来存储控制器通过物理内存地址定位到具体的存储器模块从芯片中取出物理内存地址对应的数据存储控制器将读取到的数据放到存储总线上随后将存储总线上的数据信号转换为系统总线上的数据信号然后继续沿着系统总线传递芯片感受到系统总线上的数据信号将数据从系统总线上读取出来并拷贝到寄存器中以上就是读取内存数据到寄存器中的完整过程但是其中还涉及到一个重要的过程这里我们还是需要摊开来介绍一下那就是存储控制器如何通过物理内存地址从主存中读取出对应的数据的接下来我们结合前边介绍的内存结构以及从芯片读取数据的过程来总体介绍下如何从主存中读取数据如何根据物理内存地址从主存中读取数据前边介绍到当主存中的存储控制器感受到了存储总线上的地址信号时会将内存地址从存储总线上读取出来随后会通过内存地址定位到具体的存储器模块还记得内存结构中的存储器模块吗内存结构而每个存储器模块中包含了个芯片编号从存储器模块存储控制器会将物理内存地址转换为芯片中在二维矩阵中的坐标地址并将这个坐标地址发送给对应的存储器模块随后存储器模块会将和广播到存储器模块中的所有芯片依次通过从到读取到相应的芯片访问我们知道一个存储了一个字节数据这里我们从到依次读取到了个也就是个字节然后将这个字节返回给存储控制器由存储控制器将数据放到存储总线上总是以为单位从内存中读取数据在位处理器中的为个字节位的内存每次只能吞吐个字节每次会向内存读写一个大小的数据个字节但是内存一次只能吞吐个字节所以在物理内存地址对应的存储器模块中芯片存储第一个低位字节芯片存储第二个字节依次类推芯片存储最后一个高位字节读取存储器模块数据由于存储器模块中这种由个芯片组成的物理存储结构的限制内存读取数据只能是按照物理内存地址个字节个字节地顺序读取数据所以说内存一次读取和写入的单位是个字节内存单位而且在程序员眼里连续的物理内存地址实际上在物理上是不连续的因为这连续的个字节其实是存储于不同的芯片上的每个芯片存储一个字节向内存写入数据过程我们现在假设要将寄存器中的数据写到物理内存地址中同样的道理芯片中的总线接口会向总线发起写事务写事务步骤如下将要写入的物理内存地址放入系统总线上通过的信号转换将物理内存地址传递到存储总线上存储控制器感受到存储总线上的地址信号将物理内存地址从存储总线上读取出来并等待数据的到达将寄存器中的数据拷贝到系统总线上通过的信号转换将数据传递到存储总线上存储控制器感受到存储总线上的数据信号将数据从存储总线上读取出来存储控制器通过内存地址定位到具体的存储器模块最后将数据写入存储器模块中的个芯片中总结本文我们从虚拟内存地址开始聊起一直到物理内存地址结束包含的信息量还是比较大的首先笔者通过一个进程的运行实例为大家引出了内核引入虚拟内存空间的目的及其需要解决的问题在我们有了虚拟内存空间的概念之后笔者又近一步为大家介绍了内核如何划分用户态虚拟内存空间和内核态虚拟内存空间并在次基础之上分别从位体系结构和位体系结构的角度详细阐述了虚拟内存空间的整体布局分布我们可以通过或者命令来查看进程用户态虚拟内存空间的实际分布还可以通过命令来查看进程内核态虚拟内存空间的的实际分布在我们清楚了虚拟内存空间的整体布局分布之后笔者又介绍了内核如何对分布在虚拟内存空间中的各个虚拟内存区域进行管理以及每个虚拟内存区域的作用在这个过程中还介绍了相关的内核数据结构近一步从内核源码实现角度加深大家对虚拟内存空间的理解最后笔者介绍了物理内存的结构以及如何通过物理内存地址来读写内存中的数据这里笔者需要特地再次强调的是只会访问虚拟内存地址只不过在操作总线之前通过一个地址转换硬件将虚拟内存地址转换为物理内存地址然后将物理内存地址作为地址信号放在总线上传输由于地址转换的内容和本文主旨无关考虑到文章的篇幅以及复杂性笔者就没有过多的介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-13 14:47:48',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 1.05rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 1.05rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 1.05rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 1.05rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 1.05rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-08-12T03:18:47.311Z" title="发表于 2024-08-12 11:18:47">2024-08-12</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-08-13T06:47:48.779Z" title="更新于 2024-08-13 14:47:48">2024-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2024-08-12T03:18:47.311Z" title="发表于 2024-08-12 11:18:47">2024-08-12</time><time itemprop="dateCreated datePublished" datetime="2024-08-13T06:47:48.779Z" title="更新于 2024-08-13 14:47:48">2024-08-13</time></header><p>Linux 内核内存管理子系统源码解析</p>
<hr>
<p>从本文开始我们就正式开启了 Linux 内核内存管理子系统源码解析系列，笔者还是会秉承之前系列文章的风格，采用一步一图的方式先是详细介绍相关原理，在保证大家清晰理解原理的基础上，我们再来一步一步的解析相关内核源码的实现。有了源码的辅证，这样大家看得也安心，理解起来也放心，最起码可以证明笔者没有胡编乱造骗大家，哈哈~~</p>
<p>内存管理子系统可谓是 Linux 内核众多子系统中最为复杂最为庞大的一个，其中包含了众多繁杂的概念和原理，通过内存管理这条主线我们把可以把操作系统的众多核心系统给拎出来，比如：进程管理子系统，网络子系统，文件子系统等。</p>
<p>由于内存管理子系统过于复杂庞大，其中涉及到的众多繁杂的概念又是一环套一环，层层递进。如何把这些繁杂的概念具有层次感地，并且清晰地，给大家梳理呈现出来真是一件比较有难度的事情，因此关于这个问题，笔者在动笔写这个内存管理源码解析系列之前也是思考了很久。</p>
<p>万事开头难，那么到底什么内容适合作为这个系列的开篇呢 ？笔者还是觉得从大家日常开发工作中接触最多最为熟悉的部分开始比较好，比如：在我们日常开发中创建的类，调用的函数，在函数中定义的局部变量以及 new 出来的数据容器（Map，List，Set ….. 等）都需要存储在物理内存中的某个角落。</p>
<p>而我们在程序中编写业务逻辑代码的时候，往往需要引用这些创建出来的数据结构，并通过这些引用对相关数据结构进行业务处理。</p>
<p>当程序运行起来之后就变成了进程，而这些业务数据结构的引用在进程的视角里全都都是虚拟内存地址，因为进程无论是在用户态还是在内核态能够看到的都是虚拟内存空间，物理内存空间被操作系统所屏蔽进程是看不到的。</p>
<p>进程通过虚拟内存地址访问这些数据结构的时候，虚拟内存地址会在内存管理子系统中被转换成物理内存地址，通过物理内存地址就可以访问到真正存储这些数据结构的物理内存了。随后就可以对这块物理内存进行各种业务操作，从而完成业务逻辑。</p>
<ul>
<li>那么到底什么是虚拟内存地址 ？</li>
<li>Linux 内核为啥要引入虚拟内存而不直接使用物理内存 ？</li>
<li>虚拟内存空间到底长啥样？</li>
<li>内核如何管理虚拟内存？</li>
<li>什么又是物理内存地址 ？如何访问物理内存？</li>
</ul>
<p>本文笔者就来为大家详细一一解答上述几个问题，让我们马上开始吧~~~~</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTNfQ6WSkpeNANq9RovbFiafnYm86718mQUReXSA2AAlt3icZYCoW6fhEQ/640?wx_fmt=png">本文概要. png</p>
<ol>
<li>到底什么是虚拟内存地址</li>
</ol>
<hr>
<p>首先人们提出地址这个概念的目的就是用来方便定位现实世界中某一个具体事物的真实地理位置，它是一种用于定位的概念模型。</p>
<p>举一个生活中的例子，比如大家在日常生活中给亲朋好友邮寄一些本地特产时，都会填写收件人地址以及寄件人地址。以及在日常网上购物时，都会在相应电商 APP 中填写自己的收获地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTKUG9rxboRf74OXdcDQEpXQJMPf7Xj9zbDhatWY6Exd5jaD0tjN8OUg/640?wx_fmt=png"></p>
<p>随后快递小哥就会根据我们填写的收货地址找到我们的真实住所，将我们网购的商品送达到我们的手里。</p>
<p>收货地址是用来定位我们在现实世界中真实住所地理位置的，而现实世界中我们所在的城市，街道，小区，房屋都是一砖一瓦，一草一木真实存在的。但收货地址这个概念模型在现实世界中并不真实存在，它只是人们提出的一个虚拟概念，通过收货地址这个虚拟概念将它和现实世界真实存在的城市，小区，街道的地理位置一一映射起来，这样我们就可以通过这个虚拟概念来找到现实世界中的具体地理位置。</p>
<p>综上所述，收货地址是一个虚拟地址，它是人为定义的，而我们的城市，小区，街道是真实存在的，他们的地理位置就是物理地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTleL73x2AXcOKcIc4wbxpC8UfZyKmJt0L2GMdmsP5DgoEGQy1HIJyDQ/640?wx_fmt=png"></p>
<p>比如现在的广东省深圳市在过去叫宝安县，河北省的石家庄过去叫常山，安徽省的合肥过去叫泸州。不管是常山也好，石家庄也好，又或是合肥也好，泸州也罢，这些都是人为定义的名字而已，但是地方还是那个地方，它所在的地理位置是不变的。也就说虚拟地址可以人为的变来变去，但是物理地址永远是不变的。</p>
<p>现在让我们把视角在切换到计算机的世界，在计算机的世界里内存地址用来定义数据在内存中的存储位置的，内存地址也分为虚拟地址和物理地址。而虚拟地址也是人为设计的一个概念，类比我们现实世界中的收货地址，而物理地址则是数据在物理内存中的真实存储位置，类比现实世界中的城市，街道，小区的真实地理位置。</p>
<p>说了这么多，那么到底虚拟内存地址长什么样子呢？</p>
<p>我们还是以日常生活中的收货地址为例做出类比，我们都很熟悉收货地址的格式：xx 省 xx 市 xx 区 xx 街道 xx 小区 xx 室，它是按照地区层次递进的。同样，在计算机世界中的虚拟内存地址也有这样的递进关系。</p>
<p>这里我们以 Intel Core i7 处理器为例，64 位虚拟地址的格式为：全局页目录项（9 位）+ 上层页目录项（9 位）+ 中间页目录项（9 位）+ 页表项（9 位）+ 页内偏移（12 位）。共 48 位组成的虚拟内存地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTrRwwRoicDmo0xr1zkn2tbghDgDPXNKFJ8PiaxIGNhwibTicibWZj1m5nmdg/640?wx_fmt=png"></p>
<p>虚拟内存地址中的全局页目录项就类比我们日常生活中收获地址里的省，上层页目录项就类比市，中间层页目录项类比区县，页表项类比街道小区，页内偏移类比我们所在的楼栋和几层几号。</p>
<blockquote>
<p>这里大家只需要大体明白虚拟内存地址到底长什么样子，它的格式是什么，能够和日常生活中的收货地址对比理解起来就可以了，至于页目录项，页表项以及页内偏移这些计算机世界中的概念，大家暂时先不用管，后续文章中笔者会慢慢给大家解释清楚。</p>
</blockquote>
<p>32 位虚拟地址的格式为：页目录项（10 位）+ 页表项（10 位） + 页内偏移（12 位）。共 32 位组成的虚拟内存地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTl58jTcPaz0Ux8W4GN4IElq59hGWPLl6qTw1ia5NVxvghiciaJibibAc9UFA/640?wx_fmt=png"></p>
<blockquote>
<p>进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节。</p>
</blockquote>
<ol start="2">
<li>为什么要使用虚拟地址访问内存</li>
</ol>
<hr>
<p>经过第一小节的介绍，我们现在明白了计算机世界中的虚拟内存地址的含义及其展现形式。那么大家可能会问了，既然物理内存地址可以直接定位到数据在内存中的存储位置，那为什么我们不直接使用物理内存地址去访问内存而是选择用虚拟内存地址去访问内存呢？</p>
<p>在回答大家的这个疑问之前，让我们先来看下，如果在程序中直接使用物理内存地址会发生什么情况？</p>
<p>假设现在没有虚拟内存地址，我们在程序中对内存的操作全都都是使用物理内存地址，在这种情况下，程序员就需要精确的知道每一个变量在内存中的具体位置，我们需要手动对物理内存进行布局，明确哪些数据存储在内存的哪些位置，除此之外我们还需要考虑为每个进程究竟要分配多少内存？内存紧张的时候该怎么办？如何避免进程与进程之间的地址冲突？等等一系列复杂且琐碎的细节。</p>
<p>如果我们在单进程系统中比如嵌入式设备上开发应用程序，系统中只有一个进程，这单个进程独享所有的物理资源包括内存资源。在这种情况下，上述提到的这些直接使用物理内存的问题可能还好处理一些，但是仍然具有很高的开发门槛。</p>
<p>然而在现代操作系统中往往支持多个进程，需要处理多进程之间的协同问题，在多进程系统中直接使用物理内存地址操作内存所带来的上述问题就变得非常复杂了。</p>
<p>这里笔者为大家举一个简单的例子来说明在多进程系统中直接使用物理内存地址的复杂性。</p>
<p>比如我们现在有这样一个简单的 Java 程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">string</span> <span class="variable">i</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        ..........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在程序代码相同的情况下，我们用这份代码同时启动三个 JVM 进程，我们暂时将进程依次命名为 a , b , c 。</p>
<p>这三个进程用到的代码是一样的，都是我们提前写好的，可以被多次运行。由于我们是直接操作物理内存地址，假设变量 i 保存在 0x354 这个物理地址上。这三个进程运行起来之后，同时操作这个 0x354 物理地址，这样这个变量 i 的值不就混乱了吗？ 三个进程就会出现变量的地址冲突。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTdkYRNwjZKSpQhK3Zj76ia1xamewMP0KhHNNrTVJwpEeibUYoI7BJEJzg/640?wx_fmt=png"></p>
<p>所以在直接操作物理内存的情况下，我们需要知道每一个变量的位置都被安排在了哪里，而且还要注意和多个进程同时运行的时候，不能共用同一个地址，否则就会造成地址冲突。</p>
<p>现实中一个程序会有很多的变量和函数，这样一来我们给它们都需要计算一个合理的位置，还不能与其他进程冲突，这就很复杂了。</p>
<p>那么我们该如何解决这个问题呢？程序的局部性原理再一次救了我们~~</p>
<blockquote>
<p>程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</p>
</blockquote>
<p>从程序局部性原理的描述中我们可以得出这样一个结论：进程在运行之后，对于内存的访问不会一下子就要访问全部的内存，相反进程对于内存的访问会表现出明显的倾向性，更加倾向于访问最近访问过的数据以及热点数据附近的数据。</p>
<p>根据这个结论我们就清楚了，无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，我们只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。</p>
<p>而虚拟内存的引入正是要解决上述的问题，虚拟内存引入之后，进程的视角就会变得非常开阔，每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。每个进程都认为自己独占所有内存空间，自己想干什么就干什么。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTJARMZJCXHv9mjibj0gVPdicJTiaKmej7Es23ib8Rc0AUAkYZsk8SIfD8XQ/640?wx_fmt=png"></p>
<p>系统上还运行了哪些进程和我没有任何关系。这样一来我们就可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理，极大地解放了程序员的心智负担。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLINE1jjQPxBJrZqwwSMJgMP6WHR0rLxsICVroYUN5HQv7Kk5a8aS3g/640?wx_fmt=png"></p>
<p>这样进程就以为自己独占了整个内存空间资源，给进程产生了所有内存资源都属于它自己的幻觉，这其实是 CPU 和操作系统使用的一个障眼法罢了，任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<p>当 CPU 访问进程的虚拟地址时，经过地址翻译硬件将虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了。</p>
<ol start="3">
<li>进程虚拟内存空间</li>
</ol>
<hr>
<p>上小节中，我们介绍了为了防止多进程运行时造成的内存地址冲突，内核引入了虚拟内存地址，为每个进程提供了一个独立的虚拟内存空间，使得进程以为自己独占全部内存资源。</p>
<p>那么这个进程独占的虚拟内存空间到底是什么样子呢？在本小节中，笔者就为大家揭开这层神秘的面纱~~~</p>
<p>在本小节内容开始之前，我们先想象一下，如果我们是内核的设计人员，我们该从哪些方面来规划进程的虚拟内存空间呢？</p>
<blockquote>
<p>本小节我们只讨论进程用户态虚拟内存空间的布局，我们先把内核态的虚拟内存空间当做一个黑盒来看待，在后面的小节中笔者再来详细介绍内核态相关内容。</p>
</blockquote>
<p>首先我们会想到的是一个进程运行起来是为了执行我们交代给进程的工作，执行这些工作的步骤我们通过程序代码事先编写好，然后编译成二进制文件存放在磁盘中，CPU 会执行二进制文件中的机器码来驱动进程的运行。所以在进程运行之前，这些存放在二进制文件中的机器码需要被加载进内存中，而用于存放这些机器码的虚拟内存空间叫做代码段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTvoFvPLedMwWZ12oz9vlBJgaAPryNZRbXh1FWIQKj3Y0UTzGRfgC1RA/640?wx_fmt=png"></p>
<p>在程序运行起来之后，总要操作变量吧，在程序代码中我们通常会定义大量的全局变量和静态变量，这些全局变量在程序编译之后也会存储在二进制文件中，在程序运行之前，这些全局变量也需要被加载进内存中供程序访问。所以在虚拟内存空间中也需要一段区域来存储这些全局变量。</p>
<ul>
<li><p>那些在代码中被我们指定了初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做数据段。</p>
</li>
<li><p>那些没有指定初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做 BSS 段。这些未初始化的全局变量被加载进内存之后会被初始化为 0 值。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTnJA0UxdicicudWnJAx39pAB6WoW74icPY0nhzRicWwfxVrputCHNJibUzMw/640?wx_fmt=png"></p>
<p>上面介绍的这些全局变量和静态变量都是在编译期间就确定的，但是我们程序在运行期间往往需要动态的申请内存，所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存，这块区域就叫做堆。注意这里的堆指的是 OS 堆并不是 JVM 中的堆。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTNPgtIIf5ZFrNQPIcDAz6Lqd4zCib3OLTPSVh7jRfbBsaMyvxz86Ew6g/640?wx_fmt=png"></p>
<p>除此之外，我们的程序在运行过程中还需要依赖动态链接库，这些动态链接库以 .so 文件的形式存放在磁盘中，比如 C 程序中的 glibc，里边对系统调用进行了封装。glibc 库里提供的用于动态申请堆内存的 malloc 函数就是对系统调用 sbrk 和 mmap 的封装。这些动态链接库也有自己的对应的代码段，数据段，BSS 段，也需要一起被加载进内存中。</p>
<p>还有用于内存文件映射的系统调用 mmap，会将文件与内存进行映射，那么映射的这块内存（虚拟内存）也需要在虚拟地址空间中有一块区域存储。</p>
<p>这些动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区，在虚拟内存空间的存储区域叫做文件映射与匿名映射区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT8U1Q0hXl5iaMReI67lEzNibZtcqKUicLicia6tpSxObJ7ics7LDxeywFoUBA/640?wx_fmt=png"></p>
<p>最后我们在程序运行的时候总该要调用各种函数吧，那么调用函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存。这一块区域在虚拟内存空间中叫做栈。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png"></p>
<p>现在进程的虚拟内存空间所包含的主要区域，笔者就为大家介绍完了，我们看到内核根据进程运行的过程中所需要不同种类的数据而为其开辟了对应的地址空间。分别为：</p>
<ul>
<li><p>用于存放进程程序二进制文件中的机器指令的代码段</p>
</li>
<li><p>用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。</p>
</li>
<li><p>用于在程序运行过程中动态申请内存的堆。</p>
</li>
<li><p>用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。</p>
</li>
<li><p>用于存放函数调用过程中的局部变量和函数参数的栈。</p>
</li>
</ul>
<p>以上就是我们通过一个程序在运行过程中所需要的数据所规划出的虚拟内存空间的分布，这些只是一个大概的规划，那么在真实的 Linux 系统中，进程的虚拟内存空间的具体规划又是如何的呢？我们接着往下看~~</p>
<ol start="4">
<li>Linux 进程虚拟内存空间</li>
</ol>
<hr>
<p>在上小节中我们介绍了进程虚拟内存空间中各个内存区域的一个大概分布，在此基础之上，本小节笔者就带大家分别从 32 位 和 64 位机器上看下在 Linux 系统中进程虚拟内存空间的真实分布情况。</p>
<h3 id="4-1-32-位机器上进程虚拟内存空间分布"><a href="#4-1-32-位机器上进程虚拟内存空间分布" class="headerlink" title="4.1 32 位机器上进程虚拟内存空间分布"></a>4.1 32 位机器上进程虚拟内存空间分布</h3><p>在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。</p>
<p>其中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000  。</p>
<p>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png"></p>
<p>但是用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。</p>
<p>0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。</p>
<p>保留区的上边就是代码段和数据段，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。</p>
<p>紧挨着 BSS 段的上边就是我们经常使用到的堆空间，从图中的红色箭头我们可以知道在堆空间中地址的增长方向是从低地址到高地址增长。</p>
<p>内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。</p>
<p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。<strong>注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p>
<p>接下来用户态虚拟内存空间的最后一块区域就是栈空间了，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。<strong>栈空间中的地址增长方向是从高地址向低地址增长</strong>。每次进程申请新的栈地址时，其地址值是在减少的。</p>
<p>在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。</p>
<p>在栈空间的下边也有一段待分配区域用于扩展栈空间，在栈空间的上边就是内核空间了，进程虽然可以看到这段内核空间地址，但是就是不能访问。这就好比我们在饭店里虽然可以看到厨房在哪里，但是厨房门上写着 “厨房重地，闲人免进” ，我们就是进不去。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTsiceVVZuF68UrbjUJYtoLWTEHbTXYmeZj34OhZttVia9YR73dNDxysXA/640?wx_fmt=png"></p>
<h3 id="4-2-64-位机器上进程虚拟内存空间分布"><a href="#4-2-64-位机器上进程虚拟内存空间分布" class="headerlink" title="4.2 64 位机器上进程虚拟内存空间分布"></a>4.2 64 位机器上进程虚拟内存空间分布</h3><p>上小节中介绍的 32 位虚拟内存空间布局和本小节即将要介绍的 64 位虚拟内存空间布局都可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 来查看某个进程的实际虚拟内存布局。</p>
<p>我们知道在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。</p>
<p>那么我们理所应当的会认为在 64 位机器上，指针的寻址范围为 2^64，所能表达的虚拟内存空间为 16 EB 。虚拟内存地址范围为：0x0000 0000 0000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p>
<p>好家伙 !!! 16 EB 的内存空间，笔者都没见过这么大的磁盘，在现实情况中根本不会用到这么大范围的内存空间，</p>
<p>事实上在目前的 64 位系统下只使用了 48 位来描述虚拟内存空间，寻址范围为  2^48 ，所能表达的虚拟内存空间为 256TB。</p>
<p>其中低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000  - 0x0000 7FFF FFFF F000 。</p>
<p>高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000  - 0xFFFF FFFF FFFF FFFF 。</p>
<p>这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段 0x0000 7FFF FFFF F000  -  0xFFFF 8000 0000 0000  的地址空洞，我们把这个空洞叫做 canonical address 空洞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLPmAARV9MdjF6Ts8damEDNEVbTBnfibG8ZUDhkyNAE5FiaxAOepGupSQ/640?wx_fmt=png"></p>
<p>那么这个 canonical address 空洞是如何形成的呢？</p>
<p>我们都知道在 64 位机器上的指针寻址范围为 2^64，但是在实际使用中我们只使用了其中的低 48 位来表示虚拟内存地址，那么这多出的高 16 位就形成了这个地址空洞。</p>
<p>大家注意到在低 128T 的用户态地址空间：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 范围中，所以虚拟内存地址的高 16 位全部为 0 。</p>
<p>如果一个虚拟内存地址的高 16 位全部为 0 ，那么我们就可以直接判断出这是一个用户空间的虚拟内存地址。</p>
<p>同样的道理，在高 128T 的内核态虚拟内存空间：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 范围中，所以虚拟内存地址的高 16 位全部为 1 。</p>
<p>也就是说内核态的虚拟内存地址的高 16 位全部为 1 ，如果一个试图访问内核的虚拟地址的高 16 位不全为 1 ，则可以快速判断这个访问是非法的。</p>
<p>这个高 16 位的空闲地址被称为 canonical 。如果虚拟内存地址中的高 16 位全部为 0 （表示用户空间虚拟内存地址）或者全部为 1 （表示内核空间虚拟内存地址），这种地址的形式我们叫做 canonical form，对应的地址我们称作 canonical address 。</p>
<p>那么处于 canonical address 空洞 ：0x0000 7FFF FFFF F000 - 0xFFFF 8000 0000 0000 范围内的地址的高 16 位 不全为 0 也不全为 1 。如果某个虚拟地址落在这段 canonical address 空洞区域中，那就是既不在用户空间，也不在内核空间，肯定是非法访问了。</p>
<p>未来我们也可以利用这块 canonical address 空洞，来扩展虚拟内存地址的范围，比如扩展到 56 位。</p>
<p>在我们理解了 canonical address 这个概念之后，我们再来看下 64 位 Linux 系统下的真实虚拟内存空间布局情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png"></p>
<p>从上图中我们可以看出 64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。主要不同的地方有三点：</p>
<ol>
<li><p>就是前边提到的由高 16 位空闲地址造成的  canonical address 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。</p>
</li>
<li><p>在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</p>
</li>
<li><p>用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低 128T 分配给用户态虚拟内存空间，高 128T 分配给内核态虚拟内存空间。</p>
</li>
<li><p>进程虚拟内存空间的管理</p>
</li>
</ol>
<hr>
<p>在上一小节中，笔者为大家介绍了 Linux 操作系统在 32 位机器上和 64 位机器上进程虚拟内存空间的布局分布，我们发现无论是在 32 位机器上还是在 64 位机器上，进程虚拟内存空间的核心区域分布的相对位置是不变的，它们都包含下图所示的这几个核心内存区域。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png"></p>
<p>唯一不同的是这些核心内存区域在 32 位机器和 64 位机器上的绝对位置分布会有所不同。</p>
<p>那么在此基础之上，内核如何为进程管理这些虚拟内存区域呢？这将是本小节重点为大家介绍的内容~~</p>
<p>既然我们要介绍进程的虚拟内存空间管理，那就离不开进程在内核中的描述符 task_struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 进程id</span></span><br><span class="line">     <span class="type">pid_t</span>    pid;</span><br><span class="line">        <span class="comment">// 用于标识线程所属的进程 pid</span></span><br><span class="line">     <span class="type">pid_t</span>    tgid;</span><br><span class="line">        <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>  *<span class="title">files</span>;</span></span><br><span class="line">        <span class="comment">// 内存描述符表示进程虚拟地址空间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>  *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">        .......... 省略 .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了前边几个小节中介绍的进程虚拟内存空间的全部信息。</p>
<p>每个进程都有唯一的 mm_struct 结构体，也就是前边提到的每个进程的虚拟地址空间都是独立，互不干扰的。</p>
<p>当我们调用 fork() 函数创建进程的时候，表示进程地址空间的 mm_struct 结构会随着进程描述符 task_struct 的创建而创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _do_fork(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">       <span class="type">int</span> __user *parent_tidptr,</span><br><span class="line">       <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">        ......... 省略 ..........</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">        ......... 省略 ..........</span><br><span class="line">    <span class="comment">// 为进程创建 task_struct 结构，用父进程的资源填充 task_struct 信息</span></span><br><span class="line"> p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">    child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">         ......... 省略 ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后会在 copy_process 函数中创建 task_struct 结构，并拷贝父进程的相关资源到新进程的 task_struct 结构里，其中就包括拷贝父进程的虚拟内存空间 mm_struct 结构。<strong>这里可以看出子进程在新创建出来之后它的虚拟内存空间是和父进程的虚拟内存空间一模一样的，直接拷贝过来</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> __user *child_tidptr,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> pid *pid,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> trace,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> tls,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 创建 task_struct 结构</span></span><br><span class="line">    p = dup_task_struct(current, node);</span><br><span class="line"></span><br><span class="line">        ....... 初始化子进程 ...........</span><br><span class="line"></span><br><span class="line">        ....... 开始继承拷贝父进程资源  .......      </span><br><span class="line">    <span class="comment">// 继承父进程打开的文件描述符</span></span><br><span class="line"> retval = copy_files(clone_flags, p);</span><br><span class="line">    <span class="comment">// 继承父进程所属的文件系统</span></span><br><span class="line"> retval = copy_fs(clone_flags, p);</span><br><span class="line">    <span class="comment">// 继承父进程注册的信号以及信号处理函数</span></span><br><span class="line"> retval = copy_sighand(clone_flags, p);</span><br><span class="line"> retval = copy_signal(clone_flags, p);</span><br><span class="line">    <span class="comment">// 继承父进程的虚拟内存空间</span></span><br><span class="line"> retval = copy_mm(clone_flags, p);</span><br><span class="line">    <span class="comment">// 继承父进程的 namespaces</span></span><br><span class="line"> retval = copy_namespaces(clone_flags, p);</span><br><span class="line">    <span class="comment">// 继承父进程的 IO 信息</span></span><br><span class="line"> retval = copy_io(clone_flags, p);</span><br><span class="line"></span><br><span class="line">      ...........省略.........</span><br><span class="line">    <span class="comment">// 分配 CPU</span></span><br><span class="line">    retval = sched_fork(clone_flags, p);</span><br><span class="line">    <span class="comment">// 分配 pid</span></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children);</span><br><span class="line"></span><br><span class="line">.     ..........省略.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重点关注 copy_mm 函数，正是在这里完成了子进程虚拟内存空间 mm_struct 结构的的创建以及初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 子进程虚拟内存空间，父进程虚拟内存空间</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line"> <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        ...... 省略 ......</span><br><span class="line"></span><br><span class="line"> tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"> tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取父进程虚拟内存空间</span></span><br><span class="line"> oldmm = current-&gt;mm;</span><br><span class="line"> <span class="keyword">if</span> (!oldmm)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ...... 省略 ......</span><br><span class="line"> <span class="comment">// 通过 vfork 或者 clone 系统调用创建出的子进程（线程）和父进程共享虚拟内存空间</span></span><br><span class="line"> <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        <span class="comment">// 增加父进程虚拟地址空间的引用计数</span></span><br><span class="line">        mmget(oldmm);</span><br><span class="line">        <span class="comment">// 直接将父进程的虚拟内存空间赋值给子进程（线程）</span></span><br><span class="line">        <span class="comment">// 线程共享其所属进程的虚拟内存空间</span></span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> retval = -ENOMEM;</span><br><span class="line"> <span class="comment">// 如果是 fork 系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的 mm_struct 结构中。</span></span><br><span class="line"> mm = dup_mm(tsk);</span><br><span class="line"> <span class="keyword">if</span> (!mm)</span><br><span class="line">  <span class="keyword">goto</span> fail_nomem;</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line"> <span class="comment">// 将拷贝出来的父进程虚拟内存空间 mm_struct 赋值给子进程</span></span><br><span class="line"> tsk-&gt;mm = mm;</span><br><span class="line"> tsk-&gt;active_mm = mm;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ...... 省略 ......</span><br></pre></td></tr></table></figure>

<p>由于本小节中我们举的示例是通过  fork() 函数创建子进程的情形，所以这里大家先占时忽略 <code>if (clone_flags &amp; CLONE_VM)</code> 这个条件判断逻辑，我们先跳过往后看~~</p>
<p>copy_mm  函数首先会将父进程的虚拟内存空间 current-&gt;mm 赋值给指针 oldmm。然后通过 dup_mm 函数将父进程的虚拟内存空间以及<strong>相关页表</strong>拷贝到子进程的 mm_struct 结构中。最后将拷贝出来的 mm_struct 赋值给子进程的 task_struct 结构。</p>
<blockquote>
<p>通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。</p>
</blockquote>
<p>而当我们通过 vfork 或者 clone 系统调用创建出的子进程，首先会设置 CLONE_VM 标识，这样来到 copy_mm 函数中就会进入  <code>if (clone_flags &amp; CLONE_VM)</code>  条件中，在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。</p>
<p>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</strong>。</p>
<p>内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。</p>
<p>当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程，因为内核线程不会访问用户空间的内存，它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。</p>
<blockquote>
<p>父进程与子进程的区别，进程与线程的区别，以及内核线程与用户态线程的区别其实都是围绕着这个 mm_struct 展开的。</p>
</blockquote>
<p>现在我们知道了表示进程虚拟内存空间的 mm_struct 结构是如何被创建出来的相关背景，那么接下来笔者就带大家深入 mm_struct 结构内部，来看一下内核如何通过这么一个 mm_struct 结构体来管理进程的虚拟内存空间的。</p>
<h3 id="5-1-内核如何划分用户态和内核态虚拟内存空间"><a href="#5-1-内核如何划分用户态和内核态虚拟内存空间" class="headerlink" title="5.1 内核如何划分用户态和内核态虚拟内存空间"></a>5.1 内核如何划分用户态和内核态虚拟内存空间</h3><p>通过 《3. 进程虚拟内存空间》小节的介绍我们知道，进程的虚拟内存空间分为两个部分：一部分是用户态虚拟内存空间，另一部分是内核态虚拟内存空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png"></p>
<p>那么用户态的地址空间和内核态的地址空间在内核中是如何被划分的呢？</p>
<p>这就用到了进程的内存描述符 mm_struct 结构体中的 task_size 变量，task_size 定义了用户态地址空间与内核态地址空间之间的分界线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size; <span class="comment">/* size of task vm space */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前边小节的内容介绍，我们知道在  32 位系统中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。</p>
<p>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png">32 位地址空间. png</p>
<p>32 位系统中用户地址空间和内核地址空间的分界线在 0xC000 000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0xC000 000。</p>
<p>我们来看下内核在 <code>/arch/x86/include/asm/page_32_types.h</code> 文件中关于 TASK_SIZE 的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User space process size: 3GB (default).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE  __PAGE_OFFSET</span></span><br></pre></td></tr></table></figure>

<p>如下图所示：__PAGE_OFFSET 的值在 32 位系统下为  0xC000 000。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTwn4kedvjD143dXc3MMSuQHNQUu9padcq5PI9QQmKRcIee0gImtguRg/640?wx_fmt=png">&#x2F;arch&#x2F;arm&#x2F;Kconfig.png</p>
<p>而在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。</p>
<p>内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png">64 位地址空间. png</p>
<p>64 位系统中用户地址空间和内核地址空间的分界线在  0x0000 7FFF FFFF F000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0x0000 7FFF FFFF F000 。</p>
<p>我们来看下内核在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中关于 TASK_SIZE 的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \</span></span><br><span class="line"><span class="meta">     IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX  task_size_max()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_size_max()  ((_AC(1,UL) &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __VIRTUAL_MASK_SHIFT 47</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来看下在 64 位系统中内核如何来计算 TASK_SIZE，在  task_size_max() 的计算逻辑中 1 左移 47 位得到的地址是 0x0000800000000000，然后减去一个 PAGE_SIZE （默认为 4K），就是 0x00007FFFFFFFF000，共 128T。所以在 64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000 。</p>
<blockquote>
<p>这里我们可以看出，64 位虚拟内存空间的布局是和物理内存页 page 的大小有关的，物理内存页 page 默认大小 PAGE_SIZE 为 4K。</p>
</blockquote>
<p>PAGE_SIZE 定义在 <code>/arch/x86/include/asm/page_types.h</code>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PAGE_SHIFT determines the page size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE  (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>

<p>而内核空间的起始地址是 0xFFFF 8000 0000 0000 。在 0x00007FFFFFFFF000 - 0xFFFF 8000 0000 0000 之间的内存区域就是我们在 《4.2 64 位机器上进程虚拟内存空间分布》小节中介绍的 canonical address 空洞。</p>
<h3 id="5-2-内核如何布局进程虚拟内存空间"><a href="#5-2-内核如何布局进程虚拟内存空间" class="headerlink" title="5.2 内核如何布局进程虚拟内存空间"></a>5.2 内核如何布局进程虚拟内存空间</h3><p>在我们理解了内核是如何划分进程虚拟内存空间和内核虚拟内存空间之后，那么在 《3. 进程虚拟内存空间》小节中介绍的那些虚拟内存区域在内核中又是如何划分的呢？</p>
<p>接下来笔者就为大家介绍下内核是如何划分进程虚拟内存空间中的这些内存区域的，本小节的示例图中，笔者只保留了进程虚拟内存空间中的核心区域，方便大家理解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTRV8O9NcRglfjls8RoaE2pOElX2BkmGhX4VRuoG257kTwfR2tBRuzUA/640?wx_fmt=png"></p>
<p>前边我们提到，内核中采用了一个叫做内存描述符的 mm_struct 结构体来表示进程虚拟内存空间的全部信息。在本小节中笔者就带大家到 mm_struct 结构体内部去寻找下相关的线索。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;    <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;  <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;    <span class="comment">/* Total pages mapped */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;  <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;    <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;    <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;    <span class="comment">/* VM_STACK */</span></span><br><span class="line"></span><br><span class="line">       ...... 省略 ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核中用 mm_struct 结构体中的上述属性来定义上图中虚拟内存空间里的不同内存区域。</p>
<p>start_code 和 end_code 定义代码段的起始和结束位置，程序编译后的二进制文件中的机器码被加载进内存之后就存放在这里。</p>
<p>start_data 和 end_data 定义数据段的起始和结束位置，二进制文件中存放的全局变量和静态变量被加载进内存中就存放在这里。</p>
<p>后面紧挨着的是 BSS 段，用于存放未被初始化的全局变量和静态变量，这些变量在加载进内存时会生成一段 0 填充的内存区域 （BSS 段）， BSS 段的大小是固定的，</p>
<p>下面就是 OS 堆了，在堆中内存地址的增长方向是由低地址向高地址增长， start_brk 定义堆的起始位置，brk 定义堆当前的结束位置。</p>
<blockquote>
<p>我们使用 malloc 申请小块内存时（低于 128K），就是通过改变 brk 位置调整堆大小实现的。</p>
</blockquote>
<p>接下来就是内存映射区，在内存映射区内存地址的增长方向是由高地址向低地址增长，mmap_base 定义内存映射区的起始地址。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段以及我们调用 mmap 映射出来的一段虚拟内存空间就保存在这个区域。</p>
<p>start_stack 是栈的起始位置在 RBP 寄存器中存储，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储。在栈中内存地址的增长方向也是由高地址向低地址增长。</p>
<p>arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中的最高地址处。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png"></p>
<p>在 mm_struct 结构体中除了上述用于划分虚拟内存区域的变量之外，还定义了一些虚拟内存与物理内存映射内容相关的统计变量，操作系统会把物理内存划分成一页一页的区域来进行管理，所以物理内存到虚拟内存之间的映射也是按照页为单位进行的。这部分内容笔者会在后续的文章中详细介绍，大家这里只需要有个概念就行。</p>
<p>mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。</p>
<blockquote>
<p>注意映射这个概念，它表示只是将虚拟内存与物理内存建立关联关系，并不代表真正的分配物理内存。</p>
</blockquote>
<p>当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。locked_vm 就是被锁定不能换出的内存页总数，pinned_vm  表示既不能换出，也不能移动的内存页总数。</p>
<p>data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。</p>
<p>现在关于内核如何对进程虚拟内存空间进行布局的内容我们已经清楚了，那么布局之后划分出的这些虚拟内存区域在内核中又是如何被管理的呢？我们接着往下看~~~</p>
<h3 id="5-3-内核如何管理虚拟内存区域"><a href="#5-3-内核如何管理虚拟内存区域" class="headerlink" title="5.3 内核如何管理虚拟内存区域"></a>5.3 内核如何管理虚拟内存区域</h3><p>在上小节的介绍中，我们知道内核是通过一个 mm_struct 结构的内存描述符来表示进程的虚拟内存空间的，并通过 task_size 域来划分用户态虚拟内存空间和内核态虚拟内存空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png"></p>
<p>而在划分出的这些虚拟内存空间中如上图所示，里边又包含了许多特定的虚拟内存区域，比如：代码段，数据段，堆，内存映射区，栈。那么这些虚拟内存区域在内核中又是如何表示的呢？</p>
<p>本小节中，笔者将为大家介绍一个新的结构体 vm_area_struct，正是这个结构体描述了这些虚拟内存区域 VMA（virtual memory area）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_start;  <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_end;  <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">        within vm_mm. */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_flags; </span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span> <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>  <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;  <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">        units */</span> </span><br><span class="line"> <span class="type">void</span> * vm_private_data;  <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"> <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 vm_area_struct 结构对应于虚拟内存空间中的唯一虚拟内存区域 VMA，vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是 [vm_start，vm_end) 这样一段左闭右开的虚拟内存区域。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTCwh0csrop8H9RPKibNQSiaqM11pOcaAnCBXBAIOibm8hgFICKQibObAcOQ/640?wx_fmt=png"></p>
<h3 id="5-4-定义虚拟内存区域的访问权限和行为规范"><a href="#5-4-定义虚拟内存区域的访问权限和行为规范" class="headerlink" title="5.4 定义虚拟内存区域的访问权限和行为规范"></a>5.4 定义虚拟内存区域的访问权限和行为规范</h3><p>vm_page_prot 和 vm_flags 都是用来标记 vm_area_struct 结构表示的这块虚拟内存区域的访问权限和行为规范。</p>
<p>上边小节中我们也提到，内核会将整块物理内存划分为一页一页大小的区域，以页为单位来管理这些物理内存，每页大小默认 4K 。而虚拟内存最终也是要和物理内存一一映射起来的，所以在虚拟内存空间中也有虚拟页的概念与之对应，虚拟内存中的虚拟页映射到物理内存中的物理页。无论是在虚拟内存空间中还是在物理内存中，内核管理内存的最小单位都是页。</p>
<p>vm_page_prot 偏向于定义底层内存管理架构中页这一级别的访问控制权限，它可以直接应用在底层页表中，它是一个具体的概念。</p>
<blockquote>
<p>页表用于管理虚拟内存到物理内存之间的映射关系，这部分内容笔者后续会详细讲解，这里大家有个初步的概念就行。</p>
</blockquote>
<p>虚拟内存区域 VMA 由许多的虚拟页 (page) 组成，每个虚拟页需要经过页表的转换才能找到对应的物理页面。页表中关于内存页的访问权限就是由 vm_page_prot 决定的。</p>
<p>vm_flags 则偏向于定于整个虚拟内存区域的访问权限以及行为规范。描述的是虚拟内存区域中的整体信息，而不是虚拟内存区域中具体的某个独立页面。它是一个抽象的概念。可以通过 <code>vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags)</code> 实现到具体页面访问权限 vm_page_prot 的转换。</p>
<p>下面笔者列举一些常用到的 vm_flags 方便大家有一个直观的感受：</p>
<table><thead><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: white;"><th data-style="border-top-width: 1px; border-color: rgb(204, 204, 204); background-color: rgb(240, 240, 240); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">vm_flags</th><th data-style="border-top-width: 1px; border-color: rgb(204, 204, 204); background-color: rgb(240, 240, 240); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">访问权限</th></tr></thead><tbody><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: white;"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_READ</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">可读</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248);"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_WRITE</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">可写</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: white;"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_EXEC</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">可执行</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248);"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_SHARD</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">可多进程之间共享</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: white;"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_IO</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">可映射至设备 IO 空间</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248);"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_RESERVED</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">内存区域不可被换出</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: white;"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_SEQ_READ</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">内存区域可能被顺序访问</td></tr><tr data-style="border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248);"><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">VM_RAND_READ</td><td data-style="border-color: rgb(204, 204, 204); color: rgb(66, 75, 93); font-size: 14px; min-width: 85px; text-align: center;">内存区域可能被随机访问</td></tr></tbody></table>

<p>VM_READ，VM_WRITE，VM_EXEC 定义了虚拟内存区域是否可以被读取，写入，执行等权限。</p>
<p>比如代码段这块内存区域的权限是可读，可执行，但是不可写。数据段具有可读可写的权限但是不可执行。堆则具有可读可写，可执行的权限（Java 中的字节码存储在堆中，所以需要可执行权限），栈一般是可读可写的权限，一般很少有可执行权限。而文件映射与匿名映射区存放了共享链接库，所以也需要可执行的权限。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTpl6pHWb18OgpCQSFx88HvCalkeMjcyv7ckibCU6ZPy5FEfeWnY0j4Mw/640?wx_fmt=png"></p>
<p>VM_SHARD 用于指定这块虚拟内存区域映射的物理内存是否可以在多进程之间共享，以便完成进程间通讯。</p>
<blockquote>
<p>设置这个值即为 mmap 的共享映射，不设置的话则为私有映射。这个等后面我们讲到 mmap 的相关实现时还会再次提起。</p>
</blockquote>
<p>VM_IO 的设置表示这块虚拟内存区域可以映射至设备 IO 空间中。通常在设备驱动程序执行 mmap 进行 IO 空间映射时才会被设置。</p>
<p>VM_RESERVED 的设置表示在内存紧张的时候，这块虚拟内存区域非常重要，不能被换出到磁盘中。</p>
<p>VM_SEQ_READ 的设置用来暗示内核，应用程序对这块虚拟内存区域的读取是会采用顺序读的方式进行，内核会根据实际情况决定预读后续的内存页数，以便加快下次顺序访问速度。</p>
<p>VM_RAND_READ 的设置会暗示内核，应用程序会对这块虚拟内存区域进行随机读取，内核则会根据实际情况减少预读的内存页数甚至停止预读。</p>
<p>我们可以通过 posix_fadvise，madvise 系统调用来暗示内核是否对相关内存区域进行顺序读取或者随机读取。相关的详细内容，大家可以看下笔者上篇文章 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a>中的第 9 小节文件页预读部分。</p>
<p>通过这一系列的介绍，我们可以看到 vm_flags 就是定义整个虚拟内存区域的访问权限以及行为规范，而内存区域中内存的最小单位为页（4K），虚拟内存区域中包含了很多这样的虚拟页，对于虚拟内存区域 VMA 设置的访问权限也会全部复制到区域中包含的内存页中。</p>
<h3 id="5-5-关联内存映射中的映射关系"><a href="#5-5-关联内存映射中的映射关系" class="headerlink" title="5.5 关联内存映射中的映射关系"></a>5.5 关联内存映射中的映射关系</h3><p>接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。</p>
<p>那么这个映射关系在内核中该如何表示呢？这就用到了 vm_area_struct 结构体中的上述三个属性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png"></p>
<p>当我们调用 malloc 申请内存时，如果申请的是小块内存（低于 128K）则会使用 do_brk() 系统调用通过调整堆中的 brk 指针大小来增加或者回收堆内存。</p>
<p>如果申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域（这里是匿名映射）。这块匿名映射区域就用 struct anon_vma 结构表示。</p>
<p>当调用 mmap 进行文件映射时，vm_file 属性就用来关联被映射的文件。这样一来虚拟内存区域就与映射文件关联了起来。vm_pgoff 则表示映射进虚拟内存中的文件内容，在文件中的偏移。</p>
<blockquote>
<p>当然在匿名映射中，vm_area_struct 结构中的 vm_file 就为 null，vm_pgoff 也就没有了意义。</p>
</blockquote>
<p>vm_private_data 则用于存储 VMA 中的私有数据。具体的存储内容和内存映射的类型有关，我们暂不展开论述。</p>
<h3 id="5-6-针对虚拟内存区域的相关操作"><a href="#5-6-针对虚拟内存区域的相关操作" class="headerlink" title="5.6 针对虚拟内存区域的相关操作"></a>5.6 针对虚拟内存区域的相关操作</h3><p>struct vm_area_struct 结构中还有一个 vm_ops 用来指向针对虚拟内存区域 VMA 的相关操作的函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line"> <span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line"> <span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="type">vm_fault_t</span> (*fault)(<span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line">    <span class="type">vm_fault_t</span> (*page_mkwrite)(<span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line"></span><br><span class="line">    ..... 省略 .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当指定的虚拟内存区域被加入到进程虚拟内存空间中时，open 函数会被调用</p>
</li>
<li><p>当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时，close 函数会被调用</p>
</li>
<li><p>当进程访问虚拟内存时，访问的页面不在物理内存中，可能是未分配物理内存也可能是被置换到磁盘中，这时就会产生缺页异常，fault 函数就会被调用。</p>
</li>
<li><p>当一个只读的页面将要变为可写时，page_mkwrite 函数会被调用。</p>
</li>
</ul>
<p>struct vm_operations_struct 结构中定义的都是对虚拟内存区域 VMA 的相关操作函数指针。</p>
<p>内核中这种类似的用法其实有很多，在内核中每个特定领域的描述符都会定义相关的操作。比如在前边的文章 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a> 中我们介绍到内核中的文件描述符 struct file 中定义的 struct file_operations  *f_op。里面定义了内核针对文件操作的函数指针，具体的实现根据不同的文件类型有所不同。</p>
<p>针对 Socket 文件类型，这里的 file_operations 指向的是 socket_file_ops。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTpJKpGlocuxEfConFicRSdhlicskcHsr6ETUJqAAcpnUqDbkLicHaR8lcQ/640?wx_fmt=png">进程中管理文件列表结构. png</p>
<p>在 ext4 文件系统中管理的文件对应的 file_operations 指向 ext4_file_operations，专门用于操作 ext4 文件系统中的文件。还有针对 page cache 页高速缓存相关操作定义的 address_space_operations 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT6QNuOEO3cjwD6D14LstYQMSTGM6WOeDicV3EXIasbsic4YwK6RbTmuaw/640?wx_fmt=png"></p>
<p>还有我们在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6&chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&scene=21#wechat_redirect">《从 Linux 内核角度看 IO 模型的演变》</a>一文中介绍到，socket 相关的操作接口定义在 inet_stream_ops 函数集合中，负责对上给用户提供接口。而 socket 与内核协议栈之间的操作接口定义在 struct sock 中的 sk_prot 指针上，这里指向 tcp_prot 协议操作函数集合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT5TjyB66fyZCRKuOwKxG5HJ5ebERelmfGZc5PosSu4XibrwSQHD63iaoQ/640?wx_fmt=png">系统 IO 调用结构. png</p>
<p>对 socket 发起的系统 IO 调用时，在内核中首先会调用 socket 的文件结构 struct file 中的 file_operations 文件操作集合，然后调用 struct socket 中的 ops 指向的 inet_stream_opssocket 操作函数，最终调用到 struct sock 中 sk_prot 指针指向的 tcp_prot 内核协议栈操作函数接口集合。</p>
<h3 id="5-7-虚拟内存区域在内核中是如何被组织的"><a href="#5-7-虚拟内存区域在内核中是如何被组织的" class="headerlink" title="5.7 虚拟内存区域在内核中是如何被组织的"></a>5.7 虚拟内存区域在内核中是如何被组织的</h3><p>在上一小节中，我们介绍了内核中用来表示虚拟内存区域 VMA 的结构体 struct vm_area_struct ，并详细为大家剖析了 struct vm_area_struct 中的一些重要的关键属性。</p>
<p>现在我们已经熟悉了这些虚拟内存区域，那么接下来的问题就是在内核中这些虚拟内存区域是如何被组织的呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png"></p>
<p>我们继续来到 struct vm_area_struct 结构中，来看一下与组织结构相关的一些属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* The address space we belong to. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;     <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;       <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>  <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>      <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;     <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units */</span> </span><br><span class="line">    <span class="type">void</span> * vm_private_data;     <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中其实是通过一个 struct vm_area_struct 结构的双向链表将虚拟内存空间中的这些虚拟内存区域 VMA 串联起来的。</p>
<p>vm_area_struct 结构中的 vm_next ，vm_prev 指针分别指向 VMA 节点所在双向链表中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点按照低地址到高地址的增长方向排序。</p>
<p>双向链表中的最后一个 VMA 节点的 vm_next 指针指向 NULL，双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 mmap 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>  <span class="comment">/* list of VMAs */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个虚拟内存区域 VMA 中又通过 struct vm_area_struct 中的 vm_mm 指针指向了所属的虚拟内存空间 mm_struct。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT9micXwnnJLk1icdR1KJeSMqiarDJX8venibtYAMAl0LG4lMlSpNDlRUFCg/640?wx_fmt=png"></p>
<p>我们可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 查看进程的虚拟内存空间布局以及其中包含的所有内存区域。这两个命令背后的实现原理就是通过遍历内核中的这个 vm_area_struct 双向链表获取的。</p>
<p>内核中关于这些虚拟内存区域的操作除了遍历之外还有许多需要根据特定虚拟内存地址在虚拟内存空间中查找特定的虚拟内存区域。</p>
<p>尤其在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O(logN) ，可以显著减少查找所需的时间。</p>
<p>所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找。</p>
<p>每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。</p>
<p>而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 mm_rb 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTkDjSrw0Zfl8RI3ibrp7ST6kibrgBvybgFxSGodZnGiarqNCUY2l5f6dBw/640?wx_fmt=png"></p>
<ol start="6">
<li>程序编译后的二进制文件如何映射到虚拟内存空间中</li>
</ol>
<hr>
<p>经过前边这么多小节的内容介绍，现在我们已经熟悉了进程虚拟内存空间的布局，以及内核如何管理这些虚拟内存区域，并对进程的虚拟内存空间有了一个完整全面的认识。</p>
<p>现在我们再来回到最初的起点，进程的虚拟内存空间 mm_struct 以及这些虚拟内存区域 vm_area_struct 是如何被创建并初始化的呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png"></p>
<p>在 《3. 进程虚拟内存空间》小节中，我们介绍进程的虚拟内存空间时提到，我们写的程序代码编译之后会生成一个 ELF 格式的二进制文件，这个二进制文件中包含了程序运行时所需要的元信息，比如程序的机器码，程序中的全局变量以及静态变量等。</p>
<p>这个 ELF 格式的二进制文件中的布局和我们前边讲的虚拟内存空间中的布局类似，也是一段一段的，每一段包含了不同的元数据。</p>
<blockquote>
<p>磁盘文件中的段我们叫做 Section，内存中的段我们叫做 Segment，也就是内存区域。</p>
</blockquote>
<p>磁盘文件中的这些 Section 会在进程运行之前加载到内存中并映射到内存中的 Segment。通常是多个 Section 映射到一个 Segment。</p>
<p>比如磁盘文件中的 .text，.rodata 等一些只读的 Section，会被映射到内存的一个只读可执行的 Segment 里（代码段）。而 .data，.bss 等一些可读写的 Section，则会被映射到内存的一个具有读写权限的 Segment 里（数据段，BSS 段）。</p>
<p>那么这些 ELF 格式的二进制文件中的 Section 是如何加载并映射进虚拟内存空间的呢？</p>
<p>内核中完成这个映射过程的函数是 load_elf_binary ，这个函数的作用很大，加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立上述提到的内存映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">      ...... 省略 ........</span><br><span class="line">  <span class="comment">// 设置虚拟内存空间中的内存映射区域起始地址 mmap_base</span></span><br><span class="line">  setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line">  <span class="comment">// 创建并初始化栈对应的 vm_area_struct 结构。</span></span><br><span class="line">  <span class="comment">// 设置 mm-&gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&gt;arg_start 是指向栈底的。</span></span><br><span class="line">  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">         executable_stack);</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line">  <span class="comment">// 将二进制文件中的代码部分映射到虚拟内存空间中</span></span><br><span class="line">  error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,</span><br><span class="line">        elf_prot, elf_flags, total_size);</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line"> <span class="comment">// 创建并初始化堆对应的的 vm_area_struct 结构</span></span><br><span class="line"> <span class="comment">// 设置 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的</span></span><br><span class="line">  retval = set_brk(elf_bss, elf_brk, bss_prot);</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line">  <span class="comment">// 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域</span></span><br><span class="line">  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">              interpreter,</span><br><span class="line">              &amp;interp_map_addr,</span><br><span class="line">              load_bias, interp_elf_phdata);</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line">  <span class="comment">// 初始化内存描述符 mm_struct</span></span><br><span class="line">  current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">  current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">  current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">  current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">  current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">     ...... 省略 ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>setup_new_exec 设置虚拟内存空间中的内存映射区域起始地址 mmap_base</p>
</li>
<li><p>setup_arg_pages 创建并初始化栈对应的 vm_area_struct 结构。置 mm-&gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&gt;arg_start 是指向栈底的。</p>
</li>
<li><p>elf_map 将 ELF 格式的二进制文件中. text ，.data，.bss 部分映射到虚拟内存空间中的代码段，数据段，BSS 段中。</p>
</li>
<li><p>set_brk 创建并初始化堆对应的的 vm_area_struct 结构，设置 <code>current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk</code>，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的。</p>
</li>
<li><p>load_elf_interp 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域</p>
</li>
<li><p>初始化内存描述符 mm_struct</p>
</li>
</ul>
<ol start="7">
<li>内核虚拟内存空间</li>
</ol>
<hr>
<p>现在我们已经知道了进程虚拟内存空间在内核中的布局以及管理，那么内核态的虚拟内存空间又是什么样子的呢？本小节笔者就带大家来一层一层地拆开这个黑盒子。</p>
<p>之前在介绍进程虚拟内存空间的时候，笔者提到不同进程之间的虚拟内存空间是相互隔离的，彼此之间相互独立，相互感知不到其他进程的存在。使得进程以为自己拥有所有的内存资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLINE1jjQPxBJrZqwwSMJgMP6WHR0rLxsICVroYUN5HQv7Kk5a8aS3g/640?wx_fmt=png"></p>
<p>而内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。</p>
<p>什么意思呢？比如上图中的进程 a，进程 b，进程 c 分别在各自的用户态虚拟内存空间中访问虚拟地址 x 。由于进程之间的用户态虚拟内存空间是相互隔离相互独立的，虽然在进程 a，进程 b，进程 c 访问的都是虚拟地址 x 但是看到的内容却是不一样的（背后可能映射到不同的物理内存中）。</p>
<p>但是当进程 a，进程 b，进程 c 进入到内核态之后情况就不一样了，由于内核虚拟内存空间是各个进程共享的，所以它们在内核空间中看到的内容全部是一样的，比如进程 a，进程 b，进程 c 在内核态都去访问虚拟地址 y。这时它们看到的内容就是一样的了。</p>
<blockquote>
<p>这里笔者和大家澄清一个经常被误解的概念：由于内核会涉及到物理内存的管理，所以很多人会想当然地认为只要进入了内核态就开始使用物理地址了，这就大错特错了，千万不要这样理解，进程进入内核态之后使用的仍然是虚拟内存地址，只不过在内核中使用的虚拟内存地址被限制在了内核态虚拟内存空间范围中，这也是本小节笔者要为大家介绍的主题。</p>
</blockquote>
<p>在清楚了这个基本概念之后，下面笔者分别从 32 位体系 和 64 位体系下为大家介绍内核态虚拟内存空间的布局。</p>
<h3 id="7-1-32-位体系内核虚拟内存空间布局"><a href="#7-1-32-位体系内核虚拟内存空间布局" class="headerlink" title="7.1 32 位体系内核虚拟内存空间布局"></a>7.1 32 位体系内核虚拟内存空间布局</h3><p>在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 <code>/arch/x86/include/asm/page_32_types.h</code> 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User space process size: 3GB (default).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE       __PAGE_OFFSET</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>__PAGE_OFFSET 的值在 32 位系统下为 0xC000 000</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png"></p>
<p>在 32 位体系结构下进程用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。</p>
<p>本小节我们主要关注 0xC000 000 - 0xFFFF FFFF 这段虚拟内存地址区域也就是内核虚拟内存空间的布局情况。</p>
<h3 id="7-1-1-直接映射区"><a href="#7-1-1-直接映射区" class="headerlink" title="7.1.1 直接映射区"></a>7.1.1 直接映射区</h3><p>在总共大小 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，我们称之为直接映射区或者线性映射区，地址范围为 3G – 3G + 896m 。</p>
<p>之所以这块 896M 大小的区域称为直接映射区或者线性映射区，是因为这块连续的虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上。</p>
<p>也就是说 3G – 3G + 896m 这块 896M 大小的虚拟内存会直接映射到 0 - 896M 这块 896M 大小的物理内存上，<strong>这块区域中的虚拟内存地址直接减去 0xC000 0000 (3G) 就得到了物理内存地址</strong>。所以我们称这块区域为直接映射区。</p>
<blockquote>
<p>为了方便为大家解释，我们假设现在机器上的物理内存为 4G 大小</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTFnmSNJxcOXI7TxpbhdNzgJnvDt81tMEyFGsnNic5DZx9L2mkn77RLmQ/640?wx_fmt=png"> </p>
<blockquote>
<p>虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。关于页表的概念笔者后续会为大家详细讲解，这里大家只需要简单理解为页表保存了虚拟地址到物理地址的映射关系即可。</p>
</blockquote>
<p><strong>大家这里只需要记得内核态虚拟内存空间的前 896M 区域是直接映射到物理内存中的前 896M 区域中的，直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变</strong>。</p>
<p>明白了这个关系之后，我们接下来就看一下这块直接映射区域在物理内存中究竟存的是什么内容~~~</p>
<p>在这段 896M 大小的物理内存中，前 1M 已经在系统启动的时候被系统占用，1M 之后的物理内存存放的是内核代码段，数据段，BSS 段（这些信息起初存放在 ELF 格式的二进制文件中，在系统启动的时候被加载进内存）。</p>
<blockquote>
<p>我们可以通过 <code>cat /proc/iomem</code> 命令查看具体物理内存布局情况。</p>
</blockquote>
<p>当我们使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如之前提到的进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等。</p>
<p>这些进程相关的数据结构也会存放在物理内存前 896M 的这段区域中，当然也会被直接映射至内核态虚拟内存空间中的 3G – 3G + 896m 这段直接映射区域中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTkDjSrw0Zfl8RI3ibrp7ST6kibrgBvybgFxSGodZnGiarqNCUY2l5f6dBw/640?wx_fmt=png"></p>
<p>当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，内核会为每个进程分配一个固定大小的内核栈（一般是两个页大小，依赖具体的体系结构），每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。</p>
<p>与进程用户空间中的栈不同的是，内核栈容量小而且是固定的，用户空间中的栈容量大而且可以动态扩展。内核栈的溢出危害非常巨大，它会直接悄无声息的覆盖相邻内存区域中的数据，破坏数据。</p>
<p>通过以上内容的介绍我们了解到内核虚拟内存空间最前边的这段 896M 大小的直接映射区如何与物理内存进行映射关联，并且清楚了直接映射区主要用来存放哪些内容。</p>
<p>写到这里，笔者觉得还是有必要再次从功能划分的角度为大家介绍下这块直接映射区域。</p>
<p>我们都知道内核对物理内存的管理都是以页为最小单位来管理的，每页默认 4K 大小，理想状况下任何种类的数据页都可以存放在任何页框中，没有什么限制。比如：存放内核数据，用户数据，缓冲磁盘数据等。</p>
<p>但是实际的计算机体系结构受到硬件方面的限制制约，间接导致限制了页框的使用方式。</p>
<p>比如在 X86 体系结构下，ISA 总线的 DMA （直接内存存取）控制器，只能对内存的前 16M 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，只能使用物理内存的前 16M 进行 DMA 操作。</p>
<p>因此直接映射区的前 16M 专门让内核用来为 DMA 分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。</p>
<blockquote>
<p>用于 DMA 的内存必须从 ZONE_DMA 区域中分配。</p>
</blockquote>
<p>而直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。从字面意义上我们可以了解到，这块区域包含的就是正常的页框（使用没有任何限制）。</p>
<p>ZONE_NORMAL 由于也是属于直接映射区的一部分，对应的物理内存 16M 到 896M 这段区域也是被直接映射至内核态虚拟内存空间中的 3G + 16M 到 3G + 896M 这段虚拟内存上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT8zuLLYT3jE5gI1XxxuhpM1Qlg82wzlwGPNy9Bl8xCo5dYdKxY2Oqzg/640?wx_fmt=png"></p>
<blockquote>
<p>注意这里的 ZONE_DMA 和 ZONE_NORMAL 是内核针对物理内存区域的划分。</p>
</blockquote>
<p>现在物理内存中的前 896M 的区域也就是前边介绍的 ZONE_DMA 和 ZONE_NORMAL 区域到内核虚拟内存空间的映射笔者就为大家介绍完了，它们都是采用直接映射的方式，一比一就行映射。</p>
<h3 id="7-1-2-ZONE-HIGHMEM-高端内存"><a href="#7-1-2-ZONE-HIGHMEM-高端内存" class="headerlink" title="7.1.2  ZONE_HIGHMEM 高端内存"></a>7.1.2  ZONE_HIGHMEM 高端内存</h3><p>而物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。</p>
<p>本例中我们的物理内存假设为 4G，高端内存区域为 4G - 896M &#x3D; 3200M，那么这块 3200M 大小的 ZONE_HIGHMEM 区域该如何映射到内核虚拟内存空间中呢？</p>
<p>由于内核虚拟内存空间中的前 896M 虚拟内存已经被直接映射区所占用，而在 32 体系结构下内核虚拟内存空间总共也就 1G 的大小，这样一来内核剩余可用的虚拟内存空间就变为了 1G - 896M &#x3D; 128M。</p>
<p>显然物理内存中 3200M 大小的 ZONE_HIGHMEM 区域无法继续通过直接映射的方式映射到这 128M 大小的虚拟内存空间中。</p>
<p>这样一来物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。</p>
<p>知道了 ZONE_HIGHMEM 区域的映射原理，我们接着往下看这 128M 大小的内核虚拟内存空间究竟是如何布局的？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTPbibvHGL4nm4dwdjUSHEAAGN8RBUweEasfbqZRfXmJ4ogqz6zZWoGPQ/640?wx_fmt=png"></p>
<p>内核虚拟内存空间中的 3G + 896M 这块地址在内核中定义为 high_memory，high_memory 往上有一段 8M 大小的内存空洞。空洞范围为：high_memory 到  VMALLOC_START 。</p>
<p>VMALLOC_START 定义在内核源码 <code>/arch/x86/include/asm/pgtable_32_areas.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_OFFSET (8 * 1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_START ((unsigned long)high_memory + VMALLOC_OFFSET)</span></span><br></pre></td></tr></table></figure>

<h3 id="7-1-3-vmalloc-动态映射区"><a href="#7-1-3-vmalloc-动态映射区" class="headerlink" title="7.1.3 vmalloc 动态映射区"></a>7.1.3 vmalloc 动态映射区</h3><p>接下来 VMALLOC_START 到 VMALLOC_END 之间的这块区域成为动态映射区。采用动态映射的方式映射物理内存中的高端内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> VMALLOC_END (PKMAP_BASE - 2 * PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> VMALLOC_END (LDT_BASE_ADDR - 2 * PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZHjzia2OcPveiaAD6Sjj44WzTVu7xMB3dqHlZqzX6IDdWh8Ouwf5XvmQ/640?wx_fmt=png"></p>
<p>和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc 进行内存分配。由于之前介绍的动态映射的原因，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。</p>
<blockquote>
<p>由于 vmalloc 获得的物理内存页是不连续的，因此它只能将这些物理内存页一个一个地进行映射，在性能开销上会比直接映射大得多。</p>
</blockquote>
<p>关于 vmalloc 分配内存的相关实现原理，笔者会在后面的文章中为大家讲解，这里大家只需要明白它在哪块虚拟内存区域中活动即可。</p>
<h3 id="7-1-4-永久映射区"><a href="#7-1-4-永久映射区" class="headerlink" title="7.1.4 永久映射区"></a>7.1.4 永久映射区</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfdtjLnvoyuauI7AeWzkv3MnrW4vmX8sAp7dyP7OGEZxFFuM1icNjqWw/640?wx_fmt=png"></p>
<p>而在 PKMAP_BASE 到 FIXADDR_START 之间的这段空间称为永久映射区。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。比如内核通过 alloc_pages() 函数在物理内存的高端内存中申请获取到的物理内存页，这些物理内存页可以通过调用 kmap 映射到永久映射区中。</p>
<blockquote>
<p>LAST_PKMAP 表示永久映射区可以映射的页数限制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PKMAP_BASE  \</span></span><br><span class="line"><span class="meta"> ((LDT_BASE_ADDR - PAGE_SIZE) &amp; PMD_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_PKMAP 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="8-1-5-固定映射区"><a href="#8-1-5-固定映射区" class="headerlink" title="8.1.5 固定映射区"></a>8.1.5 固定映射区</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTr7KEhCehnXzscf3hkJudYmFbLFialcUax2icKHKzmcfia7jZrOPRt6yqA/640?wx_fmt=png"></p>
<p>内核虚拟内存空间中的下一个区域为固定映射区，区域范围为：FIXADDR_START 到 FIXADDR_TOP。</p>
<p>FIXADDR_START 和 FIXADDR_TOP 定义在内核源码 <code>/arch/x86/include/asm/fixmap.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_START  (FIXADDR_TOP - FIXADDR_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> __FIXADDR_TOP; <span class="comment">// 0xFFFF F000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIXADDR_TOP ((unsigned long)__FIXADDR_TOP)</span></span><br></pre></td></tr></table></figure>

<p>在内核虚拟内存空间的直接映射区中，直接映射区中的虚拟内存地址与物理内存前 896M 的空间的映射关系都是预设好的，一比一映射。</p>
<p>在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。采用固定虚拟地址的好处是它相当于一个指针常量（常量的值在编译时确定），指向物理地址，如果虚拟地址不固定，则相当于一个指针变量。</p>
<p>那为什么会有固定映射这个概念呢 ?  比如：在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去。</p>
<h3 id="7-1-6-临时映射区"><a href="#7-1-6-临时映射区" class="headerlink" title="7.1.6  临时映射区"></a>7.1.6  临时映射区</h3><p>在内核虚拟内存空间中的最后一块区域为临时映射区，那么这块临时映射区是用来干什么的呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4aicM8rSpYHlFgD5OLCRuMvUhOKyLdTXJlibOEQfpU36mJibR6iadWjb0A/640?wx_fmt=png"></p>
<p>笔者在之前文章 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486623&idx=1&sn=0cafed9e89b60d678d8c88dc7689abda&chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&token=1276722624&lang=zh_CN&scene=21#wechat_redirect">《从 Linux 内核角度探秘 JDK NIO 文件读写本质》</a> 的 “12.3 iov_iter_copy_from_user_atomic” 小节中介绍在 Buffered IO 模式下进行文件写入的时候，在下图中的第四步，内核会调用 iov_iter_copy_from_user_atomic 函数将用户空间缓冲区 DirectByteBuffer 中的待写入数据拷贝到 page cache 中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicjf8r1WkxeUKn3NeibYpn7KNyI4ub2oGAcEpIP33a5OIfqdaicDkl5mA/640?wx_fmt=png"></p>
<p>但是内核又不能直接进行拷贝，因为此时从 page cache 中取出的缓存页 page 是物理地址，而在内核中是不能够直接操作物理地址的，只能操作虚拟地址。</p>
<p>那怎么办呢？所以就需要使用 kmap_atomic 将缓存页临时映射到内核空间的一段虚拟地址上，这段虚拟地址就位于内核虚拟内存空间中的临时映射区上，然后将用户空间缓存区 DirectByteBuffer 中的待写入数据通过这段映射的虚拟地址拷贝到 page cache 中的相应缓存页中。这时文件的写入操作就已经完成了。</p>
<p>由于是临时映射，所以在拷贝完成之后，调用 kunmap_atomic 将这段映射再解除掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">iov_iter_copy_from_user_atomic</span><span class="params">(<span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> iov_iter *i, <span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将缓存页临时映射到内核虚拟地址空间的临时映射区中</span></span><br><span class="line">  <span class="type">char</span> *kaddr = kmap_atomic(page), </span><br><span class="line">  *p = kaddr + offset;</span><br><span class="line">  <span class="comment">// 将用户缓存区 DirectByteBuffer 中的待写入数据拷贝到文件缓存页中</span></span><br><span class="line">  iterate_all_kinds(i, bytes, v,</span><br><span class="line">    copyin((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),</span><br><span class="line">    memcpy_from_page((p += v.bv_len) - v.bv_len, v.bv_page,</span><br><span class="line">         v.bv_offset, v.bv_len),</span><br><span class="line">    <span class="built_in">memcpy</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 解除内核虚拟地址空间与缓存页之间的临时映射，这里映射只是为了临时拷贝数据用</span></span><br><span class="line">  kunmap_atomic(kaddr);</span><br><span class="line">  <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-7-32-位体系结构下-Linux-虚拟内存空间整体布局"><a href="#7-1-7-32-位体系结构下-Linux-虚拟内存空间整体布局" class="headerlink" title="7.1.7 32 位体系结构下 Linux 虚拟内存空间整体布局"></a>7.1.7 32 位体系结构下 Linux 虚拟内存空间整体布局</h3><p>到现在为止，整个内核虚拟内存空间在 32 位体系下的布局，笔者就为大家详细介绍完毕了，我们再次结合前边《4.1 32 位机器上进程虚拟内存空间分布》小节中介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 32 位体系结构 Linux 的整个虚拟内存空间的布局：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTQxKjhIG7yiaBooWo0d4VPwd7lvblpzKYx192ibwVB1kY5CDBUhNWa1gw/640?wx_fmt=png"></p>
<h3 id="7-2-64-位体系内核虚拟内存空间布局"><a href="#7-2-64-位体系内核虚拟内存空间布局" class="headerlink" title="7.2 64 位体系内核虚拟内存空间布局"></a>7.2 64 位体系内核虚拟内存空间布局</h3><p>内核虚拟内存空间在 32 位体系下只有 1G 大小，实在太小了，因此需要精细化的管理，于是按照功能分类划分除了很多内核虚拟内存区域，这样就显得非常复杂。</p>
<p>到了 64 位体系下，内核虚拟内存空间的布局和管理就变得容易多了，因为进程虚拟内存空间和内核虚拟内存空间各自占用 128T 的虚拟内存，实在是太大了，我们可以在这里边随意翱翔，随意挥霍。</p>
<p>因此在 64 位体系下的内核虚拟内存空间与物理内存的映射就变得非常简单，由于虚拟内存空间足够的大，即便是内核要访问全部的物理内存，直接映射就可以了，不在需要用到《7.1.2 ZONE_HIGHMEM 高端内存》小节中介绍的高端内存那种动态映射方式。</p>
<p>在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \</span></span><br><span class="line"><span class="meta">     IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX  task_size_max()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_size_max()  ((_AC(1,UL) &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __VIRTUAL_MASK_SHIFT 47</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png">64 位地址空间. png</p>
<p>在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。</p>
<p>内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。</p>
<p>本小节我们主要关注 0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 这段内核虚拟内存空间的布局情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTu02UOSu8wdLWmrpjbyJQ30xXvGRsqkW32icicawDI8kSrwicx7WhyEf1w/640?wx_fmt=png"></p>
<p>64 位内核虚拟内存空间从 0xFFFF 8000 0000 0000 开始到 0xFFFF 8800 0000 0000 这段地址空间是一个 8T 大小的内存空洞区域。</p>
<p>紧着着 8T 大小的内存空洞下一个区域就是 64T 大小的直接映射区。这个区域中的虚拟内存地址减去 PAGE_OFFSET 就直接得到了物理内存地址。</p>
<p>PAGE_OFFSET 变量定义在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET_BASE      _AC(0xffff880000000000, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET           __PAGE_OFFSET_BASE</span></span><br></pre></td></tr></table></figure>

<p>从图中 VMALLOC_START 到 VMALLOC_END 的这段区域是 32T 大小的 vmalloc 映射区，这里类似用户空间中的堆，内核在这里使用 vmalloc 系统调用申请内存。</p>
<p>VMALLOC_START 和  VMALLOC_END 变量定义在 <code>/arch/x86/include/asm/pgtable_64_types.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __VMALLOC_BASE_L4 0xffffc90000000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMEMMAP_START  __VMEMMAP_BASE_L4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_END  (VMALLOC_START + (VMALLOC_SIZE_TB &lt;&lt; 40) - 1)</span></span><br></pre></td></tr></table></figure>

<p>从 VMEMMAP_START 开始是 1T 大小的虚拟内存映射区，用于存放物理页面的描述符 struct page 结构用来表示物理内存页。</p>
<p>VMEMMAP_START 变量定义在 <code>/arch/x86/include/asm/pgtable_64_types.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __VMEMMAP_BASE_L4 0xffffea0000000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> VMEMMAP_START  __VMEMMAP_BASE_L4</span></span><br></pre></td></tr></table></figure>

<p>从 __START_KERNEL_map 开始是大小为 512M 的区域用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空洞区域，早就过了内核代码在物理内存中加载的位置。</p>
<p>__START_KERNEL_map 变量定义在 <code>/arch/x86/include/asm/page_64_types.h</code> 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __START_KERNEL_map  _AC(0xffffffff80000000, UL)</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-1-64-位体系结构下-Linux-虚拟内存空间整体布局"><a href="#7-2-1-64-位体系结构下-Linux-虚拟内存空间整体布局" class="headerlink" title="7.2.1 64 位体系结构下 Linux 虚拟内存空间整体布局"></a>7.2.1 64 位体系结构下 Linux 虚拟内存空间整体布局</h3><p>到现在为止，整个内核虚拟内存空间在 64 位体系下的布局笔者就为大家详细介绍完毕了，我们再次结合前边《4.2 64 位机器上进程虚拟内存空间分布》小节介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 64 位体系结构 Linux 的整个虚拟内存空间的布局：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTXmRqaPO5z5RrOjseNbic1LiaUN1o1C8THRicxZicictv5xm46KkUy5gmLMQ/640?wx_fmt=png"></p>
<ol start="8">
<li>到底什么是物理内存地址</li>
</ol>
<hr>
<p>聊完了虚拟内存，我们接着聊一下物理内存，我们平时所称的内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：</p>
<ul>
<li>一类是静态 RAM（ <code>SRAM</code> ），这类 SRAM 用于 CPU 高速缓存 L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTJ5alHgqgibtia7vjXBkR000djmOfzEsYTWoA46W7elZV9iaSNwWV90IXg/640?wx_fmt=png">CPU 缓存结构. png</p>
<ul>
<li>另一类则是动态 RAM ( <code>DRAM</code> )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。</li>
</ul>
<p>内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以 64 位为单位（ 8 个字节）传输数据到存储控制器上或者从存储控制器传出数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTiajJYbncwV0Oia7M1QABIbJ97ne8vGujGCsaUTuPEA3tS0JupaN2tcCw/640?wx_fmt=png"></p>
<p>如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTeFKnMiaONgEVaoQJmovBnGLO9ksqEUbued8YhQoavJ9VnxLXa6K9y2Q/640?wx_fmt=png">内存结构. png</p>
<p>而 DRAM 芯片就包装在存储器模块中，每个存储器模块中包含 8 个 DRAM 芯片，依次编号为 0 - 7 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTlrGGlRuia5pOWnVCYfTlag58YNb6KtouDTRk3a3aibVIrE0g96nja57w/640?wx_fmt=png">存储器模块. png</p>
<p>而每一个 DRAM 芯片的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（supercell），每个 supercell 大小为一个字节（8 bit）。每个 supercell 都由一个坐标地址（i，j）。</p>
<blockquote>
<p>i 表示二维矩阵中的行地址，在计算机中行地址称为 RAS (row access strobe，行访问选通脉冲)。 j 表示二维矩阵中的列地址，在计算机中列地址称为 CAS (column access strobe, 列访问选通脉冲)。</p>
</blockquote>
<p>下图中的 supercell 的 RAS &#x3D; 2，CAS &#x3D; 2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTia6GWhFXBFDnxVpNDS6dXIYshGib6JUibddicqmuNjo04XC65rY2yTrGhQ/640?wx_fmt=png">DRAM 结构. png</p>
<p>DRAM 芯片中的信息通过引脚流入流出 DRAM 芯片。每个引脚携带 1 bit 的信号。</p>
<p>图中 DRAM 芯片包含了两个地址引脚 ( <code>addr</code> )，因为我们要通过 RAS，CAS 来定位要获取的 supercell 。还有 8 个数据引脚（<code>data</code>），因为 DRAM 芯片的 IO 单位为一个字节（8 bit），所以需要 8 个 data 引脚从 DRAM 芯片传入传出数据。</p>
<blockquote>
<p>注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。</p>
</blockquote>
<h3 id="8-1-DRAM-芯片的访问"><a href="#8-1-DRAM-芯片的访问" class="headerlink" title="8.1 DRAM 芯片的访问"></a>8.1 DRAM 芯片的访问</h3><p>我们现在就以读取上图中坐标地址为（2，2）的 supercell 为例，来说明访问 DRAM 芯片的过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZezPX4v7jrWqCtPQU5PVS8knFfGavYFtdBwVjZfUGs3RzoV1nn8jYQ/640?wx_fmt=png">DRAM 芯片访问. png</p>
<ol>
<li><p>首先存储控制器将行地址 RAS &#x3D; 2 通过地址引脚发送给 DRAM 芯片。</p>
</li>
<li><p>DRAM 芯片根据 RAS &#x3D; 2 将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中。</p>
</li>
<li><p>接下来存储控制器会通过地址引脚发送 CAS &#x3D; 2 到 DRAM 芯片中。</p>
</li>
<li><p>DRAM 芯片从内部行缓冲区中根据 CAS &#x3D; 2 拷贝出第二列的 supercell 并通过数据引脚发送给存储控制器。</p>
</li>
</ol>
<blockquote>
<p>DRAM 芯片的 IO 单位为一个 supercell ，也就是一个字节 (8 bit)。</p>
</blockquote>
<h3 id="8-2-CPU-如何读写主存"><a href="#8-2-CPU-如何读写主存" class="headerlink" title="8.2 CPU 如何读写主存"></a>8.2 CPU 如何读写主存</h3><p>前边我们介绍了内存的物理结构，以及如何访问内存中的 DRAM 芯片获取 supercell 中存储的数据（一个字节）。本小节我们来介绍下 CPU 是如何访问内存的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfY776YyT3I63PTt9uVeCufTuU54A5ovp7N7vqt5XuwwcbmmyBsvicDw/640?wx_fmt=png">CPU 与内存之间的总线结构. png</p>
<p>CPU 与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。</p>
<p>其中数据从内存传送到 CPU 称之为读事务（read transaction），数据从 CPU 传送到内存称之为写事务（write transaction）。</p>
<p>总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：</p>
<ul>
<li><p>当前这个事务是到内存的？还是到磁盘的？或者是到其他 IO 设备的？</p>
</li>
<li><p>这个事务是读还是写？</p>
</li>
<li><p>总线上传输的地址信号（物理内存地址），还是数据信号（数据）？。</p>
</li>
</ul>
<blockquote>
<p><strong>这里大家需要注意总线上传输的地址均为物理内存地址</strong>。比如：在 MESI 缓存一致性协议中当 CPU core0 修改字段 a 的值时，其他 CPU 核心会在总线上嗅探字段 a 的<strong>物理内存地址</strong>，如果嗅探到总线上出现字段 a 的<strong>物理内存地址</strong>，说明有人在修改字段 a，这样其他 CPU 核心就会失效字段 a 所在的 cache line 。</p>
</blockquote>
<p>如上图所示，其中系统总线是连接 CPU 与 IO bridge 的，存储总线是来连接 IO bridge 和主存的。</p>
<p>IO bridge 负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge 也会将系统总线和存储总线连接到 IO 总线（磁盘等 IO 设备）上。这里我们看到 IO bridge 其实起的作用就是转换不同总线上的电子信号。</p>
<h3 id="8-3-CPU-从内存读取数据过程"><a href="#8-3-CPU-从内存读取数据过程" class="headerlink" title="8.3 CPU 从内存读取数据过程"></a>8.3 CPU 从内存读取数据过程</h3><p>假设 CPU 现在需要将物理内存地址为 A 的内容加载到寄存器中进行运算。</p>
<blockquote>
<p>大家需要注意的是 CPU 只会访问虚拟内存，在操作总线之前，需要把虚拟内存地址转换为物理内存地址，总线上传输的都是物理内存地址，这里省略了虚拟内存地址到物理内存地址的转换过程，这部分内容笔者会在后续文章的相关章节详细为大家讲解，这里我们聚焦如果通过物理内存地址读取内存数据。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT72O3UQ0t2nJB8YD8u44h1Cbr3DdCSxZ2yY7nfee5qOUeoQ1gC6IiaRA/640?wx_fmt=png">CPU 读取内存. png</p>
<p>首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：</p>
<ol>
<li><p>CPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。</p>
</li>
<li><p>主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。</p>
</li>
<li><p>存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。</p>
</li>
<li><p>存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。</p>
</li>
<li><p>CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。</p>
</li>
</ol>
<p>以上就是 CPU 读取内存数据到寄存器中的完整过程。</p>
<p>但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过物理内存地址 A 从主存中读取出对应的数据 X 的？</p>
<p>接下来我们结合前边介绍的内存结构以及从 DRAM 芯片读取数据的过程，来总体介绍下如何从主存中读取数据。</p>
<h3 id="8-4-如何根据物理内存地址从主存中读取数据"><a href="#8-4-如何根据物理内存地址从主存中读取数据" class="headerlink" title="8.4 如何根据物理内存地址从主存中读取数据"></a>8.4 如何根据物理内存地址从主存中读取数据</h3><p>前边介绍到，当主存中的存储控制器感受到了存储总线上的地址信号时，会将内存地址从存储总线上读取出来。</p>
<p>随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗 ？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTeFKnMiaONgEVaoQJmovBnGLO9ksqEUbued8YhQoavJ9VnxLXa6K9y2Q/640?wx_fmt=png">内存结构. png</p>
<p>而每个存储器模块中包含了 8 个 DRAM 芯片，编号从 0 - 7 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTlrGGlRuia5pOWnVCYfTlag58YNb6KtouDTRk3a3aibVIrE0g96nja57w/640?wx_fmt=png">存储器模块. png</p>
<p>存储控制器会将<strong>物理内存地址</strong>转换为 DRAM 芯片中 supercell 在二维矩阵中的坐标地址 (RAS，CAS)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将 RAS 和 CAS 广播到存储器模块中的所有 DRAM 芯片。依次通过 (RAS，CAS) 从 DRAM0 到 DRAM7 读取到相应的 supercell 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZezPX4v7jrWqCtPQU5PVS8knFfGavYFtdBwVjZfUGs3RzoV1nn8jYQ/640?wx_fmt=png">DRAM 芯片访问. png</p>
<p>我们知道一个 supercell 存储了一个字节（ 8 bit ） 数据，这里我们从 DRAM0 到 DRAM7 依次读取到了 8 个 supercell 也就是 8 个字节，然后将这 8 个字节返回给存储控制器，由存储控制器将数据放到存储总线上。</p>
<p><strong>CPU 总是以 word size 为单位从内存中读取数据，在 64 位处理器中的 word size 为 8 个字节。64 位的内存每次只能吞吐 8 个字节。</strong></p>
<blockquote>
<p>CPU 每次会向内存读写一个 cache line 大小的数据（ 64 个字节），但是内存一次只能吞吐 8 个字节。</p>
</blockquote>
<p>所以在物理内存地址对应的存储器模块中，DRAM0 芯片存储第一个低位字节（ supercell ），DRAM1 芯片存储第二个字节，…… 依次类推 DRAM7 芯片存储最后一个高位字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfdypa7oUmDksZq4YldUaRkVEYggYibu4wtlf0GCdBxT6VKMlCKU1obQ/640?wx_fmt=png">读取存储器模块数据. png</p>
<p>由于存储器模块中这种由 8 个 DRAM 芯片组成的物理存储结构的限制，内存读取数据只能是按照物理内存地址，8 个字节 8 个字节地顺序读取数据。所以说内存一次读取和写入的单位是 8 个字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImToQMMG7NSnwNQdV7oicnkcibdAyfFNPrt6beM4CicSGexMicMsUaMGdRvPQ/640?wx_fmt=png">内存 IO 单位. png</p>
<p>而且在程序员眼里连续的物理内存地址实际上在物理上是不连续的。因为这连续的 8 个字节其实是存储于不同的 DRAM 芯片上的。每个 DRAM 芯片存储一个字节（supercell）</p>
<h3 id="8-5-CPU-向内存写入数据过程"><a href="#8-5-CPU-向内存写入数据过程" class="headerlink" title="8.5 CPU 向内存写入数据过程"></a>8.5 CPU 向内存写入数据过程</h3><p>我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：</p>
<ol>
<li><p>CPU 将要写入的物理内存地址 A 放入系统总线上。</p>
</li>
<li><p>通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。</p>
</li>
<li><p>存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。</p>
</li>
<li><p>CPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。</p>
</li>
<li><p>存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。</p>
</li>
<li><p>存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们从虚拟内存地址开始聊起，一直到物理内存地址结束，包含的信息量还是比较大的。首先笔者通过一个进程的运行实例为大家引出了内核引入虚拟内存空间的目的及其需要解决的问题。</p>
<p>在我们有了虚拟内存空间的概念之后，笔者又近一步为大家介绍了内核如何划分用户态虚拟内存空间和内核态虚拟内存空间，并在次基础之上分别从 32 位体系结构和 64 位体系结构的角度详细阐述了 Linux 虚拟内存空间的整体布局分布。</p>
<ul>
<li><p>我们可以通过 <code>cat /proc/pid/maps</code> 或者 <code>pmap pid</code> 命令来查看进程用户态虚拟内存空间的实际分布。</p>
</li>
<li><p>还可以通过 <code>cat /proc/iomem</code> 命令来查看进程内核态虚拟内存空间的的实际分布。</p>
</li>
</ul>
<p>在我们清楚了  Linux 虚拟内存空间的整体布局分布之后，笔者又介绍了 Linux 内核如何对分布在虚拟内存空间中的各个虚拟内存区域进行管理，以及每个虚拟内存区域的作用。在这个过程中还介绍了相关的内核数据结构，近一步从内核源码实现角度加深大家对虚拟内存空间的理解。</p>
<p>最后笔者介绍了物理内存的结构，以及 CPU 如何通过物理内存地址来读写内存中的数据。这里笔者需要特地再次强调的是 CPU 只会访问虚拟内存地址，只不过在操作总线之前，通过一个地址转换硬件将虚拟内存地址转换为物理内存地址，然后将物理内存地址作为地址信号放在总线上传输，由于地址转换的内容和本文主旨无关，考虑到文章的篇幅以及复杂性，笔者就没有过多的介绍。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/')">远辰</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=远辰&amp;url=https://shippomx.github.io/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/31/sdn/dpdk/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/08/13/containers/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20%5B%E4%B8%80%5D%20-%20%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-32-%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="toc-number">1.</span> <span class="toc-text">4.1 32 位机器上进程虚拟内存空间分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-64-%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="toc-number">2.</span> <span class="toc-text">4.2 64 位机器上进程虚拟内存空间分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">5.1 内核如何划分用户态和内核态虚拟内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">4.</span> <span class="toc-text">5.2 内核如何布局进程虚拟内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">5.3 内核如何管理虚拟内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%AE%9A%E4%B9%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83"><span class="toc-number">6.</span> <span class="toc-text">5.4 定义虚拟内存区域的访问权限和行为规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%85%B3%E8%81%94%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E4%B8%AD%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">5.5 关联内存映射中的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E9%92%88%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">5.6 针对虚拟内存区域的相关操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E7%BB%84%E7%BB%87%E7%9A%84"><span class="toc-number">9.</span> <span class="toc-text">5.7 虚拟内存区域在内核中是如何被组织的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-32-%E4%BD%8D%E4%BD%93%E7%B3%BB%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">10.</span> <span class="toc-text">7.1 32 位体系内核虚拟内存空间布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">11.</span> <span class="toc-text">7.1.1 直接映射区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-ZONE-HIGHMEM-%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98"><span class="toc-number">12.</span> <span class="toc-text">7.1.2  ZONE_HIGHMEM 高端内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-vmalloc-%E5%8A%A8%E6%80%81%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">13.</span> <span class="toc-text">7.1.3 vmalloc 动态映射区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E6%B0%B8%E4%B9%85%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">14.</span> <span class="toc-text">7.1.4 永久映射区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5-%E5%9B%BA%E5%AE%9A%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">15.</span> <span class="toc-text">8.1.5 固定映射区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-6-%E4%B8%B4%E6%97%B6%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">16.</span> <span class="toc-text">7.1.6  临时映射区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-7-32-%E4%BD%8D%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8B-Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%95%B4%E4%BD%93%E5%B8%83%E5%B1%80"><span class="toc-number">17.</span> <span class="toc-text">7.1.7 32 位体系结构下 Linux 虚拟内存空间整体布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-64-%E4%BD%8D%E4%BD%93%E7%B3%BB%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">18.</span> <span class="toc-text">7.2 64 位体系内核虚拟内存空间布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-64-%E4%BD%8D%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8B-Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%95%B4%E4%BD%93%E5%B8%83%E5%B1%80"><span class="toc-number">19.</span> <span class="toc-text">7.2.1 64 位体系结构下 Linux 虚拟内存空间整体布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-DRAM-%E8%8A%AF%E7%89%87%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">20.</span> <span class="toc-text">8.1 DRAM 芯片的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-CPU-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E4%B8%BB%E5%AD%98"><span class="toc-number">21.</span> <span class="toc-text">8.2 CPU 如何读写主存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-CPU-%E4%BB%8E%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">8.3 CPU 从内存读取数据过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%BB%8E%E4%B8%BB%E5%AD%98%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">23.</span> <span class="toc-text">8.4 如何根据物理内存地址从主存中读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-CPU-%E5%90%91%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">24.</span> <span class="toc-text">8.5 CPU 向内存写入数据过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E4%BB%8E%E7%A1%AC%E4%BB%B6%E7%9C%8B%E4%B8%AD%E6%96%AD%E4%B9%8B%20APIC%EF%BC%88%E4%B8%89%E4%B8%87%EF%BC%89-CSDN%20%E5%8D%9A%E5%AE%A2/" title="无题">无题</a><time datetime="2024-08-13T07:48:29.025Z" title="发表于 2024-08-13 15:48:29">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/linux/%E5%86%85%E5%AD%98/%E9%A1%B5%E8%A1%A8/" title="无题">无题</a><time datetime="2024-08-13T06:57:36.023Z" title="发表于 2024-08-13 14:57:36">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20%5B%E4%B8%80%5D%20-%20%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/" title="无题">无题</a><time datetime="2024-08-13T06:50:07.571Z" title="发表于 2024-08-13 14:50:07">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="无题">无题</a><time datetime="2024-08-12T03:18:47.311Z" title="发表于 2024-08-12 11:18:47">2024-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/sdn/dpdk/" title="无题">无题</a><time datetime="2024-07-31T11:36:18.019Z" title="发表于 2024-07-31 19:36:18">2024-07-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 0.88rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 0.88rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 0.88rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 0.88rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 0.88rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>