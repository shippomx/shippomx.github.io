<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>远辰 | 远辰</title><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="远辰"><meta name="application-name" content="远辰"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="远辰"><meta property="og:url" content="https://shippomx.github.io/2024/07/31/sdn/dpdk/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="基本前面把环境基本搭好，今天开始编译 DPDK。首先是下载 DPDK 的源码，地址是：https:&amp;#x2F;&amp;#x2F;core.dpdk.org&amp;#x2F;download&amp;#x2F;也可以从官网 https:&amp;#x2F;&amp;#x2F;www.dpdk.org &amp;#x2F; 跳过来。然后就可以看到排下载的 DPDK 的版本： 官方的安装说明及相关文档地址："><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="基本前面把环境基本搭好，今天开始编译 DPDK。首先是下载 DPDK 的源码，地址是：https:&amp;#x2F;&amp;#x2F;core.dpdk.org&amp;#x2F;download&amp;#x2F;也可以从官网 https:&amp;#x2F;&amp;#x2F;www.dpdk.org &amp;#x2F; 跳过来。然后就可以看到排下载的 DPDK 的版本： 官方的安装说明及相关文档地址："><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2024/07/31/sdn/dpdk/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: '远辰',
  postAI: '',
  pageFillDescription: '基本, 简介, 框架主要结构, 源码目录结构, hello world例程, 网络发展和 DPDK, 技术分析, UIO 机制, DPDK 的并发, 多线程模型及源码分析, 多进程, 例程, 虚拟化, 虚拟化的分类, 虚拟化的应用方向, DPDK 和虚拟化, virtio, vhost, virtio 的框架流程, DPDK 的 virtio 的应用, virio-net, 前后端的数据通信, virtio和 vhost 的通信, 基础数据结构, PCI 设备简介, PCI 设备发现基本流程, vring基础数据结构, vring主要功能, 基本流程, DPDK 网卡抽象实现, 基本数据结构, 基本流程, vhost 的基础数据结构, 源码分析, vhost-user, 数据结构, 通信, virtio, 用户态驱动, DPDK 中实现机制, NFV, DPDK 中的内存, DPDK 的整体内存层次结构, 相关的数据结构和 API, IOVA, 数据结构和源码, 网络传输中的分包, 内存池, 网络中的控制, DPDK 中的内存池, DPDK 中的 Cache 处理, DIDO, DIDO 的流程, DPDK 启动分析, 分配初始化, DPDK 中的大页内存管理, 环形队列, DPDK并行机制, DPDK 中并行机制及弹性扩展, SIMD, 同步, 并行和并发中的同步, DPDK 对网络数据的处理, 网络报文处理, 转发应用框架, Pipleline 模型（Packet Framework）, run to completion 模型（RTC）, 相关算法, 报文分发, PCIe 总线和 DMA 及缓存, 数据传输, 数据转发, 优化, 网卡优化, 软件层面, IO 优化, 平台及配置优化, 相关设置适配, 源码分析, 多队列技术, 流分类, 硬件加速, 三、源码分析, 数据包流程, 三、源码分析, 接收数据, 二、发送数据, 三、源码分析, 网络编程, UDP 编程基本前面把环境基本搭好今天开始编译首先是下载的源码地址是也可以从官网跳过来然后就可以看到排下载的的版本官方的安装说明及相关文档地址简介提起需要先回顾一下网络的发展最初的网络的出现是从美国军方的局域网发展起来的从一开始网络的应用并没有现在这么复杂数据传输量也没有现在这么巨大更不要提现在什么高清等等这些初时的大数据流传送同样也不会有什么双之类海量的并发为什么说这些呢随着网络的不断发展全球网络的应用可以说用井喷来形容对应用的人来说只是把生活变得更丰富更美好应用更简单更容易可对于底层的计算机技术来说这需要不断的演进技术才能够保证上层的这些应用搞技术的都清楚早期的一些网站包括很多大型的网站其实就是用的最基础的通信中的轮询再辅以多进程即可以实现上面的应用但这些问题随着应用规模越来越大已经完全无法满足需求了解决这种问题的方式有两种一种是在应用层使用更好的框架和通信模型如等另外一种就是修改网络的底层协议这两种方式应用层好完善大不了迭代一个新版本但修改协议这个就麻烦大了涉及到多的东西更为关键的是要硬件的跟进这几乎是不可能的而且这需要一个很漫长的时间才能实现另外更关键的是随着云技术的兴起导致了网络数据传输的路径更加延长也就是说网络的吞吐量理论上讲进一步减少同时异构和多多核的出现又需要能尽量公平的使用保证数据的调度这也是原来的整个技术栈没有考虑到的而就相对较好的解决了这些问题它掠过了内核中的网络协议栈而将其迁移到了用户态消除和减少了中断以及内存数据的拷贝次数通过网卡和用户进行直接的数据交互它的优势是明显的特别是在云的环境下虚拟技术可以更好的和真实的网卡进行数据通信框架主要结构先看一下的框架结构图结合着这张图再回头和前面编译过程的代码就会更加清晰的理解整个的框架结构源码目录结构在源码中主要的目录如下是应用程序的源码包括测试应用代码编译配置脚本平台编译配置设置管理脚本轮询驱动代码内核相关代码库源码提供给用户的一些工具例程看一下自带的一个例程这是一个最简单的程序了一般所有的新的语言或者框架出来都会有一个这个就是的程序中首先使用来对主线程和子线程进行创建初始化通过管道实现它们之间的通信然后使用宏来实现对核的遍历除外而就是实现的具体的函数可以理解为一种主从线程之间的同步的机制主线程会等待所有的子线程进入等待状态后才可以进行消息的通信其实网络技术发展不是一蹴而就的从最初的到总之消除和减少各种冗余动作的技术不断出现直到的出现其实是一个延续发展的过程随着的广泛应用硬件厂商特别是云厂商对其的支持不断增加和完善而原来提到过的上层应用也是对的一种扩展专门就而言其实可以理解为应用倒逼的技术的进步所以说人多这也是一个优势没有应用场景技术进步就不会那么迫切或许这也是理论联系实际的一个典型例子网络发展和网络应用对出现的影响而具体体现在技术上从最简单来看就是从到甚至更多而相应的计算的发展也从挖掘单的性能发展到了瓶颈同样对于网络设备也遇到了类似的问题而目前解决问题的方法硬件上就是多核多分布式中多台电脑也可以理解成宏观上的多而在软件上就是云的虚拟化而在原来的网络处理路径中本身就已经较长再经过虚拟化含后导致整体上的一些辅助工作大消耗了时间而且过长的路径也会导致更多的意外发生另外即使在正常的情况下过长路径也会造成缓存命中失效的可能性大大增加而学过计算机的人都知道二八原理缓存命中失效会使得耗费的时间更长针对上面的这些问题主要解决了控制硬中断和消耗等不再通过内核路径拷贝上下文切换锁过滤等这样一方面大大提高了的处理速度又解决了路径长所引起的内核瓶颈及相关的意外因素所以从某种程度上可以理解是在网卡到用户态绕过了内核直接桥接过去达成了一个旁路这其实和实际生活中如果电路必须过某个复杂的电缆柜但又不知道内部的情况直接飞线过去有相通之处当然飞线是不好的不过在社区上提供了旁路机制不过这玩意儿没弄好所以现在其实就是半死活至于和它们的关系和影响就不得而知了传统的网络编程数据流是从网卡驱动协议栈应用则是网卡基础库应用有过工程管理管理经验的都知道路径越长不可控的风险越大简单就是王道这才是王道技术分析的处理网络通信的技术特点主要有轮询传统的内核处理一般有两种情况中断和轮询两种方式中断的耗时对海量数据传输来说太长了而使用轮询则可以大幅降低中断引起的上下文开销用户态驱动前面提到过路径越长需要数据传递的路径越长就不可避免的产生内存复制和系统调用而直接到用户态就避免是大量不必要的数据复制的亲和性设计现代计算机几乎很难遇到单核单的机器了所以如果设置的亲和性保证的命中率就是一个很好的设计降低访存开销转译后备缓冲区利用大页内存减少的丢失命中并利用内存多通道交错访问提高内存带宽利用率软件优化这个就比较好理解了缓冲的行对齐多线程中的伪共享数据预读以及批量处理等在中最显著的部分就是上层的用户态库它主要分成以下几个部分核心库环境抽象层在基础上进行初始化其中有巨页分配缓冲区和队列分配无锁操作亲和性绑定等它就是绕过内核的关键直接通过或技术将设备地址映射到用户空间同时为了更好的处理数据它还创建了适应环境的内存池缓冲区管理内存复制定时器和环境缓冲等平台库这些个主要是包括能耗管理和接口主要是用进行内核态和用户态间的协议栈处理能耗管理主要处理休眠状态和频率等则提供了虚拟机内存共享管理机制包括映射世面为设备池并传递给轮询驱动库虽然支持混杂中断驱动但一般还是用轮询为主它支持物理和虚拟网卡随着各大硬件厂商的跟进目前基本整个行业生态都支持了库这个用来做一些辅助服务的比如一些通配符匹配精确匹配什么的还有一些报文转发如限速和调度等等高性能实现的代码基础通过降低这个其实比较好理解小的缓冲容易溢出就容易大的就次数少很多而在中把默认的提到及以上数量级会下降很多命中率会提高很多其实就是在并行计算中的分治法减少全局共享同时对体系下不跨远程使用内存这个学过计算机体系结构的应该很清楚中也尽量利用了这个优势通过批处理和向量编程来增加单位时间内的数据包处理使用更先进的库接口这个其实很简单就是把普适性的库有针对的进行完善和修改包括对一些硬件有针对性的处理优化编译执行这个就是比较常见的了比如分支预测内核和新标准预取内存对齐包括前面提到的伪共享和跨常量优化以及直接调用指令等等这里简单分析一下非统一内存访问它和一致性内存访问相对应其实说的通俗一些就是本地管理和分布式管理的区别但为了解决分布式管理出现的缓慢和无法访问所有存储器的情况就针对性的提出了把存储分为本地存储和远端存储它的优势在于既兼顾上模式下的系统拷贝和易于管理又继承了分布式模式的可扩充性另外还一个重要的问题毕竟不是一个官方统一的基础库而一个和硬件版本及相关参数配置有关的一个基础框架所以在实际部署时也要考虑到这些因素特别是硬件的支持一般来说重点需要处理核心的隔离和中断的转移屏蔽即使无法完全处理好中断也要尽量减少中断的次数机制提供了机制即它可以通过实现和网卡的通信在有如下的数据结构体定义上面把的相关技术进行了整体的分析这样就可以从整体上对的技术栈进行一个认知从这篇之后将从两个角度来分析一个是应用的角度如何使用从分析例程的角度来探究运行的技术另外一个角度是从源码的角度由浅入深的分析相关的源码和上层的应用情况进行结合分析作始也简的并发前面提到了网络爆发式的发展提出了到甚至更多并发的要求其实本质上还是对数据接收和处理的速度即从软件硬件实现整体的最大性能的平衡这时候在软件上多线程多进程以至于并行编程就拿到台面上毕竟这是解决接收和处理数据的一个最有力的方法和手段在前面也提到过的优势在于缩短了数据流的路径但另外一个重要的方面就是多核的利用以及在指令处理方面使用了正如前面所分析合理的利用核心的数量和并处理好缓存的命中就可以大幅的提高处理的效率再加上类似于批处理的数量优势自然就会有大幅度的效能的提升说得更通俗一些就是要挖掘多核和多以及硬件的资源但这些资源的挖掘尽量要从软件上来实现这就是并发的意义多线程模型及源码分析中的线程创建是基于库创建的从这方面来看就没有脱离开上层应用编程的范围说这个的意思就是说这块本质上是没有难度的看一下相关的线程处理代码这个函数在前面的文章中的例程中用过看看开头的几个变量和函数不用看内部的实现都应该猜到是什么了在处理好开始调用来处理参数进行核的确定和的管理确定哪核可用到这里基本就应该明白要怎么使用线程了再加上开头的应该立刻明白了吧并行计算中处理的第一个要务就是对的分配和管理包括一些控制在内接着往下看就是一系列的初始化如前面文章提到的配置内存内存池队列定时器等等最后到主核心线程和各个子线程核心的启动和它们都会调用来进行的绑定然后不同模块为了使用线程就需要进行注册即创建后紧随的调用初始的是一个空的系统函数有兴趣可以搜一搜这个函数的使用你会发现真得好多它的定义这明显是注册函数用的函数指针放到了第一个参数上尽管创建线程的手法一致但尽量还是使用创建的线程它能更好的发挥的性能原因在后面分析代码中就慢慢明白了从上面的代码和分析是不是总结中线程模型和常用的开发的模型有所不同之处如果有做类似并行计算如开发的会发现有相似之处其实就是把线程的自由调用也就是时间片的任意轮转固定到了指定的核心上线程间通过进行通信通过上面找分析可以总结出的并发模型从提高指令的并行度和多核并发出发通过内存和的管理提高水平扩展的能力利用的亲和力使用主从线程的分配管理利用提高整体的吞吐量而从实际情况来看由于内核是不区分线程和进程动作的在内核看来二者都是的结果上下文的切换的消耗对于线程和进程没有不可忽视的区别反而是线程和进程对于处理不同内存的共享时导致的性能开销会有较大的差异在多核心的情况下由于线程伪共享的问题多进程反而较多线程更有优势在排除不同进程线程间通信这种复杂情况下多进程性能还是要高于多线程并且更健壮在中利用巨页机制可以降低多线程在频繁交互下对多进程的优势所以在实际的应用过程中还是要根据实际情况来决定应用的具体情况多进程同样在中对多进程也是支持的需要在启动任务时手动指定相关的主从进程应用的一些参数基本的格式说明的默认参数其形式为十六进制位掩码表示分配的逻辑内核数量十进制整数表示每个逻辑内核的内存通道数量十六进制位掩码即分配的端口数量是指后两位为即起点两个端口分配到每个逻辑内核的收发队列数量打印统计数据上屏的时间间隔默认为秒中多进程的情况下主从进程有点类似于线程共享进程的资源一样主从进程共享大页内存以及一些相关的队列说到共享如果有框架分析经验的肯定会首先想起对也是所以说多看代码多看优秀的框架会明白很多事儿在这个基础上才可能产生创新例程前面看一个简单的多线程的下面看自带的一个多进程的简装版重点看一下前面对进程的判断和创建过程与线程有何不同会更好的理解的并行模型通过整合的管理通过对核心的具体分析来确定主从线程配置亲和性保证缓存的命中率真并尽量减小上下文的场景开销虚拟化什么是虚拟化技术呢虚拟化技术发展编年史中是这样定义在计算机科学中虚拟化技术是一种资源管理优化技术将计算机的各种物理资源内存以及磁盘空间网络适配器等设备予以抽象转换然后呈现出来的一个可供分割并任意组合为一个或多个虚拟计算机的配置环境维基百科中的解释和上面的解释基本一致虚拟化的分类虚拟化技术一般可按对象分为三类平台虚拟化即大家常见的计算机和的虚拟化资源虚拟化包含网卡虚拟化虚拟化存储虚拟化及其它硬件虚拟化也就是虚拟网卡虚拟内在虚拟存储等等应用虚拟化这个就更常见了虚拟机各种训练仪等等虚拟化中一般分为两种类型原生托管虚拟化实现可以分为三类纯软件仿真这种就是用软件来模拟系统比如还有安卓的模拟器等虚拟化层翻译它又分为全虚拟技术这种非常多见它基于指令的全翻译技术比如等等还有半虚拟化技术这个典型的是一般人可能不太清楚但一提这个云平台几乎没有不知道它底层就是从开始起步的当然现在已经有了极大的改进最后就是基于硬件辅助的也就是提到的和的硬件虚拟技术解决了平台不支持此类技术的解决方案了容器技术容器技术应该就更容易理解了基于和的容器技术是现在服务集群管理的重要的基础搞后台开发的要是不知道点技术都不好意思说话容器可以理解成轻量级的虚拟化它只能虚拟化部分容器的优势在于它轻量化更容易部署和管理虚拟化的应用方向目前主流的虚拟化的方向有以下几类虚拟化也就是人们常说的云计算的前提它分为纯软件虚拟化和硬件虚拟化两类前者限制较多但硬件方案出来的较晚网络虚拟化这个目前比较宽泛但做为小白来说可以认为是对常见的网卡网络进行虚拟化常见的就是一种网络虚拟化服务器虚拟化这个就更好理解了说直白一些就是虚拟出一个个虚拟机来做为服务器这可是云厂商最关注的啊毕竟用户付费一般是按机器来付费的这个里面就包含容器技术存储虚拟化这个还是基于网络应用的快速增长数据的存储或者说大数据提出的要求起初大家认知的可能只是虚拟内在后来又增加了外存的虚拟化等等这些都叫做虚拟存储和虚拟化中大幅优化了网络通信的效率这里也重点对网卡的虚拟化进行分析网卡基本属于虚拟化但是虚拟化又有全虚拟化和半虚拟化之分那么在中使用的哪种呢虚拟化一般有全虚拟化半虚拟化透传和几种方式这里重点比较前两者全虚拟化技术是由指令的翻译的全翻译来实现的也就是说虚拟机可以模拟宿主机的的所有功能但这样做有一个问题它会导致上下文的切换降低效率这时候半虚拟化又叫虚拟化技术就出现了半虚拟化技术中虚拟机和宿主机并不是完全隔离的它是在敏感指令上通过调用来实现的这样就节省了指令捕获和完整模拟提高了效率在中通过和来实现的半虚拟化功能在中对的支持已经到的版本版本也出来了来源于这篇论文当中这篇论文提出了两个通用的和同时提供了对虚拟设备的向后兼容性以及协商机制是一种接口规范用来统一半虚拟化抽象它提供了一套层应用与虚拟化设备等之间的通信框架和编程接口大大减少了平台的兼容性差异一般来说在宿主机上的虚拟机客户端上实现的半虚拟化的前半端驱动程序叫做而在宿主机实现的后半端驱动程序叫做它们两个通过的虚拟队列通信虚拟机发送的数据报文到达虚拟交换机再转发到物理网卡中在层上定义了所以可以配置一个或者多个此类型队列保证数据的收发在内核怸中负责报文送达消息的通知中断做为上层应用和物理设备的桥梁对相应的进出数据报文队列进行操作并通知中断的产生也可以把迁移到用户态即此时为第个创建一个端口实现后端逻辑以及报文的收发请求用户态的数据的拷贝是由共享内在来实现的中就是使用的机制中的支持字符设备和服务两种消息机制它主要是负责的创建和管理以及销毁动作它的封装形式主要有和前者实现了用户态的驱动而后者则是前者的封装进一步形成标准的虚拟端口内核态和二者不同在于前者是沟通用户态和内核内的接口而后者则通过域来处理共享内能达到同样的效果既可以处理也可以处理网络子系统在重点是对网络子系统的应用目前是和网络功能虚拟化和容器化的一个重要组成部分在现在的云服务中网络功能虚拟化已经是软件硬件解耦的一个重要部分它可以做为各种网络功能的基础设施层有效支撑在实际的应用中虚拟网络交换机是一个重要的应用开源的有等等在开源的中还有很多的项目直接或者间接应用到了毕竟做为一个开发套件理论上只要是有和网络数据通信的都可以应用得到云的兴起对和的要求是只有更高没有最高而在这其中还有更多的事情要做而且确实也在不断的增加着一些功能这使得会更好的为服务降低成本方便网络的弹性部署最后再提一下透传和前者效率非常好可以简单理解为就是虚拟设备和物理设备合而为一了但这样做的缺点就是不灵活而后者是为了实现在单张物理设备上提供多个虚拟子设备的问题也同样支持这两种方式前提是硬件也要提供支持所以说一个好的框架支持的力度是在尽可能的情况下要宽泛这样才可以保证框架的可适用性并为广大开发者接受的框架流程其主要架构如下从图上可以看出其共分为了四层前端驱动和后端驱动以及中间层的和层前端驱动和后端设备通过传输层中间层两层来实现数据的通信其主要的流程图如下前端驱动中主要是虚拟机对模拟设备的驱动程序用来管理设备接收虚拟机的请求并根据协议连接设备在内核中基本已经实现了一系列的此类前端驱动如和等等同时在中实现了对网络设备的用户态驱动传输层顾名思义就是用前后端的数据通信它主要是支持虚拟机和之间正如图上所讲利用共享内在实现两个虚拟队列来完成数据的传输前端虚拟队列用于前端动态数据的传输后端虚拟队列用于前端设备提交的请求处理后端设备主要承担两类功能一个是对后端设备的模拟第二是依据协议处理虚拟机传过来的请求不过随着技术的进步又出现了前面提到的等等加速方案的的应用在内核中对的抽象实现如下底层设备抽象层管理检测设备初始化相应设备驱动程序其通过两个抽象类即和来负责此工作中间虚拟队列层其主要是其主要由和等类来实现上层网络设备抽象层通过实现底层抽象类和来提供普通的网络接口使用而在基本上也是沿袭了这个路线中对设备的优化单帧的网络包收发优化固定了环表表项和描述符表项的映射特性在网络发送包中的支持即发送包只需要一个描述符普通的包至少需要两个这要归功于中并没有完全实现中对所有相关的实现只是实现了对网卡设备的支持这样就可以针对其进行具体的上述优化了中对相关虚拟化的实现代码主有以下几部分主目录或其主要内容包括从整体上讲在路径下有和两块在中有及相关抽象实现而在中又有用户态的等在文件夹中通过文件名也基本可以判断出其功能是上层设备的抽象即前端驱动而是底层抽象即后端的驱动而等含有源码文件都负责传输的而又是传输的抽象层中又提供了相关用户态的实现它实现对容器对的支持并且可以用于与通信的驱动最初从后端再到内核怸的发展到用户态的其实就是对效率和扩展性的一个不断演进的过程在前面提到过提高云环境下的网络数据传输速度一个是减少传播路径一个是减少中断的影响然后再辅以软件硬件上的配合如亲和性处置内在控制和各种调优等而在减少传播路径中用户态直接处理设备数据则可以大大减少数据传输的流程从这些结果上反推刚刚的的发展就可以明白了一开始只是一个单纯的后端需要不断的处理用户态内核态的数据交互后来干脆直接搞进内核减少了一部分最后另起炉灶直接在用户态处理只是为了保证有些和内核必要的通信增加了通信的接口这里面其实也不是说这种用户态的就一定完美至少它还是额外增加了开发成本但是这种成本在实际应用中是舍得付出的那么就可以这样做技术主要是优化了的后端驱动后端服务主要有三个部分内核模块部分和部分内核模块其实是把原后端驱动数据部分迁移到了内核中而控制部分仍然在上层中相当于实现了一个后端的它通过实现了用户端对网络设备的读写主要是前面的分析的部分其通过来模拟系统环境而则是独立于传统内核模块之外的负责为程序提供虚拟化硬件支持内核模块而在最初的后端驱动中主要的就是虚拟队列消息通知和中断三大机制为了对后端驱动进行优化则在中在内核中增加了相应模块通过中断来实现内核虚拟队列操作减少了拷贝同样进一步绕过内核直接共享虚拟队列来实现用户层和设备的数据通信将上述说的更直白一些就是在内核态的绕过了上层的模拟状态转换减少数据操作而则是进一步绕过了内核直接让用户层和设备进行数据操作前者是虚拟机与内核的数据交互虚拟机与内核共享数据队列缺点是如果与用户进程进行通信比较麻烦而后者使用来通信用户进程间共享内存其效果和前者一样的采用的有两种封装形式即前者实现了用户态的驱动供其应用程序调用而后者对进行了进一步的封装抽象为一个虚拟端口可以使其象标准端口一样通过接口调用来实现管理和数据报文的收发的其实是在基础上进行修改而来的在中容器环境下虚拟机是通过来模拟的这就导致数据共享时会将所有环境数据与宿主机物理机共享但实际上只有数据交互部分的大页内在有实际的意义从的角度来看是一个由前端驱动虚拟出来的一个虚拟设备其后端对就着相应的用户态的二者之间就是通过进程间通信来实现数据交互同时为了保证一些异常数据和内核的交互还需要通过接口实现和内核的交互的源码在相关的一些接口代码这里重点说一下相关的注意点通信是采用通信所以其可以采用客户端或者服务端两种形式但在后续版本默认为服务端的通信数据交互是在进程和进程间而不是和之间进程运行于进程内有自己的通信格式必须要在源码中卸载在内核中原有的相关部分必须处理的轮询的存在其实最主要的就是减少虚拟机通过与网卡的数据传输路径和数据的拷贝所以在网上可以经常看到它被叫做加速器它通过队列直接将数据和内核中的虚拟以太网设备设备进行交互大家都知道内核态和用户态的数据交的成本是相当高的减少的交互越多理论上数据传输的效率越高而在中更是将其提到即可以理解其为一个虚拟的设备这样就可以更好的提供网络的通信同时它也可以支持目前云环境下的容器中的应用不过掠过内核后传统的编程就需要改变一下这个在网上也有很多相关的资料反正不可能是光有优点没有劣势各取所需吧前后端的数据通信在把虚拟化虚拟化的方式介绍完成后重点分析了半虚拟化的对进分成前后端两部分以及从后端发展到内核再发展到纯用户态也一路进行了分析那么这就提出来了一个问题在中数据是如何通信的它们的框架流程是什么有没有什么不同的具体的性能如何这都需要进一步的分析和说明在前面提到过前后端的驱动是通过传输数据结构抽象模型其具体的实现为这个个体的数据类型可以理解为数据队列和队列存储的具体数据类的关系和的通信下面看一下的路径传递过程就可以清晰的看出其发展的过程在的标准中一般来说是由设置发送的数据然后前端通知后端叫后端的然后陷出从虚拟机进入反之为陷入从内核态切换到切换到用户态的进程然后再将数据传递到设备而由内核态控制的前面和标准设计一致只是在最后一步不再由内核转到用户态而是直接由把数据传递给设备而做为则在用户态进程中通知陷出前与前面两种均相同将数据直接发送到设备下面的就具体的前后端后通信看一下数据流动的过程创建共享内存通知内核或者通过使用与其它进程通信即这里以后者为例利用传递文件描句柄通过创建共享内存发送句柄到通过内存映射直接操作减少文件打开动作和通过数据结构共享内存每一段是一个可以有多段初始化共享内存发送的地址给通过后计算出端这些地址进行数据读写数据指针需要在和地址转换读写操作在通信中一个发送一个接收两个共享内存保持有等相关信息包括等当写数据时数据放在的中在和中不同为链表的头尾其将增加到中并将接收信号通知即从到开始读取数据端处理一条请求完成其同时插入到中表示最新的位置信息通知处理完成消息即可回收的描述符通知的过程均为创建通过发送通过技术从虚拟机到利用大页共享实现了数据的而从到也实现这样就进一步加快了数据的传输中由于只针对特定的设备所以对相关的传输进行了进一步的优化即对网络发送包和发送过程中的支持在的中为不同的用户场景提供了三种数据收发和路径可合并路径大数据包设计为专门的转发的向量路径如未给参数则默认为不可合并路径可合并路径虚拟机将中的独立组织为一个链表用来接收各种数据包向量路径利用处理器中的单个指令通过来处理收发数据在只处理数据包转发这类数据时性能会更优不可合并的路径一种比较少使用的方式基础数据结构中源码在底层设备抽象的是和它主要用来对设备的检测并实现相关设备的驱动看一下基础的数据结构和宏定义上面的宏定义中英文的注释已经很明显主要分为设备控制设备类型版本控制设备标准状态配置等等下面再看一下相关的数据结构硬件设备的抽象其实有过驱动开发经验的可以比较容易的看出抽象出来的设备要有描述其设备功能的数据结构体也有要有相关配置的结构体对硬件设备的映射以及具体操作的数据结构体封装的函数指针在读内核代码的过程中可以发现基本上这类数据结构体都包含描述数据结构体配置结构体和操作函数指针结构体可能再辅助一些相关的数据内容结构体通过上面的代码可以再次印证这一点设备简介这一部分的主要功能其实就是对硬件到抽象的一次抽象特别是在计算机设备的发展过程中经历了各种总线的出现和共存到现在发展到总线换句话说现在的很多设备都支持在总线上的挂载通过抽象的总线设备支持就可以对中支持的包括存储网络等进行统一的支持使得整个设备的管理更方便更容易扩展新的设备既然是直接从设备到应用层也不能脱离这个框架这就是这一层的主要作用设备有自己的配置空间所以在的定义中也要有相关的配置定义包括宏和数据结构体每个设备由最多个寄存器组成在此设备出厂时其相关的地址及就已经在硬件上固定写好设备在整个管理层维护着一个设备链表这也是在数据结构体中可以看到的设备地址的物理地址和中断地址及其相关的驱动更加详细的匹配说明可以参看相关设备的资料和书籍设备发现基本流程在上面提到了本层主要是进行设备的发现注册和挂载等流程看一下相关的源码发现在中一切都是文件所以可以看到上面的代码先是判断指定路径上有没有相关的设备有的话开始遍历读取而就是将设备目录下的文件读取出来上面的就是用来读取设备中的寄存器映射后的物理空间地址然后再将其设备以地址大小顺序插入到中探测这段代码如果有内核开发经验或者阅读过内核源码的应该很清楚注册注册的相关代码如下它们最终会变换到实际的设备链表如下面的网卡上述转换的方式是使用宏映射地址上面提到了读取文件后要进行物理空间的映射在下面的代码中中的相关函数这里看一下在前面的中的相关函数实现先看一下原来的声明然后看一下调用及实现上面这个函数会调用这个函数这里主要要区分和两个不同的版本前者是在中后者在及以后中其它的几个函数也比较简单可以对应着看一下源码即可基础数据结构在中中间层的数据管理是一个重点前期的文章中提到的相关的队列和缓冲区就是最典型的数据结构即它们两个定义在和这两个文件下面看一看与其相关的定义代码描述符主要用于对客户端一侧的数据缓冲用来提供和的数据传递请注意这是一个链表用来包含多个此类缓冲数据标记已使用其实是把上述的数据结构代码合并即版本后实现上面的代码是的数据结构在以前几个是分开的在以后合在一起也叫而以前的则称呼为再看一下的定义数据的类型收发或者控制其实通过上述的代码可以看出队列中包含有这个数据结构是一个环形的读写空间在实际的运行中把插入到这个队列中而队列会根据不同设备安排不同的数量一般来说网络设备有两个队列即用于收和发两种数据类型主要功能在上面的分析中知道了和它们都是用来做为前后端数据交互的数据结构在实际的运行的过程中通过其产生的结构体对象形成的队列及队列内的环形缓冲区通过级联式的内存缓冲和复制来保证数据的安全性相关的数据传输的效率不同之处在于由于是分离的所以其数据结构在中是要求严格有序的其代理的一些缓冲区及内存数组部分需要使用相关来操作标记结构也比较少而在中由于三个合在一起增加了的相关标记值去除了字段同时增加了对支持进行了增强而且还更容易增加与硬件的亲和性并更好的利用基本流程在源码中先看一下处理的分支此处代码即用来判断是否为在上面的代码中不同的设备状态会引起不同的操作函数来处理这也是一种兼容的方式下面看一下两种处理方式的具体的代码处理缓冲区拷贝处理数据填充小数据处理更新前端的处理代码判断当前是否满足拷贝的需求拷贝到处理小数据通过上面两种代码的分别处理流程即可处理相关的数据结构也就是分别数据最初提出的不同的内存数据结构体其实本身就是一种以数据流动为向导的框架追根到底就是极致的增加数据传输的效率所以扭住了数据传送中的数据对象的数据定义其实就找到了中为实现这种高效的数据流动所采取的算法和各种通信方式动作形式和数据管理机制把这些都搞明白后那么学习的基础和前提就有了就可以结合上层的如亲和大内存等一一进行分析处理网卡抽象实现其实不管怎么设计如何开发结果都是要展现一个结果能够为人所用虽然说的应用场景有不少但是在中主要就是网卡所以在此处主要是对网卡的抽象的实现即对上层的应用实现底层的驱动和相关设备的定义这样的话就可以在上层软件中将其看做普通的网卡接口来使用也就达到了抽象的目的隔离了虚拟设备的种类和具体实现对外暴露统一的网络接口上层应用不需要区分到底是真实的网卡还是虚拟的网卡而中使用这种机制能更好的发挥本身实现网络通信功能并实现更好的适应性基本数据结构在中对抽象实现的数据结构代码上面的三个数据结构用来说明网卡通信数据的内容用来网卡的整体的描述包括收发数据和函数指针的定义用来对网卡设备的驱动的操作定义导出函数这三个组合在一起就可以把一个网卡整体框架的数据和函数功能基本表现出来基本流程其实在底层实现中为了描述对底层的函数调用简单分析过一些此处的函数所以应该看到有的函数并不陌生下面看一下主要的流程代码这个函数的说明里也告诉大家基础的调用是在中和刚刚提到是底层抽象的具体实现的互相呼应在这个函数里主要是对描述的数据结构进行初始化和定义对相关设备进行初始化同时对一些交互的特征值进行预定义包括对数据队列的初始化收发函数的设置在其中和两个系列的函数就是用来进行收发的两大类具体的工作的下面的再看一下函数定义均定义在先是基础数据结构的变量定义然后利用进行初步的判断通过得报文的数量包括描述符然后再将其内部数据读取完毕后将回收然后通过循环读取具体的数据最后更新可用分配并插入到可用队列同时通知再看一下函数定义真正的数据发送发生在循环中调用这个函数上其它的都是一些相关状态及数量等的准备发送完成后更新状态参数再看一下调用的实际发送函数在这个函数中其实就是可以看到前面提到的队列和描述符的操作动作了特别是一些数据结构的来回填充回收使用的过程的第一个判断主要处理的是等情况重点看一下里即循环的代码的基础数据结构的编程有内核态和态两种在中使用后者可以更好的操作数据流程减少数据的流动路径和复制的过程在中主要的控制文件在和和三个文件夹中分布其中在中的中还有一些中相关的数据结构这里看一下中的中的数据结构看到上面的一系列的数据结构是不是有熟悉的感觉和上层的是不是有一些类似这些数据都是为了的准备包括在前面提到的在新版本中使用了的方式来处理数据在设备处理的数据结构定义在中除了上述的定义其还有一些内存数据结构相关管理数据都分散在上面提到的这些文件夹内可以在分析代码时有针对性的看一看源码分析通过上面的数据结构可以清楚的看到数据的定义那么把这些数据结构串通起来的代码就可以看做是的数据流动的过程其实在通信中从底层来看只有三种状况收发和事件这里就从收发开始处理这里有一个需要注意的情况在中有抽象出来的封装函数和在使用的更上层的封装函数先看中从上层客户端中得到缓冲区的数据下面是增加到队列中缓冲区的数据向设备的接收增加缓冲区再看一下中的处理封装函数看上面的最后一行代码通过来查找相关的函数函数并将其通过强制转到相关的函数指针这就和下面分析如何与中的相关封装函数连接在一起进行了一个转换下面是二者是如何转换的过程看下面的代码定义函数指针此处的代码认真分析一下可以看到转换的过程此处调用了从此处可以看出中封装了另外一个也是如此在网络的半虚拟中是目前最优秀的解决方案在中同样也采用了这种方式是为了解决内核状态数据操作复杂的情况提出的一种解决方式通过在用户进程来替代内核进程来实现数据交互的最少化在中使用进行设备文件间通信替代了模式而数据交换则采用的进程内存共享的模式减少数据的交互在中的库中实现其包含了完整的的后端逻辑功能在软件虚拟交的机中就应用到了这个库一般来说由为每个虚拟创建珍上端口来实现相关数据操作而此时的前端和会调用此相关的端口进行通信数据结构基本的数据结构如下其中最主要的就是最后一个数据结构这个消息里包含着消息的种类内容和相关内容的数据大小而这个消息正是通过中的这个函数来处理的它们之间的消息类型定义如下随着版本的迭代和新的设备及相关控制手段增加会引起一些消息的增加再看一下相关的共享内存数据结构对应端的结构上面的两个不同文件夹的相关数据结构体互相对应通信连接和初始化连接的建立是使用来进行的在前面的消息数据结构体中其实是定义了很多消息枚举和相关的数组的这个上面的数据结构体中已经有所体现通过线程来启动分发控制最后根据是客户端或者服务端来启动相应的功能函数当有一个新的连接时则处理为其实你看中的代码如果有编程的经验的一眼就可以看出好多相关的处理函数和处理手段数据通信数据通信中数据交互使用相关设置代码地址的转换是在下面的函数数据的实际通信在前面分析过就是和这两个函数通知机制基本上是采用的方式这和网络通信保持一致上述交互使用机制也就是轮询来不断驱动着数据的流动在网络的半虚拟中是目前最优的解决方案在中同样也采用了这种方式是为了解决内核状态数据操作复杂的情况提出的一种解决方式通过在用户进程来替代内核进程来实现数据交互的最少化在在应用场景中虚拟化的容器支持是一个重点方向起初的就是为了支持容器内部与通信的后来也发展到虚拟设备间的通信与的通信也叫做通常来说这种通信方式主要有几种是目前中用户使用的主要方案即通过虚拟网络接口利用队列和应用交的数据但无法实现一种负载均衡的手段或者需要内核切换效率差虚拟多张网卡依赖硬件不灵活和这是比较好的一种实现机制在和虚拟场景下的应用还是非常多的虚拟出的设备和真实的设备在上层看没有区别这个非常重要下面看一下在中相关的数据结构定义除了虚拟设备外其实它主要是和以及相关数据队列的操作而那些数据结构在前面已经基本都介绍过了其实在前面说了在虚拟环境中应用非常广泛在文件夹下可以看到其实最主要的就是那几个文件先是对设备的初始化然后进行然后在处理用户状态时可以启动这里其实会调用来传递内存数据中设置如果后端为时即为找到相关的选项设置就看了数据的准备从调用函数就可以一路深入进去明白整个过程这里就不再做介绍通过上面的分析可以看出既可以实现虚拟机前后端的通信也可以实现不同设备间的通信还可以实现与内核间的通信所以一种新的技术被提出后会不断的推动应用的向前发展反过来应用的发展又不断要求前者提供更好的支持互相促进就会形成一个新的应用场景并有可能暴发做为半虚拟化的应用标准在中最典型的应用其实就是在前面的一样都是把工作放到了用户态也就是说把设备驱动搬到了用户态在网络半虚拟化中这样做能够更好的提高应用效率而在中把这种驱动称之为而中的既可以创建设备并与后端的完成初始化配置又可以在没有的参与的非虚拟环境下使用相关的设备再次强调一次中支持虚拟设备这在现在云技术应用中非常用用处这种设备是自己在用户态虚拟的内部设备由自己管理这点要清楚它是和由模拟出的设备是两回事这里对做一个说明即设备的学过网络编程的应用知道啥它通过接口实现对虚拟或者物理网卡的用户态配置和数据处理用户态驱动在大家的眼中一般习惯的把驱动理解成内核态毕竟从一开始学习牵扯硬件和的相关知识都强调驱动的重要性毕竟就是为了隔离用户直接和硬件打交道的硬件的复杂性和安全性都不能随便开放给普通用户但是随着应用技术的不断发展出现了一些新的需求大规模的数据通信和处理被内核的性能和管理限制的条条框框太多技术人员需要不断的压榨整条数据链上的所有的剩余价值那么在某些情况就提出了把驱动做到用户态减少数据链中的传送节点少的中间节点越多理论上传输速度一定会更快用户态驱动最主要的就是把原来内核态需要处理的中断和硬件地址等内核态才能访问的内容能映射到用户态来用户态的驱动技术有两种即和中版本前同时支持两类但以为主更早期则只支持但在此版本后基于框架的模块不再进入默认编译选项即不再建议使用在网上很多人都推荐使用版本以前的做为入门学习的原因大概也是因此中实现机制中也是上面的两种实现机制即和是的缩写它的基本原理就是为每个注册使用的设备提供一个的字符设备通过这个字符设备可以实现设备映射和设备中断开关以及中断获取得操作是一个应用框架使用它需要自己实现一个内核驱动模块而在中则是一个标准的设备驱动提供接口来向内核接管相关设备通过的接口注册提供的用户态文件接口也就是通过此框架实现了从内核到用户态的一个操作转化但由于其没有如果想使用相关的物理地址必须要进行映射并注册给这种方式的应用有两个缺陷不支持使用设备比较复杂并县城需要权限地址映射异常会引起崩溃一个设备只支持一个中断对模式的影响有限但扩展受限即可以简单理解为对的高级版本其主要通过来进行设备的访问和中断重定向知道中的大概就会明白其实就是一层抽象隔离隔离就是为了更好的兼容性和扩展性不过它也和一样需要映射到指定的中来进行实现相关驱动也是有接口层和具体的设备驱动模块即绑定到驱动再由提供的相关文件即刚刚提到的接口来操作不需要权限通过注册来提供中断的用户态揽收方式在中实现的主要功能有在用户态实现了设备与传统的虚拟化技术不同在用户态进程实现了和其后端控制面配置实现了在内部总线上与或者的通信这基本上是可以根据实际情况把省略来实现高速的网络通信主要的应用场景就是在虚拟机中可以更好的提高虚拟机中的网络通信效率当然它也支持设备的和的物理网卡操作而除了上述与内核交互的应用外则在容器中应用通过与或者通信来更好的实现高性能的网络通信虚拟网络功能网络功能虚拟化是的重要组成部分之一那么是什么其实很简明了重点在虚拟化虚拟化对谁来说是最重要的对重设备厂商来说是最重要的再换句话说是云厂商这样说当然不是特别准确但基本上现在的主流就是这些不知道大家对前些年电信公司对微信的占用信令的讨伐还有没有印象可是现在为什么没有了当然直接的原因和没有太大关系但是却是后来者居上云化是未来发展的方向所以云上一个重要的部分就是网络通信那么和提供就是一种必然的选择主要是通过软件来实现网络功能也就前面反复提到的隔离硬件它可以做为一个类似于网络中的一个节点来实现节点的各种功能可以认为这是一种新型的网络设备部署方式中的一个实例这样动态的根据实际情况进行伸缩正是云厂商的一个痛点大家广为理解的双等促销时对节点的渴求和之后对节点的浪费就容易消弥其中的代价了同样提供了所需的基础设施通过软硬件的管理实现对整体网络需求的一个系统支撑也就是说通过提供来实现虚拟化功能后可以更好的进行网络的弹性扩容并找到最佳的软硬件结合点便于对不同平台的移植和提升资源的利用率做为一个数据平台的开发套件本身就已经成为和的一个重要组件所以的发展其实可以在其中起到基础框架的作用跳过内核而隔离软硬件通过不断的解耦让二者可以更加良好的结合来达到高速网络通信而通过前面的分析对主流的硬件主机和虚拟化主机全虚拟化和半虚拟化都已经支持的比较完善对硬件虚拟化和基于的半虚拟化都提供了用户态的加速方案即和驱动和基于的软件交换机同样针对云上应用的容器化也提供了可以说实现了对容器支持的专门定制对于硬真能方式驱动也实现了对网卡设备的支持的不断完善几乎达到了和裸机效果一致提供了对多种设备的抽象实现了较好的网络功能的基础设施层目前来看基于的优化方案是业内的主流形式的硬件抽象大大降低了对硬件的差异导致的各种问题除此之外还在一些基础软件应用上对进行支持比如网络应用中的数据压缩和数据加密等等这些都是在网络应用中广泛采用的技术同时在一些虚拟的网络应用如网关路由器等上都可以一展身手中的内存一般来说做为软件平台或者框架要么直接应用或者一些公认的标准库的内存管理简单方便但可能不太尽如人意要么就得自己搞一套内存管理系统而自己搞内存管理系统一般又有两类一种是在原来内存管理系统的前提下再抽象一层为自己的框架所用另外一种就比较狠了直接修改底层或者标准库的内存管理系统正常情况下绝大数应用的开发都是第一大类没人愿意搞内存管理底层的框架或者一些大的平台软件愿意自己处理一下内存管理但多数是再抽象一层但是到了或者虚拟机基本都会自己得写内存管理的手段和方法在操作系统原理中对内存管理的算法都有学习过网上也有很多相关书籍这里不再展开上面说这么多目的是为引入下面的话做为一个开发套件一定会自己对内存管理进行处理但是它与上面的都有不同一是它确实是对现有内存管理的一种抽象但它又节省了传统的内存处理的一些流程使用了特别是在虚拟设备中另外它对大页和的内存处理也进行了优化最后其对的重新抽象后直接供上层应用只不过不同于为所用而为被设备使用同样对内存管理涉及到的对齐技术以及这些已有的技术也不做重点分析只在用到时带一下如果有需要的翻阅一下相关的书籍或者网上查找一下资料的老版本和新版本之间内存的管理有着很大的不同老版本的内存映射是静态的而新版本的是动态的同时其也支持外部内存老版本中的地址是连续的但新版本是不保证的或者说二者已经不再有严格的关联同时对内存的大小和模式的控制更灵活也为此增加一些新的标志在不使用新特性新标志等的情况下新版本的是可以老的版本上跑的或者说老的可以无感的升级到新的中来在中内存可以看做三种情况即内存物理内存和虚拟内存重点当然是虚拟内存虚拟内存中比较容易理解的就是和而在中就有内存对齐的要求从整体上来看虚拟内存可以划分为内存池和大页内存管理而可以为分内存物理或中的内存管理主要有两个大的特点第一支持大页目的是为了更好的增加的命中率提高内存的使用效率另外其可以提供对中的内存固定处理提高内存的使用效率和安全性这样就可以防止线程对不同节点内存的访问最后可以技术和大页技术来固定物理内存从而允许硬件自己启动来执行数据的访问降低和框架本身的开销中的主要分为两种模式即和模式前者指物理地址后者指虚拟的地址利用自己对内存模式的了解可以根据实际情况对内存进行优化特别是使用可以使更安全效率更好在中内存的管理分配等没有使用常见的系统内存分析而是自己管理内存自己分配大页并利用堆来给用户程序提供内存的应用操作这样就可以在原有的基础上重点处理与相关的内存区域控制大页内存管理内存的管理以及对和的访问控制等中的内存分配是安全的这和基础库和有所加强基础库一般情况下是线程安全的同时其强制进行内存的对齐通过共享内存来进行不同进程中的数据资源这个好像在底层很流行像安卓等也是如此这对于这种大数据量跨进程交互的框架来说异常重要更为关键的是对抽象的内存池进行了有针对性的优化它可以让用户指定是否为线程安全和批量操作不过这个线程池仍然没有摆脱普通线程池的问题只能是固定大小的内存对象结果肯定是速度快内存碎片少另外需要说明的在节点间处理内存分配可以平均分配也可以偏向分配但总的内存不要超过实际的物理内存数量说得粗浅不准确一些其实就是一个高效的数据转发框架或者高效网络框架肯定是不准确人家叫数据平面开发套件也可以用在数据存储上说的再不准确一下可以理解为一种网络开发模式这样就会有一个非常形象化的情况认知然后再认真学习就可以明白了为啥不准确比较典型的有数据包的输入和输出加密事件调度和进程数据管理等等中的内存管理应用无处不在毕竟跟数据相关的离开内存基本就啥也别干了简单介绍一下技术这是由公司提出的主要目的就是为了让网络接口数据的吞吐性更高传统的网络通信数据从网卡通过总线传输到内存然后再读取其到处理后再写回再写回内存然后回到网卡网卡读取再由总线送到网卡内部并通过接口发送出去这个过程中和内存会参与进来网卡也会多次读写内存但学过计算机原理的都知道和内存及的数据处理是不在一个量级上的这样就一定会浪费很多资源这里其实就是通过来直接略过内存直接让网卡和通信的整体内存层次结构前面提到了中自己对内存进行了抽象那么既然决定自己伸手处理内存那就得有自己的一套处理体系肯定不能简单的一个链表就搞定学过操作系统和计算机原理的都明白计算机的内存管理是一个相当复杂的系统退回来说就在更上层中使用中中的内存管理开发者能熟练的控制内存的能有多少再退一步讲直接操作内存的为什么会越来越多的被上层应用抛弃其实最典型的就是内存的管理很多开发者是搞不定的一旦出了异常实在是不好下手分析甚至解决问题的时间超过了开发的时间为了更好的管理内存把内存划分成三层如果物理层也算是四层即大块区域池和缓冲区而在每层中又划分了基于功能或者逻辑不同的相关数据结构并提供了相关的的管理控制其实这个很好理解举一个例子家里想过个肥年肯定是买一大块肉或者一大片肉回来后再根据应用范围炒菜炖肉等等切成不同的块最后实际应用时可能进一步分解成小块或者切成各种肉片肉沫儿等等不同的是肉最终就吃了而内存用完了还得收回去不但要收回去还要有效率的收回去所以内存管理更复杂相关的数据结构和既然分为三层来管理内存这里的数据结构和接口也按照这种方式来说明这里需要注意此处的是给网络通信包准备的不推荐使用这个而是可以自定义内存池来处理下面看一下相关的数据结构定义这个数据结构有点大略过中间环节更多的细节还是要看头文件和整个的这个文件下的相关源文件其主要接口有这个更多毕竟在上层应用各种花式的处理也更多内部的外部的池子和缓冲区的初始化块的重置的等等都可以在和相关的此文件夹下的源文件发现详细的在后面再分析这里就不展开了太多了再看一下内存池的定义其实重点是要明白在中的作用和相关头和的作用一个用来管理内存池对象一个用来管理内存池的地址块它的主要接口有这个就不一一列举了比较多可以去列也的文件去看在后面的具体的源码分析中会对这些接口及流程里进行详细的说明在这个层次上的内存分配管理相对就简单一些了先看它的数据结构在这段代码的上面有注释说明它就是对物理内存的名称标识看它的内部定义也是哪些其实就是长度的数据其实包括等好多都分配在这个之上所以也可以把这个分为这几个类型从逻辑上也是可以理解的它的几个接口函数上面的接口没有全部列出来可以在相关路径查找接口不多但介绍非常详细所以引处就不再重复说明了不过看接口应该可以分析出这些接口的作用基本上就是分配对齐查找导出释放和返回列表之类的正如前面分析说过适合于固定大小的内存应用而适合于网络包的使用提供了底层的封装支持所以在一些常见的数据结构里都可以看到它的影子而为了应用的方便在每一种层次上又设计了一些相关的具体的数据结构综合起来让其使用更方便快捷比如在内存池中可以看到对象和内存的列表可以看到的头定义数据结构在这些结构里可以轻松的对进行查找处理这种设计思想其实是从最简单的底层数据处理开始一步步的向上为了逻辑应用和业务处理的一种内存数据封装最终形成一套对外的业务接口数据结构供上层应用开发者的使用虚拟地址在中上层的环境抽象层负责管理的一部分功能中就包含将硬件设备的寄存器映射到内存中以供其它驱动程序来应用也就是说用户态的进程可以直接使用地址并执行操作在前面已经提到过这些地址可以分为物理地址和虚拟地址即上层并不对二者区分即对应用层来说对二者是不敏感的用户态进程中看到的都是地址的模式的优势在于在内核空间的应用中并且对于所有硬件都可以使用它的缺点就是如果对内存操作对权限有要求时就麻烦了同样如果内存碎片较多的情况下可能无法分配内存会导致整个初始化的失败为了解决这些问题一般来说就会使用更大分页比如并且在启动时就引导系统使用大页可明眼人一眼就会看出这只是一种治标的办法正所谓头疼医了头脚疼医了脚而的模式就需要一个来进行地址的转换和分析它等于额外又抽象了一层一般做过设计的都明白抽象大多意味着效率的降低零成本抽象除外它的优势在于内存的处理不完全受限于真实的物理内存的限制也不需要一些特殊的权限特别在云环境下虚拟环境下更合适应用就有了更广泛的应用方式当然它的缺点也不少硬件不一定支持或者干脆平台就没有这个软件不支持或者受限等等在正常的情况下默认是选择使用的模式这样做一个是安全另外一个是适用性广但如果条件允许还是建议使用的模式在更高以上版本可以使用命令来自动选择合适的模式既然是操作理论上讲这块就和传统的驱动的功能类似中对硬件的中断映射和寄存器映射都需要内核的协助它需要绑定到这个玩儿过计算机的人基本都明白而这个一个特点是并未被绑定到特定的一些设备集中写过硬件驱动都知道一般在驱动中会写死一些设备的类型所以理论上讲它可以和任意此类型的设备通用中在用户空间中由于其本身的限制其使用的为只能使用的模式这也就限定了中的应用而在高版本中推荐使用的内核驱动中它特地与进行了开发所以在中可以选择前面的两种模式来进行处理但模式下的权限问题仍然存在等到了内核的更高版本在设置了选项后可以在没有的情况下使用这个就更有优势了当然在中软件轮询模式驱动程序及一些相关软件并不需要来操作驱动它们通过标准的内核基础架构来操作硬件这样就可以忽略到上面提到的换句话说这个就无所谓了数据结构和源码先看下相关的地址定义在前面分析包括在后面分析的数据结构中都可以看这两个数据类型的应用下面看一下相关的转换代码再看一下中再看一下模式判断相关再看下内核中对的支持其实和这些东西就是一个地址的控制方式可以更好的为服务反正在上层应用眼里没有物理和虚拟的一说它只关心操作的地址至于地址最终怎么处理不是人家关心的事儿就和把钱存储到银行一样你只管把钱送进去至于银行把钱干啥了不要关心网络传输中的分包有过网络编程经验的程序员都知道一般在上层应用设计时尽量保持数据包体的大小和最小传输单元保持一致这样就可以保证一包数据的传输中的完整性减少层出现问题导致传输层的重传机制启动主要是指自己已经处理一般来说在传输过程中饰面还会加上开头结尾校验等单元这样使用抓包工具时的范围在实际是那小于个字节呢老规矩自动补齐呗做一种直接和打交道的框架自然有收发两种情况也就是说既有从上层传入的完整的数据流需要框架来拆解成分片大小可允许又要可以将分片数据重组为完整的数据流正反两个方向都是流畅清晰的这是做为网络编程框架的一个基本要求在这个分片和组装的过程中就会用前面学习过的零拷贝技术再重复看一下的数据结构全部数据定义请查看源码在这个数据结构体里有两个奇怪的标记和看这个定义这类似于汇编语言中的标签被定义为需要注意的是是一个可扩展数组是支持的但在编译器中会报错可以使用长度数组来代替可以理解成一个数据结构里面有两个指针分别指向不同功能的域虽然是传输网络包的但是理论上缓冲存储何种数据都是可以的其实主要看利用效率所以把它分为两个域也是可以理解的经常使用的放在第一个域内扩展的数据放在第二个域内可以使用指针指向下一个相同的数据结构形成链表而本身也有两种方式来存储数据一种是直接的即元数据和数据在一个内而另外一种是元数据和数据分别使用各自的缓冲区两者的各自优势也很明显前者类似于固定的内存池操作容易但可能因为数据包大小不同导致有浪费而后者则可能导致操作复杂效率低为了效率肯定是选用第一种了不过在巨型帧中元信息只在第一帧中体现其后帧该部分为空需要说明的是在内部的头部和实际的数据包之间是有一段控制信息的也就是用来存储一些交互信息其起始的地址为指针可以用来调整大小而数据帧的地址可以调用宏来得到看一下这个宏的定义就明白了其实就是地址的偏移处理另外其还还有一个尾部的它们的定义有内核中的协议栈有些类似相关的接口都是中包括创建匹配释放等上面只是举了几个典型的接口更多的可以去查看相关源码内存池在中网络数据会被存储在一个环形缓冲区内同时在的环形缓冲区内创建一个对象因为是内存池所以这都不需要申请新的内存意思就是速度非常快二者之间通过通道或者进行对齐其实就是补有开发经验的都知道对齐上面的内存池是在中已经创建好了不过这里面还有一个问题当多核同时访问一个缓冲区时仍然有竞争的问题虽然使用减少了锁的压力但仍然导致效率会降低这时就需要通过对每个核心进行缓存这样通过减少访问内存池的次数来降低竞争使用来进行管理在上面的数据结构定义中可以看到一个指针向了当然在这里面为了提高效率也大量使用了汇编汇合编程如更详细的内存池会在相关部分详细分析此处只是带过网络中的控制在网络通信过程中会产生很多控制数据其实就是元数据包括一些硬件和协议层的元数据最典型的就是一些校验和长度等等另外一些扩展数据可以在中自己定义在其数据结构最后有一个字段它的说明就是保留的动态域这些都可以是的一种动态适应机制中的内存池内存池那真是分析的太多了几乎这玩意儿是所有的框架必备哪有计算机框架不用内存的哪有内存分配就直接扎楞楞的就的先不说是不是看上去让人觉得太关键是内存确实是很难管理应用场景的不同内存池的管理也要有调整你看有单一大小的这算是入门版有多个大小动态适应的这算高级版还有动态生成和静态分组管理的这算是专家版总之就是要让内存分配和管理回收之间达到一个效率与资源的平衡这在不同场景下可能就有所不同侧重点有所不一样所以一切以实际应用为原则做为固定大小内存分配的一种管理方式内存池其实是预应对内存快速的分配和回收的但是一般情况下内存的大小是无法精确确定的所以内存池往往的结果是浪费一小部分内存这也是一种妥协在的内存池中由三个部分来实现内存池的节点对象这些对象存储在全局队列中可通过唯一标识来访问当然它只是一个指针结构并不是真正的内存区内存的实际存储区它在中分配出来的连续内存中用来存储相关的内存池对象无锁队列无锁队列意味着多线程中是安全的它可以用来管理的对象整个内存池通过环形无锁队列映射进行内存池对象的存取同时为了兼顾多核冲突而引入了对象缓冲区尽量减少多核访问环形队列的并发处理在前面已经把内存池这个数据结构简单分析了一下这里只给出相关的代码片段创建它调用了这个函数在前面说过在内存池的数据结构定义中有三个重要的部分和它们都在上面的函数中创建生成的对象都挂在类型的静态变量中然后通过对三个数据结构体进行计算得到的头大小并得到所有核的的大小真正的内存也就是实际的内存创建是在这个函数中创建的其中通过下面的函数来创建分配就得看中的这个在哪里初始化了这样基本注册宏的调用就可以明白流程了这里面嵌套的很深有兴趣可以逐一跟进整体上就是函数创建后插入到全局的然后再通过函数调用函数将申请的实际内存插入到链表中使用使用是分配下面是的调用下面是的接口它最终会调用函数来获得内存对象先从本地的中获取不够才会从中获取并存储在本地的中回收回收是一路下去就找到结果了中的处理其实一直不想分析这个问题主要是这个问题太多了即使不学计算机的原理和操作系统内存型框架等等中都回避不了这个问题包括多线程的伪共享也提到了这个问题可以说这个问题是绕不开的老生常谈谈得都糊了所以这里重点不谈这个原理书和网上都多得看不过来了这里重点分析一下在是怎么样使用的也就是说的有什么用处减少对内存锁的并发的冲突目的也是为提高读写速度提高读写速度对的支持大页内存命中率提高直接和硬件缓冲打交道略过内存配合大页仍然是提高命中率的方法预取指令一般到这个级别都是硬件最多操作处理一下对上层一般是不开放的但随着技术的发展软件开发者也可以操作预取指令同时底层也开放了这些软件预取的指令就可以利用这个技术来处理的数据加载提高执行效率但需要注意的是如果自己也软件也要这样做就得考虑好策略别到时候儿画虎不成反类其犬预取指令一般是汇编命令但有些程序也提供了封装的上层库在中为了和数据处理保持时钟周期的匹配即达到最大效率就必须保证数据都可以在中否则性能会严重下降而这个预取指令就是为了配合这个命中采用的一种手段当然在中还有其它的手段同样也可以达到这个目的结果只有一个让处理和数据读取保持一致中预取一致性处理现代计算机基本都是多核或者多的如何处理当不同的核去访问同一的冲突呢也就是说如何保证数据的一致性呢解决的方法很简单粗暴直接每个核给单独一个这样读写只操作自己的数据队列就不会有冲突的问题但是这也带来了数据的最终一致性问题这个就需要设计来搞定了尽量避免冲突如果非要有那么只好加锁或者用一些协议来解决另外为了保持冲突最小化最小单元直接在分配时对齐这算是另外一个手段换句话说尽量保证能在一个的不让他们分成两个那么一致性协议有几种呢目录协议和总线窥探协议这里不展开有兴趣可以去查查资料下面看一下的相关源码在基础的数据结构中经常可以看到这个宏它其实就是对的一种处理对齐方式再看一下为每个核的配置数据结构定义总是行对齐防止跨是当前的最大核心数量通过编号来控制对核心的访问避免出现多个核心访问同一个数据结构的问题同样现代的网卡一般都支持多队列网卡为其准备多个读写队列来应对这些问题如果从前面的安装过来的读者可能会想起在安装时的配置看一下收的预取上面的预取写得很清楚看一下定义源码中有三类平台的这里只看的其它预取的可以搜索都了这里不再赘述随着计算机技术发展特别是应用技术的快速发展应用场景对计算机的处理速度几乎已经到了疯狂的地步说句大白话再快的也嫌慢没办法和等技术基本目前都处在了瓶颈之处大幅度提高短时间内看不到希望但是不可以在某些部分进行优化而就是这么一项技术数据直通网上和书上说得比较玄乎其实就是一句话缩短数据传输路径减少数据拷贝次数它的结果当然是提高敢吞吐量减少了延迟在传统的网络通信时网络报文在到达网卡时要把数据和相关元数据传输到内存读内存到然后进寄存器处理再原路返回最终通过网络发走从上面的分析可以看到数据不断的在内存和缓存中进行传输而的处理速度和内存的处理速度以及总线和的处理速度这都是有量级的差别那么如何操作呢它通过直接和网卡打交道不让中间商吃差价的流程在中是如何进行的数据传输呢看一下读的过程读取报文和相关元数据并把内存中的缓冲区预取到中将传送报文利用技术通过总线直接将送到总线再看一下写的过程报文及相关元数据通过总线直接送入中此时有两种情况缓存命中即有此段内存则直接覆盖写没有则分配一块区域更新表写内容通知报文到达产生内存读操作因为原因直接读然后发走在中本身就是一种整体上更强于的优化方式可以把当成的放大版功能上数据处理上和传输上都做了一种整体上的即从用户态直接处理网卡而不是绕道内核进行处理传统的数据传输硬中断取数据包分发至内核线程软中断内核线程在协议栈中处理数据包处理完成通知用户层上层收包网络层逻辑层业务层中硬中断放弃中断流程用户层从设备映射取数据包进入用户层协议栈逻辑层业务层在中也是一种数据处理手段启动分析在前面对中的内存进行了各个模块的分析这次开始整体流程的分析说明重点是分析一下内存从开始准备到最终应用的过程从而把各个分别讲的模板贯穿起来从而能够更好的了解和认识中内存的使用中启动时对内存的处理如下大页内存的处理这个在前面分析过两种情况一种是直接在内核配置文件中处理另外一种是使用用命令配置临时就用挂载一直第一次就用命令找到挂载点设置当然这有一个前提就是在内核中已经预留了大页内存使用进行多进程内存共享也即的主进程通过进行初始化并巨页内存然后再通过配置文件共享给其它进程看一下相关的配置文件上面的四个数据结构其实就是全局配置文件到然后再有就是巨页内存的配置和相关信息的数据结构其中的英文注释已经详细的不得了了再看一下对世面的管理数据结构将同一的大小相同并且地址连续的巨页存储在此结构中方便管理和优化分配初始化从启动后就正式开始了初始化和相关分配的流程环境初始化函数此函数里主要包含了四个主要的初始化函数即上面列出的当然这个函数里还包括了不少的参数分析日志以及其它初始化动作但分析内存重点还是看内存相关的全局配置初始化看相关代码由从进程执行而由主进程执行此处要进行前面提到的映射过程即从文件中的配置映射到所在进程的数据结构中看明白这个需要有一些的相关知识其实一般共享内存会有两个入口一个是创建并使用一个是使用如果对此不是很清楚的可以看看相关的知识不难不过需要指出的中有两种内存映射一种是而此处使用的巨页内存信息配置初始化其初始化代码其实大概上面的代码分为几个过程首先准备巨页相关的数据结构然后进行巨页的在中通过读取配置文件中的信息对整个巨页的信息进行配置并加载其次判断是否有共享文件否则退出再次根据前面得到的相关信息开始创建共享内存并拷贝文件描述符到共享内存这没啥可讲的最后处理从进程中无用的部分即可内存初始化同样在完成上述的内存处理动作后就开始了的处理同样在函数内这里把下面的那个初始化也搞进来这个在后头就不再拷贝了这个函数调用这个函数来分配这个数据结构用来处理创建和附加的内存区域确保调用的安全内存初始化在上面把内存初始化的代码调用已经说明了现在看一下其代码实现及其调用的两个主要函数和在内存初始化的函数中调用实现主从进程中的内存段相关初始化主进程使用函数子进程使用函数来实现这其中通过结构体来描述其数量从而进一步其分配虚拟的内存空间的大小从进程使用来操作主进程分配的相关并过来二者共享空间同时要做一些虚拟地址空间的大页保留动作而函数就比较简单了同样分为主从进程前者对所有的的文件描述符进行初始化而后者初始化自己本地内存的映射并保存到本地大页内存初始化函数内在前面的函数中主要是处理大页内存外部配置的初始化动作而在此处的则根据情况来实际完成初始化的动作中分为两类内存模式静态模式即在程序初始化时分配内存并一直使用它能保证内存空间的连续性虚拟和物理但内存不足时则不可再分配动态模式即程序在初始化过程中逐步根据情况分配内存并一直持续到结束但是在内存不足时可以向申请并使用而且在使用完成后返回给但是这样内存地址就无法保证连续在静态模式下会调用函数相反则调用前者根据配置来将相关对中的进行映射并排序然后通过巨页内存文件的重映射来保证虚拟和物理地址二者同时的连续性保存相关信息及描述符到巨页数据文件并采用做为技术保证这样就可以保障相关数据操作的效率而后者则通过实际的需求来计算在不同的上的分配通过算法对内存进行分配它采用来保证整体的性能需求总之各有各的好处各有各的香中的大页内存管理大页内存在前面已经分析过很多但大多是在形式上进行说明本篇主要对大页内存的特点和提高性能的原理以及优化的过程等进行分析说明说大页内存就得提到系列中对虚拟内存的管理段和页这里仅简单说明一下如果有想更清楚的明白这两个定义的可以去看原理的相关已知或者汇编相关书籍段式管理其主要的方式就是把程序按内容或者函数相关分成若干段并给每个段命名一个用户进程对应一个二维线性的虚拟内存空间也就是段通过来查找可通过段表来查找页式管理其主要的方式是把虚拟空间划分为若干相等子空间即页然后每个页的虚拟地址与物理内存地址建立映射的页表它需要有相应的硬件转换机构来进行地址变换段页式管理上述二者的结合但增加了复杂性在现在普遍使用的位操作系统上除一些比较特殊的情况下基本上已经不再使用段换句话说主要使用页而使用页时一个经常遇到的问题是如果发生缺页中断会导致进程的延迟进而导致整个性能的显著降低在某些情况下可能导致无法想到的后果缺页是快表没有命中的结果可以简单理解成页的缓冲区引起页缺失有两大类可能一种是软缺失即内存中页存在但没有向注册另外一种是硬缺失即页没有加载到内存中已经交换到硬盘软缺失的性能损失稍小但硬缺则非常大其实这就是在前面不断提到的计算机资源比较少导致的理论上讲内存越大发生缺页的可能性就越小也正因为资源紧张一般都设计成虚拟地址可共享或者不常使用的页可以交换出去等等通过上面的分析可以知道缺页的基本原理其实是缺少进程运行需要的内容页较小那直白想到把页加大不就行了甚至干脆就分一个页回到早期的内存管理但这样又会有一个问题如果内存不够怎么办丧失了灵活性多进程的处理也退步回到了早期所以大家要明白大页内存是有其应用场景的也就是说对内存操作非常敏感的业务内存使用量大十几以上频繁且随机局部性差内存访问导致瓶颈否则就会大量浪费内存反而导致整体性能的下降在中本身就带有一个大页内存的库可以通过配置使用另外在一些大型的互联网公司往往为了自身的实际应用场景或多或少的对一些大页内存进行处理形成自己的库网上有原来字节内部人员的相关文章有兴趣可以找一找下来重点分析一下中对大页内存的处理这里需要说明的是在中对大页内存采用的是段页式管理但有一个前提这些大页必须是属于同一且连续要想使用自己的内存管理系统就须要把原来系统自带的相关一套如等系统调用替换在中其使用的是和实际上从中得到内存而又从段内存中获取得来而段内存最终维护着一系列的大页内存大页内存的整体流程初始化并进行共享配置映射这个在前面分析过通过读取配置文件从根目录加载然后主进程申请共享内存从进程映射大页内存的映射主进程的大页映射其实就是在目录下进行配置然后将大页内存映射到刚刚建立好的共享内存中去并维护页表记录大页内存的虚拟地址和物理地址的关系大页内存要进行两次映射两次映射的目的第一次是为了完善相关大页内存的信息然后进行各种转换第二次的目的是为了保持虚拟内存的连续性并最终提供映射到共享内存连续性是段页管理的前提在本项工作完成后就可以提供抽象层的内存管理了如刚刚提到的等段内存的管理段页式管理的优点很明显就是提高效率但缺点是复杂性增强之所以使用这种方式就是为了提高效率的实现在段里存储着可以使用的内存但是在中是对段内存所指的大页内存申请内存大小的一种管理它相当于对内存池中对使用中内存的一种描述管理的链表也就是每当向段申请一次内存就会生成一个对象内存的管理这就回到了本节开头的话上层应用开始调用来实现对内存的控制这里需要注意的是由的存在必须保证对每个都进行堆内存的管理而每个堆中又有一系列的空闲链表这些空闲链表按被指向申请内存的大小来划分更合理的使用内存减少浪费提高使用效率至于链表管理内存分配这块学过内存池的应该非常清楚方法有很多具体到中取其中一条链表来说明的话就是查找空闲头申请内存通过数据结构将其划分成两部分每部分都有一个的头类似于一个双向队列的的头不动而尾的头不断的切割形成链表然后分配使用再次分配后先查询此空闲链表头分析是否够用够用则在链表内存中分配继续从已经跳转的尾部头向前跳跃走到不够后再申请内存通过形成链表如此反复同样释放时反向操作即可需要注意的是释放的内存的头指针仍然指向前一个位置保证访问的连续段内存分配的相关代码初始化申请等申请和先看一下分配代码最终回到了链表队列的操作上看一下释放的代码同样也要回到链表的操作上了环形队列环形队列是数据结构里一个常用的数据结构一般来说开发者对其基本都清楚即使不清楚的翻翻书也就明白了这里重点不再于讲环形队列的基本实现那个资料太多了这里也不再狗尾续貂环形队列在实际应用中最常用的方法是一个数组或者链表把尾和头在某种条件下连接起来可以用取余的方式也可以用指针的方式但一般都会有一个置空位防止和指针的相遇目的是为了明确的判断全空载和满载的不同这样当指针时环形队列就是满的因此环形队列的容量是固定的也就是说环形队列是逻辑上的环形不是一个真正的环形计算机的内存都是平坦的怎么可能拐个弯儿但在实际应用中还有另外一种情况就是做为一种数据缓冲区时对数据的位置不敏感数据被定时刷新时就可以不留置空区直接这样做的好处是处理会更简单方便每次给数据只要从下一个序号开始到本序号截止即为缓冲区内的全部数据在中的环形缓冲队列是什么样的呢的环形队列是一个无锁的环形队列它借鉴了内核中的无锁队列听名字就可以大概判断出的是一个无锁的先进先出队列它有下面一些特点多对多队列即可以多生产者或单生产者入队多消费者或单消费者出队无锁即使用实现无锁进出批量出入队列支持突发出入队列当然环形队列本身的一些特点它也都具有下面重点说一下环形队列的出入队的出入队看似复杂其实有规律可寻网上的很多资料其实只是对官网的一种简单翻译这里进行一下初步的总结在队列中有两对头尾指针一个指向生产者的头尾一个指向消费者的头尾为什么不是两个而是两对其实很容易理解因为要批量插入如果是一个一个的插入就不需要两对了这也是为什么一个个入队时单对的头尾指针相同的原因为什么开始生产操作时只操作生产者那对指针中的头指针反之消费者只操作尾因为头指针会移动插入的数量大小始终保持前进反之尾始终保持后退这样如果是一个逻辑环形的队列时可以看到它们都是朝着一个方向在前进顺时针形成然后另外的两个指针可以根据实际的生产和消费过程推导出来需要注意的是循环队列需要一个哨兵置空区官网的说明应该是头指针不存储数据做为哨兵多核的入队出队涉及到局部变量和的相关变量的更新问题使用来实现有不明白的可以查找一下相关资料这里分析一下如果只是一个核心一个进程或线程那么问题就简单了更新一下就结束了可以把理解成一把硬件锁本身也是两个核上的进程或线程同时入队出队完成后更新状态时核更新成功时核不可能成功但核成功后核更新状态后可以导致核再次时成功这个要不明白就得翻的相关资料了推理可到个核所以这里也需要次环形队列为什么有码目的其实就是为了方便快捷的处理溢出的情况下自动取模官网的例子中其实就是溢出时让减去计算值的反向正值上面就是就是这个意思弄明白了上面的逻辑再看代码就明白很多了先看一下定义再看一下创建重点看一下出入队列即生产和消费看一下单生产入队上面的代码最终调用宏代码中其实是将插入的数量以四个为基准分批插入不足的在后面的中再完成单消费者出队多生产入队最终的处理走到了一起多消费者出队突传的几个函数自己看一看就了重点看一下那个入队时的和的标记导致的代码不同上面的代码中对的处理和对的处理就体现了消费者最终也有类似的处理这里就不再多贴代码了并行机制什么是并行机制这个很多开发者的眼中其实是模糊的可能说起来头头是道但是细一查究竟发现都是飘在空中的东西在前面的多核和多编程中对并行机制已经进行了较深入的分析这里只简单说明一下说起并行就不得不提并发并发一般是指多线进程在一个执行单元上进行轮流执行时间片而并行指多线进程在多个执行单元上同时执行大多数开发者一个最明显的谬误往往就在于把并发和并行混淆当然有的书籍中把二者说的不太清楚甚至从某个角度上有意无意的误导了学习者也是一个重要原因之所以产生这个现象一个最重要的原因在于大学课程中的操作系统和计算机原理为了更容易说明进程线程的机制而简化了很多东西这样就导致很多开发者在一开始就把学习的知识想当然的扩展了这在国外的教科书中就做的比较好所以搞计算机教科书尽量用国外的技术尽量上国外的官网另外一个就是在计算机普及的过程中并发比并行更简单实现成本更低这也导致很多老的开发者如果技术没有跟进也会产生这种误解起初的大型机和小型机上多的很正常所以并行编程其实出现的很早而并发编程也就是现在开发者理解的多线进程早期的多道程排除出去其实比并行编程要出现的晚就一如线程这个概念一样需要注意的是上面虽然以多线进程为例说明但一定要记清楚这是任务分配前端到底决定是并行还是并发还是看执行后端是同一执行单元还是多执行单元另外不要混淆并行和并发混合个线程个执行单元这种情况还有一个说明点所谓异步和协程的虚拟线程这些都算这些都是在以此为基础的另外一种抽象的应用不要硬夹杂进来明白了什么是并行机制后现在看一下中是如何引入并行机制的从宏观上来看提高执行效率不外乎以下几点执行计算等单元的数量从简单理论不考虑竞态上理解越多越好人多好干活嘛线进程的调度简单来说没有调度这种理想状态效率最好人多更要合理分工动态的扩展性即运行过程中动态的增减来达到效率的最高否则一个单元执行足以应付即有九十九个线程闲置也是低效即达到线性的伸缩人员需求动态可调配而算法等的完善和优化提高人员素质这属于计算机提高效率的细节了或者说具体的业务范畴这里暂时不做讨论在中应对上面的这些解决方式有支持多和多核心并进一步支持以此演进的现代的一般可以有多个安装在一台服务器上一个上有多个而一个又会有多个逻辑核心超线程技术甚至从宏观上看分布式的系统都可以看做一个大型的计算机这个扯远了扯回来这样通过多个含核心可以最大限度保持非关联的并行度而多个又进一步衍生出保证内存访问的安全和快捷用来保持内存访问的效率支持线程亲和性和线程独占这个有点类似于减少调度尽量减少线程开销提高命中率多个核心就很容易保持着不相关的线程的并行执行这其实就是干活的人多了假如你做为一个包工头如何保证这些多的人产生出更高的结果那么最简单的一种办法如果某个人擅长打字你就让他专职打字而不是打一会字就去搬砖有些人有力气你非要让他搬一会砖就去打字除了让这两人感到痛苦还会直线降低工作效率这就是的亲和性这在的机器上非常重要同样亲和性只是让任务偏重于少调度而不是不调度所以就又有线程独占也就是绑定到核心上也就是说这个核心不会再调度只和绑定的线程快乐的玩耍当然这些是有条件的如果你的任务需要密集性的计算或者非常复杂和对实时性要求非常高等才会要求这样做这和大页内存的限制条件原理是类似的可扩展性通过配置等手段可以实现对核心数量的支持来实现计算的可扩展性同样利用内存的管理实现内存的可扩展性操作其它也是如此特别是虚拟化的支持其实已经从底层更好的支持了可扩展性之所以这样做和整体任务计划中的局部性减少互斥访问和避免多核调度以及锁的粒度尽量小或者尽快通过临界区是密不可分的但即使如此在实际的应用中不可避免的会出现并行的并行控制问题这其实又重新回到了一个数学概率的问题以及具体到某个场景的数学概率问题在中在代码分析中可以知道其通过库创建线程的方式来线程并且通过上述的方式来绑定到具体的核心来实现的高效率真通信的目标它分为主从两类分布在主从核心上一般控制线程做为主线程而数据线程做为从线程其实也是针对上面的几个方面进行了实现只不过在逻辑上划分出来主从来区分管理和业务能够更好的满足实际的需求的内存机制基本告一段落那么高效的另外一个重点就是并行以目前的计算机资源的使用来看没有一个高效的并行框架基本上是无法达到榨干资源的可能的就如资本一样不浪费每一个资源每一个资源的每一部分是计算机开发者的终极目标整体上要推进资源的技术进步在无法短时间内实现技术进步的前提下组合应用各种技术把对资源的利用达到极致这就是计算机技术的宏观的目的就是这其中一个典型的代表所以这个并行的机制就不得直面对待中并行机制及弹性扩展在前面的简介中对并行机制进行了一个初步的分析在中对并行的支持是一个整体的流程在外面有多核心并行和绑定等的支持在内部有多线程和多队列网卡以及无锁编程的应用而从一些算法上则提供了负载均衡等自动控制从而才能保证在整体上达到最优的并行效果也正是通过上面的一系列手段的综合运用打开了千万并发的突破口亲和性和独占在内核中会通过位的掩码来控制进程的亲合力为此内核提供了相关的接口设置位掩码获取当前位掩码而在的使用库中的线程可以通过下面的手段来实现另外为了实现绑定需要提供了配置文件和相关的数据结构上面的这些数据结构的变量将会在函数中对其进行处理通过这些配置来确定相关的核心和线程的具体的工作情况而中的线程独占采用了内核提供的启动参数通过配置参数来处理管理和调度在前面分析过在中既可以实现静态的配置文件管理也可以在实际运行中进行通过动态的设置管理这更得适应实际环境中封装了这层抽象可以更好的管理相关的并行控制处理注册通过任务的注册来保证管理调度然后在回调的线程中执行相关任务弹性扩展在初始化中可以通过配置文件来实现的配置文件一般在目录下当然也可以通过命令参数来实现参的处理在中利用了内核中的与良好的配合实现了的动态管理有过经验的知道中也是利用了机制来实现的资源管理有兴趣的可以查看一下相关的技术资料在前面介绍了中的上层对并行的支持特别是对多核的支持但是大家都知道再怎么好的设计和架构再优秀的编码最终都要落到硬件和固件对整个上层应用的支持单纯的硬件好处理一个核不够多个核在可能的情况下把的频率增加加大缓存等等在现有水平的范围内这些都是可以比较容易做到的但是另外一个就是在上如何最终运行指令也可以叫做固件设计这个就需要设计人员动脑子了一般来说一个时钟周期内执行的指令数量可不要看成进程间通信的数量越高运行性能越高频率和核数相同现代基本使用了越标量体系结构通过以空间换时间的方式实行了指令级并行运算不同的架构的处理器可能在硬件设计本身有所不同但在追求并行度上原理基本相同在前面的多核编程中介绍过几种指令目前常用的基本以单指令流多数据流和多指令流多数据流为主后者一般是多核和多当然更高层次的多计算机也算但在分析本文中更倾向的是毕竟一个核心能处理多少更能体现性能和效率其实很容易理解可以认为是一种并行的批处理原来只能一次取一条指令处理一条数据这次可以一条指令处理多条数据举个最简单的例子加指令需要有两次读操作数而如果使用则一次就可以都读进来其后的处理周期也是如此那么效率至少增加了一倍而这些指令设计和处理会形成一个指令集它的发展也有一个过程的指令集主要有主流就是的比较复杂有兴趣可以查找看一下在中对的应用体现在数据的处理上提供了一个化化的拷贝函数它充分利用了指令集更多相关的代码在和中注意它包含不同架构平台的多个版本不要搞混从上面的代码可以看到影响拷贝速度的有以下几点字节对齐和数据的加载存储这个大家都明白除了字节对齐速度加快外而且中还对不同的字节对齐以及长度进行了控制充分发挥的优势说直白一点就是在条件允许的情况下一次拷贝数量多字节位这个和平台支持有关函数和库调用开销库函数需要调用过程这个也浪费时间这个库调用过程在编译选择优化的过程中优化难度也比较大不如在中直接调用特别是使用静态内联时这在网上有很多优化的比较自己也可以试一试整体上来说数据量越大上面的优化越优势越大否则优势则不明显上述的比较是针对库以及相比而言的至于个人优化过的则不在此范畴之内另外随着技术的进步如果用高版本的并开启优化后可能效果差别也不大这个没有进行比较有兴趣可以看看等几个函数需要说明的是对于某一类函数没有普遍最优之说只有场景条件限制下的最合适也就是说的拷贝函数不代表此函数比中的拷贝函数优秀只是说明此函数在的应用场景下更合适最后总结一下针对内存拷贝的优化点减少拷贝过程中的附加处理如字节对齐在平台允许情况下使用最大带宽拷贝最大数量使用平坦顺序内存并使用分支预测减少分支跳转如是否有范围重叠等有可能的情况下使用访存执令使用加速拷贝的一些指令操作指令等处理大内存以上和小内存以下的不同场景这个在一些常用框架中都会处理同步同步很好理解简单的可以认为是同一个节奏引申到计算机其实就是多任务保持一致性这个一致性一般是指数据也可能会是操作在单任务单线进程中同步是天然的在多任务无共同操作条件下同步没有意义同步一般是在多线进程多任务且这些线程之间必须有共同操作部分时才会有意义以前说过计算机中的应用和现实的应用是映射什么意思呢如果计算机解决的问题在现实世界上都可以找到原型比如同步举一个例子如果测试学生做操的成绩各自单独测试即可可要测试班级操的成绩这个即使每个学生做的都非常好但各自做各自的那么成绩也不一定好只有同一班的学生保持一致同步这样才成绩更优秀并行和并发中的同步刚刚说过在单线程和多线程的某些情况下同步是没有意义的所以同步一定是在并发和并行中且有交互的情况下才有意义而并发和并行又增加了同步的复杂性但是当把同步抽象出来其实就是具体到某一个粒度是串行的也就是说如何保证这个粒度是最合适的也就引出了后面使用哪种锁是最合适的话题在开发者们学习多线程编程时最先接触的同步方式一般是互斥体它是一种重量级锁既支持进程间的同步又支持线程间的同步方式然后才是其它的如信号量条件变量临界区等等使用互斥锁缺点主要是太耗费时间而且一不小心还有可能产生死锁那么就产生了一种读写锁读写锁其实是一种对锁机制的平衡在正常的情况下如果只是读取的话其实数据自然是同步的而且事实是在某些场合下读是一种非常频繁的操作比如缓存所以这就可以不进行排它的读减少锁的时间耗费当然如果判断一个线程要写数据时需要启动排它性只能它一个操作了在中设计了一个读写锁但是一定要知道在什么情况下使用读写锁比如一个场景就是十个线程抢占式写一个数据区那么读写锁反而没啥意义了读写锁其实是两部分一部分是读锁需要支持多个持有者一个是写锁排它在内核中使用提把一个型分成高低两位一部分用来处理读两个字节最多个读锁持有者一部分用来处理写读部分因为是共同持有所以需要使用进行处理而在中推出了原子操作当然别的语言和别的情况下也各自有各自的原子操作的方式所谓原子操作就是不可再分解的意思也就是说这是串行化的操作它只能一个个轮流来不能说你读一下我写一下乱序执行原子操作其实就基本涉及到了硬件操作了通过汇编的指令接口来影响具体的执行过程一般为说原子操作和内存顺序也是有一定的关系的需要大家注意同时不同的架构的和不同的架构体系也有不同的处理方式都需要根据实际情况来分析原子操作只能操作一个变量当然一个位操作也算一个变量也就是原子位操作还有一种比较常见的也是目前在无锁编程中用得比较多的自旋锁自旋锁就是自个儿旋转的锁表面上看就是这么一个玩意儿它底层其实是通过不断的尝试去读取锁表现出来就是一个循环但其实底层如果支持指令则可以使用其获取了就操作不获取就继续有几个经典的问题问题时间耗费问题和只能操作一个变量这也是前面把一个分成高低两部分的原因但它也有闪光点啊一般来说在多线程编程中当线程达到一定数量后线程上下文的切换就成为了一个需要重视的点互斥锁等会引起线程的切换及线程的睡眠而只是阻塞而不会引起线程的退让这在某些场景下优势还是非常明显的那么就可以明白在只有一颗一个核心的情况下自旋锁没有意义已经退化为普通的互斥体类似的机制只有在多核多的情况下才有意义同时自旋锁持有不放所以只能短时间使用如果长时间需要锁住一个数据就不能使用自旋锁所以早期的自旋锁基本都只是在内核中使用后期才渐渐在应用层开始使用同时为了安全应用层使用自旋锁往往会提供一些安全机制比如回退到某个时间点上会退化为普通锁自旋锁在使用过程中是不允许递归的同样在自旋锁的源码中可以看到其屏蔽了中断请求的函数中断中如果也有自旋锁这事儿就难办了当然还有一些其它的同步操作方式如内存栅栏等它们之间或多或少都有一些相通之处这里不再赘述最后所有的有锁编程当然不如无锁编程更好无锁并不是真正意义上的无锁而把锁进一步下移到非上层控制在上层表现为无传统意义上锁机制可以简单的理解成使用指令级操作通过硬件来进行锁操作速度更快中同样也引入原子操作读写锁和自旋锁三种方式原子操作读写锁自旋锁无锁队列这里多说一句的无锁队列是通过来实现的目前无锁队列也是应用最广泛的一种应用这个队列在前面分析过这里就不再重贴代码了对网络数据的处理中对网络数据的处理主要有以下几个方面涉及到从硬件网卡等到数据通信等从基础数据包到上层分发处理队列从处理到性能优化等等多个方面基础数据包的转发也就是数据报文的转发就是最基础的网络数据的转发它涉及到报文的输入输出调度缓存等方方面面处理在计算机中目前是和通信的重要总线一般来说在计算机限制速度的除了通信本身的速度外计算机总线的带宽也是一个重要的瓶颈在中对其进行了淡民的优化并且使用等技术尽量减少中间环节提高通信效率硬件优化特别是网卡的优化是重中之重在计算软件的设计中有一个原则就是最小功能原则自己只管自己的事这从设计一般来说是最优的但在性能角度未必就是抓住了这一点把网卡等硬件整体来看通过一系列的软件设计和硬件优化达到了一个整体的最优的效果流分类和多队列技术网卡多队列技术是指一个网卡上的队列有多个即网卡有基于多个队列分配的机制而流分类则是指网卡可根据具体的网络数据包的性质将其分成不同的类型的技术前者很好理解多队列意味着数据包转发可以并行进行而后者稍微难以理解其实分析后就明白了流分类和多队列技术是一个衔接匹配的流程只有将原始数据包可以根据一定类别进行分类才可以有针对性的对某些数据进行加速或者优化比如实时控制数据就可以专门分流出来引导入一个专门的队列进行数据处理软件定义网络和硬件加速和卸载软件定义网络是指抽象出控制平面数据平面管理平面三个不同的层通过分层实现网络流量的灵活控制使网络更加智能并提供一个应用创新的良好平台它其实就是网络虚拟化的一种实现形式硬件卸载是指将某些任务或计算从计算机的转移到专用硬件组件例如或等硬件专门芯片的过程以提高系统性能和效率软件定义网络相当抽象大家可以简单理解为一种网络虚拟化和硬件虚拟化有些类似只是抽象的层次更高一些而硬件卸载主要是不要被名字卸载误导硬件卸载指的是对主流的混合处理单元如等进行功能卸载卸载的功能由于处理呢即专门的硬件芯片也就是刚刚提到的网卡或者等前者的意义不必多说后者主要是降低了与网卡等的来回通信浪费的时间一种很好的优化手段网络报文处理学过网络通信的都知道其实在网络的底层数据就是一包帧包的换句话说所有的网络设备转发的其实就是一包包的二进制流数据对设备或者驱动来说这些数据没有什么任何意义它们只是负责进行检验处理转发说白了就像一个个的物流中转站它只管看看包裹是否损坏发往何地然后扔到指定的传送带上即可网络上的数据包也是如此现实世界中当双时包裹量大增物流中心也得搞一些处理的方法或者加人加机器或者改善流程更或者直接升级物流设备采用机器人自动仓储同样对于网络世界也是如此它会从软件到硬件有一个完整的数据处理的流程包括应用框架算法以及后面要提到的硬件的处理等等那么首先这里要先弄明白网络处理模块有哪些首先得有输入输出模块这是网络吞吐的接口即报文输入硬件发出然后需要对报文进行处理报文比较粗粒度处理报文较细粒度分流然后是数据管理和控制模块提供基于描述符的队列根据队列优先级和状态进行调度提供加解密和压缩解压缩等硬件功能在出口上根据等级进行调度完成后清扫现场后期报文处理释放缓存其实把这些模块按功能逻辑一划分立刻就明白了这比画张图还好理解转发应用框架说到应该框架就要谈到转发模型一提到模型大家就基本可以明白了如果没有明显的技术突破模型基本是不会动的所以这里用到的模型有两种模型很好理解计算机的中使用就是这种流水模型流水模型非常适合于一些有节奏的有规律的工作比如对密集型应用和密集型应用可以分别用不同的引擎来处理在中其可以按功能分成多核应用框架和单个流水线模块在这些模块中通过使用三部分即逻辑端口查找表和处理逻辑单元来实现对的报文处理端口做为每流水单元的模块输入而通过查找表来确定处理方法而处理逻辑则决定了报文的处理和最终流向这样一层层的堆叠就形成了一个支持的有以下几种这些都可以简单的通过配置文件来使用其进行应用但是这种模型由于流水的限制不容易进行扩展对多核支持的也不如好模型看到这个模型写过网络编程的小伙伴是不是想到了完成端口这两还真得非常类似说白了都是为了充分挖掘多核的优势它对于处理一些上下文逻辑关系并行的数据流则非常有优势它可以充分使用各个核心动态的分配处理各个逻辑层并且很容易进行扩展在中可以通过参数指令将核心绑定到线程上这样不同的数据收发队列就可以与逻辑核心从而保证一个报文只能在一个线程中进行处理同时通用的处理器单元使得编程也变得更简单通过上面分析其实可以总结出来对于并行度要求高但优化处理不高的报文可以使用模型反之可以使用模型前者更适合于高并发的短连接后者更适合于长连接连续数据处理方便进行优化动作相关算法相关的算法就比较简单了主要有以下几种精确匹配算法从名字就可以看出来直接就可以匹配上精确配对在网络中常用的就是哈希不管你是哪种哈希反正是哈希应用哈希就需要解决哈希冲突的问题常用的还是两种链表和开放地址这些都是老生常谈不再赘述同样在中对哈希的校验也进行了优化对字节对齐进行了处理然后使用不同的硬件指令一次处理相关校验或者在无法使用硬件时使用查表的方法进行这是典型的空间换时间最长匹配算法最长前缀匹配算法是指在协议中被路由器用于在路由表中进行选择的一个算法这个算法也很常见在密码学和网络中经常可以用到一般比较常用的是算法算法算法其实就是通过访问一个控制库利用分类规则来对输入的数据包进行处理分类库利用元组的匹配规则进行类型匹配提供如下操作创建的上下文加规则到的上下文中对于所有规则创建相关的结构体进行入方向报文分类销毁相关的资源报文分发中提供了一套报文转发的库和它的原理基本上就是通过分发给不同的工作者而则从中拿到相关数据这样就形成了一个完整的分发流程下面看一下中相关的源码其实其核心的两组一个在和中上面是前者下面看看后者总线和及缓存如果一条通信链路要想达到最优的效果一定是整体上每个环节都要有最佳的节奏协调控制而不一定是每个环节都是最优这个在计算机的数据处理上就更是明显一般来说的速度是最低的至少在可见的时光里要想超越和内存还是很难的以网卡通信为例网卡本身就传输然后通过总线传输进入内存内存进缓存缓存到然后再原路一个反馈学过计算机的一般都知道这里面涉及到的几个部分数据的处理速度那是有着量层级上的差异的所以在处理问题上有三条思路一是把短板补齐也就是那个慢把哪个速度提起来这其中就包含着近些年来不断提高的处理速度和总线处理速度的速度提高反而不太明显主要是横向扩展二是把不必要的中间环节去除也就是本来是是不是有可能把去除直接让通信三是通过软件优化最大化的利用硬件资源并行等一般来说这就是目前优化的三个主要的思路在中基本也是延着这两条思路前进的不过前者可能不是所能控制的其更重要的是朝着后二种前进是一种高速串联通信标准目前的最新版本是但主流的标准应该和居多主要用来连接显卡固态硬盘以及采集卡和无线网卡等外设用来为高速外设进行数据传输直接内存访问主要是绕过直接与进行数据通信缓存就更好理解了一般使用静态存储器用来做为主存与速度不匹配的一种缓冲存储缓存的速度已经很接近的处理速度其重要指标就是命中率数据传输这里不展开具体的及相关的等的数据传输细节一般来说支持的的版本越高其数据传输的速度越快即使扣除相关的协议开销和控制指令等的开销后其对数据传输的瓶颈解决越明显但光其一个最优不行中间的其它传输也要共同优化节奏相同是通过环形队列与交互利用技术减少对主存的访问次数环形队列一般学过算法的都清楚怎么回事而为了提高数据访问的速度环形队列缓冲区的大小必须是网卡支持最大的整数倍这样做的目的当然是为了方便内存对齐即提高访问效率效率高了自然速度就上来了正常的网卡驱动通信一般是以下几步将缓冲地址写到地址描述符移动队列尾指针到指定位置判断描述符中的状态位是否完成如果是接收还要申请新的缓冲区发送则需要释放已发送缓冲区这些其实都是一些头尾的动作一些处理操作如描述符的内容更新和控制头的解析等数据转发刚刚提到了某个局部最优并不一定是整体的最优解所以要处理好数据传输一个重要的问题是要处理好数据在各个环节的转发的问题在网卡通信中最重的是将中的缓存与的通信整体协调好那么首先要理顺一下在这个通信过程中需要哪几个环节协调首先面对的主存和外部寄存器而对来说就是主存和而它们之间的数据需要来传输所以优化的手段就明晰了减少对外部寄存器的读取提高的效率即在固定的带宽下如何最大程度的利用满减少的部分写这都比较好理解先从最后一个说起的内存未对齐也就是部分写会导致对缓存的二次操作效率至少降低一半而余下二者其实类似于批处理把单次的操作改成多次合成减少相关的控制和协议处理自然可以提高数据的传输速度在中使用来处理网络数据帧而在网络帧的处理上有两种情况一种是将元数据和数据同时存放另外一个是将二者分开存放这样说有点不直白其实就是空间利用率和时间利用率效率的二者的权衡前者又更好的利用内存空间而后者则能够在浪费一部分内存的情况下更好的提高数据转发效率当然选择了后者而为了更好的利用内存将形成一个内存池双环形缓冲区为应对多核的情况允许每个缓存一部分缓冲区然后在写时进行操作处理当然这样做的缺点和上面一样也会浪费一部分缓存上面把相关的内容理顺了一下这样再和源码匹配就好理解了前面的队列和等进行过分析这里只讲一些整体上的源码流程这段代码会在最初始的函数这个函数中调用这个函数不陌生吧在最初的文章里就介绍过它主要用来在初始时对固定内存的地址映射而若是对小的临时的地址映射可以使用下面的函数这里不细节展开在使用虚地址和实地址以及自定义地址时对其的各自处理的细节有兴趣可以自己查看源码中对数据的传输其实就是对缓冲池和的处理在更高的版本中在库单独对进行了封装处理数据的过程将在后面的整体流程源码分析中进行说明再看一下相关首先是扫描对于一些基础的相关的应用知识需要懂一些否则代码看不看也没啥意义扫描并增加相关设备后就可以将其位于的每个设备对应的文件中保存的设备寄存器的地址映射信息在这个设备启动加载时将映射的物理内存地址信息保存在寄存器中同时写入到此文件而就是通过这个文件来使用对其的物理地址进行映射然后就可以在应用层对此设备进行访问了等的代码在前面分析过这里就不再重复如果需要可以翻翻前面的文章优化网卡优化一般来说对某个设备的优化除了涉及到硬件设备本身也要兼顾着上下游的软硬件协调优化才可能达到最优同样对于来讲除了要考虑软件层面还要考虑硬件平台及相关设置置的控制将其看成一个整体入手才能真正的把优化做到最好软件层面在实际的应用场景中可能存在着收发包较少的情况也可能存在着连续的大数据量吞吐的情况而更多的情况可能是上面的两种情况交互最典型的可能是某个时间段上网的人很多可有一段时间又没什么人上网比如上下班时间和交通拥堵一样也会有这种高峰低谷的情况这就需要根据情况来进行动态的控制软件层面做这种设计还是比较方便的实际上提供了三种模式来分别适应上述不同的场景异步中断模式其实中断都是异步的好像没听说过同步中断的情况此模式比较适合于收发较少的情况能更好的利用硬件资源轮询模式其实就是反复的去操作接口特别适合于大数据量的吞吐的情况混合模式这个其实就是一种对上述二者场景进行兼容的一种情况可能在实际情况中更合适优化这个其实就涉及到数据处理过程数据本身的粒度大小处理数据的批量数量缓存的对齐以及特定硬件的一个的指令优化控制等等中采用的方式来收发包减少对内存或的访问次数同时利用批处理来提高对时延和吞吐的优化平台及配置优化这个就比较多了一般来说它和技术本身没有什么太大关系更和硬件及相关的具体的提供的功能有关同时可能还要涉及到一些的支持诸如大页内存电源设置硬件本身固件的一些支持以及总线的控制等等相关设置适配相关设置的适配涉及到收发包队列的长度以及队列中的可释放描述符的数量阈值这都需要根据文档的说明按照实际场景的需求来进行安排从而能更好的发挥整个软件层面的适配性更好的协调软件和网卡的数据收发达到最优源码分析了解了相关的优化措施后看一下中相关的源码在中的轮询模式中有及和半虚拟化的轮询模式驱动程序它支持和管道两种情况这里不展开在中的的接收函数中有行代码要注意一个是通过真正处理数据另外一个就是循环查找有无数据的回调函数这两个函数在层可以通过不断的循环来调用就可以达到轮询的目的在前者的中源码中注释说明其指向接收函数这下就明白了吧可以在中看到相关的代码上面的代码是轮询机制中的主要的代码代码整体比较容易理解操作将报文写到相关的内存即中这行代码是不是有点熟悉类似于计数器它控制着不断拿到新的并写入到中轮询的方式也比较好理解通过略过内核然后拦截了硬中断直接操作实现了定时器和三种中断中断操作可以理解成线程正在忙着突然来了一个信号让线程别干了去忙别的那么为了安全调度需要处理上下文的堆栈数据等等然后才能进行相关的操作这个过程需要耗费非常多的时钟周期如果中断比较多的话可以想象数据的吞吐量会下降多少这部分代码待后面的文章再展开分析多队列技术中的是天然支持多队列技术的通过一系列的配置可以绑定与核心队列等而网卡报文的队列分配一般是使用和技术其实就是哈希均匀分配到队列而后者则是使用查找的精确匹配方式将包发送到指定队列另外还需要注意的是优先给毕竟有的包命令是处理一些控制状态的需要优先处理这都需要在包分配时有一些应对机制流分类为了实现多队列和提到的优先级就需要对包的种类进行分类比如常见的以及自定义或者云等虚拟包等有两种处理的方式即上面提到的和接收方向扩展负载均衡这个光看名字都知道什么意思特别是这些年来开发技术的普及基本上搞后台搞网络的都懂这个技术简单来说就是不分彼此不厚此薄彼每个队列享受相同的待遇这里面的重点是哈希计算的对应值怎么取可以是网络四元组也可以是其它这个根据实际情况来定精确字段匹配可以将报文数据转到相应的队列中在网卡上会有一个表表中会有相关的关键字和动作此表由驱动来进行管理每当数据从网卡进入就可以通过查询此表来进行相关的动作服务质量其实就是对于些特定的业务需求进行调度划分类型并确定优先级虚拟场景下的分类现在的实际业务中云虚拟化的业务占有非常大的比重所以会有一组队列与等相对应进行数据处理流过滤主要是通过分类进行合法性验证过滤的方法有地址过滤标签过滤和管理数据包过滤当然在不同的网卡上也提供了多种规则供调用它们包括元组指定队列以太网报文的指定队列云应用中的等隧道报文指定队列等如果实现流分类那么必须明白流是哪种类型可这种类型从哪里得到呢就需要解析数据报文的头而在网卡中可以使用接收描述符来快速确定包的类型在中的中定义有相关的对应字段来映射类型有这个类型的处理就可以动态的快速把报文转到相关队列不过需要注意的是虽然主流的网卡都支持多队列但并不是所有的都支持此功能同样即使支持支持的程度也有不同中遇到的场景非常复杂可能有的需要数据发有的需要命令处理有的需要逻辑转发等等不一而足那么对数据队列就可以动态的根据实际情况来进行定制可以通过实现负载均衡然后再通过实现报文的定向分配通过绑定的专门的核心进行特定的数据队列处理另外中还可以通过虚拟化网卡来进行工作实现动态的资源利用先看一下相关的配置数据结构体定义在这个结构定义中可以看到和以及而和就涉及和的配置分为三种即单一队列的带有硬件队列的和还有消息中断的其实还是硬件不匹配造成的在提供的例程中可以看到相关的配置代码配置相关的或配置收发队列启动设备启动设备的函数在在使用使用函数中注意在以上版本已经由代替了接口细节请参看相关文档通过上面的分析就可以明白队列的控制相关流程另外一些配置相关的就需要大家自己多看相关文档了硬件加速硬件加速听名字就是明白是利用硬件加速不太准确硬件加速其实更有效进行硬件的分工通过分工实现硬件的整体的效率的提升其实硬件卸载就是硬件加速而实现硬件加速就需要进行功能卸载整体上就可以叫做硬件卸载硬件卸载是指将某些任务或计算从计算机的主处理器或一些软件功能转移到专用硬件组件例如网络接口卡或图形处理单元的过程以提高系统性能和效率而提到硬件卸载就不得提到软件定义网络软件定义网络的主流的解决方案是从传统的包含专用硬件与控制平面相结合并提供选定的功能的交换机等单个设备转移到软件定义网络抽象出的控制平面数据平面管理平面三个不同的层第一层是管理层或管理平面它包括像这类应用所在的位置可以将一些配置应用于网络并将其用于虚拟化等领域下一层是控制平面最下面是数据平面它由硬件例如白盒交换机和软件软件数据平面组成数据平面就是硬件卸载所在的地方而软件定义网络一般是指通过某种技术将网络设备的控制面与数据面分离开形成灵活智能的网络软件数据平面是一个常用的术语用来描述处理网络数据包中用户数据的应用程序数据平面开发套件这下明白了吧主要是应对网络应用开发所以其主要和网卡打交道为了支持网卡的硬件卸载需要提供相关的软件接口具体到实际情况网卡的硬件卸载可能是基于端口设置也可能是基于每个包设置使能的可能是对应着一个包也可能多个对应着一个包这在中都有对应的标识来标定在中有这些具体的定义如等等在相同文件夹下还有其它一些具体的宏定义大家也可以参考相关的硬件卸载功能主要是与实际的网卡的实现情况有关其主要有以下几种情况硬件与更新功能卸载它根据实际情况又可以分为硬件卸载通过报文中标识来进行标识控制通过硬件卸载可以直接使用硬件操作而非软件利用来进行操作减轻了的负荷硬件卸载功能精准时间同步协议这个用硬件实现更便捷准确硬件卸载功能这个就不用说了硬件更快捷高效硬件卸载功能这个更好理解其实就是纯粹的协议的控制隧道就是一个安全通道一个专门的通道可以将不同的协议连接起来类似于集装箱直接把原始包扔进去做负载这种简单的封装其实更适合用硬件来完成分片功能卸载分片说得有点高级其实也很好理解一个大城市不好管理划成一个个小片不就好管理了这就是分片在网络通信中上层应用可能不会顾及底层的硬件和驱动的缓冲大小向下输出大量数据可实际的的传输是有大小控制的这就需要将上层的数据分片成合适的大小而这个分片的过程软件其实是不如硬件更容易实现因为这种机械的固定的功能最是硬件的擅长的了组包功能卸载组包其实就上面分片的逆操作毕竟数据最终还是回流到上层应用必须保持数据的一致性呈现这就需要把在数据传输过程中的一系列辅助的动作恢复原样这就和在网上购物一样可能是一个很小的物件但在实际传输中可能不断的被打包验证然后装箱运输等到达目的地时再逆向操作最终原样送到购买者手中三源码分析在提供了对的功能支持上面的代码很清晰就是使能和读取双向的时间戳而在中有计算的方法看一下组包的支持会对进行判断来决定是否组包这个其实是的另外一种描述方式数据包流程在前面详细分析过数据包的转运流程其实做一种接口一定是分成两部分即数据的接收和发送从宏观上看无论数据的接收和发送都需要网卡到队列然后到应用层的这么一个过程的特点是尽量不打扰内核并通过的方式将数据利用队列将应用层与网卡进行交互而在这个交互的过程中又有几种方式如轮询中断和混合三种方式明白了这些再加上前面的相关文章的分析那么整体的流程和细节的程序大致已经把握了那么最重要的就是看的源码是如何实现这些的三源码分析闲言少叙直接进入正题先看入口函数从代码上看首先是主函数中需要调用对所有的相关参数和设置进行初始化这个函数已经分析过多次了但是其中其实还有很多的细节没有分析到位这个只有真正的用到哪块才会认真的去看每一行代码这个代码其实就是大量的参数配置大页内存等待的初始化反正代码里大量的估计即使不明白初始化啥也知道是初始化的功能其下就是检查偶数个端的函数然后开始创建内存池然后调用端口初始化函数然后通过来判断逻辑核心的数量如果多于个在本程序其实没啥意义最后调用函数真正的处理数据收发如果退出则需要调用来清理现场并返回这个程序相对简单又对数据流进行了网口的转发这样对数据包正好有收有接容易分析理解在这个简单的服务代码中开始展开对中数据流程的整体流转的源码分析调用的数据结构和相关函数源码在上半部分函数在其后调用代码及数据结构体在上方使用默认配置一个默认的数据结构收发环形队列数量端口是否可用由端口获得设备信息对收发描述符数量进行合格检查如果为架构则使用这个函数得到对应的以太网设备否则为表示使用默认设备否则指向的队列启动设备设置网卡为混杂模式即接收所有网卡接收到的数据这里很重要的一个函数是最后是启动设备在一切准备就绪后就可以进行收发数据了最主要的当然是两个函数先看接收再看一下发送函数这两块具体的数据收发流程会在后面详细分析通过上面的代码分析可以发现整个中对数据的收发需要进行下面基本的流程环境初始化即函数对一系列的参数和环境进行处理比如内存的管理等网络设备的配置特别是相关收发队列的内存配置即调用具体的收发队列的分配和管理即和函数的调用在一系列的准备和配备及相关安全检测通过后启动网卡设备将相关数据结构和内存等与网卡关联即函数在循环中处理收发数据即和函数当然这个程序里处理报文相当简单处理程序结束后的环境资源回收即函数接收数据中对数据的处理简化一下就如现在分析的这个程序其实就是一个收发的过程只要把基础的收发搞明白再加上其它逻辑其实就是一个丰富的应用在这里首先看一下此程序中如何接收数据接收数据包括下面的发送数据其实都包含了非常多的知识点除了前面已经分析过的相关知识外还有的具体知识这个需要注意的是现在设备自身也增加了控制系统即现在系统分两类一类是内部一类是系统系统其它具体的相关技术需要自己去学习相关的知识包括软件方面的当然也有关联到的硬件方面的网卡与内存通信的协议这个就包括相关一些说明文件和格式特别是后者包括一些描述符的性质等应该是实际用到的需要认真的弄明白从宏观上讲数据包会先通过物理途径到达网卡然后网卡将数据包写入到系统收包队列进入内存上层应用内存映射拿到数据具体的流程如下与通信配置相关队列的信息含头地址和大小等物理地址会通过队列中描述符得到上层应用的虚拟地址并将把收到数据包保存到地址内存虚拟地址即会从接收方的描述符中得到数据缓冲地址指向上层应用的中的指定内存网卡读取接收接收端的描述符同时获取上层应用的缓冲地址网卡接收网络数据到网卡本地缓冲区网卡的控制器将数据写到指定的上层应用内存缓冲区网卡更新描述符队列物理地址中相关标志为即数据接收完成读取标志为则表示可以读取网卡数据读取相关系统队列虚拟地址中数据并申请新的替换该描述符同转换相关地址并更新物理地址和描述符中的标志为表示可以继续接收数据处理寄存器的接收队列此处是更新寄存器而不是将新的填充到寄存器此处的重点其实就是在于两个队列即上层应用的系统内存队列虚拟地址与描述符接收队列物理地址一个动态的转换操作有点类似于映射而不是强硬的进行增加和删除操作二发送数据发送数据也是如此上层应用写入到内存然后到访问的内存拷贝到网卡然后网卡将数据发送即可其具体的流程如下的内存地址写入数据读取发送端的队列物理中的标志是否为表示发送完成将发送完成的描述符对应的缓冲区释放虚拟将发送缓冲区虚拟填充到描述符的系统队列虚拟将中的物理地址转换到到后填充到发送端队列物理并置标志为控制器读取寄存器得到发送端描述符并获取发送队列地址物理根据标志为则读取数据虚拟到网卡缓存并发送控制器置标志位为并触发数据发送成功消息其实从上面的分析可以看到很多细节其实需要对硬件和及相关网卡中的控制器等需要有一个相对了解的过程这也是前面提示大家需要对一些基础准备知识要有一个心理准备一样三源码分析对数据的收发进行分析后结合源码来看一下接收数据在中有很多类似下面网卡的相关定义注意下面的函数注册和上面的数据结构体的函数指针注册结合起来注册函数调用下面的函数注意每个设备的注册可能都有不同在上面的注册函数中还有很多的函数需要注意的是不同的设备可能注册的函数都有所不同不要盲目的僵化套路这些功能在数据结构体中注册的函数中调用了然后启动队列然后就可以真正接收数据了在接收数据前得看看如何将函数指针挂接到相关的设备函数中就是那个总提到的标志位大家对应着相关的上面的说明并结合注释就基本弄明白了整个细节发送数据发送的前的准备和接收前的准备有些类似在上面的注册函数中都有这里就不再拷贝进来可以直接下载源码观看重点看一下发送的代码系统和描述符映射代码上文分析过这两个队列挺重要并做了一个转换的动作在可以看到和的创建但其真正的关联是在上面的函数中完成的当然不同的设备可能还是有所不同请大家注意通过上面的源码分析和流程说明其实发现的应用可以分成两个层次一个层次是偏向于上层应用的可以用软件的编译思维去解决另外一个是硬件层次的毕竟是一种数据平台框架它一定最终落实到某个型号的网卡上那么这其实就是类似于驱动层次了需要对硬件的各种情况非常了解这就需要对进行详细的掌握当然可能对于常见的几种网卡和常见的应用形式其实第二个层次基本已经成熟仍然是聚集到第一个层次网络编程的源码分析的很多了也应该让他发挥一些作用了前面的分析可以知道的优势在于网络通信那么它可不可以替代传统的网络通信的底层协议栈呢答案是肯定的一个框架最重要的意义就在能为上层所应用并且达到一个新的性能上的高度正是如此网络编程中常用的是编程和编程本篇就用模拟实现网络通信的一个简单框架流程的分析说明为下一步的等网络编程进行一个基础的准备利用实现网络编程主要需要实现通过的相关接口来模拟实现与网卡的网络通信编程包括相关的设备初始化通过与网卡进行数据交互应用层的模拟通信接口和上层应用的数据收发处理下面看一下主体框架的代码上面只是一个基本的使用的网络通信框架具体的实现都没有完成但基本上整体的流程都清晰了细一看和前面分析的的代码基本没有什么大差别但真正的差别就在实现的细节里这些放到下一篇再分析首先需要说明一点开发者需要对基本编程和相关协议至少有基础的了解否则可能会有理解上的偏差这里不对这些协议等进行介绍主要是资料太多了从教科书到网上到各种培训机构视频多得很有不太清楚的可以回头稍微补充一下下面代码来自开源网站编程的要点在上一篇分析过下面看一个开源的例程数据结构和协议实现种连接状态接口实现唤醒中的等待校验和搜索涵盖了半连接队列和全连接队列搜索的根据状态调用对应处理函数这里的源指的是对端先广播发个包确定对端地址将取出的数据再次放入队列应用例程后续将全局变量统一初始化不再使用后续将全局变量统一初始化不再使用后续将全局变量统一初始化不再使用后续将全局变量统一初始化不再使用后续将全局变量统一初始化不再使用端口配置信息配置以太网设备维护一个表这个代码的优点在于实现的比较简单简单才是王道特别是对于学习没有太多复杂的相关协议的处理只实现主干而且代码实现的手段也相对容易看明白这样更有助于学习源码的中有相关测试启动的方法此处不再赘述另外此开源的代码基本实现了相关的功能如果有什么需要可以继续在这个基础上进行完善或者重构非常感谢作者不过需要注意的是代码的管理有点零乱需要自己处理一下编程编程的应用和编程的应用同样非常广泛如果说真得想使用编程一般情况下还真得不至于运用这种重量级的框架但一个框架的优秀与否不仅仅在于自身的整体设计优秀更重要的在于其对应用的支持更完善正如对的支持一样其实对于这种更侧重于底层的应用来说实现和没有本质的区别只是套的一层解析的协议不同罢了同样与的不同及其协议的内容如有不明白可自行查看相关资料此处不再赘述下面看一下例程代码来源与相同数据结构和协议表的单个条目表结构的数据包数据处理分为两类一类是控制包一类是负载包也就是数据包表的作用类似于快递小哥的作用查找与的映射并实现数据包的准确传输即其有两个出口一个是数据发送时的出口保存发送时的和没有则先广播一个是接收时的出口用来保存收到的数据包对应的和代码没有什么难度大家对照着相关的协议实现就明白了发送接口实现查询对端地址先广播发个包确定对端地址将取出的数据再次写入队列机制和类似上层应用端口配置信息配置以太网设备维护一个表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-13 14:23:41',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 1.05rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 1.05rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 1.05rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 1.05rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 1.05rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-31T11:36:18.019Z" title="发表于 2024-07-31 19:36:18">2024-07-31</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-08-13T06:23:41.241Z" title="更新于 2024-08-13 14:23:41">2024-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2024/07/31/sdn/dpdk/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2024-07-31T11:36:18.019Z" title="发表于 2024-07-31 19:36:18">2024-07-31</time><time itemprop="dateCreated datePublished" datetime="2024-08-13T06:23:41.241Z" title="更新于 2024-08-13 14:23:41">2024-08-13</time></header><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>前面把环境基本搭好，今天开始编译 DPDK。首先是下载 DPDK 的源码，地址是：<br><a target="_blank" rel="noopener" href="https://core.dpdk.org/download/">https://core.dpdk.org/download/</a><br>也可以从官网 <a target="_blank" rel="noopener" href="https://www.dpdk.org/">https://www.dpdk.org</a> &#x2F; 跳过来。然后就可以看到排下载的 DPDK 的版本：</p>
<p>官方的安装说明及相关文档地址：<br><a target="_blank" rel="noopener" href="http://core.dpdk.org/doc/archives/">http://core.dpdk.org/doc/archives/</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>提起 DPDK，需要先回顾一下网络的发展。最初的网络的出现是从美国军方的局域网发展起来的，从一开始，网络的应用并没有现在这么复杂，数据传输量也没有现在这么巨大。更不要提现在什么高清、3D 等等这些初时的大数据流传送。同样，也不会有什么双 11，618 之类海量的并发。  
为什么说这些呢？随着网络的不断发展，全球网络的应用可以说用井喷来形容，对应用的人来说，只是把生活变得更丰富更美好，应用更简单更容易。可对于底层的计算机技术来说，这需要不断的演进技术，才能够保证上层的这些应用。搞技术的都清楚，早期的一些网站，包括很多大型的网站，其实就是用的最基础的 Socket 通信中的 Select 轮询，再辅以多进程即可以实现上面的应用。但这些问题随着应用规模越来越大，已经完全无法满足需求了。  
解决这种问题的方式有两种，一种是在应用层使用更好的框架和通信模型（如 epoll 等）；另外一种就是修改网络的底层协议（TCP/IP）。  
这两种方式，应用层好完善，大不了迭代一个新版本，但修改协议这个就麻烦大了，涉及到 N 多的东西，更为关键的是，要硬件的跟进。这几乎是不可能的，而且这需要一个很漫长的时间才能实现。另外更关键的是，随着云技术的兴起，导致了网络数据传输的路径更加延长，也就是说，网络的吞吐量理论上讲进一步减少。同时，异构和多 CPU 多核的出现，又需要能尽量公平的使用 CPU，保证数据的调度，这也是原来的整个技术栈没有考虑到的。  
而 DPDK 就相对较好的解决了这些问题，它掠过了内核中的网络协议栈，而将其迁移到了用户态，消除和减少了中断以及内存数据的拷贝次数，通过网卡和用户进行直接的数据交互。它的优势是明显的，特别是在云的环境下，虚拟技术可以更好的和真实的网卡进行数据通信。
</code></pre>
<h2 id="框架主要结构"><a href="#框架主要结构" class="headerlink" title="框架主要结构"></a>框架主要结构</h2><p>先看一下 DPDK 的框架结构图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/5ad453f60ff146e7c25d1eb6f0a47599.png">  </p>
<p>结合着这张图再回头和前面编译过程的代码就会更加清晰的理解整个 DPDK 的框架结构。</p>
<h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><p>在 DPDK 源码中主要的目录如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ABI_VERSION</span><br><span class="line">app # 是 DPDK 应用程序的源码，包括测试应用代码  </span><br><span class="line">buildtools # 编译配置脚本</span><br><span class="line">config # 平台编译配置</span><br><span class="line">devtools # 设置管理脚本</span><br><span class="line">doc</span><br><span class="line">drivers # DPDK 轮询驱动代码</span><br><span class="line">dts</span><br><span class="line">examples</span><br><span class="line">kernel # 内核相关代码</span><br><span class="line">lib # 库源码 </span><br><span class="line">license</span><br><span class="line">MAINTAINERS</span><br><span class="line">Makefile</span><br><span class="line">meson.build</span><br><span class="line">meson_options.txt</span><br><span class="line">README</span><br><span class="line">usertools # 提供给用户的一些工具</span><br><span class="line">VERSION</span><br></pre></td></tr></table></figure>

<h2 id="hello-world例程"><a href="#hello-world例程" class="headerlink" title="hello world例程"></a>hello world例程</h2><p>看一下自带的一个 HelloWrold 例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_launch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_per_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lcore_hello</span><span class="params">(__attribute__((unused)) <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> lcore_id;</span><br><span class="line">        lcore_id = rte_lcore_id();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello from core %u\n&quot;</span>, lcore_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">        ret = rte_eal_init(argc, argv);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                rte_panic(<span class="string">&quot;Cannot init EAL\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* call lcore_hello() on every slave lcore */</span></span><br><span class="line">        RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">                rte_eal_remote_launch(lcore_hello, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* call it on master lcore too */</span></span><br><span class="line">        lcore_hello(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* clean up the EAL */</span></span><br><span class="line">        rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>这是一个最简单的程序了，一般所有的新的语言或者框架出来都会有一个 “Hello World”，这个就是 DPDK 的。程序中首先使用 rte_eal_init 来对主线程和子线程进行创建初始化，通过管道实现它们之间的通信。然后使用 RTE_LCORE_FOREACH_SLAVE 宏来实现对 CPU 核的遍历（Master 除外），而 rte_eal_remote_launch 就是实现的具体的函数。rte_eal_mp_wait_lcore 可以理解为一种主从线程之间的同步的机制，主线程会等待所有的子线程进入等待状态后，才可以进行消息的通信。  

其实网络技术发展不是一蹴而就的，从最初的 DMA，到 COW，总之，消除和减少各种冗余动作的技术不断出现，直到 DPDK 的出现其实是一个延续发展的过程。随着 DPDK 的广泛应用，硬件厂商特别是云厂商对其的支持不断增加和完善。而原来提到过的上层应用 SPDK 也是对 DPDK 的一种扩展。专门就 DPDK 而言，其实可以理解为应用倒逼的技术的进步。所以说，人多，这也是一个优势。没有应用场景，技术进步就不会那么迫切，或许，这也是理论联系实际的一个典型例子。
</code></pre>
<h2 id="网络发展和-DPDK"><a href="#网络发展和-DPDK" class="headerlink" title="网络发展和 DPDK"></a>网络发展和 DPDK</h2><pre><code>网络应用对 DPDK 出现的影响。而具体体现在技术上，从最简单来看就是从 C10K 到 c100K 甚至更多。而相应的计算的发展也从挖掘单 CPU 的性能发展到了瓶颈，同样，对于网络设备也遇到了类似的问题。而目前解决问题的方法硬件上就是多核多 CPU（分布式中多台电脑也可以理解成宏观上的多 CPU），而在软件上就是云的虚拟化。  
而在原来的网络 IO 处理路径中，本身就已经较长，再经过虚拟化(含 NFV) 后，导致整体上的一些辅助工作大消耗了时间，而且过长的路径也会导致更多的意外发生，另外即使在正常的情况下，过长路径也会造成缓存命中失效的可能性大大增加。而学过计算机的人都知道二八原理，缓存命中失效会使得耗费的时间更长。  
DPDK 针对上面的这些问题，主要解决了 IO 控制（硬中断和 CPU 消耗等）、不再通过内核路径（拷贝、上下文切换、锁、过滤、Cache 等）。这样，一方面大大提高了 IO 的处理速度，又解决了路径长所引起的内核瓶颈及相关的意外因素。所以从某种程度上可以理解 DPDK 是在网卡到用户态绕过了内核直接桥接过去，达成了一个旁路。这其实和实际生活中，如果电路必须过某个复杂的电缆柜，但又不知道内部的情况，直接飞线过去有相通之处（当然，飞线是不好的）。不过在 Linux 社区上，提供了旁路机制，不过这玩意儿没弄好，所以现在其实就是半死活。至于 DPDK 和它们的关系和影响，就不得而知了。  
</code></pre>
<ul>
<li>传统的网络编程数据流是从：网卡 -&gt; 驱动 -&gt; 协议栈 -&gt;Socket-&gt; 应用。  </li>
<li>DPDK 则是：网卡 -&gt;DPDK-&gt;DPDK 基础库 -&gt; 应用</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/e90207d90d9e7febe8d8bb2627dd17ff.png"></p>
<p>有过工程管理管理经验的都知道，路径越长，不可控的风险越大。简单就是王道，这才是王道。</p>
<h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><p>DPDK 的处理网络通信的技术特点主要有：<br>1、轮询<br>    传统的内核处理一般有两种情况，中断和轮询两种方式。中断的耗时对海量数据传输来说太长了。而使用轮询则可以大幅降低中断引起的上下文开销。<br>2、用户态驱动<br>    前面提到过，路径越长，需要数据传递的路径越长，就不可避免的产生内存复制和系统调用。而直接到用户态，就避免是大量不必要的数据复制。<br>3、CPU 的亲和性设计<br>    现代计算机几乎很难遇到单核单 CPU 的机器了，所以如果设置 CPU 的亲和性，保证 Cache 的命中率就是一个很好的设计。<br>4、降低访存开销<br>    TLB（Translation Lookaside Buffer），转译后备缓冲区。DPDK 利用大页内存减少 TLB 的丢失命中并利用内存多通道交错访问提高内存带宽利用率<br>5、软件优化<br>    这个就比较好理解了，缓冲的行对齐（多线程中的伪共享），数据预读以及批量处理等。</p>
<p>在 DPDK 中，最显著的部分就是上层的用户态库，它主要分成以下几个部分：</p>
<p>1、核心库（core Libraries）<br>    环境抽象层（EAL）在 Linux 基础上进行初始化，其中有巨页分配、缓冲区和队列分配、无锁操作、CPU 亲和性绑定等。它就是绕过内核的关键，直接通过 UIO 或 VFIO 技术将 PCI 设备地址映射到用户空间。同时，为了更好的处理数据，它还创建了适应环境的内存池、缓冲区管理、内存复制、定时器和环境缓冲等。</p>
<p>2、平台库（ platform）<br>    这些个主要是包括 KNI、能耗管理 和 IVSHMEM 接口。KNI 主要是用进行内核态和用户态间的协议栈处理。能耗管理主要处理休眠状态和 CPU 频率等；IVSHMEM 则提供了虚拟机内存共享管理机制，包括映射世面为 IVSHMEME 设备池并传递给 QEMU。  </p>
<p>3、轮询驱动库<br>    虽然 DPDK 支持混杂中断驱动，但一般还是用轮询为主。它支持物理和虚拟网卡，随着各大硬件厂商的跟进，目前基本整个行业生态都支持了。 </p>
<p>4、QoS 库<br>    这个用来做一些辅助服务的，比如一些 ACL（通配符匹配），精确匹配什么的，还有一些报文转发如限速（METER）和调度（SCHED）等等。</p>
<p>DPDK 高性能实现的代码基础：<br>1、通过 HugePage 降低 TLB miss<br>    这个其实比较好理解，小的缓冲容易溢出，就容易 Miss，大的就次数少很多。而在 Linux 中把默认的 4K 提到 2M 及以上，数量级会下降很多，命中率会提高很多。<br>2、SNA（Shared-nothing Architecture）<br>    其实就是在并行计算中的分治法，减少全局共享。同时，对 NUMA 体系下不跨 Node 远程使用内存。<br>3、SIMD（Single Instruction Multiple Data）<br>    这个学过计算机体系结构的应该很清楚。DPDK 中也尽量利用了这个优势，通过批处理和向量编程来增加单位时间内的数据包处理。<br>4、使用更先进的库接口<br>    这个其实很简单，就是把普适性的库，有针对的进行完善和修改。包括对一些硬件有针对性的处理。<br>5、优化编译执行<br>    这个就是比较常见的了，比如分支预测（内核和 c++ 新标准），Cache 预取，内存对齐（包括前面提到的伪共享和跨 Cache Line），常量优化以及直接调用 Cpu 指令等等。</p>
<pre><code>这里简单分析一下 NUMA，Non Uniform Memory Access，非统一内存访问，它和 UMA，Uniform Memory Access，一致性内存访问相对应。其实说的通俗一些就是本地管理和分布式管理的区别。但为了解决分布式管理出现的缓慢和无法访问所有存储器的情况就针对性的提出了 NUMA，把存储分为本地存储和远端存储。它的优势在于既兼顾上 SMP 模式下的系统拷贝和易于管理又继承了分布式（MPP）模式的可扩充性。  
另外还一个重要的问题，DPDK 毕竟不是一个官方统一的基础库，而一个和硬件、OS 版本及相关参数配置有关的一个基础框架。所以在实际部署时也要考虑到这些因素，特别是硬件的支持。一般来说，重点需要处理 CPU 核心的隔离和中断的转移屏蔽。即使无法完全处理好中断也要尽量减少中断的次数。
</code></pre>
<h2 id="UIO-机制"><a href="#UIO-机制" class="headerlink" title="UIO 机制"></a>UIO 机制</h2><pre><code>Linux 提供了 UIO（https://lwn.net/Articles/232575/）机制即 user-space drivers，它可以通过 mmap 实现和网卡的通信。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/fcb2e7b3faba80460575194d0ef4ae9e.png"></p>
<p>在 linux&#x2F;uio_driver.h 有如下的数据结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uio_info</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>			*name;</span><br><span class="line">	<span class="type">char</span>			*version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uio_mem</span>		<span class="title">mem</span>[<span class="title">MAX_UIO_MAPS</span>];</span></span><br><span class="line">	<span class="type">long</span>			irq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		irq_flags;</span><br><span class="line">	<span class="type">void</span>			*priv;</span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span> irq, <span class="keyword">struct</span> uio_info *dev_info);</span><br><span class="line">	<span class="type">int</span> (*mmap)(<span class="keyword">struct</span> uio_info *info, <span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line">	<span class="type">int</span> (*open)(<span class="keyword">struct</span> uio_info *info, <span class="keyword">struct</span> inode *inode);</span><br><span class="line">	<span class="type">int</span> (*release)(<span class="keyword">struct</span> uio_info *info, <span class="keyword">struct</span> inode *inode);</span><br><span class="line">	<span class="comment">/* Internal stuff omitted */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>上面把 DPDK 的相关技术进行了整体的分析，这样就可以从整体上对 DPDK 的技术栈进行一个认知。从这篇之后，将从两个角度来分析 DPDK，一个是应用的角度，如何使用，从分析例程的角度来探究 DPDK 运行的技术；另外一个角度是从源码的角度，由浅入深的分析相关的源码和上层的应用情况进行结合分析。  
</code></pre>
<p>作始也简。</p>
<h1 id="DPDK-的并发"><a href="#DPDK-的并发" class="headerlink" title="DPDK 的并发"></a>DPDK 的并发</h1><p>前面提到了网络爆发式的发展，提出了 C10K 到 c100K 甚至更多并发的要求，其实本质上还是对数据接收和处理的速度，即从软件、硬件实现整体的最大性能的平衡。这时候在软件上多线程、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E8%BF%9B%E7%A8%8B&spm=1001.2101.3001.7020">多进程</a>以至于并行编程就拿到台面上，毕竟这是解决接收和处理数据的一个最有力的方法和手段。  </p>
<p>在前面也提到过，DPDK 的优势在于缩短了数据流的路径，但另外一个重要的方面就是多核（CPU）的利用以及在指令处理方面使用了 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SIMD&spm=1001.2101.3001.7020">SIMD</a>。正如前面所分析，合理的利用核心的数量和并处理好缓存的命中，就可以大幅的提高处理的效率，再加上类似于批处理的数量优势，自然就会有大幅度的效能的提升。  </p>
<p>说得更通俗一些，就是要挖掘多核和多 CPU 以及硬件的资源，但这些资源的挖掘尽量要从软件上来实现。这就是 DPDK 并发的意义。</p>
<h2 id="多线程模型及源码分析"><a href="#多线程模型及源码分析" class="headerlink" title="多线程模型及源码分析"></a>多线程模型及源码分析</h2><p>DPDK 中的线程创建是基于 Posix 库创建的，从这方面来看，就没有脱离开上层应用编程的范围。说这个的意思就是说，这块本质上是没有难度的。看一下相关的线程处理代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Launch threads, called at application init(). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, fctret, ret;</span><br><span class="line">	<span class="type">pthread_t</span> thread_id;</span><br><span class="line">	<span class="type">static</span> <span class="type">rte_atomic32_t</span> run_once = RTE_ATOMIC32_INIT(<span class="number">0</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> logid[PATH_MAX];</span><br><span class="line">	<span class="type">char</span> cpuset[RTE_CPU_AFFINITY_STR_LEN];</span><br><span class="line">	<span class="type">char</span> thread_name[RTE_MAX_THREAD_NAME_LEN];</span><br><span class="line">	<span class="type">bool</span> phys_addrs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// checks if the machine is adequate</span></span><br><span class="line">	<span class="keyword">if</span> (!rte_cpu_is_supported()) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;unsupported cpu type.&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_atomic32_test_and_set(&amp;run_once)) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;already called initialization.&quot;</span>);</span><br><span class="line">		rte_errno = EALREADY;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	strlcpy(logid, p ? p + <span class="number">1</span> : argv[<span class="number">0</span>], <span class="keyword">sizeof</span>(logid));</span><br><span class="line">	thread_id = pthread_self();</span><br><span class="line"></span><br><span class="line">	eal_reset_internal_config(&amp;internal_config);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set log level as early as possible</span></span><br><span class="line">	eal_log_level_parse(argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_cpu_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot detect lcores.&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fctret = eal_parse_args(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (fctret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Invalid &#x27;command line&#x27; arguments.&quot;</span>);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (eal_plugins_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init plugins&quot;</span>);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (eal_option_device_parse()) &#123;</span><br><span class="line">		rte_errno = ENODEV;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_config_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init config&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_intr_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init interrupt-handling thread&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_alarm_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init alarm&quot;</span>);</span><br><span class="line">		<span class="comment">/* rte_eal_alarm_init sets rte_errno on failure. */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put mp channel init before bus scan so that we can init the vdev</span></span><br><span class="line">	<span class="comment">// bus through mp channel in the secondary process before the bus scan.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (rte_mp_channel_init() &lt; <span class="number">0</span> &amp;&amp; rte_errno != ENOTSUP) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;failed to init mp channel&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY) &#123;</span><br><span class="line">			rte_errno = EFAULT;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register multi-process action callbacks for hotplug</span></span><br><span class="line">	<span class="keyword">if</span> (eal_mp_dev_hotplug_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;failed to register mp callback for hotplug&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_bus_scan()) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot scan the buses for devices&quot;</span>);</span><br><span class="line">		rte_errno = ENODEV;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	phys_addrs = rte_eal_using_phys_addrs() != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if no EAL option &quot;--iova-mode=&lt;pa|va&gt;&quot;, use bus IOVA scheme</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.iova_mode == RTE_IOVA_DC) &#123;</span><br><span class="line">		<span class="comment">// autodetect the IOVA mapping mode</span></span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span> =</span> rte_bus_get_iommu_class();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (iova_mode == RTE_IOVA_DC) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Buses did not request a specific IOVA mode.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!phys_addrs) &#123;</span><br><span class="line">				<span class="comment">// if we have no access to physical addresses,</span></span><br><span class="line">				<span class="comment">// pick IOVA as VA mode.</span></span><br><span class="line">				iova_mode = RTE_IOVA_VA;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;Physical addresses are unavailable, selecting IOVA as VA mode.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RTE_LIBRTE_KNI) &amp;&amp; LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 10, 0)</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rte_eal_check_module(<span class="string">&quot;rte_kni&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">				iova_mode = RTE_IOVA_PA;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;KNI is loaded, selecting IOVA as PA mode for better KNI performance.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_iommu_enabled()) &#123;</span><br><span class="line">				<span class="comment">/* we have an IOMMU, pick IOVA as VA mode */</span></span><br><span class="line">				iova_mode = RTE_IOVA_VA;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;IOMMU is available, selecting IOVA as VA mode.\n&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* physical addresses available, and no IOMMU</span></span><br><span class="line"><span class="comment">				 * found, so pick IOVA as PA.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				iova_mode = RTE_IOVA_PA;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;IOMMU is not available, selecting IOVA as PA mode.\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RTE_LIBRTE_KNI) &amp;&amp; LINUX_VERSION_CODE &lt; KERNEL_VERSION(4, 10, 0)</span></span><br><span class="line">		<span class="comment">// Workaround for KNI which requires physical address to work</span></span><br><span class="line">		<span class="comment">// in kernels &lt; 4.10</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> (iova_mode == RTE_IOVA_VA &amp;&amp;</span><br><span class="line">				rte_eal_check_module(<span class="string">&quot;rte_kni&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (phys_addrs) &#123;</span><br><span class="line">				iova_mode = RTE_IOVA_PA;</span><br><span class="line">				RTE_LOG(WARNING, EAL, <span class="string">&quot;Forcing IOVA as &#x27;PA&#x27; because KNI module is loaded\n&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;KNI can not work since physical addresses are unavailable\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		rte_eal_get_configuration()-&gt;iova_mode = iova_mode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rte_eal_get_configuration()-&gt;iova_mode =</span><br><span class="line">			internal_config.iova_mode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_iova_mode() == RTE_IOVA_PA &amp;&amp; !phys_addrs) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot use IOVA as &#x27;PA&#x27; since physical addresses are not available&quot;</span>);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Selected IOVA mode &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">		rte_eal_iova_mode() == RTE_IOVA_PA ? <span class="string">&quot;PA&quot;</span> : <span class="string">&quot;VA&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_hugetlbfs == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// rte_config isn&#x27;t initialized yet</span></span><br><span class="line">		ret = internal_config.process_type == RTE_PROC_PRIMARY ?</span><br><span class="line">				eal_hugepage_info_init() :</span><br><span class="line">				eal_hugepage_info_read();</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_eal_init_alert(<span class="string">&quot;Cannot get hugepage information.&quot;</span>);</span><br><span class="line">			rte_errno = EACCES;</span><br><span class="line">			rte_atomic32_clear(&amp;run_once);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.memory == <span class="number">0</span> &amp;&amp; internal_config.force_sockets == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (internal_config.no_hugetlbfs)</span><br><span class="line">			internal_config.memory = MEMSIZE_IF_NO_HUGE_PAGE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.vmware_tsc_map == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT</span></span><br><span class="line">		rte_cycles_vmware_tsc_map = <span class="number">1</span>;</span><br><span class="line">		RTE_LOG (DEBUG, EAL, <span class="string">&quot;Using VMWARE TSC MAP, &quot;</span></span><br><span class="line">				<span class="string">&quot;you must have monitor_control.pseudo_perfctr = TRUE\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		RTE_LOG (WARNING, EAL, <span class="string">&quot;Ignoring --vmware-tsc-map because &quot;</span></span><br><span class="line">				<span class="string">&quot;RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT is not set\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_log_init(logid, internal_config.syslog_facility) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init logging.&quot;</span>);</span><br><span class="line">		rte_errno = ENOMEM;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VFIO_PRESENT</span></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_vfio_setup() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init VFIO&quot;</span>);</span><br><span class="line">		rte_errno = EAGAIN;</span><br><span class="line">		rte_atomic32_clear(&amp;run_once);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* in secondary processes, memory init may allocate additional fbarrays</span></span><br><span class="line"><span class="comment">	 * not present in primary processes, so to avoid any potential issues,</span></span><br><span class="line"><span class="comment">	 * initialize memzones first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_memzone_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init memzone&quot;</span>);</span><br><span class="line">		rte_errno = ENODEV;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_memory_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init memory&quot;</span>);</span><br><span class="line">		rte_errno = ENOMEM;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the directories are locked during eal_hugepage_info_init */</span></span><br><span class="line">	eal_hugedirs_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_malloc_heap_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init malloc heap&quot;</span>);</span><br><span class="line">		rte_errno = ENODEV;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_tailqs_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init tail queues for objects&quot;</span>);</span><br><span class="line">		rte_errno = EFAULT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_timer_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init HPET or TSC timers&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eal_check_mem_on_local_socket();</span><br><span class="line"></span><br><span class="line">	eal_thread_init_master(rte_config.master_lcore);</span><br><span class="line"></span><br><span class="line">	ret = eal_thread_dump_affinity(cpuset, <span class="keyword">sizeof</span>(cpuset));</span><br><span class="line"></span><br><span class="line">	RTE_LOG(DEBUG, EAL, <span class="string">&quot;Master lcore %u is ready (tid=%zx;cpuset=[%s%s])\n&quot;</span>,</span><br><span class="line">		rte_config.master_lcore, (<span class="type">uintptr_t</span>)thread_id, cpuset,</span><br><span class="line">		ret == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	RTE_LCORE_FOREACH_SLAVE(i) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * create communication pipes between master thread</span></span><br><span class="line"><span class="comment">		 * and children</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_master2slave) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pipe(lcore_config[i].pipe_slave2master) &lt; <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		lcore_config[i].state = WAIT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">		ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">				     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			rte_panic(<span class="string">&quot;Cannot create thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Set thread_name for aid in debugging. */</span></span><br><span class="line">		<span class="built_in">snprintf</span>(thread_name, <span class="keyword">sizeof</span>(thread_name),</span><br><span class="line">			<span class="string">&quot;lcore-slave-%d&quot;</span>, i);</span><br><span class="line">		ret = rte_thread_setname(lcore_config[i].thread_id,</span><br><span class="line">						thread_name);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			RTE_LOG(DEBUG, EAL,</span><br><span class="line">				<span class="string">&quot;Cannot set name for lcore thread\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Launch a dummy function on all slave lcores, so that master lcore</span></span><br><span class="line"><span class="comment">	 * knows they are all ready when this function returns.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rte_eal_mp_remote_launch(sync_func, <span class="literal">NULL</span>, SKIP_MASTER);</span><br><span class="line">	rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize services so vdevs register service during bus_probe. */</span></span><br><span class="line">	ret = rte_service_init();</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;rte_service_init() failed&quot;</span>);</span><br><span class="line">		rte_errno = ENOEXEC;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Probe all the buses and devices/drivers on them */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_bus_probe()) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot probe devices&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VFIO_PRESENT</span></span><br><span class="line">	<span class="comment">/* Register mp action after probe() so that we got enough info */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_vfio_is_enabled(<span class="string">&quot;vfio&quot;</span>) &amp;&amp; vfio_mp_sync_setup() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize default service/lcore mappings and start running. Ignore</span></span><br><span class="line"><span class="comment">	 * -ENOTSUP, as it indicates no service coremask passed to EAL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = rte_service_start_with_defaults();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != -ENOTSUP) &#123;</span><br><span class="line">		rte_errno = ENOEXEC;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clean up unused files in runtime directory. We do this at the end of</span></span><br><span class="line"><span class="comment">	 * init and not at the beginning because we want to clean stuff up</span></span><br><span class="line"><span class="comment">	 * whether we are primary or secondary process, but we cannot remove</span></span><br><span class="line"><span class="comment">	 * primary process&#x27; files because secondary should be able to run even</span></span><br><span class="line"><span class="comment">	 * if primary process is dead.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In no_shconf mode, no runtime directory is created in the first</span></span><br><span class="line"><span class="comment">	 * place, so no cleanup needed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!internal_config.no_shconf &amp;&amp; eal_clean_runtime_dir() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot clear runtime directory&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eal_mcfg_complete();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call each registered callback, if enabled  */</span></span><br><span class="line">	rte_option_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fctret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在前面的文章中的例程中用过。看看开头的几个变量和 rte_eal_cpu_init 函数，不用看内部的实现，都应该猜到是什么了。在 rte_eal_cpu_init 处理好 CPU，开始调用 eal_parse_args 来处理参数进行 Master 核的确定和 CPU 的管理（确定哪核可用）。<br>到这里，基本就应该明白要怎么使用线程了，再加上开头的 pthread_t thread_id; 应该立刻明白了吧。并行计算中处理的第一个要务就是对 CPU 的分配和管理，包括一些 CPU 控制在内。<br>接着往下看就是一系列的初始化如前面文章提到的，配置、内存、内存池、队列、定时器等等。最后到主核心线程和各个子线程核心的启动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">eal_thread_init_master(rte_config.master_lcore);</span><br><span class="line"></span><br><span class="line">ret = eal_thread_dump_affinity(cpuset, <span class="keyword">sizeof</span>(cpuset));</span><br><span class="line"></span><br><span class="line">RTE_LOG(DEBUG, EAL, <span class="string">&quot;Master lcore %u is ready (tid=%zx;cpuset=[%s%s])\n&quot;</span>,</span><br><span class="line">	rte_config.master_lcore, (<span class="type">uintptr_t</span>)thread_id, cpuset,</span><br><span class="line">	ret == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">RTE_LCORE_FOREACH_SLAVE(i) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * create communication pipes between master thread</span></span><br><span class="line"><span class="comment">	 * and children</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pipe(lcore_config[i].pipe_master2slave) &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pipe(lcore_config[i].pipe_slave2master) &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	lcore_config[i].state = WAIT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">	ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>,</span><br><span class="line">			     eal_thread_loop, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;Cannot create thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set thread_name for aid in debugging. */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(thread_name, <span class="keyword">sizeof</span>(thread_name),</span><br><span class="line">		<span class="string">&quot;lcore-slave-%d&quot;</span>, i);</span><br><span class="line">	ret = rte_thread_setname(lcore_config[i].thread_id,</span><br><span class="line">					thread_name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		RTE_LOG(DEBUG, EAL,</span><br><span class="line">			<span class="string">&quot;Cannot set name for lcore thread\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eal_thread_init_master 和 eal_thread_loop 它们都会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set affinity for current EAL thread */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eal_thread_set_affinity</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> lcore_id = rte_lcore_id();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* acquire system unique id  */</span></span><br><span class="line">	rte_gettid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update EAL thread core affinity */</span></span><br><span class="line">	<span class="keyword">return</span> rte_thread_set_affinity(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来进行 CPU 的绑定。然后不同模块为了使用线程，就需要进行注册，即创建后紧随的调用 rte_eal_mp_remote_launch：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Launch a dummy function on all slave lcores, so that master lcore</span></span><br><span class="line"><span class="comment"> * knows they are all ready when this function returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rte_eal_mp_remote_launch(sync_func, <span class="literal">NULL</span>, SKIP_MASTER);</span><br><span class="line">rte_eal_mp_wait_lcore();</span><br></pre></td></tr></table></figure>

<p>初始的是一个空的系统函数。有兴趣可以搜一搜这个函数的使用，你会发现真得好多。它的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that every SLAVE lcores are in WAIT state, then call</span></span><br><span class="line"><span class="comment"> * rte_eal_remote_launch() for all of them. If call_master is true</span></span><br><span class="line"><span class="comment"> * (set to CALL_MASTER), also call the function on the master lcore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_mp_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg,</span></span><br><span class="line"><span class="params">			 <span class="keyword">enum</span> <span class="type">rte_rmt_call_master_t</span> call_master)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lcore_id;</span><br><span class="line">	<span class="type">int</span> master = rte_get_master_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check state of lcores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].state != WAIT)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send messages to cores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">		rte_eal_remote_launch(f, arg, lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (call_master == CALL_MASTER) &#123;</span><br><span class="line">		lcore_config[master].ret = f(arg);</span><br><span class="line">		lcore_config[master].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send a message to a slave lcore identified by slave_id to call a</span></span><br><span class="line"><span class="comment"> * function f with argument arg. Once the execution is done, the</span></span><br><span class="line"><span class="comment"> * remote lcore switch in FINISHED state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> slave_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m2s = lcore_config[slave_id].pipe_master2slave[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> s2m = lcore_config[slave_id].pipe_slave2master[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_config[slave_id].state != WAIT)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	lcore_config[slave_id].f = f;</span><br><span class="line">	lcore_config[slave_id].arg = arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send message */</span></span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n == <span class="number">0</span> || (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR))</span><br><span class="line">		n = write(m2s, &amp;c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot write on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wait ack */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		n = read(s2m, &amp;c, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">&quot;cannot read on configuration pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这明显是注册函数用的，函数指针放到了第一个参数上。尽管创建线程的手法一致，但尽量还是使用 DPDK 创建的线程，它能更好的发挥 DPDK 的性能，原因在后面分析代码中就慢慢明白了。<br>从上面的代码和分析是不是总结中线程模型和常用的开发的模型有所不同之处，如果有做类似并行计算如 OpenMP 开发的会发现有相似之处，其实就是把线程的自由调用也就是时间片的任意轮转，固定到了指定的核心上。线程间通过 PIPE 进行通信。<br>通过上面找分析，可以总结出 DPDK 的并发模型从提高指令的并行度和多核并发出发，通过内存和 NUMA 的管理提高水平扩展的能力。利用 CPU 的亲和力，使用主从线程的分配管理，利用 SIMD，提高整体的吞吐量。<br>而从实际情况来看，由于 Linux 内核是不区分线程和进程动作的，在内核看来二者都是 Fork 的结果。上下文的切换的消耗对于线程和进程没有不可忽视的区别。反而是线程和进程对于处理不同内存的共享时，导致的性能开销会有较大的差异。在多核心的情况下，由于线程伪共享的问题，多进程反而较多线程更有优势。在排除不同进程线程间通信这种复杂情况下，多进程性能还是要高于多线程，并且更健壮。<br>在 DPDK 中利用巨页机制可以降低多线程在频繁交互下对多进程的优势。所以，在实际的应用过程中，还是要根据实际情况来决定应用的具体情况。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>同样在 DPDK 中对多进程也是支持的，需要在启动任务时，手动指定相关的主从进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./xxx -c 0xf -n 2 -- -q 2 -p 0xf -proc-type primary</span><br><span class="line">./xxx -c 0xf -n 2 -- -q 2 -p 0xf -proc-type secondary</span><br></pre></td></tr></table></figure>

<p>应用的一些参数基本的格式说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./xxx [options] -- -p PORTMASK [-q NQ -T t]</span><br><span class="line"></span><br><span class="line">option:DPDK EAL的默认参数，其形式为 -c COREMASK -n NUM</span><br><span class="line">       COREMASK：十六进制位掩码表示分配的逻辑内核数量</span><br><span class="line">       NUM：十进制整数表示每个逻辑内核的内存通道数量</span><br><span class="line">-p PORTMASK</span><br><span class="line">PORTMASK：十六进制位掩码即分配的端口数量。0x3是指 后两位为1，即起点两个端口</span><br><span class="line">-q NQ</span><br><span class="line">NQ：分配到每个逻辑内核的收发队列数量</span><br><span class="line">-T t</span><br><span class="line">t: 打印统计数据上屏的时间间隔，默认为10秒</span><br></pre></td></tr></table></figure>

<p>DPDK 中，多进程的情况下，主从进程有点类似于线程共享进程的资源一样，主从进程共享大页内存以及一些相关的队列。说到共享，如果有 Android 框架分析经验的肯定会首先想起 mmap。对，DPDK 也是，所以说，多看代码，多看优秀的框架，会明白很多事儿。在这个基础上，才可能产生创新。</p>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>前面看一个简单的多线程的，下面看自带的一个多进程的简装版：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_LOGTYPE_APP RTE_LOGTYPE_USER1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *_MSG_POOL = <span class="string">&quot;MSG_POOL&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *_SEC_2_PRI = <span class="string">&quot;SEC_2_PRI&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *_PRI_2_SEC = <span class="string">&quot;PRI_2_SEC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">send_ring</span>, *<span class="title">recv_ring</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">message_pool</span>;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> quit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lcore_recv</span><span class="params">(__attribute__((unused)) <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> lcore_id = rte_lcore_id();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Starting core %u\n&quot;</span>, lcore_id);</span><br><span class="line">        <span class="keyword">while</span> (!quit)&#123;</span><br><span class="line">                <span class="type">void</span> * msg;</span><br><span class="line">                <span class="keyword">if</span> (rte_ring_dequeue(recv_ring, &amp;msg) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        usleep(<span class="number">5</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;core %u: Received &#x27;%s&#x27;\n&quot;</span>, lcore_id, (<span class="type">char</span> * )msg);</span><br><span class="line">                rte_mempool_put(message_pool, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> ring_size = <span class="number">64</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> pool_size = <span class="number">1024</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> pool_cache = <span class="number">32</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> priv_data_sz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">        ret = rte_eal_init(argc, argv);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot init EAL\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY) &#123;</span><br><span class="line">            send_ring = rte_ring_create(_PRI_2_SEC, ring_size, rte_socket_id(), flags);</span><br><span class="line">            recv_ring = rte_ring_create(_SEC_2_PRI, ring_size, rte_socket_id(), flags);</span><br><span class="line">            message_pool = rte_mempool_create(_MSG_POOL, pool_size,</span><br><span class="line">                    STR_TOKEN_SIZE, pool_cache, priv_data_sz,</span><br><span class="line">                    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                    rte_socket_id(), flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recv_ring = rte_ring_lookup(_PRI_2_SEC);</span><br><span class="line">            send_ring = rte_ring_lookup(_SEC_2_PRI);</span><br><span class="line">            message_pool = rte_mempool_lookup(_MSG_POOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (send_ring == <span class="literal">NULL</span>)</span><br><span class="line">            rte_exit(EXIT_FAILURE, <span class="string">&quot;Problem getting sending ring\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (recv_ring == <span class="literal">NULL</span>)</span><br><span class="line">            rte_exit(EXIT_FAILURE, <span class="string">&quot;Problem getting receiving ring\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (message_pool == <span class="literal">NULL</span>)</span><br><span class="line">            rte_exit(EXIT_FAILURE, <span class="string">&quot;Problem getting message pool\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RTE_LOG(INFO, APP, <span class="string">&quot;Finished Process Init.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* call lcore_recv() on every slave lcore */</span></span><br><span class="line">        RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">            rte_eal_remote_launch(lcore_recv, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* call cmd prompt on master lcore */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmdline</span> * <span class="title">cl</span> =</span> cmdline_stdin_new(simple_mp_ctx, <span class="string">&quot;\nsimple_mp &gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cl == <span class="literal">NULL</span>)</span><br><span class="line">            rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot create cmdline instance\n&quot;</span>);</span><br><span class="line">        cmdline_interact(cl);</span><br><span class="line">        cmdline_stdin_exit(cl);</span><br><span class="line"></span><br><span class="line">        rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* clean up the EAL */</span></span><br><span class="line">        rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看一下，前面对进程的判断和创建过程与线程有何不同，会更好的理解 DPDK 的并行模型。</p>
<p>DPDK 通过 NUMA 整合 CPU 的管理，通过对 CPU 核心的具体分析来确定主从线程，配置亲和性保证缓存的命中率真并尽量减小上下文的场景开销。</p>
<h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>什么是虚拟化技术呢？《虚拟化技术发展编年史》中是这样定义：在计算机科学中，虚拟化技术（Virtualization）是一种资源管理（优化）技术，将计算机的各种物理资源（e.g. CPU、内存以及磁盘空间、网络适配器等 I&#x2F;O 设备）予以抽象、转换，然后呈现出来的一个可供分割并任意组合为一个或多个（虚拟）计算机的配置环境。<br>维基百科中的解释和上面的解释基本一致。</p>
<h2 id="虚拟化的分类"><a href="#虚拟化的分类" class="headerlink" title="虚拟化的分类"></a>虚拟化的分类</h2><p>虚拟化技术一般可按对象分为三类：<br>1、平台虚拟化，即大家常见的计算机和 OS 的虚拟化<br>2、资源虚拟化（包含网卡虚拟化、GPU 虚拟化、存储虚拟化及其它硬件虚拟化），也就是虚拟网卡、虚拟内在、虚拟存储等等<br>3、应用虚拟化，这个就更常见了，Java 虚拟机、各种训练仪等等。<br>虚拟化中，Hypervisor 一般分为两种类型：<br>1、原生 Hypervisor<br>2、托管 Hypervisor  </p>
<p>虚拟化实现可以分为三类：<br>1、纯软件仿真<br>这种就是用软件来模拟系统，比如 QEMU 还有安卓的模拟器等。<br>2、虚拟化层翻译<br>它又分为全虚拟技术，这种非常多见，它基于指令的全翻译技术，比如 VMware、VirtualPC、QEMU(KVM) 等等；还有半虚拟化技术，这个典型的是 Xen，一般人可能不太清楚，但一提 AWS 这个云平台几乎没有不知道。它底层就是从 Xen 开始起步的。当然现在已经有了极大的改进。最后就是基于硬件辅助的，也就是提到的 INTEL 和 AMD 的硬件虚拟技术解决了 x86 平台不支持此类技术的解决方案了。<br>3、容器技术<br>容器技术应该就更容易理解了，基于 LXC 和 Docker 的容器技术，是现在服务集群管理的重要的基础。搞后台开发的，要是不知道点 Docker 技术，都不好意思说话。容器可以理解成轻量级的虚拟化，它只能虚拟化部分 OS。容器的优势在于它轻量化，更容易部署和管理。</p>
<h3 id="虚拟化的应用方向"><a href="#虚拟化的应用方向" class="headerlink" title="虚拟化的应用方向"></a>虚拟化的应用方向</h3><p>目前主流的虚拟化的方向有以下几类：<br>1、CPU 虚拟化<br>也就是人们常说的云计算的前提，它分为纯软件虚拟化和硬件虚拟化两类。前者限制较多，但硬件方案出来的较晚。<br>2、网络虚拟化<br>这个目前比较宽泛，但做为小白来说，可以认为是对常见的网卡网络进行虚拟化。常见的 VPN 就是一种网络虚拟化。<br>3、服务器虚拟化<br>这个就更好理解了，说直白一些就是虚拟出一个个虚拟机来做为服务器。这可是云厂商最关注的啊，毕竟用户付费一般是按机器来付费的。这个里面就包含容器技术。<br>4、存储虚拟化<br>这个还是基于网络应用的快速增长，数据的存储，或者说大数据提出的要求。起初大家认知的可能只是虚拟内在，后来又增加了外存的虚拟化等等。这些都叫做虚拟存储。</p>
<h2 id="DPDK-和虚拟化"><a href="#DPDK-和虚拟化" class="headerlink" title="DPDK 和虚拟化"></a>DPDK 和虚拟化</h2><p>DPDK 中大幅优化了网络通信的效率，这里也重点对网卡的虚拟化进行分析。网卡基本属于 IO 虚拟化。但是，虚拟化又有 IO 全虚拟化和 IO 半虚拟化之分，那么在 DPDK 中使用的哪种呢？IO 虚拟化一般有全虚拟化、半虚拟化、透传和 SR-IOV 几种方式，这里重点比较前两者。<br>IO 全虚拟化技术是由指令的翻译的全翻译来实现的，也就是说虚拟机可以模拟宿主机的的所有功能。但这样做有一个问题，它会导致上下文的切换降低效率。这时候，半虚拟化（又叫 CPU 虚拟化）技术就出现了，半虚拟化技术中虚拟机和宿主机并不是完全隔离的，它是在敏感指令上通过 HyperCall 调用来实现的，这样就节省了指令捕获和完整模拟提高了效率。<br>DPDK 在 PMD（Poll Mode Drivers）中通过 virtio 和 vhost 来实现 IO 的半虚拟化功能。</p>
<h3 id="virtio"><a href="#virtio" class="headerlink" title="virtio"></a>virtio</h3><p>在 DPDK 中，对 virtio 的支持已经到 1.1 的版本（virtio1.2 版本也出来了）。virtio ，来源于《 towards a de-facto standard for virtual I&#x2F;O devices》这篇论文当中。这篇论文提出了 “两个通用的 ABI，Virtqueue 和 Linux API for virtual IO device”，同时提供了对虚拟设备的向后兼容性以及 Feautre 协商机制。<br>virtio 是一种接口规范，用来统一 IO 半虚拟化抽象。它提供了一套层应用与 Hypervisor 虚拟化设备（KVM，Xen，VMware 等）之间的通信框架和编程接口，大大减少了平台的兼容性差异。<br>一般来说，在宿主机上的虚拟机（客户端）上实现的 IO 半虚拟化的前半端驱动程序叫做 virtio，而在宿主机 host 实现的后半端驱动程序叫做 vhost。它们两个通过 virtio 的虚拟队列通信。虚拟机发送的数据报文到达虚拟交换机，再转发到物理网卡中。<br>virtio 在 PCI 层上定义了 virqueue，所以可以配置一个或者多个此类型队列保证数据的收发。  </p>
<h3 id="vhost"><a href="#vhost" class="headerlink" title="vhost"></a>vhost</h3><p>在内核怸中，vhost 负责报文送达消息的通知中断。vhost-net 做为上层应用和物理设备的桥梁，对相应的进出数据报文队列进行操作，并通知中断的产生。也可以把 vhost-net 迁移到用户态，即 vhost-user, 此时，vhost-user 为第个 VM 创建一个端口，实现后端逻辑以及报文的收发请求。用户态的 vhost-user 数据的拷贝是由共享内在来实现的。<br>DPDK 中就是使用的 vhost-user 机制。DPDK 中的 vhost 支持字符设备和 Socket 服务两种消息机制，它主要是负责 virtio-net 的创建和管理以及销毁动作。它的封装形式主要有 vhost lib 和 vhost PMD。前者实现了用户态的 vhost 驱动，而后者则是前者的封装进一步形成标准的虚拟端口。<br>vhost-net(内核态 vhost) 和 vhost-user 二者不同在于，前者是沟通用户态和内核内的接口而后者则通过域来处理共享内能达到同样的效果。</p>
<p>virtio 既可以处理 IO 也可以处理网络子系统，在 DPDK 重点是对网络子系统的应用。DPDK 目前是 VNF 和 NFC（网络功能虚拟化和容器化）的一个重要组成部分。在现在的云服务中，网络功能虚拟化已经是软件硬件解耦的一个重要部分，它可以做为各种网络功能的基础设施层（NFCi）有效支撑。<br>在实际的应用中，虚拟网络交换机是一个重要的应用，开源的有 Open vSwitch（OVS)，Snabb Switch 等等。在开源的 OPNFC 中，还有很多的项目直接或者间接应用到了 DPDK。毕竟，DPDK 做为一个开发套件，理论上只要是有 IO 和网络数据通信的，都可以应用得到。<br>云的兴起，对 VNF 和 NFC 的要求是只有更高没有最高，而 DPDK 在这其中还有更多的事情要做，而且 DPDK 确实也在不断的增加着一些功能。这使得 DPDK 会更好的为 VNF 服务，降低成本，方便网络的弹性部署。</p>
<p>最后再提一下透传和 SR-IOV，前者效率非常好，可以简单理解为就是虚拟设备和物理设备合而为一了，但这样做的缺点就是不灵活。而后者是为了实现在单张物理设备上提供多个虚拟子设备的问题，DPDK 也同样支持这两种方式（前提是硬件也要提供支持）。所以说一个好的框架，支持的力度是在尽可能的情况下要宽泛，这样才可以保证框架的可适用性并为广大开发者接受。</p>
<h3 id="virtio-的框架流程"><a href="#virtio-的框架流程" class="headerlink" title="virtio 的框架流程"></a>virtio 的框架流程</h3><p>其主要架构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/309176efc7eaa7a859532e45eca92001.png"></p>
<p>从图上可以看出，其共分为了四层，前端驱动和后端驱动，以及中间层的 virtio 和 virtio ring 层。<br>前端驱动和后端设备通过传输层（中间层两层）来实现数据的通信，其主要的流程图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/bd976cb442a701b63fe2451e84e11065.png"></p>
<p>前端驱动（virtio）中，主要是虚拟机对 virtio 模拟设备的驱动程序，用来管理 virtio 设备，接收虚拟机的请求并根据协议连接 virtio 设备。在 Linux 内核中，基本已经实现了一系列的此类前端驱动，如 virtio-ballon、virtio-net、virtio-blk 和 virtio-scsi 等等。同时在 DPDK 中实现了对网络设备的用户态（virtio-pmd）驱动。<br>传输层，顾名思义，就是用前后端的数据通信，它主要是支持虚拟机和 VMM（Hypervisor）之间。正如图上所讲，利用共享内在实现两个虚拟队列来完成数据的传输。前端虚拟队列用于前端动态数据的传输，后端虚拟队列用于前端设备提交的 IO 请求处理。<br>后端设备主要承担两类功能，一个是对 virtio 后端设备的模拟，第二是依据协议处理虚拟机传过来的请求。不过随着技术的进步，又出现了前面提到的 vhost,vhost-user、vDPA 等等加速方案。</p>
<h3 id="DPDK-的-virtio-的应用"><a href="#DPDK-的-virtio-的应用" class="headerlink" title="DPDK 的 virtio 的应用"></a>DPDK 的 virtio 的应用</h3><p>在 Linux 内核中对 virtio 的抽象实现如下：<br>1、底层 PCI-e 设备抽象层，管理检测 PCI-e 设备，初始化相应设备驱动程序, 其通过两个抽象类即 virtio_driver 和 virtio_device 来负责此工作<br>2、中间 virio 虚拟队列层，其主要是 virtqueue，其主要由 vring_virtqueue 和 vring 等类来实现<br>3、上层网络设备抽象层，通过实现底层抽象类 virtio_net_driver 和 dev 来提供普通的网络接口使用<br>而在 DPDK 基本上也是沿袭了这个路线。<br>DPDK 中对 virtio 设备的优化：<br>1、单帧 mbuf 的网络包收发优化，固定了环表表项和描述符表项的映射<br>2、Indirect 特性在网络发送包中的支持，即发送包只需要一个描述符（普通的包至少需要两个）<br>这要归功于 DPDK 中并没有完全实现 virtio 中对所有相关 IO 的实现，只是实现了对网卡设备的支持，这样就可以针对其进行具体的上述优化了。</p>
<p>DPDK 中对相关虚拟化 virtio 的实现代码主有以下几部分（DPDK 主目录 &#x2F; drviers&#x2F;net&#x2F;virtio 或 vhost）：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">├── meson.build</span><br><span class="line">├── virtio.c</span><br><span class="line">├── virtio_cvq.c</span><br><span class="line">├── virtio_cvq.h</span><br><span class="line">├── virtio_ethdev.c</span><br><span class="line">├── virtio_ethdev.h</span><br><span class="line">├── virtio.h</span><br><span class="line">├── virtio_logs.h</span><br><span class="line">├── virtio_pci.c</span><br><span class="line">├── virtio_pci_ethdev.c</span><br><span class="line">├── virtio_pci.h</span><br><span class="line">├── virtio_ring.h</span><br><span class="line">├── virtio_rxtx.c</span><br><span class="line">├── virtio_rxtx.h</span><br><span class="line">├── virtio_rxtx_packed_avx.h</span><br><span class="line">├── virtio_rxtx_packed.c</span><br><span class="line">├── virtio_rxtx_packed.h</span><br><span class="line">├── virtio_rxtx_packed_neon.h</span><br><span class="line">├── virtio_rxtx_simple_altivec.c</span><br><span class="line">├── virtio_rxtx_simple.c</span><br><span class="line">├── virtio_rxtx_simple.h</span><br><span class="line">├── virtio_rxtx_simple_neon.c</span><br><span class="line">├── virtio_rxtx_simple_sse.c</span><br><span class="line">├── virtio_user</span><br><span class="line">│   ├── vhost.h</span><br><span class="line">│   ├── vhost_kernel.c</span><br><span class="line">│   ├── vhost_kernel_tap.c</span><br><span class="line">│   ├── vhost_kernel_tap.h</span><br><span class="line">│   ├── vhost_user.c</span><br><span class="line">│   ├── vhost_vdpa.c</span><br><span class="line">│   ├── virtio_user_dev.c</span><br><span class="line">│   └── virtio_user_dev.h</span><br><span class="line">├── virtio_user_ethdev.c</span><br><span class="line">├── virtqueue.c</span><br><span class="line">└── virtqueue.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其主要内容包括：<br>1、从整体上讲，在 net 路径下有 vhost 和 virtio 两块；在 virtio 中有 virtio-user 及相关抽象实现；而在 wirtio-user 中又有用户态的 vhost 等<br>2、在 virtio 文件夹中，通过文件名也基本可以判断出其功能：virtio_ethdev.c 是上层设备的抽象即前端驱动；而 virtio_pci.c 是底层抽象即后端的驱动；而 virtio_rxtx.c 等含有 rxtx 源码文件都负责传输的，而 virtio_ring.h,virtqueue.c 又是传输的抽象层<br>3、virtio_user 中又提供了相关用户态的实现，它实现 DPDK 对容器对 virtio 的支持并且可以用于与 Kernel 通信。</p>
<h1 id="virio-net"><a href="#virio-net" class="headerlink" title="virio-net"></a>virio-net</h1><p>virtio-net 的驱动最初从后端再到内核怸的 vhost-net，发展到用户态的 vhost-user，其实就是对效率和扩展性的一个不断演进的过程。在前面提到过，提高云环境下的网络数据传输速度，一个是减少传播路径，一个是减少中断的影响。然后再辅以软件硬件上的配合，如 CPU 亲和性处置、内在控制和各种调优等。而在减少传播路径中，用户态直接处理设备数据则可以大大减少数据传输的流程</p>
<p>从这些结果上反推刚刚的 vhost 的发展，就可以明白了，一开始只是一个单纯的后端，需要不断的处理用户态、内核态的数据交互；后来干脆直接搞进内核，减少了一部分；最后另起炉灶直接在用户态处理，只是为了保证有些和内核必要的通信增加了通信的接口。  </p>
<p>这里面其实也不是说这种用户态的就一定完美，至少，它还是额外增加了开发成本。但是这种成本在实际应用中是舍得付出的，那么就可以这样做。</p>
<p>vhost 技术主要是优化了 virtio-net 的后端驱动。vhost 后端服务主要有三个部分：内核模块、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=qemu&spm=1001.2101.3001.7020">qemu</a> 部分和 KVM 部分。内核模块其实是把原 virtio 后端驱动数据部分迁移到了内核中而控制部分仍然在上层 qemu 中。vhost 相当于实现了一个后端的 virtio server server。它通过 virtio ring 实现了用户端对网络设备的读写。qumu 主要是前面的分析的 virtio 部分，其通过 KVM 来模拟系统环境；而 KVM 则是独立于 “传统内核模块” 之外的，负责为程序提供虚拟化硬件支持内核模块。  </p>
<p>而在最初的后端驱动中，主要的就是 “虚拟队列、消息通知和中断” 三大机制。为了对后端驱动进行优化，则在 vhost-net 中，在内核中增加了相应模块，通过中断来实现内核虚拟队列操作减少了拷贝。同样，vhost-user 进一步绕过内核直接共享虚拟队列来实现用户层和设备的数据通信。 </p>
<p>将上述说的更直白一些，就是在内核态的 vhost 绕过了上层 qemu 的模拟状态转换减少数据操作而 vhost-user 则是进一步绕过了内核，直接让用户层和设备进行数据操作。前者是虚拟机（client）与内核（server）的数据交互，虚拟机与内核共享数据队列，缺点是如果与用户进程进行通信比较麻烦； 而后者（vhost-user）使用 unix domain 来通信，用户进程间共享内存，其效果和前者一样。</p>
<p>DPDK 的 vhost 采用的 vhost-user，有两种封装形式，即 lib,PMD。前者实现了用户态的 vhost 驱动供其应用程序调用；而后者对 lib 进行了进一步的封装，抽象为一个虚拟端口，可以使其象标准端口一样通过接口调用来实现管理和数据报文的收发。DPDK 的 vhost-user 其实是在 virtio PMD 基础上进行修改而来的。在 DPDK 中，容器环境下虚拟机是通过 qemu 来模拟的，这就导致数据共享时会将所有环境数据与宿主机（物理机）共享，但实际上只有数据交互部分的大页内在有实际的意义。从 DPDK 的角度来看，virtio-user 是一个由 virtio 前端驱动虚拟出来的一个虚拟设备，其后端对就着相应的用户态的 vhost-user，二者之间就是通过进程间通信来实现数据交互。同时，为了保证一些异常数据和内核的交互，还需要通过接口实现 virtio-user 和内核的交互。</p>
<p>vhost 的源码在 lib&#x2F;librte_vhost 相关的一些接口代码，这里重点说一下相关的注意点：<br>1、通信是采用 Socket 通信，所以其可以采用客户端或者服务端两种形式，但在后续版本默认为服务端<br>2、Socket 的通信数据交互是在 OVS 进程和 QEMU 进程间，而不是和 VM 之间（VM 进程运行于 QEMU 进程内）<br>3、DPDK 有自己的通信 Message 格式（lib&#x2F;librte_vhost&#x2F;vhost_user.c）<br>4、必须要在源码中卸载 virtio 在内核中原有的相关部分<br>5、必须处理 OVS（Open vSwitch）的轮询</p>
<p>vhost 的存在，其实最主要的就是减少虚拟机通过 Hypervisor 与网卡的数据传输路径和数据的拷贝，所以在网上可以经常看到它被叫做加速器。它通过队列直接将数据和 tap(内核中的虚拟以太网设备) 设备进行交互，大家都知道，内核态和用户态的数据交的成本是相当高的，减少的交互越多，理论上数据传输的效率越高。而在 DPDK 中更是将其提到 virtio-user 即 vhost-user，可以理解其为一个虚拟的设备，这样就可以更好的提供网络的通信。同时，它也可以支持目前云环境下的容器中 virtio 的应用。<br>不过掠过内核后，传统的 TCP&#x2F;UDP 编程就需要改变一下，这个在网上也有很多相关的资料，反正，不可能是光有优点，没有劣势，各取所需吧。</p>
<h3 id="前后端的数据通信"><a href="#前后端的数据通信" class="headerlink" title="前后端的数据通信"></a>前后端的数据通信</h3><p>在把虚拟化，虚拟化的方式介绍完成后，重点分析了半虚拟化的 virtio，对进分成前后端两部分以及从后端发展到内核再发展到纯用户态也一路进行了分析。那么这就提出来了一个问题，在 virtio 中，数据是如何通信的，它们的框架流程是什么，有没有什么不同的？具体的性能如何，这都需要进一步的分析和说明。<br>在前面提到过前后端的驱动是通过 virqueue 传输数据结构抽象模型，其具体的实现为 virtio_ring 这个个体的数据类型。可以理解为数据队列和队列存储的具体数据类的关系。</p>
<h3 id="virtio和-vhost-的通信"><a href="#virtio和-vhost-的通信" class="headerlink" title="virtio和 vhost 的通信"></a>virtio和 vhost 的通信</h3><p>下面看一下 virtio 的 IO 路径传递过程，就可以清晰的看出其发展的过程，在 virtio 的标准中，一般来说是由 Client（Guest）设置发送的数据（Tx），然后 Kick（前端 Client 通知后端 Host 叫 Kick）后端的 host，然后陷出（从虚拟机进入 VMM，反之为陷入）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=KVM&spm=1001.2101.3001.7020">KVM</a>，KVM 从内核态切换到切换到用户态的 qemu 进程，然后再将数据传递到 tap 设备；<strong>而由内核态控制的 virtio-net 前面和标准设计一致，只是在最后一步，不再由内核转到用户态，而是直接由 vhost-net 把数据传递给 tap 设备；而做为 virtio-use 则在用户态进程中通知 vhost-backend（陷出前与前面两种均相同），将数据直接发送到 nic 设备。</strong></p>
<p>下面的就具体的前后端后通信，看一下数据流动的过程：<br>1、Guest（qemu）创建共享内存，通知内核 vhost-net 或者通过 Unix domain 使用 Socket 与其它进程通信，即 vhost-user。这里以后者为例<br>2、利用 sendmsg&#x2F;recvmsg 传递文件描句柄，通过 Guest 创建共享内存，发送句柄到 server，server 通过内存映射直接操作 (mmap，减少文件打开动作)<br>3、guest 和 Server 通过数据结构 virtio_ring 共享内存，每一段是一个 virtio_ring，可以有多段<br>4、Guest（Client）初始化共享内存 virtio_ring<br>5、Guest 发送 virtio_ring 的 desc，avail，used 地址给 server，server 通过 mmap 后，计算出 Server 端这些（desc，avail，used）地址进行数据读写（数据指针需要在 client 和 Server 地址转换）<br>6、读写操作：在 Net 通信中，一个发送 tx，一个接收 rx 两个 virtio_ring<br>7、共享内存保持有 desc，avail，used 等相关信息（包括 avail-&gt;idx, used-&gt;idx 等）<br>8、当 Guest 写数据时，数据放在 virtio_ring 的 last_avail_idx 中（last_avail_idx、last_used_idx 在 Guest 和 Server 中不同，为链表的头尾），其将 id 增加到 avail 中并将 shared.avail.idx++<br>9、Server 接收信号通知即从 last_avail_idx 到 avail-&gt;idx 开始读取数据<br>10、Server 端处理一条请求完成其 last_avail_idx++， 同时插入 id 到 used 中，used.idx 表示最新的位置信息<br>11、Server 通知 client 处理完成消息，client 即可回收 used 的描述符<br>12、client 通知 server 的过程（kick）,Kickfd，callfd 均为 client 创建，通过 unix domain 发送 server<br>通过 vhost-user 技术，从虚拟机到 host 利用大页共享实现了数据的 zero copy，而从 host 到 nic 也实现 zero copy，这样，就进一步加快了数据的传输。</p>
<p>DPDK 中由于只针对特定的 NET 设备，所以对相关的传输进行了进一步的优化即对网络发送包和发送过程中的支持。在 DPDK 的 vhost-virtio 中，为不同的用户场景提供了三种数据收发（Rx 和 Tx）路径。可合并路径（大数据包 Rx &#x2F; Tx 设计）为专门的 IO 转发的向量路径，如未给参数，则默认为不可合并路径。<br>1、可合并路径<br>虚拟机将 vring 中的独立 mbuf 组织为一个链表，用来接收各种数据包。<br>2、向量路径<br>利用处理器中的单个指令，通过 SIMD 来处理收发数据，在只处理 IO 数据包转发这类数据时，性能会更优。<br>3、不可合并的路径<br>一种比较少使用的方式。</p>
<h3 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h3><p> DPDK 中 virtio 源码在底层设备抽象的是 virtio_pci.h 和 virtio_pci.c, 它主要用来对 PCI 设备的检测并实现相关设备的驱动，看一下基础的数据结构和宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VirtIO PCI vendor/device ID. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CRYPTO_PCI_VENDORID 0x1AF4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CRYPTO_PCI_DEVICEID 0x1054</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* VirtIO ABI version, this must match exactly. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_ABI_VERSION 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* VirtIO Header, located in BAR 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_HOST_FEATURES 0 <span class="comment">/* host&#x27;s supported features (32bit, RO)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_GUEST_FEATURES 4 <span class="comment">/* guest&#x27;s supported features (32, RW) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_QUEUE_PFN 8 <span class="comment">/* physical address of VQ (32, RW) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_QUEUE_NUM 12 <span class="comment">/* number of ring entries (16, RO) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_QUEUE_SEL 14 <span class="comment">/* current VQ selection (16, RW) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_QUEUE_NOTIFY 16 <span class="comment">/* notify host regarding VQ (16, RW) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_STATUS 18 <span class="comment">/* device status register (8, RW) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_ISR 19 <span class="comment">/* interrupt status register, reading  also clears the register (8, RO)</span></span></span><br><span class="line"><span class="comment"><span class="meta">*/</span></span></span><br><span class="line"><span class="comment">/* Only if MSIX is enabled: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* configuration change vector (16, RW) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MSI_CONFIG_VECTOR 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* vector for selected VQ notifications */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MSI_QUEUE_VECTOR 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The bit of the ISR which indicates a device has an interrupt. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_ISR_INTR 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The bit of the ISR which indicates a device configuration change. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_ISR_CONFIG 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Vector value used to disable MSI for queue. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MSI_NO_VECTOR 0xFFFF</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Status byte for guest to report progress. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_RESET 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_ACK 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_DRIVER 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_DRIVER_OK 0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_FEATURES_OK 0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_CONFIG_STATUS_FAILED 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Each virtqueue indirect descriptor list must be physically contiguous.</span></span><br><span class="line"><span class="comment">* To allow us to malloc(9) each list individually, limit the number</span></span><br><span class="line"><span class="comment">* supported to what will fit in one page. With 4KB pages, this is a limit</span></span><br><span class="line"><span class="comment">* of 256 descriptors. If there is ever a need for more, we can switch to</span></span><br><span class="line"><span class="comment">* contigmalloc(9) for the larger allocations, similar to what</span></span><br><span class="line"><span class="comment">* bus_dmamem_alloc(9) does.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note the sizeof(struct vring_desc) is 16 bytes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MAX_INDIRECT ((int) (rte_mem_page_size() / 16))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do we get callbacks when the ring is completely used, even if we&#x27;ve</span></span><br><span class="line"><span class="comment">* suppressed them?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_F_NOTIFY_ON_EMPTY 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can the device handle any descriptor layout? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_F_ANY_LAYOUT 27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We support indirect buffer descriptors */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_RING_F_INDIRECT_DESC 28</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_F_VERSION_1 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_F_IOMMU_PLATFORM 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The Guest publishes the used index for which it expects an interrupt</span></span><br><span class="line"><span class="comment">* at the end of the avail ring. Host should ignore the avail-&gt;flags field.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The Host publishes the avail index for which it expects a kick</span></span><br><span class="line"><span class="comment">* at the end of the used ring. Guest should ignore the used-&gt;flags field.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_RING_F_EVENT_IDX 29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common configuration */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_CAP_COMMON_CFG 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notifications */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_CAP_NOTIFY_CFG 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ISR Status */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_CAP_ISR_CFG 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device specific configuration */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_CAP_DEVICE_CFG 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PCI configuration access */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_CAP_PCI_CFG 5</span></span><br></pre></td></tr></table></figure>

<p>上面的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%8F%E5%AE%9A%E4%B9%89&spm=1001.2101.3001.7020">宏定义</a>中，英文的注释已经很明显主要分为：设备控制，设备类型，版本控制，virtio 设备标准，状态配置等等。下面再看一下相关的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the PCI capability header: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> cap_vndr;		<span class="comment">/* Generic PCI field: PCI_CAP_ID_VNDR */</span></span><br><span class="line">	<span class="type">uint8_t</span> cap_next;		<span class="comment">/* Generic PCI field: next ptr. */</span></span><br><span class="line">	<span class="type">uint8_t</span> cap_len;		<span class="comment">/* Generic PCI field: capability length */</span></span><br><span class="line">	<span class="type">uint8_t</span> cfg_type;		<span class="comment">/* Identifies the structure. */</span></span><br><span class="line">	<span class="type">uint8_t</span> bar;			<span class="comment">/* Where to find it. */</span></span><br><span class="line">	<span class="type">uint8_t</span> padding[<span class="number">3</span>];		<span class="comment">/* Pad to full dword. */</span></span><br><span class="line">	<span class="type">uint32_t</span> offset;		<span class="comment">/* Offset within bar. */</span></span><br><span class="line">	<span class="type">uint32_t</span> length;		<span class="comment">/* Length of the structure, in bytes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_notify_cap</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_cap</span> <span class="title">cap</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> notify_off_multiplier;	<span class="comment">/* Multiplier for queue_notify_off. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fields in VIRTIO_PCI_CAP_COMMON_CFG: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_common_cfg</span> &#123;</span></span><br><span class="line">	<span class="comment">/* About the whole device. */</span></span><br><span class="line">	<span class="type">uint32_t</span> device_feature_select;	<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> device_feature;	<span class="comment">/* read-only */</span></span><br><span class="line">	<span class="type">uint32_t</span> guest_feature_select;	<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> guest_feature;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint16_t</span> msix_config;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint16_t</span> num_queues;		<span class="comment">/* read-only */</span></span><br><span class="line">	<span class="type">uint8_t</span> device_status;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint8_t</span> config_generation;	<span class="comment">/* read-only */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* About a specific virtqueue. */</span></span><br><span class="line">	<span class="type">uint16_t</span> queue_select;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint16_t</span> queue_size;		<span class="comment">/* read-write, power of 2. */</span></span><br><span class="line">	<span class="type">uint16_t</span> queue_msix_vector;	<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint16_t</span> queue_enable;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint16_t</span> queue_notify_off;	<span class="comment">/* read-only */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_desc_lo;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_desc_hi;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_avail_lo;	<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_avail_hi;	<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_used_lo;		<span class="comment">/* read-write */</span></span><br><span class="line">	<span class="type">uint32_t</span> queue_used_hi;		<span class="comment">/* read-write */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_ops</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*read_dev_cfg) (<span class="keyword">struct</span> virtio_hw * hw, <span class="type">size_t</span> offset, <span class="type">void</span> * dst, <span class="type">int</span> len);</span><br><span class="line">	<span class="type">void</span> (*write_dev_cfg)(<span class="keyword">struct</span> virtio_hw * hw, <span class="type">size_t</span> offset, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> (*get_status) (<span class="keyword">struct</span> virtio_hw * hw);</span><br><span class="line">	<span class="type">void</span>    (*set_status) (<span class="keyword">struct</span> virtio_hw * hw, <span class="type">uint8_t</span> status);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> (*get_features) (<span class="keyword">struct</span> virtio_hw * hw);</span><br><span class="line">	<span class="type">void</span>     (*set_features) (<span class="keyword">struct</span> virtio_hw * hw, <span class="type">uint64_t</span> features);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> (*get_isr) (<span class="keyword">struct</span> virtio_hw * hw);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> (*set_config_irq) (<span class="keyword">struct</span> virtio_hw * hw, <span class="type">uint16_t</span> vec);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> (*set_queue_irq) (<span class="keyword">struct</span> virtio_hw * hw, <span class="keyword">struct</span> virtqueue * vq, <span class="type">uint16_t</span> vec);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> (*get_queue_num) (<span class="keyword">struct</span> virtio_hw * hw, <span class="type">uint16_t</span> queue_id);</span><br><span class="line">	<span class="type">int</span> (*setup_queue) (<span class="keyword">struct</span> virtio_hw * hw, <span class="keyword">struct</span> virtqueue * vq);</span><br><span class="line">	<span class="type">void</span> (*del_queue) (<span class="keyword">struct</span> virtio_hw * hw, <span class="keyword">struct</span> virtqueue * vq);</span><br><span class="line">	<span class="type">void</span> (*notify_queue) (<span class="keyword">struct</span> virtio_hw * hw, <span class="keyword">struct</span> virtqueue * vq);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_config</span>;</span></span><br><span class="line"><span class="comment">//硬件设备的抽象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_ctl</span> * <span class="title">cvq</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span>    req_guest_features;</span><br><span class="line">	<span class="type">uint64_t</span>    guest_features;</span><br><span class="line">	<span class="type">uint32_t</span>    max_queue_pairs;</span><br><span class="line">	<span class="type">bool</span>        started;</span><br><span class="line">	<span class="type">uint16_t</span>	max_mtu;</span><br><span class="line">	<span class="type">uint16_t</span>    vtnet_hdr_size;</span><br><span class="line">	<span class="type">uint8_t</span>	    vlan_strip;</span><br><span class="line">	<span class="type">uint8_t</span>	    use_msix;</span><br><span class="line">	<span class="type">uint8_t</span>     modern;</span><br><span class="line">	<span class="type">uint8_t</span>     use_simple_rx;</span><br><span class="line">	<span class="type">uint8_t</span>     use_inorder_rx;</span><br><span class="line">	<span class="type">uint8_t</span>     use_inorder_tx;</span><br><span class="line">	<span class="type">uint8_t</span>     weak_barriers;</span><br><span class="line">	<span class="type">bool</span>        has_tx_offload;</span><br><span class="line">	<span class="type">bool</span>        has_rx_offload;</span><br><span class="line">	<span class="type">uint16_t</span>    port_id;</span><br><span class="line">	<span class="type">uint8_t</span>     mac_addr[RTE_ETHER_ADDR_LEN];</span><br><span class="line">	<span class="type">uint32_t</span>    notify_off_multiplier;</span><br><span class="line">	<span class="type">uint8_t</span>     * isr;</span><br><span class="line">	<span class="type">uint16_t</span>    * notify_base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_common_cfg</span> * <span class="title">common_cfg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_config</span> * <span class="title">dev_cfg</span>;</span></span><br><span class="line">	<span class="type">void</span>	    * virtio_user_dev;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * App management thread and virtio interrupt handler thread</span></span><br><span class="line"><span class="comment">	 * both can change device state, this lock is meant to avoid</span></span><br><span class="line"><span class="comment">	 * such a contention.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_spinlock_t</span> state_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> ** <span class="title">inject_pkts</span>;</span></span><br><span class="line">	<span class="type">bool</span>        opened;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> ** <span class="title">vqs</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While virtio_hw is stored in shared memory, this structure stores</span></span><br><span class="line"><span class="comment"> * some infos that may vary in the multiple process model locally.</span></span><br><span class="line"><span class="comment"> * For example, the vtpci_ops pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw_internal</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_ops</span> * <span class="title">vtpci_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_ioport</span> <span class="title">io</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VTPCI_OPS(hw)	(virtio_hw_internal[(hw)-&gt;port_id].vtpci_ops)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VTPCI_IO(hw)	(&amp;virtio_hw_internal[(hw)-&gt;port_id].io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw_internal</span> <span class="title">virtio_hw_internal</span>[<span class="title">RTE_MAX_ETHPORTS</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is just a reference to read</span></span><br><span class="line"><span class="comment"> * net device specific config space; it just a chodu structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_config</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The config defining mac address (if VIRTIO_NET_F_MAC) */</span></span><br><span class="line">	<span class="type">uint8_t</span>    mac[RTE_ETHER_ADDR_LEN];</span><br><span class="line">	<span class="comment">/* See VIRTIO_NET_F_STATUS and VIRTIO_NET_S_* above */</span></span><br><span class="line">	<span class="type">uint16_t</span>   status;</span><br><span class="line">	<span class="type">uint16_t</span>   max_virtqueue_pairs;</span><br><span class="line">	<span class="type">uint16_t</span>   mtu;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * How many bits to shift physical queue address written to QUEUE_PFN.</span></span><br><span class="line"><span class="comment"> * 12 is historical, and due to x86 page size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_QUEUE_ADDR_SHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The alignment to use between consumer and producer parts of vring. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_PCI_VRING_ALIGN 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">virtio_msix_status</span> &#123;</span></span><br><span class="line">	VIRTIO_MSIX_NONE = <span class="number">0</span>,</span><br><span class="line">	VIRTIO_MSIX_DISABLED = <span class="number">1</span>,</span><br><span class="line">	VIRTIO_MSIX_ENABLED = <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实有过驱动开发经验的可以比较容易的看出，抽象出来的 PCI 设备，要有描述其设备功能的数据结构体，也有要有相关配置的结构体，对硬件设备的映射以及具体操作的数据结构体封装的函数指针。<br>在读 Linux 内核代码的过程中，可以发现基本上这类数据结构体，都包含描述数据结构体，配置结构体和操作函数指针结构体。可能再辅助一些相关的数据内容结构体，通过上面的代码可以再次印证这一点。</p>
<h3 id="PCI-设备简介"><a href="#PCI-设备简介" class="headerlink" title="PCI 设备简介"></a>PCI 设备简介</h3><p>这一部分的主要功能其实就是对硬件到抽象的一次抽象，特别是在计算机设备的发展过程中，经历了各种总线的出现和共存，到现在发展到 PCI 总线。换句话说，现在的很多设备都支持在 PCI 总线上的挂载。通过抽象的 PCI 总线设备支持就可以对 DPDK 中支持的包括存储、网络等进行统一的支持。使得整个设备的管理更方便，更容易扩展新的设备。DPDK 既然是直接从设备到应用层，也不能脱离这个框架，这就是这一层的主要作用。<br>PCI 设备有自己的配置空间，所以在 DPDK 的定义中也要有相关的配置定义（包括宏和数据结构体），每个 PCI 设备由最多 6 个 BAR 寄存器组成，在此设备出厂时，其相关的地址及 offset 就已经在硬件上固定写好。PCI 设备在整个管理层维护着一个 PCI 设备链表，这也是在数据结构体中可以看到的设备地址、ID、BAR 的物理地址和中断地址及其相关的驱动。<br>更加详细的匹配说明可以参看相关 PCI 设备的资料和书籍。</p>
<h3 id="PCI-设备发现基本流程"><a href="#PCI-设备发现基本流程" class="headerlink" title="PCI 设备发现基本流程"></a>PCI 设备发现基本流程</h3><p>在上面提到了，本层主要是进行 PCI 设备的发现注册和挂载等流程，看一下相关的源码：<br>1、发现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drvice/bus/pci/pci_common.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_bus</span> <span class="title">rte_pci_bus</span> =</span> &#123;</span><br><span class="line">	.bus = &#123;</span><br><span class="line">		.scan = rte_pci_scan,</span><br><span class="line">		.probe = pci_probe,</span><br><span class="line">		.find_device = pci_find_device,</span><br><span class="line">		.plug = pci_plug,</span><br><span class="line">		.unplug = pci_unplug,</span><br><span class="line">		.parse = pci_parse,</span><br><span class="line">		.dma_map = pci_dma_map,</span><br><span class="line">		.dma_unmap = pci_dma_unmap,</span><br><span class="line">		.get_iommu_class = rte_pci_get_iommu_class,</span><br><span class="line">		.dev_iterate = rte_pci_dev_iterate,</span><br><span class="line">		.hot_unplug_handler = pci_hot_unplug_handler,</span><br><span class="line">		.sigbus_handler = pci_sigbus_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	.device_list = TAILQ_HEAD_INITIALIZER(rte_pci_bus.device_list),</span><br><span class="line">	.driver_list = TAILQ_HEAD_INITIALIZER(rte_pci_bus.driver_list),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RTE_REGISTER_BUS(pci, rte_pci_bus.bus);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pci.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scan the content of the PCI bus, and the devices in the devices</span></span><br><span class="line"><span class="comment"> * list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_pci_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">e</span>;</span></span><br><span class="line">	DIR * dir;</span><br><span class="line">	<span class="type">char</span> dirname[PATH_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for debug purposes, PCI can be disabled */</span></span><br><span class="line">	<span class="keyword">if</span> (!rte_eal_has_pci())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VFIO_PRESENT</span></span><br><span class="line">	<span class="keyword">if</span> (!pci_vfio_is_enabled())</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;VFIO PCI modules not loaded\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	dir = opendir(rte_pci_get_sysfs_path());</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): opendir failed: %s\n&quot;</span>,</span><br><span class="line">			__func__, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((e = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (parse_pci_addr_format(e-&gt;d_name, <span class="keyword">sizeof</span>(e-&gt;d_name), &amp;addr) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(dirname, <span class="keyword">sizeof</span>(dirname), <span class="string">&quot;%s/%s&quot;</span>,</span><br><span class="line">				rte_pci_get_sysfs_path(), e-&gt;d_name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pci_scan_one(dirname, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	closedir(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Linux 中一切都是文件，所以可以看到上面的代码先是判断指定路径上（&#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices）有没有相关的 PCI 设备，有的话开始遍历读取。而 pci_scan_one 就是将 PCI 设备目录下的文件读取出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Scan one pci sysfs entry, and fill the devices list from it. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_scan_one</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * dirname, <span class="type">const</span> <span class="keyword">struct</span> rte_pci_addr * addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> filename[PATH_MAX];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_device</span> * <span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">char</span> driver[PATH_MAX];</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	dev = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line">	<span class="keyword">if</span> (dev == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">	dev-&gt;device.bus = &amp;rte_pci_bus.bus;</span><br><span class="line">	dev-&gt;addr = *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get vendor id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/vendor&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.vendor_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get device id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/device&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.device_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get subsystem_vendor id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/subsystem_vendor&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.subsystem_vendor_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get subsystem_device id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/subsystem_device&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.subsystem_device_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get class_id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/class&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* the least 24 bits are valid: class, subclass, program interface */</span></span><br><span class="line">	dev-&gt;id.class_id = (<span class="type">uint32_t</span>)tmp &amp; RTE_CLASS_ANY_ID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get max_vfs */</span></span><br><span class="line">	dev-&gt;max_vfs = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/max_vfs&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (!access(filename, F_OK) &amp;&amp;</span><br><span class="line">	    eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">		dev-&gt;max_vfs = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* for non igb_uio driver, need kernel version &gt;= 3.8 */</span></span><br><span class="line">		<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename),</span><br><span class="line">			 <span class="string">&quot;%s/sriov_numvfs&quot;</span>, dirname);</span><br><span class="line">		<span class="keyword">if</span> (!access(filename, F_OK) &amp;&amp;</span><br><span class="line">		    eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">			dev-&gt;max_vfs = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get numa node, default to 0 if not present */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/numa_node&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (access(filename, F_OK) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">			dev-&gt;device.numa_node = tmp;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev-&gt;device.numa_node = <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;device.numa_node = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pci_name_set(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse resources */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/resource&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (pci_parse_sysfs_resource(filename, dev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): cannot parse resource\n&quot;</span>, __func__);</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse driver */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/driver&quot;</span>, dirname);</span><br><span class="line">	ret = pci_get_kernel_driver_by_path(filename, driver, <span class="keyword">sizeof</span>(driver));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Fail to get kernel driver\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;vfio-pci&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_VFIO;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;igb_uio&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_IGB_UIO;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;uio_pci_generic&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_UIO_GENERIC;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_UNKNOWN;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		dev-&gt;kdrv = RTE_KDRV_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* device is valid, add in list (sorted) */</span></span><br><span class="line">	<span class="keyword">if</span> (TAILQ_EMPTY(&amp;rte_pci_bus.device_list)) &#123;</span><br><span class="line">		rte_pci_add_device(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> rte_pci_device * dev2;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		TAILQ_FOREACH(dev2, &amp;rte_pci_bus.device_list, next) &#123;</span><br><span class="line">			ret = rte_pci_addr_cmp(&amp;dev-&gt;addr, &amp;dev2-&gt;addr);</span><br><span class="line">			<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				rte_pci_insert_device(dev2, dev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* already registered */</span></span><br><span class="line">				<span class="keyword">if</span> (!rte_dev_is_probed(&amp;dev2-&gt;device)) &#123;</span><br><span class="line">					dev2-&gt;kdrv = dev-&gt;kdrv;</span><br><span class="line">					dev2-&gt;max_vfs = dev-&gt;max_vfs;</span><br><span class="line">					pci_name_set(dev2);</span><br><span class="line">					memmove(dev2-&gt;mem_resource,</span><br><span class="line">						dev-&gt;mem_resource,</span><br><span class="line">						<span class="keyword">sizeof</span>(dev-&gt;mem_resource));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					 * If device is plugged and driver is</span></span><br><span class="line"><span class="comment">					 * probed already, (This happens when</span></span><br><span class="line"><span class="comment">					 * we call rte_dev_probe which will</span></span><br><span class="line"><span class="comment">					 * scan all device on the bus) we don&#x27;t</span></span><br><span class="line"><span class="comment">					 * need to do anything here unless...</span></span><br><span class="line"><span class="comment">					 **/</span></span><br><span class="line">					<span class="keyword">if</span> (dev2-&gt;kdrv != dev-&gt;kdrv ||</span><br><span class="line">						dev2-&gt;max_vfs != dev-&gt;max_vfs)</span><br><span class="line">						<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 * This should not happens.</span></span><br><span class="line"><span class="comment">						 * But it is still possible if</span></span><br><span class="line"><span class="comment">						 * we unbind a device from</span></span><br><span class="line"><span class="comment">						 * vfio or uio before hotplug</span></span><br><span class="line"><span class="comment">						 * remove and rebind it with</span></span><br><span class="line"><span class="comment">						 * a different configure.</span></span><br><span class="line"><span class="comment">						 * So we just print out the</span></span><br><span class="line"><span class="comment">						 * error as an alarm.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						RTE_LOG(ERR, EAL, <span class="string">&quot;Unexpected device scan at %s!\n&quot;</span>,</span><br><span class="line">							filename);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (dev2-&gt;device.devargs !=</span><br><span class="line">						 dev-&gt;device.devargs) &#123;</span><br><span class="line">						rte_devargs_remove(dev2-&gt;device.devargs);</span><br><span class="line">						pci_name_set(dev2);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">free</span>(dev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rte_pci_add_device(dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 pci_parse_sysfs_resource 就是用来读取 PCI 设备中的 bar 寄存器映射后的物理空间地址，然后再将其设备以地址大小顺序插入到 List 中。<br>2、 探测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If vendor/device ID match, call the probe() function of all</span></span><br><span class="line"><span class="comment"> * registered driver for the given device. Return &lt; 0 if initialization</span></span><br><span class="line"><span class="comment"> * failed, return 1 if no driver is found for this device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_probe_all_drivers</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_driver</span> *<span class="title">dr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	FOREACH_DRIVER_ON_PCIBUS(dr) &#123;</span><br><span class="line">		rc = rte_pci_probe_one_driver(dr, dev);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">/* negative value is an error */</span></span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line">		<span class="keyword">if</span> (rc &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">/* positive value means driver doesn&#x27;t support it */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scan the content of the PCI bus, and call the probe() function for</span></span><br><span class="line"><span class="comment"> * all registered drivers that have a matching entry in its id_table</span></span><br><span class="line"><span class="comment"> * for discovered devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_probe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_device</span> *<span class="title">dev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> probed = <span class="number">0</span>, failed = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_devargs</span> *<span class="title">devargs</span>;</span></span><br><span class="line">	<span class="type">int</span> probe_all = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_pci_bus.bus.conf.scan_mode != RTE_BUS_SCAN_WHITELIST) &#123;</span><br><span class="line">		probe_all = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOREACH_DEVICE_ON_PCIBUS(dev) &#123;</span><br><span class="line">		probed++;</span><br><span class="line"></span><br><span class="line">		devargs = dev-&gt;device.devargs;</span><br><span class="line">		<span class="comment">/* probe all or only whitelisted devices */</span></span><br><span class="line">		<span class="keyword">if</span> (probe_all)</span><br><span class="line">			ret = pci_probe_all_drivers(dev);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (devargs != <span class="literal">NULL</span> &amp;&amp; devargs-&gt;policy == RTE_DEV_WHITELISTED)</span><br><span class="line">			ret = pci_probe_all_drivers(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ret != -EEXIST) &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL, <span class="string">&quot;Requested device &quot;</span></span><br><span class="line">					PCI_PRI_FMT <span class="string">&quot; cannot be used\n&quot;</span>,</span><br><span class="line">					dev-&gt;addr.domain, dev-&gt;addr.bus,</span><br><span class="line">					dev-&gt;addr.devid, dev-&gt;addr.function);</span><br><span class="line">				rte_errno = errno;</span><br><span class="line">				failed++;</span><br><span class="line">			&#125;</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (probed &amp;&amp; probed == failed) ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码如果有内核开发经验或者阅读过内核源码的应该很清楚。</p>
<p>3、注册<br>注册的相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib\librte_eal\common\include\rte_dev.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A structure describing a device driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_driver</span> &#123;</span></span><br><span class="line">	TAILQ_ENTRY(rte_driver) next;  <span class="comment">/**&lt; Next in list. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                   <span class="comment">/**&lt; Driver name. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *alias;              <span class="comment">/**&lt; Driver alias. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /drviers/bus/pci/pci_common.c  rte_pci_bus.h</span></span><br><span class="line"><span class="comment">/* register a driver */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rte_pci_register</span><span class="params">(<span class="keyword">struct</span> rte_pci_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;rte_pci_bus.driver_list, driver, next);</span><br><span class="line">	driver-&gt;bus = &amp;rte_pci_bus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_PMD_REGISTER_PCI(nm, pci_drv) \</span></span><br><span class="line"><span class="meta">RTE_INIT(pciinitfn_ ##nm) \</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">	(pci_drv).driver.name = RTE_STR(nm);\</span></span><br><span class="line"><span class="meta">	rte_pci_register(&amp;pci_drv); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">RTE_PMD_EXPORT_NAME(nm, __COUNTER__)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure describing the PCI bus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_bus</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_bus</span> <span class="title">bus</span>;</span>               <span class="comment">/**&lt; Inherit the generic class */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_device_list</span> <span class="title">device_list</span>;</span>  <span class="comment">/**&lt; List of PCI devices */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_driver_list</span> <span class="title">driver_list</span>;</span>  <span class="comment">/**&lt; List of PCI drivers */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_bus</span> <span class="title">rte_pci_bus</span> =</span> &#123;</span><br><span class="line">	.bus = &#123;</span><br><span class="line">		.scan = rte_pci_scan,</span><br><span class="line">		.probe = pci_probe,</span><br><span class="line">		.find_device = pci_find_device,</span><br><span class="line">		.plug = pci_plug,</span><br><span class="line">		.unplug = pci_unplug,</span><br><span class="line">		.parse = pci_parse,</span><br><span class="line">		.dma_map = pci_dma_map,</span><br><span class="line">		.dma_unmap = pci_dma_unmap,</span><br><span class="line">		.get_iommu_class = rte_pci_get_iommu_class,</span><br><span class="line">		.dev_iterate = rte_pci_dev_iterate,</span><br><span class="line">		.hot_unplug_handler = pci_hot_unplug_handler,</span><br><span class="line">		.sigbus_handler = pci_sigbus_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	.device_list = TAILQ_HEAD_INITIALIZER(rte_pci_bus.device_list),</span><br><span class="line">	.driver_list = TAILQ_HEAD_INITIALIZER(rte_pci_bus.driver_list),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它们最终会变换到实际的设备链表如下面的网卡：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/net/e1000/igb_ethdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_driver</span> <span class="title">rte_igb_pmd</span> =</span> &#123;</span><br><span class="line">	.id_table = pci_id_igb_map,</span><br><span class="line">	.drv_flags = RTE_PCI_DRV_NEED_MAPPING | RTE_PCI_DRV_INTR_LSC,</span><br><span class="line">	.probe = eth_igb_pci_probe,</span><br><span class="line">	.remove = eth_igb_pci_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述转换的方式是使用宏 RTE_PMD_REGISTER_PCI(net_e1000_igb, rte_igb_pmd)（drivers&#x2F;net&#x2F;e1000&#x2F;igb_ethdev.c）</p>
<p>4、映射地址<br>上面提到了读取文件后要进行物理空间的映射，在下面的代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pci_comon_uio.c</span></span><br><span class="line"><span class="comment">/* Map pci device */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_pci_map_device</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try mapping the NIC resources */</span></span><br><span class="line">	<span class="keyword">switch</span> (dev-&gt;kdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> RTE_KDRV_NIC_UIO:</span><br><span class="line">		<span class="comment">/* map resources for devices that use uio */</span></span><br><span class="line">		ret = pci_uio_map_resource(dev);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		RTE_LOG(DEBUG, EAL,</span><br><span class="line">			<span class="string">&quot;  Not managed by a supported kernel driver, skipped\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* map the PCI resource of a PCI device in virtual memory */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_uio_map_resource</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, map_idx = <span class="number">0</span>, ret;</span><br><span class="line">	<span class="type">uint64_t</span> phaddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapped_pci_resource</span> * <span class="title">uio_res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapped_pci_res_list</span> * <span class="title">uio_res_list</span> =</span></span><br><span class="line">		RTE_TAILQ_CAST(rte_uio_tailq.head, mapped_pci_res_list);</span><br><span class="line"></span><br><span class="line">	dev-&gt;intr_handle.fd = <span class="number">-1</span>;</span><br><span class="line">	dev-&gt;intr_handle.uio_cfg_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* secondary processes - use already recorded details */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() != RTE_PROC_PRIMARY)</span><br><span class="line">		<span class="keyword">return</span> pci_uio_map_secondary(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate uio resource */</span></span><br><span class="line">	ret = pci_uio_alloc_resource(dev, &amp;uio_res);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Map all BARs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i != PCI_MAX_RESOURCE; i++) &#123;</span><br><span class="line">		<span class="comment">/* skip empty BAR */</span></span><br><span class="line">		phaddr = dev-&gt;mem_resource[i].phys_addr;</span><br><span class="line">		<span class="keyword">if</span> (phaddr == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		ret = pci_uio_map_resource_by_index(dev, i,</span><br><span class="line">				uio_res, map_idx);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		map_idx++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uio_res-&gt;nb_maps = map_idx;</span><br><span class="line"></span><br><span class="line">	TAILQ_INSERT_TAIL(uio_res_list, uio_res, next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; map_idx; i++) &#123;</span><br><span class="line">		pci_unmap_resource(uio_res-&gt;maps[i].addr,</span><br><span class="line">				(<span class="type">size_t</span>)uio_res-&gt;maps[i].size);</span><br><span class="line">		rte_free(uio_res-&gt;maps[i].path);</span><br><span class="line">	&#125;</span><br><span class="line">	pci_uio_free_resource(dev, uio_res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、virtio 中的相关函数<br>这里看一下在前面的 virtio 中的相关函数实现：<br>先看一下原来的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/virtio_pci.h</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function declaration from virtio_pci.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vtpci_init</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev, <span class="keyword">struct</span> virtio_hw *hw)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vtpci_reset</span><span class="params">(<span class="keyword">struct</span> virtio_hw *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vtpci_reinit_complete</span><span class="params">(<span class="keyword">struct</span> virtio_hw *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">vtpci_get_status</span><span class="params">(<span class="keyword">struct</span> virtio_hw *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vtpci_set_status</span><span class="params">(<span class="keyword">struct</span> virtio_hw *, <span class="type">uint8_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">vtpci_negotiate_features</span><span class="params">(<span class="keyword">struct</span> virtio_hw *, <span class="type">uint64_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vtpci_write_dev_config</span><span class="params">(<span class="keyword">struct</span> virtio_hw *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vtpci_read_dev_config</span><span class="params">(<span class="keyword">struct</span> virtio_hw *, <span class="type">size_t</span>, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">vtpci_isr</span><span class="params">(<span class="keyword">struct</span> virtio_hw *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> virtio_msix_status <span class="title function_">vtpci_msix_detect</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev)</span>;</span><br></pre></td></tr></table></figure>

<p>然后看一下调用及实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is based on probe() function in virtio_pci.c</span></span><br><span class="line"><span class="comment"> * It returns 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eth_virtio_dev_init</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev *eth_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> *<span class="title">hw</span> =</span> eth_dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf) &gt; RTE_PKTMBUF_HEADROOM) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Not sufficient headroom required = %d, avail = %d&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf),</span><br><span class="line">			RTE_PKTMBUF_HEADROOM);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eth_dev-&gt;dev_ops = &amp;virtio_eth_dev_ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_SECONDARY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">			ret = virtio_remap_pci(RTE_ETH_DEV_TO_PCI(eth_dev), hw);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		virtio_set_vtpci_ops(hw);</span><br><span class="line">		set_rxtx_funcs(eth_dev);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pass the information to the rte_eth_dev_close() that it should also</span></span><br><span class="line"><span class="comment">	 * release the private port resources.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	eth_dev-&gt;data-&gt;dev_flags |= RTE_ETH_DEV_CLOSE_REMOVE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate memory for storing MAC addresses */</span></span><br><span class="line">	eth_dev-&gt;data-&gt;mac_addrs = rte_zmalloc(<span class="string">&quot;virtio&quot;</span>,</span><br><span class="line">				VIRTIO_MAX_MAC_ADDRS * RTE_ETHER_ADDR_LEN, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (eth_dev-&gt;data-&gt;mac_addrs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Failed to allocate %d bytes needed to store MAC addresses&quot;</span>,</span><br><span class="line">			VIRTIO_MAX_MAC_ADDRS * RTE_ETHER_ADDR_LEN);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hw-&gt;port_id = eth_dev-&gt;data-&gt;port_id;</span><br><span class="line">	<span class="comment">/* For virtio_user case the hw-&gt;virtio_user_dev is populated by</span></span><br><span class="line"><span class="comment">	 * virtio_user_eth_dev_alloc() before eth_virtio_dev_init() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">		ret = vtpci_init(RTE_ETH_DEV_TO_PCI(eth_dev), hw);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_vtpci_init;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_init(&amp;hw-&gt;state_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reset device and negotiate default features */</span></span><br><span class="line">	ret = virtio_init_device(eth_dev, VIRTIO_PMD_DEFAULT_GUEST_FEATURES);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_virtio_init;</span><br><span class="line"></span><br><span class="line">	hw-&gt;opened = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_virtio_init:</span><br><span class="line">	<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">		rte_pci_unmap_device(RTE_ETH_DEV_TO_PCI(eth_dev));</span><br><span class="line">		<span class="keyword">if</span> (!hw-&gt;modern)</span><br><span class="line">			rte_pci_ioport_unmap(VTPCI_IO(hw));</span><br><span class="line">	&#125;</span><br><span class="line">err_vtpci_init:</span><br><span class="line">	rte_free(eth_dev-&gt;data-&gt;mac_addrs);</span><br><span class="line">	eth_dev-&gt;data-&gt;mac_addrs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数会调用 vtpci_init 这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return -1:</span></span><br><span class="line"><span class="comment"> *   if there is error mapping with VFIO/UIO.</span></span><br><span class="line"><span class="comment"> *   if port map error when driver type is KDRV_NONE.</span></span><br><span class="line"><span class="comment"> *   if whitelisted but driver type is KDRV_UNKNOWN.</span></span><br><span class="line"><span class="comment"> * Return 1 if kernel driver is managing the device.</span></span><br><span class="line"><span class="comment"> * Return 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vtpci_init</span><span class="params">(<span class="keyword">struct</span> rte_pci_device *dev, <span class="keyword">struct</span> virtio_hw *hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try if we can succeed reading virtio pci caps, which exists</span></span><br><span class="line"><span class="comment">	 * only on modern pci device. If failed, we fallback to legacy</span></span><br><span class="line"><span class="comment">	 * virtio handling.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (virtio_read_caps(dev, hw) == <span class="number">0</span>) &#123;</span><br><span class="line">		PMD_INIT_LOG(INFO, <span class="string">&quot;modern virtio pci detected.&quot;</span>);</span><br><span class="line">		virtio_hw_internal[hw-&gt;port_id].vtpci_ops = &amp;modern_ops;</span><br><span class="line">		hw-&gt;modern = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_LOG(INFO, <span class="string">&quot;trying with legacy virtio pci.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (rte_pci_ioport_map(dev, <span class="number">0</span>, VTPCI_IO(hw)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_pci_unmap_device(dev);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;kdrv == RTE_KDRV_UNKNOWN &amp;&amp;</span><br><span class="line">		    (!dev-&gt;device.devargs ||</span><br><span class="line">		     dev-&gt;device.devargs-&gt;bus !=</span><br><span class="line">		     rte_bus_find_by_name(<span class="string">&quot;pci&quot;</span>))) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO,</span><br><span class="line">				<span class="string">&quot;skip kernel managed virtio device.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	virtio_hw_internal[hw-&gt;port_id].vtpci_ops = &amp;legacy_ops;</span><br><span class="line">	hw-&gt;modern = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要要区分 legacy 和 modern 两个不同的版本，前者是在 virtio0.95 中，后者在 virtio1.0 及以后中。<br>其它的几个函数也比较简单，可以对应着看一下源码即可。</p>
<h1 id="vring基础数据结构"><a href="#vring基础数据结构" class="headerlink" title="vring基础数据结构"></a>vring基础数据结构</h1><p>在 virtio 中，中间层的数据管理是一个重点，前期的文章中提到的相关的队列和缓冲区就是最典型的数据结构即 vring,virtqueue。它们两个定义在 virtio_ring.h 和 virqueue.h 这两个文件。下面看一看与其相关的定义代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VirtIO ring descriptors: 16 bytes.</span></span><br><span class="line"><span class="comment"> * These can chain together via &quot;next&quot;. */</span></span><br><span class="line"> <span class="comment">// 描述符主要用于对客户端一侧的数据缓冲，用来提供client和host的数据传递，请注意next，这是一个链表用来包含多个此类缓冲</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_desc</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> addr;  <span class="comment">/*  Address (guest-physical). */</span></span><br><span class="line">	<span class="type">uint32_t</span> len;   <span class="comment">/* Length. */</span></span><br><span class="line">	<span class="type">uint16_t</span> flags; <span class="comment">/* The flags as indicated above. */</span></span><br><span class="line">	<span class="type">uint16_t</span> next;  <span class="comment">/* We chain unused descriptors via this. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据标记</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_avail</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">	<span class="type">uint16_t</span> idx;</span><br><span class="line">	<span class="type">uint16_t</span> ring[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* id is a 16bit index. uint32_t is used here for ids for padding reasons. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_used_elem</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Index of start of used descriptor chain. */</span></span><br><span class="line">	<span class="type">uint32_t</span> id;</span><br><span class="line">	<span class="comment">/* Total length of the descriptor chain which was written to. */</span></span><br><span class="line">	<span class="type">uint32_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vring已使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_used</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint16_t</span> idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_used_elem</span> <span class="title">ring</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For support of packed virtqueues in Virtio 1.1 the format of descriptors</span></span><br><span class="line"><span class="comment"> * looks like this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> addr;</span><br><span class="line">	<span class="type">uint32_t</span> len;</span><br><span class="line">	<span class="type">uint16_t</span> id;</span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_EVENT_FLAGS_ENABLE 0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_EVENT_FLAGS_DISABLE 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_EVENT_FLAGS_DESC 0x2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> desc_event_off_wrap;</span><br><span class="line">	<span class="type">uint16_t</span> desc_event_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> * <span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> * <span class="title">driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> * <span class="title">device</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// vring其实是把上述的数据结构代码合并，即packed ring (1.1版本后实现)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_desc</span>  * <span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_avail</span> * <span class="title">avail</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_used</span>  * <span class="title">used</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码是 vring 的数据结构，在 virtio1.1 以前，几个 ring(desc,avail,used) 是分开的，在 1.1 以后，合在一起。也叫 packed ring, 而以前的则称呼为 split ring.<br>再看一下 virqueue 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_ctrl_hdr</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="type">uint8_t</span> cmd;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> virtio_net_ctrl_ack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_NET_OK     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_NET_ERR    1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MAX_CTRL_DATA 2048</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pmd_ctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_ctrl_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">	virtio_net_ctrl_ack status;</span><br><span class="line">	<span class="type">uint8_t</span> data[VIRTIO_MAX_CTRL_DATA];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vq_desc_extra</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *cookie;</span><br><span class="line">	<span class="type">uint16_t</span> ndescs;</span><br><span class="line">	<span class="type">uint16_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span>  *<span class="title">hw</span>;</span> <span class="comment">/**&lt; virtio_hw structure pointer. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/**&lt; vring keeping desc, used and avail */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vring</span> <span class="title">ring</span>;</span></span><br><span class="line">		&#125; vq_split;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/**&lt; vring keeping descs and events */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed</span> <span class="title">ring</span>;</span></span><br><span class="line">			<span class="type">bool</span> used_wrap_counter;</span><br><span class="line">			<span class="type">uint16_t</span> cached_flags; <span class="comment">/**&lt; cached flags for descs */</span></span><br><span class="line">			<span class="type">uint16_t</span> event_flags_shadow;</span><br><span class="line">		&#125; vq_packed;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> vq_used_cons_idx; <span class="comment">/**&lt; last consumed descriptor */</span></span><br><span class="line">	<span class="type">uint16_t</span> vq_nentries;  <span class="comment">/**&lt; vring desc numbers */</span></span><br><span class="line">	<span class="type">uint16_t</span> vq_free_cnt;  <span class="comment">/**&lt; num of desc available */</span></span><br><span class="line">	<span class="type">uint16_t</span> vq_avail_idx; <span class="comment">/**&lt; sync until needed */</span></span><br><span class="line">	<span class="type">uint16_t</span> vq_free_thresh; <span class="comment">/**&lt; free threshold */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *vq_ring_virt_mem;  <span class="comment">/**&lt; linear address of vring*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vq_ring_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据的类型，收，发或者控制</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_rx</span> <span class="title">rxq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_tx</span> <span class="title">txq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_ctl</span> <span class="title">cq</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">rte_iova_t</span> vq_ring_mem; <span class="comment">/**&lt; physical address of vring,</span></span><br><span class="line"><span class="comment">	                         * or virtual address for virtio_user. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Head of the free chain in the descriptor table. If</span></span><br><span class="line"><span class="comment">	 * there are no free descriptors, this will be set to</span></span><br><span class="line"><span class="comment">	 * VQ_RING_DESC_CHAIN_END.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span>  vq_desc_head_idx;</span><br><span class="line">	<span class="type">uint16_t</span>  vq_desc_tail_idx;</span><br><span class="line">	<span class="type">uint16_t</span>  vq_queue_index;   <span class="comment">/**&lt; PCI queue index */</span></span><br><span class="line">	<span class="type">uint16_t</span> offset; <span class="comment">/**&lt; relative offset to obtain addr in mbuf */</span></span><br><span class="line">	<span class="type">uint16_t</span>  *notify_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> **<span class="title">sw_ring</span>;</span>  <span class="comment">/**&lt; RX software ring. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vq_desc_extra</span> <span class="title">vq_descx</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实通过上述的代码可以看出队列中包含有 vring 这个数据结构，vring 是一个环形的读写空间。在实际的运行中，Client 把 Buffers 插入到这个队列中，而队列会根据不同设备安排不同的数量，一般来说，网络设备有两个队列，即用于收和发两种数据类型。</p>
<h3 id="vring主要功能"><a href="#vring主要功能" class="headerlink" title="vring主要功能"></a>vring主要功能</h3><p>在上面的分析中，知道了 split ring 和 packed ring，它们都是用来做为前后端数据交互的数据结构，在实际的运行的过程中，通过其产生的结构体对象形成的队列及队列内的环形缓冲区，通过级联式的内存缓冲和复制来保证数据的安全性相关的数据传输的效率。<br>不同之处在于，Split Ring 由于是分离的，所以其数据结构在 virtq 中是要求严格有序的。其代理的一些缓冲区及内存数组部分需要使用相关 ID 来操作，标记结构也比较少；而在 Packed Ring 中，由于三个 Ring 合在一起，增加了 Flag 的相关标记值，去除了 next 字段，同时，增加了 Buffer ID，对 entries 支持进行了增强。而且，Packed Ring 还更容易增加与硬件的亲和性并更好的利用 Cache。</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>在源码中先看一下处理的分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/librte_vhost/virtio_net.c</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">virtio_dev_rx</span><span class="params">(<span class="keyword">struct</span> virtio_net *dev, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_mbuf **pkts, <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> * <span class="title">vq</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> nb_tx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处代码即用来判断是否为Packed Ring</span></span><br><span class="line">	<span class="keyword">if</span> (vq_is_packed(dev))</span><br><span class="line">		nb_tx = virtio_dev_rx_packed(dev, vq, pkts, count);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		nb_tx = virtio_dev_rx_split(dev, vq, pkts, count);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;features &amp; (<span class="number">1ULL</span> &lt;&lt; VIRTIO_F_IOMMU_PLATFORM))</span><br><span class="line">		vhost_user_iotlb_rd_unlock(vq);</span><br><span class="line"></span><br><span class="line">out_access_unlock:</span><br><span class="line">	rte_spinlock_unlock(&amp;vq-&gt;access_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_tx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，不同的设备状态会引起不同的操作函数来处理，这也是一种兼容的方式。下面看一下两种处理方式的具体的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_noinline <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">virtio_dev_rx_packed</span><span class="params">(<span class="keyword">struct</span> virtio_net *dev,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> vhost_virtqueue *vq,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> rte_mbuf **pkts,</span></span><br><span class="line"><span class="params">		     <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pkt_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> remained = count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//处理缓冲区拷贝mbuf</span></span><br><span class="line">		rte_prefetch0(&amp;vq-&gt;desc_packed[vq-&gt;last_avail_idx]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (remained &gt;= PACKED_BATCH_SIZE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!virtio_dev_rx_batch_packed(dev, vq, &amp;pkts[pkt_idx])) &#123;</span><br><span class="line">				pkt_idx += PACKED_BATCH_SIZE;</span><br><span class="line">				remained -= PACKED_BATCH_SIZE;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理数据填充</span></span><br><span class="line">		<span class="keyword">if</span> (virtio_dev_rx_single_packed(dev, vq, pkts[pkt_idx]))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		pkt_idx++;</span><br><span class="line">		remained--;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pkt_idx &lt; count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vq-&gt;shadow_used_idx) &#123;</span><br><span class="line">		do_data_copy_enqueue(dev, vq);<span class="comment">//小数据处理</span></span><br><span class="line">		vhost_flush_enqueue_shadow_packed(dev, vq);<span class="comment">//更新used ring</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pkt_idx)</span><br><span class="line">		vhost_vring_call_packed(dev, vq);<span class="comment">//kick前端</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pkt_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>split ring 的处理代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_noinline <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">virtio_dev_rx_split</span><span class="params">(<span class="keyword">struct</span> virtio_net *dev, <span class="keyword">struct</span> vhost_virtqueue *vq,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_mbuf **pkts, <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pkt_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint16_t</span> num_buffers;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buf_vector</span> <span class="title">buf_vec</span>[<span class="title">BUF_VECTOR_MAX</span>];</span></span><br><span class="line">	<span class="type">uint16_t</span> avail_head;</span><br><span class="line"></span><br><span class="line">	avail_head = * ((<span class="keyword">volatile</span> <span class="type">uint16_t</span> * )&amp;vq-&gt;avail-&gt;idx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The ordering between avail index and</span></span><br><span class="line"><span class="comment">	 * desc reads needs to be enforced.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rte_smp_rmb();</span><br><span class="line"></span><br><span class="line">	rte_prefetch0(&amp;vq-&gt;avail-&gt;ring[vq-&gt;last_avail_idx &amp; (vq-&gt;size - <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pkt_idx = <span class="number">0</span>; pkt_idx &lt; count; pkt_idx++) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> pkt_len = pkts[pkt_idx]-&gt;pkt_len + dev-&gt;vhost_hlen;</span><br><span class="line">		<span class="type">uint16_t</span> nr_vec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前avail desc是否满足拷贝mbuf的需求</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(reserve_avail_buf_split(dev, vq,</span><br><span class="line">						pkt_len, buf_vec, &amp;num_buffers,</span><br><span class="line">						avail_head, &amp;nr_vec) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">			VHOST_LOG_DEBUG(VHOST_DATA,</span><br><span class="line">				<span class="string">&quot;(%d) failed to get enough desc from vring\n&quot;</span>,</span><br><span class="line">				dev-&gt;vid);</span><br><span class="line">			vq-&gt;shadow_used_idx -= num_buffers;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		VHOST_LOG_DEBUG(VHOST_DATA, <span class="string">&quot;(%d) current index %d | end index %d\n&quot;</span>,</span><br><span class="line">			dev-&gt;vid, vq-&gt;last_avail_idx,</span><br><span class="line">			vq-&gt;last_avail_idx + num_buffers);</span><br><span class="line">    <span class="comment">//拷贝mbuf到avail desc</span></span><br><span class="line">		<span class="keyword">if</span> (copy_mbuf_to_desc(dev, vq, pkts[pkt_idx],</span><br><span class="line">						buf_vec, nr_vec,</span><br><span class="line">						num_buffers) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			vq-&gt;shadow_used_idx -= num_buffers;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vq-&gt;last_avail_idx += num_buffers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理小数据</span></span><br><span class="line">	do_data_copy_enqueue(dev, vq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(vq-&gt;shadow_used_idx)) &#123;</span><br><span class="line">		flush_shadow_used_ring_split(dev, vq);</span><br><span class="line">		vhost_vring_call_split(dev, vq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pkt_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面两种代码的分别处理流程，即可处理相关的数据结构，也就是分别数据最初提出的不同的内存数据结构体。</p>
<p>其实 DPDK 本身就是一种以数据流动为向导的框架，追根到底，就是极致的增加数据传输的效率，所以扭住了数据传送中的数据对象的数据定义，其实就找到了 DPDK 中为实现这种高效的数据流动所采取的算法和各种通信方式，IO 动作形式和数据管理机制。把这些都搞明白后，那么学习 DPDK 的基础和前提就有了，就可以结合上层的如 CPU 亲和，大内存等一一进行分析处理。</p>
<h1 id="DPDK-网卡抽象实现"><a href="#DPDK-网卡抽象实现" class="headerlink" title="DPDK 网卡抽象实现"></a>DPDK 网卡抽象实现</h1><p>其实不管怎么设计，如何开发，结果都是要展现一个结果，能够为人所用。虽然说 virtio 的应用场景有不少，但是在 DPDK 中主要就是网卡。所以，在此处主要是对网卡的抽象的实现，即对上层的应用实现底层的 virtio_net 驱动和相关设备的定义。这样的话就可以在上层软件中将其看做普通的网卡接口来使用。也就达到了抽象的目的，隔离了虚拟设备的种类和具体实现，对外暴露统一的网络接口，上层应用不需要区分到底是真实的网卡还是虚拟的网卡。<br>而 DPDK 中使用这种机制，能更好的发挥本身实现网络通信功能并实现更好的适应性。</p>
<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p>在 DPDK 中，对抽象实现的数据结构代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//librte_ethdev/rte_ethdev_core.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> * The generic data structure associated with each ethernet device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointers to burst-oriented packet receive and transmit functions are</span></span><br><span class="line"><span class="comment"> * located at the beginning of the structure, along with the pointer to</span></span><br><span class="line"><span class="comment"> * where all the data elements for the particular device are stored in shared</span></span><br><span class="line"><span class="comment"> * memory. This split allows the function pointer and driver data to be per-</span></span><br><span class="line"><span class="comment"> * process, while the actual configuration data for the device is shared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> &#123;</span></span><br><span class="line">	<span class="type">eth_rx_burst_t</span> rx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD receive function. */</span></span><br><span class="line">	<span class="type">eth_tx_burst_t</span> tx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD transmit function. */</span></span><br><span class="line">	<span class="type">eth_tx_prep_t</span> tx_pkt_prepare; <span class="comment">/**&lt; Pointer to PMD transmit prepare function. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next two fields are per-device data but *data is shared between</span></span><br><span class="line"><span class="comment">	 * primary and secondary processes and *process_private is per-process</span></span><br><span class="line"><span class="comment">	 * private. The second one is managed by PMDs if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> *<span class="title">data</span>;</span>  <span class="comment">/**&lt; Pointer to device data. */</span></span><br><span class="line">	<span class="type">void</span> *process_private; <span class="comment">/**&lt; Pointer to per-process device data. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> *<span class="title">dev_ops</span>;</span> <span class="comment">/**&lt; Functions exported by PMD */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/**&lt; Backing device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_handle</span> *<span class="title">intr_handle</span>;</span> <span class="comment">/**&lt; Device interrupt handle */</span></span><br><span class="line">	<span class="comment">/** User application callbacks for NIC interrupts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_cb_list</span> <span class="title">link_intr_cbs</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from rx_burst to post-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">post_rx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from tx_burst to pre-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the driver for transmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">pre_tx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_dev_state</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; Flag indicating the port state */</span></span><br><span class="line">	<span class="type">void</span> *security_ctx; <span class="comment">/**&lt; Context for security ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal A structure containing the functions exported by an Ethernet driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> &#123;</span></span><br><span class="line">	<span class="type">eth_dev_configure_t</span>        dev_configure; <span class="comment">/**&lt; Configure device. */</span></span><br><span class="line">	<span class="type">eth_dev_start_t</span>            dev_start;     <span class="comment">/**&lt; Start device. */</span></span><br><span class="line">	<span class="type">eth_dev_stop_t</span>             dev_stop;      <span class="comment">/**&lt; Stop device. */</span></span><br><span class="line">	<span class="type">eth_dev_set_link_up_t</span>      dev_set_link_up;   <span class="comment">/**&lt; Device link up. */</span></span><br><span class="line">	<span class="type">eth_dev_set_link_down_t</span>    dev_set_link_down; <span class="comment">/**&lt; Device link down. */</span></span><br><span class="line">	<span class="type">eth_dev_close_t</span>            dev_close;     <span class="comment">/**&lt; Close device. */</span></span><br><span class="line">	<span class="type">eth_dev_reset_t</span>		       dev_reset;	  <span class="comment">/**&lt; Reset device. */</span></span><br><span class="line">	<span class="type">eth_link_update_t</span>          link_update;   <span class="comment">/**&lt; Get device link state. */</span></span><br><span class="line">	<span class="type">eth_is_removed_t</span>           is_removed;</span><br><span class="line">	<span class="comment">/**&lt; Check if the device was physically removed. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_promiscuous_enable_t</span>   promiscuous_enable; <span class="comment">/**&lt; Promiscuous ON. */</span></span><br><span class="line">	<span class="type">eth_promiscuous_disable_t</span>  promiscuous_disable;<span class="comment">/**&lt; Promiscuous OFF. */</span></span><br><span class="line">	<span class="type">eth_allmulticast_enable_t</span>  allmulticast_enable;<span class="comment">/**&lt; RX multicast ON. */</span></span><br><span class="line">	<span class="type">eth_allmulticast_disable_t</span> allmulticast_disable;<span class="comment">/**&lt; RX multicast OFF. */</span></span><br><span class="line">	<span class="type">eth_mac_addr_remove_t</span>      mac_addr_remove; <span class="comment">/**&lt; Remove MAC address. */</span></span><br><span class="line">	<span class="type">eth_mac_addr_add_t</span>         mac_addr_add;  <span class="comment">/**&lt; Add a MAC address. */</span></span><br><span class="line">	<span class="type">eth_mac_addr_set_t</span>         mac_addr_set;  <span class="comment">/**&lt; Set a MAC address. */</span></span><br><span class="line">	<span class="type">eth_set_mc_addr_list_t</span>     set_mc_addr_list; <span class="comment">/**&lt; set list of mcast addrs. */</span></span><br><span class="line">	<span class="type">mtu_set_t</span>                  mtu_set;       <span class="comment">/**&lt; Set MTU. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_stats_get_t</span>            stats_get;     <span class="comment">/**&lt; Get generic device statistics. */</span></span><br><span class="line">	<span class="type">eth_stats_reset_t</span>          stats_reset;   <span class="comment">/**&lt; Reset generic device statistics. */</span></span><br><span class="line">	<span class="type">eth_xstats_get_t</span>           xstats_get;    <span class="comment">/**&lt; Get extended device statistics. */</span></span><br><span class="line">	<span class="type">eth_xstats_reset_t</span>         xstats_reset;  <span class="comment">/**&lt; Reset extended device statistics. */</span></span><br><span class="line">	<span class="type">eth_xstats_get_names_t</span>     xstats_get_names;</span><br><span class="line">	<span class="comment">/**&lt; Get names of extended statistics. */</span></span><br><span class="line">	<span class="type">eth_queue_stats_mapping_set_t</span> queue_stats_mapping_set;</span><br><span class="line">	<span class="comment">/**&lt; Configure per queue stat counter mapping. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_dev_infos_get_t</span>        dev_infos_get; <span class="comment">/**&lt; Get device info. */</span></span><br><span class="line">	<span class="type">eth_rxq_info_get_t</span>         rxq_info_get; <span class="comment">/**&lt; retrieve RX queue information. */</span></span><br><span class="line">	<span class="type">eth_txq_info_get_t</span>         txq_info_get; <span class="comment">/**&lt; retrieve TX queue information. */</span></span><br><span class="line">	<span class="type">eth_burst_mode_get_t</span>       rx_burst_mode_get; <span class="comment">/**&lt; Get RX burst mode */</span></span><br><span class="line">	<span class="type">eth_burst_mode_get_t</span>       tx_burst_mode_get; <span class="comment">/**&lt; Get TX burst mode */</span></span><br><span class="line">	<span class="type">eth_fw_version_get_t</span>       fw_version_get; <span class="comment">/**&lt; Get firmware version. */</span></span><br><span class="line">	<span class="type">eth_dev_supported_ptypes_get_t</span> dev_supported_ptypes_get;</span><br><span class="line">	<span class="comment">/**&lt; Get packet types supported and identified by device. */</span></span><br><span class="line">	<span class="type">eth_dev_ptypes_set_t</span> dev_ptypes_set;</span><br><span class="line">	<span class="comment">/**&lt; Inform Ethernet device about reduced range of packet types to handle. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">vlan_filter_set_t</span>          vlan_filter_set; <span class="comment">/**&lt; Filter VLAN Setup. */</span></span><br><span class="line">	<span class="type">vlan_tpid_set_t</span>            vlan_tpid_set; <span class="comment">/**&lt; Outer/Inner VLAN TPID Setup. */</span></span><br><span class="line">	<span class="type">vlan_strip_queue_set_t</span>     vlan_strip_queue_set; <span class="comment">/**&lt; VLAN Stripping on queue. */</span></span><br><span class="line">	<span class="type">vlan_offload_set_t</span>         vlan_offload_set; <span class="comment">/**&lt; Set VLAN Offload. */</span></span><br><span class="line">	<span class="type">vlan_pvid_set_t</span>            vlan_pvid_set; <span class="comment">/**&lt; Set port based TX VLAN insertion. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_queue_start_t</span>          rx_queue_start;<span class="comment">/**&lt; Start RX for a queue. */</span></span><br><span class="line">	<span class="type">eth_queue_stop_t</span>           rx_queue_stop; <span class="comment">/**&lt; Stop RX for a queue. */</span></span><br><span class="line">	<span class="type">eth_queue_start_t</span>          tx_queue_start;<span class="comment">/**&lt; Start TX for a queue. */</span></span><br><span class="line">	<span class="type">eth_queue_stop_t</span>           tx_queue_stop; <span class="comment">/**&lt; Stop TX for a queue. */</span></span><br><span class="line">	<span class="type">eth_rx_queue_setup_t</span>       rx_queue_setup;<span class="comment">/**&lt; Set up device RX queue. */</span></span><br><span class="line">	<span class="type">eth_queue_release_t</span>        rx_queue_release; <span class="comment">/**&lt; Release RX queue. */</span></span><br><span class="line">	<span class="type">eth_rx_queue_count_t</span>       rx_queue_count;</span><br><span class="line">	<span class="comment">/**&lt; Get the number of used RX descriptors. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_done_t</span>   rx_descriptor_done; <span class="comment">/**&lt; Check rxd DD bit. */</span></span><br><span class="line">	<span class="type">eth_rx_descriptor_status_t</span> rx_descriptor_status;</span><br><span class="line">	<span class="comment">/**&lt; Check the status of a Rx descriptor. */</span></span><br><span class="line">	<span class="type">eth_tx_descriptor_status_t</span> tx_descriptor_status;</span><br><span class="line">	<span class="comment">/**&lt; Check the status of a Tx descriptor. */</span></span><br><span class="line">	<span class="type">eth_rx_enable_intr_t</span>       rx_queue_intr_enable;  <span class="comment">/**&lt; Enable Rx queue interrupt. */</span></span><br><span class="line">	<span class="type">eth_rx_disable_intr_t</span>      rx_queue_intr_disable; <span class="comment">/**&lt; Disable Rx queue interrupt. */</span></span><br><span class="line">	<span class="type">eth_tx_queue_setup_t</span>       tx_queue_setup;<span class="comment">/**&lt; Set up device TX queue. */</span></span><br><span class="line">	<span class="type">eth_queue_release_t</span>        tx_queue_release; <span class="comment">/**&lt; Release TX queue. */</span></span><br><span class="line">	<span class="type">eth_tx_done_cleanup_t</span>      tx_done_cleanup;<span class="comment">/**&lt; Free tx ring mbufs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_dev_led_on_t</span>           dev_led_on;    <span class="comment">/**&lt; Turn on LED. */</span></span><br><span class="line">	<span class="type">eth_dev_led_off_t</span>          dev_led_off;   <span class="comment">/**&lt; Turn off LED. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">flow_ctrl_get_t</span>            flow_ctrl_get; <span class="comment">/**&lt; Get flow control. */</span></span><br><span class="line">	<span class="type">flow_ctrl_set_t</span>            flow_ctrl_set; <span class="comment">/**&lt; Setup flow control. */</span></span><br><span class="line">	<span class="type">priority_flow_ctrl_set_t</span>   priority_flow_ctrl_set; <span class="comment">/**&lt; Setup priority flow control. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_uc_hash_table_set_t</span>    uc_hash_table_set; <span class="comment">/**&lt; Set Unicast Table Array. */</span></span><br><span class="line">	<span class="type">eth_uc_all_hash_table_set_t</span> uc_all_hash_table_set; <span class="comment">/**&lt; Set Unicast hash bitmap. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_mirror_rule_set_t</span>	   mirror_rule_set; <span class="comment">/**&lt; Add a traffic mirror rule. */</span></span><br><span class="line">	<span class="type">eth_mirror_rule_reset_t</span>	   mirror_rule_reset; <span class="comment">/**&lt; reset a traffic mirror rule. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_udp_tunnel_port_add_t</span>  udp_tunnel_port_add; <span class="comment">/** Add UDP tunnel port. */</span></span><br><span class="line">	<span class="type">eth_udp_tunnel_port_del_t</span>  udp_tunnel_port_del; <span class="comment">/** Del UDP tunnel port. */</span></span><br><span class="line">	<span class="type">eth_l2_tunnel_eth_type_conf_t</span> l2_tunnel_eth_type_conf;</span><br><span class="line">	<span class="comment">/** Config ether type of l2 tunnel. */</span></span><br><span class="line">	<span class="type">eth_l2_tunnel_offload_set_t</span>   l2_tunnel_offload_set;</span><br><span class="line">	<span class="comment">/** Enable/disable l2 tunnel offload functions. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_set_queue_rate_limit_t</span> set_queue_rate_limit; <span class="comment">/**&lt; Set queue rate limit. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">rss_hash_update_t</span>          rss_hash_update; <span class="comment">/** Configure RSS hash protocols. */</span></span><br><span class="line">	<span class="type">rss_hash_conf_get_t</span>        rss_hash_conf_get; <span class="comment">/** Get current RSS hash configuration. */</span></span><br><span class="line">	<span class="type">reta_update_t</span>              reta_update;   <span class="comment">/** Update redirection table. */</span></span><br><span class="line">	<span class="type">reta_query_t</span>               reta_query;    <span class="comment">/** Query redirection table. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_get_reg_t</span>              get_reg;           <span class="comment">/**&lt; Get registers. */</span></span><br><span class="line">	<span class="type">eth_get_eeprom_length_t</span>    get_eeprom_length; <span class="comment">/**&lt; Get eeprom length. */</span></span><br><span class="line">	<span class="type">eth_get_eeprom_t</span>           get_eeprom;        <span class="comment">/**&lt; Get eeprom data. */</span></span><br><span class="line">	<span class="type">eth_set_eeprom_t</span>           set_eeprom;        <span class="comment">/**&lt; Set eeprom. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_get_module_info_t</span>      get_module_info;</span><br><span class="line">	<span class="comment">/** Get plugin module eeprom attribute. */</span></span><br><span class="line">	<span class="type">eth_get_module_eeprom_t</span>    get_module_eeprom;</span><br><span class="line">	<span class="comment">/** Get plugin module eeprom data. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_filter_ctrl_t</span>          filter_ctrl; <span class="comment">/**&lt; common filter control. */</span></span><br><span class="line"></span><br><span class="line">	eth_get_dcb_info           get_dcb_info; <span class="comment">/** Get DCB information. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_timesync_enable_t</span>      timesync_enable;</span><br><span class="line">	<span class="comment">/** Turn IEEE1588/802.1AS timestamping on. */</span></span><br><span class="line">	<span class="type">eth_timesync_disable_t</span>     timesync_disable;</span><br><span class="line">	<span class="comment">/** Turn IEEE1588/802.1AS timestamping off. */</span></span><br><span class="line">	<span class="type">eth_timesync_read_rx_timestamp_t</span> timesync_read_rx_timestamp;</span><br><span class="line">	<span class="comment">/** Read the IEEE1588/802.1AS RX timestamp. */</span></span><br><span class="line">	<span class="type">eth_timesync_read_tx_timestamp_t</span> timesync_read_tx_timestamp;</span><br><span class="line">	<span class="comment">/** Read the IEEE1588/802.1AS TX timestamp. */</span></span><br><span class="line">	eth_timesync_adjust_time   timesync_adjust_time; <span class="comment">/** Adjust the device clock. */</span></span><br><span class="line">	eth_timesync_read_time     timesync_read_time; <span class="comment">/** Get the device clock time. */</span></span><br><span class="line">	eth_timesync_write_time    timesync_write_time; <span class="comment">/** Set the device clock time. */</span></span><br><span class="line"></span><br><span class="line">	eth_read_clock             read_clock;</span><br><span class="line"></span><br><span class="line">	<span class="type">eth_xstats_get_by_id_t</span>     xstats_get_by_id;</span><br><span class="line">	<span class="comment">/**&lt; Get extended device statistic values by ID. */</span></span><br><span class="line">	<span class="type">eth_xstats_get_names_by_id_t</span> xstats_get_names_by_id;</span><br><span class="line">	<span class="comment">/**&lt; Get name of extended device statistics by ID. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_tm_ops_get_t</span> tm_ops_get;</span><br><span class="line">	<span class="comment">/**&lt; Get Traffic Management (TM) operations. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_mtr_ops_get_t</span> mtr_ops_get;</span><br><span class="line">	<span class="comment">/**&lt; Get Traffic Metering and Policing (MTR) operations. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_pool_ops_supported_t</span> pool_ops_supported;</span><br><span class="line">	<span class="comment">/**&lt; Test if a port supports specific mempool ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">eth_hairpin_cap_get_t</span> hairpin_cap_get;</span><br><span class="line">	<span class="comment">/**&lt; Returns the hairpin capabilities. */</span></span><br><span class="line">	<span class="type">eth_rx_hairpin_queue_setup_t</span> rx_hairpin_queue_setup;</span><br><span class="line">	<span class="comment">/**&lt; Set up device RX hairpin queue. */</span></span><br><span class="line">	<span class="type">eth_tx_hairpin_queue_setup_t</span> tx_hairpin_queue_setup;</span><br><span class="line">	<span class="comment">/**&lt; Set up device TX hairpin queue. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> * The data part, with no function pointers, associated with each ethernet device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure is safe to place in shared memory to be common among different</span></span><br><span class="line"><span class="comment"> * processes in a multi-process configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[RTE_ETH_NAME_MAX_LEN]; <span class="comment">/**&lt; Unique identifier name */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> **rx_queues; <span class="comment">/**&lt; Array of pointers to RX queues. */</span></span><br><span class="line">	<span class="type">void</span> **tx_queues; <span class="comment">/**&lt; Array of pointers to TX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rx_queues; <span class="comment">/**&lt; Number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_tx_queues; <span class="comment">/**&lt; Number of TX queues. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_sriov</span> <span class="title">sriov</span>;</span>    <span class="comment">/**&lt; SRIOV data */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *dev_private;</span><br><span class="line">			<span class="comment">/**&lt; PMD-specific private data.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_link</span> <span class="title">dev_link</span>;</span>   <span class="comment">/**&lt; Link-level information &amp; status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">dev_conf</span>;</span>   <span class="comment">/**&lt; Configuration applied to device. */</span></span><br><span class="line">	<span class="type">uint16_t</span> mtu;                   <span class="comment">/**&lt; Maximum Transmission Unit. */</span></span><br><span class="line">	<span class="type">uint32_t</span> min_rx_buf_size;</span><br><span class="line">			<span class="comment">/**&lt; Common RX buffer size handled by all queues. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> rx_mbuf_alloc_failed; <span class="comment">/**&lt; RX ring mbuf allocation failures. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> *<span class="title">mac_addrs</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Device Ethernet link address.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">	<span class="type">uint64_t</span> mac_pool_sel[ETH_NUM_RECEIVE_MAC_ADDR];</span><br><span class="line">			<span class="comment">/**&lt; Bitmap associating MAC addresses to pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> *<span class="title">hash_mac_addrs</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Device Ethernet MAC addresses of hash filtering.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">	<span class="type">uint16_t</span> port_id;           <span class="comment">/**&lt; Device [external] port identifier. */</span></span><br><span class="line"></span><br><span class="line">	__extension__</span><br><span class="line">	<span class="type">uint8_t</span> promiscuous   : <span class="number">1</span>, <span class="comment">/**&lt; RX promiscuous mode ON(1) / OFF(0). */</span></span><br><span class="line">		scattered_rx : <span class="number">1</span>,  <span class="comment">/**&lt; RX of scattered packets is ON(1) / OFF(0) */</span></span><br><span class="line">		all_multicast : <span class="number">1</span>, <span class="comment">/**&lt; RX all multicast mode ON(1) / OFF(0). */</span></span><br><span class="line">		dev_started : <span class="number">1</span>,   <span class="comment">/**&lt; Device state: STARTED(1) / STOPPED(0). */</span></span><br><span class="line">		lro         : <span class="number">1</span>;   <span class="comment">/**&lt; RX LRO is ON(1) / OFF(0) */</span></span><br><span class="line">	<span class="type">uint8_t</span> rx_queue_state[RTE_MAX_QUEUES_PER_PORT];</span><br><span class="line">		<span class="comment">/**&lt; Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0). */</span></span><br><span class="line">	<span class="type">uint8_t</span> tx_queue_state[RTE_MAX_QUEUES_PER_PORT];</span><br><span class="line">		<span class="comment">/**&lt; Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0). */</span></span><br><span class="line">	<span class="type">uint32_t</span> dev_flags;             <span class="comment">/**&lt; Capabilities. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_kernel_driver</span> <span class="title">kdrv</span>;</span>    <span class="comment">/**&lt; Kernel driver passthrough. */</span></span><br><span class="line">	<span class="type">int</span> numa_node;                  <span class="comment">/**&lt; NUMA node connection. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vlan_filter_conf</span> <span class="title">vlan_filter_conf</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; VLAN filter configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_owner</span> <span class="title">owner</span>;</span> <span class="comment">/**&lt; The port owner. */</span></span><br><span class="line">	<span class="type">uint16_t</span> representor_id;</span><br><span class="line">			<span class="comment">/**&lt; Switch-specific identifier.</span></span><br><span class="line"><span class="comment">			 *   Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三个数据结构，rte_eth_dev_data 用来说明网卡通信数据的内容，rte_eth_dev 用来网卡的整体的描述，包括收发数据和函数指针的定义。eth_dev_ops 用来对网卡设备的驱动的操作定义导出函数。这三个组合在一起就可以把一个网卡整体框架的数据和函数功能基本表现出来。</p>
<h3 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h3><p>其实在底层实现中为了描述对底层的函数调用，简单分析过一些此处的函数，所以应该看到有的函数并不陌生，下面看一下主要的流程代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is based on probe() function in virtio_pci.c</span></span><br><span class="line"><span class="comment"> * It returns 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eth_virtio_dev_init</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev *eth_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> *<span class="title">hw</span> =</span> eth_dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf) &gt; RTE_PKTMBUF_HEADROOM) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Not sufficient headroom required = %d, avail = %d&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf),</span><br><span class="line">			RTE_PKTMBUF_HEADROOM);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eth_dev-&gt;dev_ops = &amp;virtio_eth_dev_ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_SECONDARY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">			ret = virtio_remap_pci(RTE_ETH_DEV_TO_PCI(eth_dev), hw);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		virtio_set_vtpci_ops(hw);</span><br><span class="line">		set_rxtx_funcs(eth_dev);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pass the information to the rte_eth_dev_close() that it should also</span></span><br><span class="line"><span class="comment">	 * release the private port resources.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	eth_dev-&gt;data-&gt;dev_flags |= RTE_ETH_DEV_CLOSE_REMOVE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate memory for storing MAC addresses */</span></span><br><span class="line">	eth_dev-&gt;data-&gt;mac_addrs = rte_zmalloc(<span class="string">&quot;virtio&quot;</span>,</span><br><span class="line">				VIRTIO_MAX_MAC_ADDRS * RTE_ETHER_ADDR_LEN, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (eth_dev-&gt;data-&gt;mac_addrs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Failed to allocate %d bytes needed to store MAC addresses&quot;</span>,</span><br><span class="line">			VIRTIO_MAX_MAC_ADDRS * RTE_ETHER_ADDR_LEN);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hw-&gt;port_id = eth_dev-&gt;data-&gt;port_id;</span><br><span class="line">	<span class="comment">/* For virtio_user case the hw-&gt;virtio_user_dev is populated by</span></span><br><span class="line"><span class="comment">	 * virtio_user_eth_dev_alloc() before eth_virtio_dev_init() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">		ret = vtpci_init(RTE_ETH_DEV_TO_PCI(eth_dev), hw);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_vtpci_init;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_init(&amp;hw-&gt;state_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reset device and negotiate default features */</span></span><br><span class="line">	ret = virtio_init_device(eth_dev, VIRTIO_PMD_DEFAULT_GUEST_FEATURES);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_virtio_init;</span><br><span class="line"></span><br><span class="line">	hw-&gt;opened = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_virtio_init:</span><br><span class="line">	<span class="keyword">if</span> (!hw-&gt;virtio_user_dev) &#123;</span><br><span class="line">		rte_pci_unmap_device(RTE_ETH_DEV_TO_PCI(eth_dev));</span><br><span class="line">		<span class="keyword">if</span> (!hw-&gt;modern)</span><br><span class="line">			rte_pci_ioport_unmap(VTPCI_IO(hw));</span><br><span class="line">	&#125;</span><br><span class="line">err_vtpci_init:</span><br><span class="line">	rte_free(eth_dev-&gt;data-&gt;mac_addrs);</span><br><span class="line">	eth_dev-&gt;data-&gt;mac_addrs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的说明里也告诉大家基础的调用是在 virtio_pci.c 中，和刚刚提到是底层抽象的具体实现的互相呼应。在这个函数里，主要是对描述的数据结构进行初始化和定义，对相关 virtio 设备进行初始化，同时对一些交互的特征值进行预定义，包括对数据队列的初始化。<br>收发函数的设置在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set rx and tx handlers according to what is supported */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_rxtx_funcs</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev * eth_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> * <span class="title">hw</span> =</span> eth_dev-&gt;data-&gt;dev_private;</span><br><span class="line"></span><br><span class="line">	eth_dev-&gt;tx_pkt_prepare = virtio_xmit_pkts_prepare;</span><br><span class="line">	<span class="keyword">if</span> (vtpci_packed_queue(hw)) &#123;</span><br><span class="line">		PMD_INIT_LOG(INFO,</span><br><span class="line">			<span class="string">&quot;virtio: using packed ring %s Tx path on port %u&quot;</span>,</span><br><span class="line">			hw-&gt;use_inorder_tx ? <span class="string">&quot;inorder&quot;</span> : <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">			eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">		eth_dev-&gt;tx_pkt_burst = virtio_xmit_pkts_packed;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hw-&gt;use_inorder_tx) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO, <span class="string">&quot;virtio: using inorder Tx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;tx_pkt_burst = virtio_xmit_pkts_inorder;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO, <span class="string">&quot;virtio: using standard Tx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;tx_pkt_burst = virtio_xmit_pkts;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vtpci_packed_queue(hw)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vtpci_with_feature(hw, VIRTIO_NET_F_MRG_RXBUF)) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO,</span><br><span class="line">				<span class="string">&quot;virtio: using packed ring mergeable buffer Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst =</span><br><span class="line">				&amp;virtio_recv_mergeable_pkts_packed;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO,</span><br><span class="line">				<span class="string">&quot;virtio: using packed ring standard Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst = &amp;virtio_recv_pkts_packed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hw-&gt;use_simple_rx) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO, <span class="string">&quot;virtio: using simple Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst = virtio_recv_pkts_vec;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hw-&gt;use_inorder_rx) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO,</span><br><span class="line">				<span class="string">&quot;virtio: using inorder Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst =	&amp;virtio_recv_pkts_inorder;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (vtpci_with_feature(hw, VIRTIO_NET_F_MRG_RXBUF)) &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO,</span><br><span class="line">				<span class="string">&quot;virtio: using mergeable buffer Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst = &amp;virtio_recv_mergeable_pkts;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			PMD_INIT_LOG(INFO, <span class="string">&quot;virtio: using standard Rx path on port %u&quot;</span>,</span><br><span class="line">				eth_dev-&gt;data-&gt;port_id);</span><br><span class="line">			eth_dev-&gt;rx_pkt_burst = &amp;virtio_recv_pkts;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 virtio_recv_pkts 和 virtio_xmit_pkts 两个系列的函数就是用来进行收发的两大类具体的工作的。</p>
<p>下面的再看一下 virtio_recv_pkts 函数定义（均定义在 drivers\net\virtio\virtio_rxtx.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_MBUF_BURST_SZ 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_PER_CACHELINE (RTE_CACHE_LINE_SIZE / sizeof(struct vring_desc))</span></span><br><span class="line"><span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">virtio_recv_pkts</span><span class="params">(<span class="type">void</span> * rx_queue, <span class="keyword">struct</span> rte_mbuf ** rx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_rx</span> * <span class="title">rxvq</span> =</span> rx_queue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> * <span class="title">vq</span> =</span> rxvq-&gt;vq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> * <span class="title">hw</span> =</span> vq-&gt;hw;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">rxm</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_used, num, nb_rx;</span><br><span class="line">	<span class="type">uint32_t</span> len[VIRTIO_MBUF_BURST_SZ];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">rcv_pkts</span>[<span class="title">VIRTIO_MBUF_BURST_SZ</span>];</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">uint32_t</span> i, nb_enqueued;</span><br><span class="line">	<span class="type">uint32_t</span> hdr_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_hdr</span> * <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	nb_rx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(hw-&gt;started == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> nb_rx;</span><br><span class="line"></span><br><span class="line">	nb_used = VIRTQUEUE_NUSED(vq);</span><br><span class="line"></span><br><span class="line">	virtio_rmb(hw-&gt;weak_barriers);</span><br><span class="line"></span><br><span class="line">	num = likely(nb_used &lt;= nb_pkts) ? nb_used : nb_pkts;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(num &gt; VIRTIO_MBUF_BURST_SZ))</span><br><span class="line">		num = VIRTIO_MBUF_BURST_SZ;</span><br><span class="line">	<span class="keyword">if</span> (likely(num &gt; DESC_PER_CACHELINE))</span><br><span class="line">		num = num - ((vq-&gt;vq_used_cons_idx + num) % DESC_PER_CACHELINE);</span><br><span class="line"></span><br><span class="line">	num = virtqueue_dequeue_burst_rx(vq, rcv_pkts, len, num);</span><br><span class="line">	PMD_RX_LOG(DEBUG, <span class="string">&quot;used:%d dequeue:%d&quot;</span>, nb_used, num);</span><br><span class="line"></span><br><span class="line">	nb_enqueued = <span class="number">0</span>;</span><br><span class="line">	hdr_size = hw-&gt;vtnet_hdr_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num ; i++) &#123;</span><br><span class="line">		rxm = rcv_pkts[i];</span><br><span class="line"></span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;packet len:%d&quot;</span>, len[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(len[i] &lt; hdr_size + RTE_ETHER_HDR_LEN)) &#123;</span><br><span class="line">			PMD_RX_LOG(ERR, <span class="string">&quot;Packet drop&quot;</span>);</span><br><span class="line">			nb_enqueued++;</span><br><span class="line">			virtio_discard_rxbuf(vq, rxm);</span><br><span class="line">			rxvq-&gt;stats.errors++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rxm-&gt;port = rxvq-&gt;port_id;</span><br><span class="line">		rxm-&gt;data_off = RTE_PKTMBUF_HEADROOM;</span><br><span class="line">		rxm-&gt;ol_flags = <span class="number">0</span>;</span><br><span class="line">		rxm-&gt;vlan_tci = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		rxm-&gt;pkt_len = (<span class="type">uint32_t</span>)(len[i] - hdr_size);</span><br><span class="line">		rxm-&gt;data_len = (<span class="type">uint16_t</span>)(len[i] - hdr_size);</span><br><span class="line"></span><br><span class="line">		hdr = (<span class="keyword">struct</span> virtio_net_hdr * )((<span class="type">char</span> * )rxm-&gt;buf_addr +</span><br><span class="line">			RTE_PKTMBUF_HEADROOM - hdr_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hw-&gt;vlan_strip)</span><br><span class="line">			rte_vlan_strip(rxm);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hw-&gt;has_rx_offload &amp;&amp; virtio_rx_offload(rxm, hdr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			virtio_discard_rxbuf(vq, rxm);</span><br><span class="line">			rxvq-&gt;stats.errors++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		virtio_rx_stats_updated(rxvq, rxm);</span><br><span class="line"></span><br><span class="line">		rx_pkts[nb_rx++] = rxm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rxvq-&gt;stats.packets += nb_rx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate new mbuf for the used descriptor */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!virtqueue_full(vq))) &#123;</span><br><span class="line">		<span class="type">uint16_t</span> free_cnt = vq-&gt;vq_free_cnt;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">new_pkts</span>[<span class="title">free_cnt</span>];</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(rte_pktmbuf_alloc_bulk(rxvq-&gt;mpool, new_pkts,</span><br><span class="line">						free_cnt) == <span class="number">0</span>)) &#123;</span><br><span class="line">			error = virtqueue_enqueue_recv_refill(vq, new_pkts,</span><br><span class="line">					free_cnt);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; free_cnt; i++)</span><br><span class="line">					rte_pktmbuf_free(new_pkts[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			nb_enqueued += free_cnt;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">struct</span> rte_eth_dev * dev =</span><br><span class="line">				&amp;rte_eth_devices[rxvq-&gt;port_id];</span><br><span class="line">			dev-&gt;data-&gt;rx_mbuf_alloc_failed += free_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(nb_enqueued)) &#123;</span><br><span class="line">		vq_update_avail_idx(vq);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(virtqueue_kick_prepare(vq))) &#123;</span><br><span class="line">			virtqueue_notify(vq);</span><br><span class="line">			PMD_RX_LOG(DEBUG, <span class="string">&quot;Notified&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是基础数据结构的变量定义，然后利用 likely 进行初步的判断，通过 virtqueue_dequeue_burst_rx 得报文的数量，包括描述符，然后再将其内部数据读取，完毕后将 desc 回收。然后通过循环读取具体的数据。最后更新可用 desc，分配 mbuf，并插入到可用队列，同时通知 vhost。<br>再看一下 virtio_xmit_pkts 函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">virtio_xmit_pkts</span><span class="params">(<span class="type">void</span> * tx_queue, <span class="keyword">struct</span> rte_mbuf ** tx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtnet_tx</span> * <span class="title">txvq</span> =</span> tx_queue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> * <span class="title">vq</span> =</span> txvq-&gt;vq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_hw</span> * <span class="title">hw</span> =</span> vq-&gt;hw;</span><br><span class="line">	<span class="type">uint16_t</span> hdr_size = hw-&gt;vtnet_hdr_size;</span><br><span class="line">	<span class="type">uint16_t</span> nb_used, nb_tx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(hw-&gt;started == <span class="number">0</span> &amp;&amp; tx_pkts != hw-&gt;inject_pkts))</span><br><span class="line">		<span class="keyword">return</span> nb_tx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(nb_pkts &lt; <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> nb_pkts;</span><br><span class="line"></span><br><span class="line">	PMD_TX_LOG(DEBUG, <span class="string">&quot;%d packets to xmit&quot;</span>, nb_pkts);</span><br><span class="line">	nb_used = VIRTQUEUE_NUSED(vq);</span><br><span class="line"></span><br><span class="line">	virtio_rmb(hw-&gt;weak_barriers);</span><br><span class="line">	<span class="keyword">if</span> (likely(nb_used &gt; vq-&gt;vq_nentries - vq-&gt;vq_free_thresh))</span><br><span class="line">		virtio_xmit_cleanup(vq, nb_used);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (nb_tx = <span class="number">0</span>; nb_tx &lt; nb_pkts; nb_tx++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">txm</span> =</span> tx_pkts[nb_tx];</span><br><span class="line">		<span class="type">int</span> can_push = <span class="number">0</span>, use_indirect = <span class="number">0</span>, slots, need;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* optimize ring usage */</span></span><br><span class="line">		<span class="keyword">if</span> ((vtpci_with_feature(hw, VIRTIO_F_ANY_LAYOUT) ||</span><br><span class="line">		      vtpci_with_feature(hw, VIRTIO_F_VERSION_1)) &amp;&amp;</span><br><span class="line">		    rte_mbuf_refcnt_read(txm) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    RTE_MBUF_DIRECT(txm) &amp;&amp;</span><br><span class="line">		    txm-&gt;nb_segs == <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    rte_pktmbuf_headroom(txm) &gt;= hdr_size &amp;&amp;</span><br><span class="line">		    rte_is_aligned(rte_pktmbuf_mtod(txm, <span class="type">char</span> *),</span><br><span class="line">				   __alignof__(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf)))</span><br><span class="line">			can_push = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vtpci_with_feature(hw, VIRTIO_RING_F_INDIRECT_DESC) &amp;&amp;</span><br><span class="line">			 txm-&gt;nb_segs &lt; VIRTIO_MAX_TX_INDIRECT)</span><br><span class="line">			use_indirect = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* How many main ring entries are needed to this Tx?</span></span><br><span class="line"><span class="comment">		 * any_layout =&gt; number of segments</span></span><br><span class="line"><span class="comment">		 * indirect   =&gt; 1</span></span><br><span class="line"><span class="comment">		 * default    =&gt; number of segments + 1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		slots = use_indirect ? <span class="number">1</span> : (txm-&gt;nb_segs + !can_push);</span><br><span class="line">		need = slots - vq-&gt;vq_free_cnt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Positive value indicates it need free vring descriptors */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(need &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">			nb_used = VIRTQUEUE_NUSED(vq);</span><br><span class="line">			virtio_rmb(hw-&gt;weak_barriers);</span><br><span class="line">			need = RTE_MIN(need, (<span class="type">int</span>)nb_used);</span><br><span class="line"></span><br><span class="line">			virtio_xmit_cleanup(vq, need);</span><br><span class="line">			need = slots - vq-&gt;vq_free_cnt;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(need &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">				PMD_TX_LOG(ERR,</span><br><span class="line">					   <span class="string">&quot;No free tx descriptors to transmit&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Enqueue Packet buffers */</span></span><br><span class="line">		virtqueue_enqueue_xmit(txvq, txm, slots, use_indirect,</span><br><span class="line">			can_push, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		virtio_update_packet_stats(&amp;txvq-&gt;stats, txm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txvq-&gt;stats.packets += nb_tx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(nb_tx)) &#123;</span><br><span class="line">		vq_update_avail_idx(vq);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(virtqueue_kick_prepare(vq))) &#123;</span><br><span class="line">			virtqueue_notify(vq);</span><br><span class="line">			PMD_TX_LOG(DEBUG, <span class="string">&quot;Notified backend after xmit&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_tx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的数据发送发生在循环中调用 virtqueue_enqueue_xmit 这个函数上，其它的都是一些相关状态及数量等的准备。发送完成后更新状态参数。再看一下调用的实际发送函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">virtqueue_enqueue_xmit</span><span class="params">(<span class="keyword">struct</span> virtnet_tx *txvq, <span class="keyword">struct</span> rte_mbuf *cookie,</span></span><br><span class="line"><span class="params">			<span class="type">uint16_t</span> needed, <span class="type">int</span> use_indirect, <span class="type">int</span> can_push, <span class="type">int</span> in_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_tx_region</span> * <span class="title">txr</span> =</span> txvq-&gt;virtio_net_hdr_mz-&gt;addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vq_desc_extra</span> * <span class="title">dxp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtqueue</span> * <span class="title">vq</span> =</span> txvq-&gt;vq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_desc</span> * <span class="title">start_dp</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> seg_num = cookie-&gt;nb_segs;</span><br><span class="line">	<span class="type">uint16_t</span> head_idx, idx;</span><br><span class="line">	<span class="type">int16_t</span> head_size = vq-&gt;hw-&gt;vtnet_hdr_size;</span><br><span class="line">	<span class="type">bool</span> prepend_header = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net_hdr</span> * <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	head_idx = vq-&gt;vq_desc_head_idx;</span><br><span class="line">	idx = head_idx;</span><br><span class="line">	<span class="keyword">if</span> (in_order)</span><br><span class="line">		dxp = &amp;vq-&gt;vq_descx[vq-&gt;vq_avail_idx &amp; (vq-&gt;vq_nentries - <span class="number">1</span>)];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dxp = &amp;vq-&gt;vq_descx[idx];</span><br><span class="line">	dxp-&gt;cookie = (<span class="type">void</span> * )cookie;</span><br><span class="line">	dxp-&gt;ndescs = needed;</span><br><span class="line"></span><br><span class="line">	start_dp = vq-&gt;vq_split.ring.desc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (can_push) &#123;</span><br><span class="line">		<span class="comment">/* prepend cannot fail, checked by caller */</span></span><br><span class="line">		hdr = rte_pktmbuf_mtod_offset(cookie, <span class="keyword">struct</span> virtio_net_hdr *,</span><br><span class="line">					      -head_size);</span><br><span class="line">		prepend_header = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if offload disabled, it is not zeroed below, do it now */</span></span><br><span class="line">		<span class="keyword">if</span> (!vq-&gt;hw-&gt;has_tx_offload)</span><br><span class="line">			virtqueue_clear_net_hdr(hdr);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (use_indirect) &#123;</span><br><span class="line">		<span class="comment">/* setup tx ring slot to point to indirect</span></span><br><span class="line"><span class="comment">		 * descriptor list stored in reserved region.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * the first slot in indirect ring is already preset</span></span><br><span class="line"><span class="comment">		 * to point to the header in reserved region</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		start_dp[idx].addr  = txvq-&gt;virtio_net_hdr_mem +</span><br><span class="line">			RTE_PTR_DIFF(&amp;txr[idx].tx_indir, txr);</span><br><span class="line">		start_dp[idx].len   = (seg_num + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vring_desc);</span><br><span class="line">		start_dp[idx].flags = VRING_DESC_F_INDIRECT;</span><br><span class="line">		hdr = (<span class="keyword">struct</span> virtio_net_hdr *)&amp;txr[idx].tx_hdr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* loop below will fill in rest of the indirect elements */</span></span><br><span class="line">		start_dp = txr[idx].tx_indir;</span><br><span class="line">		idx = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* setup first tx ring slot to point to header</span></span><br><span class="line"><span class="comment">		 * stored in reserved region.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		start_dp[idx].addr  = txvq-&gt;virtio_net_hdr_mem +</span><br><span class="line">			RTE_PTR_DIFF(&amp;txr[idx].tx_hdr, txr);</span><br><span class="line">		start_dp[idx].len   = vq-&gt;hw-&gt;vtnet_hdr_size;</span><br><span class="line">		start_dp[idx].flags = VRING_DESC_F_NEXT;</span><br><span class="line">		hdr = (<span class="keyword">struct</span> virtio_net_hdr * )&amp;txr[idx].tx_hdr;</span><br><span class="line"></span><br><span class="line">		idx = start_dp[idx].next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	virtqueue_xmit_offload(hdr, cookie, vq-&gt;hw-&gt;has_tx_offload);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		start_dp[idx].addr  = VIRTIO_MBUF_DATA_DMA_ADDR(cookie, vq);</span><br><span class="line">		start_dp[idx].len   = cookie-&gt;data_len;</span><br><span class="line">		<span class="keyword">if</span> (prepend_header) &#123;</span><br><span class="line">			start_dp[idx].addr -= head_size;</span><br><span class="line">			start_dp[idx].len += head_size;</span><br><span class="line">			prepend_header = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		start_dp[idx].flags = cookie-&gt;next ? VRING_DESC_F_NEXT : <span class="number">0</span>;</span><br><span class="line">		idx = start_dp[idx].next;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((cookie = cookie-&gt;next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use_indirect)</span><br><span class="line">		idx = vq-&gt;vq_split.ring.desc[head_idx].next;</span><br><span class="line"></span><br><span class="line">	vq-&gt;vq_free_cnt = (<span class="type">uint16_t</span>)(vq-&gt;vq_free_cnt - needed);</span><br><span class="line"></span><br><span class="line">	vq-&gt;vq_desc_head_idx = idx;</span><br><span class="line">	vq_update_avail_ring(vq, head_idx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_order) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vq-&gt;vq_desc_head_idx == VQ_RING_DESC_CHAIN_END)</span><br><span class="line">			vq-&gt;vq_desc_tail_idx = idx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中其实就是可以看到前面提到的队列和描述符的操作动作了。特别是一些数据结构的来回填充回收使用的过程。if 的第一个判断主要处理的是 indirect 等情况，重点看一下 else 里（即 do 循环的代码）。</p>
<h1 id="vhost-的基础数据结构"><a href="#vhost-的基础数据结构" class="headerlink" title="vhost 的基础数据结构"></a>vhost 的基础数据结构</h1><p>vhost 的编程有内核态和 user 态两种，在 DPDK 中使用后者可以更好的操作数据流程减少数据的流动路径和复制的过程。在 DPDK 中主要的控制文件在 librte_vhost、librte_ethdev 和 virtio 和 vhost 三个文件夹中分布。其中在 drviers&#x2F;net&#x2F;virtio&#x2F;virtio-user 中的 vhost.h 中还有一些 user 中相关的数据结构。这里看一下 librte_vhost 中的 vhost.h 中的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure contains buffer address, length and descriptor index</span></span><br><span class="line"><span class="comment"> * from vring to do scatter RX.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf_vector</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> buf_iova;</span><br><span class="line">	<span class="type">uint64_t</span> buf_addr;</span><br><span class="line">	<span class="type">uint32_t</span> buf_len;</span><br><span class="line">	<span class="type">uint32_t</span> desc_idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to hold some fields needed in zero copy code path,</span></span><br><span class="line"><span class="comment"> * mainly for associating an mbuf with the right desc_idx.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zcopy_mbuf</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">mbuf</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> desc_idx;</span><br><span class="line">	<span class="type">uint16_t</span> desc_count;</span><br><span class="line">	<span class="type">uint16_t</span> in_use;</span><br><span class="line"></span><br><span class="line">	TAILQ_ENTRY(zcopy_mbuf) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_used_elem_packed</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> id;</span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">	<span class="type">uint32_t</span> len;</span><br><span class="line">	<span class="type">uint32_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure contains variables relevant to RX/TX virtqueues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_desc</span>	*<span class="title">desc</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span>   *<span class="title">desc_packed</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_avail</span>	*<span class="title">avail</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> *<span class="title">driver_event</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_used</span>	*<span class="title">used</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> *<span class="title">device_event</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">uint32_t</span>		size;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span>		last_avail_idx;</span><br><span class="line">	<span class="type">uint16_t</span>		last_used_idx;</span><br><span class="line">	<span class="comment">/* Last used index we notify to front end. */</span></span><br><span class="line">	<span class="type">uint16_t</span>		signalled_used;</span><br><span class="line">	<span class="type">bool</span>			signalled_used_valid;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_INVALID_EVENTFD		(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_UNINITIALIZED_EVENTFD	(-2)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Backend value to determine if device should started/stopped */</span></span><br><span class="line">	<span class="type">int</span>			backend;</span><br><span class="line">	<span class="type">int</span>			enabled;</span><br><span class="line">	<span class="type">int</span>			access_ok;</span><br><span class="line">	<span class="type">rte_spinlock_t</span>		access_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used to notify the guest (trigger interrupt) */</span></span><br><span class="line">	<span class="type">int</span>			callfd;</span><br><span class="line">	<span class="comment">/* Currently unused as polling mode is enabled */</span></span><br><span class="line">	<span class="type">int</span>			kickfd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Physical address of used ring, for logging */</span></span><br><span class="line">	<span class="type">uint64_t</span>		log_guest_addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* inflight share memory info */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_inflight_info_split</span> *<span class="title">inflight_split</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_inflight_info_packed</span> *<span class="title">inflight_packed</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_resubmit_info</span> *<span class="title">resubmit_inflight</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span>		global_counter;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span>		nr_zmbuf;</span><br><span class="line">	<span class="type">uint16_t</span>		zmbuf_size;</span><br><span class="line">	<span class="type">uint16_t</span>		last_zmbuf_idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcopy_mbuf</span>	*<span class="title">zmbufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zcopy_mbuf_list</span>	<span class="title">zmbuf_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_used_elem</span>  *<span class="title">shadow_used_split</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_used_elem_packed</span> *<span class="title">shadow_used_packed</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">uint16_t</span>                shadow_used_idx;</span><br><span class="line">	<span class="comment">/* Record packed ring enqueue latest desc cache aligned index */</span></span><br><span class="line">	<span class="type">uint16_t</span>		shadow_aligned_idx;</span><br><span class="line">	<span class="comment">/* Record packed ring first dequeue desc index */</span></span><br><span class="line">	<span class="type">uint16_t</span>		shadow_last_used_idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_vring_addr</span> <span class="title">ring_addrs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">batch_copy_elem</span>	*<span class="title">batch_copy_elems</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span>		batch_copy_nb_elems;</span><br><span class="line">	<span class="type">bool</span>			used_wrap_counter;</span><br><span class="line">	<span class="type">bool</span>			avail_wrap_counter;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">log_cache_entry</span> <span class="title">log_cache</span>[<span class="title">VHOST_LOG_CACHE_NR</span>];</span></span><br><span class="line">	<span class="type">uint16_t</span> log_cache_nb_elem;</span><br><span class="line"></span><br><span class="line">	<span class="type">rte_rwlock_t</span>	iotlb_lock;</span><br><span class="line">	<span class="type">rte_rwlock_t</span>	iotlb_pending_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">iotlb_pool</span>;</span></span><br><span class="line">	TAILQ_HEAD(, vhost_iotlb_entry) iotlb_list;</span><br><span class="line">	<span class="type">int</span>				iotlb_cache_nr;</span><br><span class="line">	TAILQ_HEAD(, vhost_iotlb_entry) iotlb_pending_list;</span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_MAX_VRING			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_MAX_QUEUE_PAIRS		0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Declare IOMMU related bits for older kernels */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VIRTIO_F_IOMMU_PLATFORM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO_F_IOMMU_PLATFORM 33</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_iotlb_msg</span> &#123;</span></span><br><span class="line">	__u64 iova;</span><br><span class="line">	__u64 size;</span><br><span class="line">	__u64 uaddr;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_ACCESS_RO      0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_ACCESS_WO      0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_ACCESS_RW      0x3</span></span><br><span class="line">	__u8 perm;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_IOTLB_MISS           1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_IOTLB_UPDATE         2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_IOTLB_INVALIDATE     3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_IOTLB_ACCESS_FAIL    4</span></span><br><span class="line">	__u8 type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_IOTLB_MSG 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vhost_msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vhost_iotlb_msg</span> <span class="title">iotlb</span>;</span></span><br><span class="line">		__u8 padding[<span class="number">64</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> addr;</span><br><span class="line">	<span class="type">uint32_t</span> len;</span><br><span class="line">	<span class="type">uint16_t</span> id;</span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> off_wrap;</span><br><span class="line">	<span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Device structure contains all configuration information relating</span></span><br><span class="line"><span class="comment"> * to the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_net</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Frontend (QEMU) memory and memory region information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_memory</span>	*<span class="title">mem</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span>		features;</span><br><span class="line">	<span class="type">uint64_t</span>		protocol_features;</span><br><span class="line">	<span class="type">int</span>			vid;</span><br><span class="line">	<span class="type">uint32_t</span>		flags;</span><br><span class="line">	<span class="type">uint16_t</span>		vhost_hlen;</span><br><span class="line">	<span class="comment">/* to tell if we need broadcast rarp packet */</span></span><br><span class="line">	<span class="type">rte_atomic16_t</span>		broadcast_rarp;</span><br><span class="line">	<span class="type">uint32_t</span>		nr_vring;</span><br><span class="line">	<span class="type">int</span>			dequeue_zero_copy;</span><br><span class="line">	<span class="type">int</span>			extbuf;</span><br><span class="line">	<span class="type">int</span>			linearbuf;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span>	*<span class="title">virtqueue</span>[<span class="title">VHOST_MAX_QUEUE_PAIRS</span> * 2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inflight_mem_info</span> *<span class="title">inflight_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IF_NAME_SZ (PATH_MAX &gt; IFNAMSIZ ? PATH_MAX : IFNAMSIZ)</span></span><br><span class="line">	<span class="type">char</span>			ifname[IF_NAME_SZ];</span><br><span class="line">	<span class="type">uint64_t</span>		log_size;</span><br><span class="line">	<span class="type">uint64_t</span>		log_base;</span><br><span class="line">	<span class="type">uint64_t</span>		log_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span>	<span class="title">mac</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span>		mtu;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_device_ops</span> <span class="title">const</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span>		nr_guest_pages;</span><br><span class="line">	<span class="type">uint32_t</span>		max_guest_pages;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guest_page</span>       *<span class="title">guest_pages</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			slave_req_fd;</span><br><span class="line">	<span class="type">rte_spinlock_t</span>		slave_req_lock;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			postcopy_ufd;</span><br><span class="line">	<span class="type">int</span>			postcopy_listening;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Device id to identify a specific backend device.</span></span><br><span class="line"><span class="comment">	 * It&#x27;s set to -1 for the default software implementation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			vdpa_dev_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* context data for the external message handlers */</span></span><br><span class="line">	<span class="type">void</span>			*extern_data;</span><br><span class="line">	<span class="comment">/* pre and post vhost user message handlers for the device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_user_extern_ops</span> <span class="title">extern_ops</span>;</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br></pre></td></tr></table></figure>

<p>看到上面的一系列的数据结构是不是有熟悉的感觉，和上层的是不是有一些类似。这些数据都是为了 RX&#x2F;TX 的准备，包括在前面提到的在新版本中使用了 Packed 的方式来处理数据。<br>在设备处理的数据结构定义在 librte_ethdev&#x2F;rte_ethdev_core.h 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> * The generic data structure associated with each ethernet device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointers to burst-oriented packet receive and transmit functions are</span></span><br><span class="line"><span class="comment"> * located at the beginning of the structure, along with the pointer to</span></span><br><span class="line"><span class="comment"> * where all the data elements for the particular device are stored in shared</span></span><br><span class="line"><span class="comment"> * memory. This split allows the function pointer and driver data to be per-</span></span><br><span class="line"><span class="comment"> * process, while the actual configuration data for the device is shared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> &#123;</span></span><br><span class="line">	<span class="type">eth_rx_burst_t</span> rx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD receive function. */</span></span><br><span class="line">	<span class="type">eth_tx_burst_t</span> tx_pkt_burst; <span class="comment">/**&lt; Pointer to PMD transmit function. */</span></span><br><span class="line">	<span class="type">eth_tx_prep_t</span> tx_pkt_prepare; <span class="comment">/**&lt; Pointer to PMD transmit prepare function. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next two fields are per-device data but *data is shared between</span></span><br><span class="line"><span class="comment">	 * primary and secondary processes and *process_private is per-process</span></span><br><span class="line"><span class="comment">	 * private. The second one is managed by PMDs if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> *<span class="title">data</span>;</span>  <span class="comment">/**&lt; Pointer to device data. */</span></span><br><span class="line">	<span class="type">void</span> *process_private; <span class="comment">/**&lt; Pointer to per-process device data. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> *<span class="title">dev_ops</span>;</span> <span class="comment">/**&lt; Functions exported by PMD */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_device</span> *<span class="title">device</span>;</span> <span class="comment">/**&lt; Backing device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_handle</span> *<span class="title">intr_handle</span>;</span> <span class="comment">/**&lt; Device interrupt handle */</span></span><br><span class="line">	<span class="comment">/** User application callbacks for NIC interrupts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_cb_list</span> <span class="title">link_intr_cbs</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from rx_burst to post-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">post_rx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User-supplied functions called from tx_burst to pre-process</span></span><br><span class="line"><span class="comment">	 * received packets before passing them to the driver for transmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">pre_tx_burst_cbs</span>[<span class="title">RTE_MAX_QUEUES_PER_PORT</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_dev_state</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; Flag indicating the port state */</span></span><br><span class="line">	<span class="type">void</span> *security_ctx; <span class="comment">/**&lt; Context for security ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_sriov</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_owner</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> * The data part, with no function pointers, associated with each ethernet device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure is safe to place in shared memory to be common among different</span></span><br><span class="line"><span class="comment"> * processes in a multi-process configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_data</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[RTE_ETH_NAME_MAX_LEN]; <span class="comment">/**&lt; Unique identifier name */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> **rx_queues; <span class="comment">/**&lt; Array of pointers to RX queues. */</span></span><br><span class="line">	<span class="type">void</span> **tx_queues; <span class="comment">/**&lt; Array of pointers to TX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rx_queues; <span class="comment">/**&lt; Number of RX queues. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_tx_queues; <span class="comment">/**&lt; Number of TX queues. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_sriov</span> <span class="title">sriov</span>;</span>    <span class="comment">/**&lt; SRIOV data */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *dev_private;</span><br><span class="line">			<span class="comment">/**&lt; PMD-specific private data.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_link</span> <span class="title">dev_link</span>;</span>   <span class="comment">/**&lt; Link-level information &amp; status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">dev_conf</span>;</span>   <span class="comment">/**&lt; Configuration applied to device. */</span></span><br><span class="line">	<span class="type">uint16_t</span> mtu;                   <span class="comment">/**&lt; Maximum Transmission Unit. */</span></span><br><span class="line">	<span class="type">uint32_t</span> min_rx_buf_size;</span><br><span class="line">			<span class="comment">/**&lt; Common RX buffer size handled by all queues. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> rx_mbuf_alloc_failed; <span class="comment">/**&lt; RX ring mbuf allocation failures. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> *<span class="title">mac_addrs</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Device Ethernet link address.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">	<span class="type">uint64_t</span> mac_pool_sel[ETH_NUM_RECEIVE_MAC_ADDR];</span><br><span class="line">			<span class="comment">/**&lt; Bitmap associating MAC addresses to pools. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> *<span class="title">hash_mac_addrs</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Device Ethernet MAC addresses of hash filtering.</span></span><br><span class="line"><span class="comment">			 *   @see rte_eth_dev_release_port()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">	<span class="type">uint16_t</span> port_id;           <span class="comment">/**&lt; Device [external] port identifier. */</span></span><br><span class="line"></span><br><span class="line">	__extension__</span><br><span class="line">	<span class="type">uint8_t</span> promiscuous   : <span class="number">1</span>, <span class="comment">/**&lt; RX promiscuous mode ON(1) / OFF(0). */</span></span><br><span class="line">		scattered_rx : <span class="number">1</span>,  <span class="comment">/**&lt; RX of scattered packets is ON(1) / OFF(0) */</span></span><br><span class="line">		all_multicast : <span class="number">1</span>, <span class="comment">/**&lt; RX all multicast mode ON(1) / OFF(0). */</span></span><br><span class="line">		dev_started : <span class="number">1</span>,   <span class="comment">/**&lt; Device state: STARTED(1) / STOPPED(0). */</span></span><br><span class="line">		lro         : <span class="number">1</span>;   <span class="comment">/**&lt; RX LRO is ON(1) / OFF(0) */</span></span><br><span class="line">	<span class="type">uint8_t</span> rx_queue_state[RTE_MAX_QUEUES_PER_PORT];</span><br><span class="line">		<span class="comment">/**&lt; Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0). */</span></span><br><span class="line">	<span class="type">uint8_t</span> tx_queue_state[RTE_MAX_QUEUES_PER_PORT];</span><br><span class="line">		<span class="comment">/**&lt; Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0). */</span></span><br><span class="line">	<span class="type">uint32_t</span> dev_flags;             <span class="comment">/**&lt; Capabilities. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_kernel_driver</span> <span class="title">kdrv</span>;</span>    <span class="comment">/**&lt; Kernel driver passthrough. */</span></span><br><span class="line">	<span class="type">int</span> numa_node;                  <span class="comment">/**&lt; NUMA node connection. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vlan_filter_conf</span> <span class="title">vlan_filter_conf</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; VLAN filter configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_owner</span> <span class="title">owner</span>;</span> <span class="comment">/**&lt; The port owner. */</span></span><br><span class="line">	<span class="type">uint16_t</span> representor_id;</span><br><span class="line">			<span class="comment">/**&lt; Switch-specific identifier.</span></span><br><span class="line"><span class="comment">			 *   Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> reserved_64s[<span class="number">4</span>]; <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">	<span class="type">void</span> *reserved_ptrs[<span class="number">4</span>];   <span class="comment">/**&lt; Reserved for future fields */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述的定义其还有一些内存数据结构相关管理数据都分散在上面提到的这些文件夹内，可以在分析代码时有针对性的看一看。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>通过上面的数据结构可以清楚的看到数据的定义，那么把这些数据结构串通起来的代码，就可以看做是 DPDK 的数据流动的过程，其实在 IO 通信中，从底层来看，只有三种状况，收、发和事件。这里就从收发开始处理，这里有一个需要注意的情况，在 DPDK 中有 lib 抽象出来的封装函数和在 PMD 使用的更上层的封装函数，先看 lib 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上层客户端中得到缓冲区的数据</span></span><br><span class="line"><span class="type">uint16_t</span>  <span class="title function_">rte_vhost_dequeue_burst</span><span class="params">(<span class="type">int</span> vid, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_mempool * mbuf_pool, <span class="keyword">struct</span> rte_mbuf ** pkts, <span class="type">uint16_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net</span> * <span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">rarp_mbuf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> * <span class="title">vq</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = get_device(vid);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(dev-&gt;flags &amp; VIRTIO_DEV_BUILTIN_VIRTIO_NET))) &#123;</span><br><span class="line">		RTE_LOG(ERR, VHOST_DATA,</span><br><span class="line">			<span class="string">&quot;(%d) %s: built-in vhost net backend is disabled.\n&quot;</span>,</span><br><span class="line">			dev-&gt;vid, __func__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!is_valid_virt_queue_idx(queue_id, <span class="number">1</span>, dev-&gt;nr_vring))) &#123;</span><br><span class="line">		RTE_LOG(ERR, VHOST_DATA, <span class="string">&quot;(%d) %s: invalid virtqueue idx %d.\n&quot;</span>,</span><br><span class="line">			dev-&gt;vid, __func__, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vq = dev-&gt;virtqueue[queue_id];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rte_spinlock_trylock(&amp;vq-&gt;access_lock) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(vq-&gt;enabled == <span class="number">0</span>)) &#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> out_access_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;features &amp; (<span class="number">1ULL</span> &lt;&lt; VIRTIO_F_IOMMU_PLATFORM))</span><br><span class="line">		vhost_user_iotlb_rd_lock(vq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(vq-&gt;access_ok == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">if</span> (unlikely(vring_translate(dev, vq) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Construct a RARP broadcast packet, and inject it to the &quot;pkts&quot;</span></span><br><span class="line"><span class="comment">	 * array, to looks like that guest actually send such packet.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Check user_send_rarp() for more information.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * broadcast_rarp shares a cacheline in the virtio_net structure</span></span><br><span class="line"><span class="comment">	 * with some fields that are accessed during enqueue and</span></span><br><span class="line"><span class="comment">	 * rte_atomic16_cmpset() causes a write if using cmpxchg. This could</span></span><br><span class="line"><span class="comment">	 * result in false sharing between enqueue and dequeue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Prevent unnecessary false sharing by reading broadcast_rarp first</span></span><br><span class="line"><span class="comment">	 * and only performing cmpset if the read indicates it is likely to</span></span><br><span class="line"><span class="comment">	 * be set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rte_atomic16_read(&amp;dev-&gt;broadcast_rarp) &amp;&amp;</span><br><span class="line">			rte_atomic16_cmpset((<span class="keyword">volatile</span> <span class="type">uint16_t</span> *)</span><br><span class="line">				&amp;dev-&gt;broadcast_rarp.cnt, <span class="number">1</span>, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		rarp_mbuf = rte_net_make_rarp_packet(mbuf_pool, &amp;dev-&gt;mac);</span><br><span class="line">		<span class="keyword">if</span> (rarp_mbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, VHOST_DATA,</span><br><span class="line">				<span class="string">&quot;Failed to make RARP packet.\n&quot;</span>);</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		count -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vq_is_packed(dev)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(dev-&gt;dequeue_zero_copy))</span><br><span class="line">			count = virtio_dev_tx_packed_zmbuf(dev, vq, mbuf_pool, pkts, count);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count = virtio_dev_tx_packed(dev, vq, mbuf_pool, pkts, count);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		count = virtio_dev_tx_split(dev, vq, mbuf_pool, pkts, count);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;features &amp; (<span class="number">1ULL</span> &lt;&lt; VIRTIO_F_IOMMU_PLATFORM))</span><br><span class="line">		vhost_user_iotlb_rd_unlock(vq);</span><br><span class="line"></span><br><span class="line">out_access_unlock:</span><br><span class="line">	rte_spinlock_unlock(&amp;vq-&gt;access_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rarp_mbuf != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Inject it to the head of &quot;pkts&quot; array, so that switch&#x27;s mac</span></span><br><span class="line"><span class="comment">		 * learning table will get updated first.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		memmove(&amp;pkts[<span class="number">1</span>], pkts, count * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_mbuf * ));</span><br><span class="line">		pkts[<span class="number">0</span>] = rarp_mbuf;</span><br><span class="line">		count += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是增加到队列中缓冲区的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Virtio设备的接收virtqueue增加缓冲区</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">rte_vhost_enqueue_burst</span><span class="params">( <span class="type">int</span> vid, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_mbuf **pkts, <span class="type">uint16_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net</span> * <span class="title">dev</span> =</span> get_device(vid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(dev-&gt;flags &amp; VIRTIO_DEV_BUILTIN_VIRTIO_NET))) &#123;</span><br><span class="line">		RTE_LOG(ERR, VHOST_DATA,</span><br><span class="line">			<span class="string">&quot;(%d) %s: built-in vhost net backend is disabled.\n&quot;</span>,</span><br><span class="line">			dev-&gt;vid, __func__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> virtio_dev_rx(dev, queue_id, pkts, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 PMD 中的处理封装函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> </span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;rx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_rx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid RX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;post_rx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_rx = cb-&gt;fn.rx(port_id, queue_id, rx_pkts, nb_rx,</span><br><span class="line">						nb_pkts, cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **tx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;tx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_tx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid TX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;pre_tx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_pkts = cb-&gt;fn.tx(port_id, queue_id, tx_pkts, nb_pkts,</span><br><span class="line">					cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;tx_pkt_burst)(dev-&gt;data-&gt;tx_queues[queue_id], tx_pkts, nb_pkts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的最后一行代码，通过 ID 来查找相关的函数函数，并将其通过 tx_pkt_burst 强制转到相关的函数指针，这就和下面分析如何与 lib 中的相关封装函数连接在一起进行了一个转换。</p>
<p>下面是二者是如何转换的过程，看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">eth_dev_vhost_create</span><span class="params">(<span class="keyword">struct</span> rte_vdev_device *dev, <span class="type">char</span> *iface_name,</span></span><br><span class="line"><span class="params">	<span class="type">int16_t</span> queues, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> numa_node, <span class="type">uint64_t</span> flags,</span></span><br><span class="line"><span class="params">	<span class="type">uint64_t</span> disable_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	eth_dev-&gt;dev_ops = &amp;ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* finally assign rx and tx ops */</span></span><br><span class="line">	eth_dev-&gt;rx_pkt_burst = eth_vhost_rx;<span class="comment">//定义函数指针</span></span><br><span class="line">	eth_dev-&gt;tx_pkt_burst = eth_vhost_tx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;rx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_rx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid RX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//此处的代码认真分析一下可以看到转换的过程</span></span><br><span class="line">	nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;post_rx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_rx = cb-&gt;fn.rx(port_id, queue_id, rx_pkts, nb_rx,</span><br><span class="line">						nb_pkts, cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">eth_vhost_rx</span><span class="params">(<span class="type">void</span> *q, <span class="keyword">struct</span> rte_mbuf **bufs, <span class="type">uint16_t</span> nb_bufs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_queue</span> *<span class="title">r</span> =</span> q;</span><br><span class="line">	<span class="type">uint16_t</span> i, nb_rx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint16_t</span> nb_receive = nb_bufs;</span><br><span class="line">	<span class="type">uint64_t</span> nb_bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rte_atomic32_read(&amp;r-&gt;allow_queuing) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rte_atomic32_set(&amp;r-&gt;while_queuing, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rte_atomic32_read(&amp;r-&gt;allow_queuing) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Dequeue packets from guest TX queue */</span></span><br><span class="line">	<span class="keyword">while</span> (nb_receive) &#123;</span><br><span class="line">		<span class="type">uint16_t</span> nb_pkts;</span><br><span class="line">		<span class="type">uint16_t</span> num = (<span class="type">uint16_t</span>)RTE_MIN(nb_receive,</span><br><span class="line">						 VHOST_MAX_PKT_BURST);</span><br><span class="line">    <span class="comment">//此处调用了rte_vhost_dequeue_burst</span></span><br><span class="line">		nb_pkts = rte_vhost_dequeue_burst(r-&gt;vid, r-&gt;virtqueue_id,</span><br><span class="line">						  r-&gt;mb_pool, &amp;bufs[nb_rx],</span><br><span class="line">						  num);</span><br><span class="line"></span><br><span class="line">		nb_rx += nb_pkts;</span><br><span class="line">		nb_receive -= nb_pkts;</span><br><span class="line">		<span class="keyword">if</span> (nb_pkts &lt; num)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r-&gt;stats.pkts += nb_rx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; likely(i &lt; nb_rx); i++) &#123;</span><br><span class="line">		bufs[i]-&gt;port = r-&gt;port;</span><br><span class="line">		bufs[i]-&gt;vlan_tci = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r-&gt;internal-&gt;vlan_strip)</span><br><span class="line">			rte_vlan_strip(bufs[i]);</span><br><span class="line"></span><br><span class="line">		nb_bytes += bufs[i]-&gt;pkt_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r-&gt;stats.bytes += nb_bytes;</span><br><span class="line">	vhost_update_packet_xstats(r, bufs, nb_rx, nb_bytes, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rte_atomic32_set(&amp;r-&gt;while_queuing, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从此处可以看出 eth_vhost_rx 中封装了 rte_vhost_dequeue_burst，另外一个 enqueue 也是如此。</p>
<h1 id="vhost-user"><a href="#vhost-user" class="headerlink" title="vhost-user"></a>vhost-user</h1><p>在网络 IO 的半虚拟中，vhost-user 是目前最优秀的解决方案。在 DPDK 中，同样也采用了这种方式。vhost-user 是为了解决内核状态数据操作复杂的情况提出的一种解决方式，通过在用户进程来替代内核进程来实现数据交互的最少化。在 vhost-user 中，使用 Socket 进行设备文件间通信（替代了 Kernel 模式），而数据交换则采用  mmap 的进程内存共享的模式减少数据的交互。<br>vhost-user 在 DPDK 中的 vhost 库中实现，其包含了完整的  virtio 的后端逻辑功能。在软件虚拟交的机 OVS 中，就应用到了 DPDK 这个库。<br>一般来说，vhost-user 由  OVS 为每个虚拟创建珍上 vhost 端口，来实现相关数据操作。而此时的 virtio 前端和会调用此相关的端口进行通信。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>基本的数据结构如下（lib&#x2F;librte_vhost&#x2F;vhost_user.h）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Same structure as vhost-user backend session info */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserCryptoSessionParam</span> &#123;</span></span><br><span class="line">	<span class="type">int64_t</span> session_id;</span><br><span class="line">	<span class="type">uint32_t</span> op_code;</span><br><span class="line">	<span class="type">uint32_t</span> cipher_algo;</span><br><span class="line">	<span class="type">uint32_t</span> cipher_key_len;</span><br><span class="line">	<span class="type">uint32_t</span> hash_algo;</span><br><span class="line">	<span class="type">uint32_t</span> digest_len;</span><br><span class="line">	<span class="type">uint32_t</span> auth_key_len;</span><br><span class="line">	<span class="type">uint32_t</span> aad_len;</span><br><span class="line">	<span class="type">uint8_t</span> op_type;</span><br><span class="line">	<span class="type">uint8_t</span> dir;</span><br><span class="line">	<span class="type">uint8_t</span> hash_mode;</span><br><span class="line">	<span class="type">uint8_t</span> chaining_dir;</span><br><span class="line">	<span class="type">uint8_t</span> * ciphe_key;</span><br><span class="line">	<span class="type">uint8_t</span> * auth_key;</span><br><span class="line">	<span class="type">uint8_t</span> cipher_key_buf[VHOST_USER_CRYPTO_MAX_CIPHER_KEY_LENGTH];</span><br><span class="line">	<span class="type">uint8_t</span> auth_key_buf[VHOST_USER_CRYPTO_MAX_HMAC_KEY_LENGTH];</span><br><span class="line">&#125; VhostUserCryptoSessionParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserVringArea</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">	<span class="type">uint64_t</span> size;</span><br><span class="line">	<span class="type">uint64_t</span> offset;</span><br><span class="line">&#125; VhostUserVringArea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserInflight</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> mmap_size;</span><br><span class="line">	<span class="type">uint64_t</span> mmap_offset;</span><br><span class="line">	<span class="type">uint16_t</span> num_queues;</span><br><span class="line">	<span class="type">uint16_t</span> queue_size;</span><br><span class="line">&#125; VhostUserInflight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserMsg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> master; <span class="comment">/* a VhostUserRequest value */</span></span><br><span class="line">		<span class="type">uint32_t</span> slave;  <span class="comment">/* a VhostUserSlaveRequest value*/</span></span><br><span class="line">	&#125; request;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_USER_VERSION_MASK     0x3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_USER_REPLY_MASK       (0x1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_USER_NEED_REPLY		(0x1 &lt;&lt; 3)</span></span><br><span class="line">	<span class="type">uint32_t</span> flags;</span><br><span class="line">	<span class="type">uint32_t</span> size; <span class="comment">/* the following payload size */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_USER_VRING_IDX_MASK   0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_USER_VRING_NOFD_MASK  (0x1&lt;&lt;8)</span></span><br><span class="line">		<span class="type">uint64_t</span> u64;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vhost_vring_state</span> <span class="title">state</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vhost_vring_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">		VhostUserMemory memory;</span><br><span class="line">		VhostUserLog    <span class="built_in">log</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vhost_iotlb_msg</span> <span class="title">iotlb</span>;</span></span><br><span class="line">		VhostUserCryptoSessionParam crypto_session;</span><br><span class="line">		VhostUserVringArea area;</span><br><span class="line">		VhostUserInflight inflight;</span><br><span class="line">	&#125; payload;</span><br><span class="line">	<span class="type">int</span> fds[VHOST_MEMORY_MAX_NREGIONS];</span><br><span class="line">	<span class="type">int</span> fd_num;</span><br><span class="line">&#125; __attribute((packed)) VhostUserMsg;</span><br></pre></td></tr></table></figure>

<p>其中最主要的就是最后一个数据结构 VhostUserMsg，这个消息里包含着消息的种类、内容和相关内容的数据大小。而这个消息，正是通过 vhost_user.c(lib&#x2F;librte_vhost) 中的 vhost_user_msg_handler 这个函数来处理的。它们之间的消息类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">VhostUserRequest</span> &#123;</span></span><br><span class="line">    VHOST_USER_NONE = <span class="number">0</span>,</span><br><span class="line">    VHOST_USER_GET_FEATURES = <span class="number">1</span>,</span><br><span class="line">    VHOST_USER_SET_FEATURES = <span class="number">2</span>,</span><br><span class="line">    VHOST_USER_SET_OWNER = <span class="number">3</span>,</span><br><span class="line">    VHOST_USER_RESET_OWNER = <span class="number">4</span>,</span><br><span class="line">    VHOST_USER_SET_MEM_TABLE = <span class="number">5</span>,</span><br><span class="line">    VHOST_USER_SET_LOG_BASE = <span class="number">6</span>,</span><br><span class="line">    VHOST_USER_SET_LOG_FD = <span class="number">7</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_NUM = <span class="number">8</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_ADDR = <span class="number">9</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_BASE = <span class="number">10</span>,</span><br><span class="line">    VHOST_USER_GET_VRING_BASE = <span class="number">11</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_KICK = <span class="number">12</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_CALL = <span class="number">13</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_ERR = <span class="number">14</span>,</span><br><span class="line">    VHOST_USER_GET_PROTOCOL_FEATURES = <span class="number">15</span>,</span><br><span class="line">    VHOST_USER_SET_PROTOCOL_FEATURES = <span class="number">16</span>,</span><br><span class="line">    VHOST_USER_GET_QUEUE_NUM = <span class="number">17</span>,</span><br><span class="line">    VHOST_USER_SET_VRING_ENABLE = <span class="number">18</span>,</span><br><span class="line">    VHOST_USER_SEND_RARP = <span class="number">19</span>,</span><br><span class="line">    VHOST_USER_NET_SET_MTU = <span class="number">20</span>,</span><br><span class="line">    VHOST_USER_SET_SLAVE_REQ_FD = <span class="number">21</span>,</span><br><span class="line">    VHOST_USER_IOTLB_MSG = <span class="number">22</span>,</span><br><span class="line">    VHOST_USER_MAX</span><br><span class="line">&#125; VhostUserRequest;</span><br></pre></td></tr></table></figure>

<p>随着版本的迭代和新的设备及相关控制手段增加会引起一些消息的增加。<br>再看一下相关的共享内存数据结构 (lib&#x2F;librte_vhost&#x2F;vhost_user.h)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应qemu端的region结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserMemoryRegion</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> guest_phys_addr;</span><br><span class="line">	<span class="type">uint64_t</span> memory_size;</span><br><span class="line">	<span class="type">uint64_t</span> userspace_addr;</span><br><span class="line">	<span class="type">uint64_t</span> mmap_offset;</span><br><span class="line">&#125; VhostUserMemoryRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VhostUserMemory</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> nregions;</span><br><span class="line">	<span class="type">uint32_t</span> padding;</span><br><span class="line">	VhostUserMemoryRegion regions[VHOST_MEMORY_MAX_NREGIONS];</span><br><span class="line">&#125; VhostUserMemory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lib/librte_vhost/rte_vhost.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Information relating to memory regions including offsets to</span></span><br><span class="line"><span class="comment"> * addresses in QEMUs memory file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_mem_region</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> guest_phys_addr;</span><br><span class="line">	<span class="type">uint64_t</span> guest_user_addr;</span><br><span class="line">	<span class="type">uint64_t</span> host_user_addr;</span><br><span class="line">	<span class="type">uint64_t</span> size;</span><br><span class="line">	<span class="type">void</span>	 *mmap_addr;</span><br><span class="line">	<span class="type">uint64_t</span> mmap_size;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Memory structure includes region and mapping information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_memory</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> nregions;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_mem_region</span> <span class="title">regions</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的两个不同文件夹的相关数据结构体互相对应。</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>1、连接和初始化<br>连接的建立是使用 Sokcet 来进行的。在前面的消息数据结构体中，其实是定义了很多消息枚举和相关的数组的。这个上面的数据结构体中已经有所体现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_vhost_driver_start</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_user_socket</span> * <span class="title">vsocket</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">pthread_t</span> fdset_tid;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;vhost_user.mutex);</span><br><span class="line">	vsocket = find_vhost_user_socket(path);</span><br><span class="line">	pthread_mutex_unlock(&amp;vhost_user.mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!vsocket)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdset_tid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * create a pipe which will be waited by poll and notified to</span></span><br><span class="line"><span class="comment">		 * rebuild the wait list of poll.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (fdset_pipe_init(&amp;vhost_user.fdset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, VHOST_CONFIG,</span><br><span class="line">				<span class="string">&quot;failed to create pipe for vhost fdset\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ret = rte_ctrl_thread_create(&amp;fdset_tid,</span><br><span class="line">			<span class="string">&quot;vhost-events&quot;</span>, <span class="literal">NULL</span>, fdset_event_dispatch,</span><br><span class="line">			&amp;vhost_user.fdset);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, VHOST_CONFIG,</span><br><span class="line">				<span class="string">&quot;failed to create fdset handling thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			fdset_pipe_uninit(&amp;vhost_user.fdset);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vsocket-&gt;is_server)</span><br><span class="line">		<span class="keyword">return</span> vhost_user_start_server(vsocket);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> vhost_user_start_client(vsocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过线程来启动分发控制，最后根据是客户端或者服务端来启动相应的功能函数。<br>当有一个新的连接时，则处理为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call back when there is new vhost-user connection from client  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vhost_user_server_new_connection</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *dat, <span class="type">int</span> * remove __rte_unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_user_socket</span> *<span class="title">vsocket</span> =</span> dat;</span><br><span class="line"></span><br><span class="line">	fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	RTE_LOG(INFO, VHOST_CONFIG, <span class="string">&quot;new vhost user connection is %d\n&quot;</span>, fd);</span><br><span class="line">	vhost_user_add_connection(fd, vsocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实你看 lib&#x2F;librte_vhost&#x2F;socket.c 中的代码，如果有 Socket 编程的经验的一眼就可以看出好多相关的处理函数和处理手段。</p>
<p>2、数据通信<br>数据通信中数据交互使用 mmap，相关设置代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vhost_user_set_mem_table</span><span class="params">(<span class="keyword">struct</span> virtio_net **pdev,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> vhu_msg_context *ctx,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> main_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net</span> *<span class="title">dev</span> =</span> *pdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">VhostUserMemory</span> *<span class="title">memory</span> =</span> &amp;ctx-&gt;msg.payload.memory;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_mem_region</span> *<span class="title">reg</span>;</span></span><br><span class="line">	<span class="type">int</span> numa_node = SOCKET_ID_ANY;</span><br><span class="line">	<span class="type">uint64_t</span> mmap_offset;</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="type">bool</span> async_notify = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (validate_msg_fds(dev, ctx, memory-&gt;nregions) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (memory-&gt;nregions &gt; VHOST_MEMORY_MAX_NREGIONS) &#123;</span><br><span class="line">		VHOST_LOG_CONFIG(dev-&gt;ifname, ERR,</span><br><span class="line">			<span class="string">&quot;too many memory regions (%u)\n&quot;</span>,</span><br><span class="line">			memory-&gt;nregions);</span><br><span class="line">		<span class="keyword">goto</span> close_msg_fds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;mem &amp;&amp; !vhost_memory_changed(memory, dev-&gt;mem)) &#123;</span><br><span class="line">		VHOST_LOG_CONFIG(dev-&gt;ifname, INFO, <span class="string">&quot;memory regions not changed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		close_msg_fds(ctx);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;mem) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;flags &amp; VIRTIO_DEV_VDPA_CONFIGURED) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_vdpa_device</span> *<span class="title">vdpa_dev</span> =</span> dev-&gt;vdpa_dev;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vdpa_dev &amp;&amp; vdpa_dev-&gt;ops-&gt;dev_close)</span><br><span class="line">				vdpa_dev-&gt;ops-&gt;dev_close(dev-&gt;vid);</span><br><span class="line">			dev-&gt;flags &amp;= ~VIRTIO_DEV_VDPA_CONFIGURED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* notify the vhost application to stop DMA transfers */</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;async_copy &amp;&amp; dev-&gt;notify_ops-&gt;vring_state_changed) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;nr_vring; i++) &#123;</span><br><span class="line">				dev-&gt;notify_ops-&gt;vring_state_changed(dev-&gt;vid,</span><br><span class="line">						i, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			async_notify = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Flush IOTLB cache as previous HVAs are now invalid */</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;features &amp; (<span class="number">1ULL</span> &lt;&lt; VIRTIO_F_IOMMU_PLATFORM))</span><br><span class="line">			vhost_user_iotlb_flush_all(dev);</span><br><span class="line"></span><br><span class="line">		free_mem_region(dev);</span><br><span class="line">		rte_free(dev-&gt;mem);</span><br><span class="line">		dev-&gt;mem = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If VQ 0 has already been allocated, try to allocate on the same</span></span><br><span class="line"><span class="comment">	 * NUMA node. It can be reallocated later in numa_realloc().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;nr_vring &gt; <span class="number">0</span>)</span><br><span class="line">		numa_node = dev-&gt;virtqueue[<span class="number">0</span>]-&gt;numa_node;</span><br><span class="line"></span><br><span class="line">	dev-&gt;nr_guest_pages = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;guest_pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		dev-&gt;max_guest_pages = <span class="number">8</span>;</span><br><span class="line">		dev-&gt;guest_pages = rte_zmalloc_socket(<span class="literal">NULL</span>,</span><br><span class="line">					dev-&gt;max_guest_pages *</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> guest_page),</span><br><span class="line">					RTE_CACHE_LINE_SIZE,</span><br><span class="line">					numa_node);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;guest_pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			VHOST_LOG_CONFIG(dev-&gt;ifname, ERR,</span><br><span class="line">				<span class="string">&quot;failed to allocate memory for dev-&gt;guest_pages\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> close_msg_fds;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;mem = rte_zmalloc_socket(<span class="string">&quot;vhost-mem-table&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_vhost_memory) +</span><br><span class="line">		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_vhost_mem_region) * memory-&gt;nregions, <span class="number">0</span>, numa_node);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		VHOST_LOG_CONFIG(dev-&gt;ifname, ERR, <span class="string">&quot;failed to allocate memory for dev-&gt;mem\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> free_guest_pages;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memory-&gt;nregions; i++) &#123;</span><br><span class="line">		reg = &amp;dev-&gt;mem-&gt;regions[i];</span><br><span class="line">		reg-&gt;guest_phys_addr = memory-&gt;regions[i].guest_phys_addr;</span><br><span class="line">		reg-&gt;guest_user_addr = memory-&gt;regions[i].userspace_addr;</span><br><span class="line">		reg-&gt;size            = memory-&gt;regions[i].memory_size;</span><br><span class="line">		reg-&gt;fd              = ctx-&gt;fds[i];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Assign invalid file descriptor value to avoid double</span></span><br><span class="line"><span class="comment">		 * closing on error path.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ctx-&gt;fds[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		mmap_offset = memory-&gt;regions[i].mmap_offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vhost_user_mmap_region(dev, reg, mmap_offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			VHOST_LOG_CONFIG(dev-&gt;ifname, ERR, <span class="string">&quot;failed to mmap region %u\n&quot;</span>, i);</span><br><span class="line">			<span class="keyword">goto</span> free_mem_table;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev-&gt;mem-&gt;nregions++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;async_copy &amp;&amp; rte_vfio_is_enabled(<span class="string">&quot;vfio&quot;</span>))</span><br><span class="line">		async_dma_map(dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vhost_user_postcopy_register(dev, main_fd, ctx) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_mem_table;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;nr_vring; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> *<span class="title">vq</span> =</span> dev-&gt;virtqueue[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!vq)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vq-&gt;desc || vq-&gt;avail || vq-&gt;used) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the memory table got updated, the ring addresses</span></span><br><span class="line"><span class="comment">			 * need to be translated again as virtual addresses have</span></span><br><span class="line"><span class="comment">			 * changed.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			vring_invalidate(dev, vq);</span><br><span class="line"></span><br><span class="line">			translate_ring_addresses(&amp;dev, &amp;vq);</span><br><span class="line">			*pdev = dev;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dump_guest_pages(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (async_notify) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;nr_vring; i++)</span><br><span class="line">			dev-&gt;notify_ops-&gt;vring_state_changed(dev-&gt;vid, i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_OK;</span><br><span class="line"></span><br><span class="line">free_mem_table:</span><br><span class="line">	free_mem_region(dev);</span><br><span class="line">	rte_free(dev-&gt;mem);</span><br><span class="line">	dev-&gt;mem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">free_guest_pages:</span><br><span class="line">	rte_free(dev-&gt;guest_pages);</span><br><span class="line">	dev-&gt;guest_pages = <span class="literal">NULL</span>;</span><br><span class="line">close_msg_fds:</span><br><span class="line">	close_msg_fds(ctx);</span><br><span class="line">	<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>地址的转换是在下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Converts QEMU virtual address to Vhost virtual address. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">qva_to_vva</span><span class="params">(<span class="keyword">struct</span> virtio_net *dev, <span class="type">uint64_t</span> qva, <span class="type">uint64_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_vhost_mem_region</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dev || !dev-&gt;mem))</span><br><span class="line">		<span class="keyword">goto</span> out_error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find the region where the address lives. */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;mem-&gt;nregions; i++) &#123;</span><br><span class="line">		r = &amp;dev-&gt;mem-&gt;regions[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (qva &gt;= r-&gt;guest_user_addr &amp;&amp;</span><br><span class="line">		    qva &lt;  r-&gt;guest_user_addr + r-&gt;size) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(*len &gt; r-&gt;guest_user_addr + r-&gt;size - qva))</span><br><span class="line">				*len = r-&gt;guest_user_addr + r-&gt;size - qva;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> qva - r-&gt;guest_user_addr +</span><br><span class="line">			       r-&gt;host_user_addr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_error:</span><br><span class="line">	*len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据的实际通信，在前面分析过，就是 “rte_vhost_enqueue_burst” 和“rte_vhost_dequeue_burst”这两个函数。</p>
<p>3、通知机制</p>
<p>基本上是采用 eventfd 的方式，这和网络通信保持一致：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">vhost_user_set_vring_kick</span><span class="params">(<span class="keyword">struct</span> virtio_net **pdev, <span class="keyword">struct</span> VhostUserMsg *msg,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> main_fd __rte_unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_net</span> *<span class="title">dev</span> =</span> *pdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_vring_file</span> <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_virtqueue</span> *<span class="title">vq</span>;</span></span><br><span class="line">	<span class="type">int</span> expected_fds;</span><br><span class="line"></span><br><span class="line">	expected_fds = (msg-&gt;payload.u64 &amp; VHOST_USER_VRING_NOFD_MASK) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (validate_msg_fds(msg, expected_fds) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line"></span><br><span class="line">	file.index = msg-&gt;payload.u64 &amp; VHOST_USER_VRING_IDX_MASK;</span><br><span class="line">	<span class="keyword">if</span> (msg-&gt;payload.u64 &amp; VHOST_USER_VRING_NOFD_MASK)</span><br><span class="line">		file.fd = VIRTIO_INVALID_EVENTFD;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		file.fd = msg-&gt;fds[<span class="number">0</span>];</span><br><span class="line">	RTE_LOG(INFO, VHOST_CONFIG,</span><br><span class="line">		<span class="string">&quot;vring kick idx:%d file:%d\n&quot;</span>, file.index, file.fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Interpret ring addresses only when ring is started. */</span></span><br><span class="line">	dev = translate_ring_addresses(dev, file.index);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">if</span> (file.fd != VIRTIO_INVALID_EVENTFD)</span><br><span class="line">			close(file.fd);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pdev = dev;</span><br><span class="line"></span><br><span class="line">	vq = dev-&gt;virtqueue[file.index];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When VHOST_USER_F_PROTOCOL_FEATURES is not negotiated,</span></span><br><span class="line"><span class="comment">	 * the ring starts already enabled. Otherwise, it is enabled via</span></span><br><span class="line"><span class="comment">	 * the SET_VRING_ENABLE message.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(dev-&gt;features &amp; (<span class="number">1ULL</span> &lt;&lt; VHOST_USER_F_PROTOCOL_FEATURES))) &#123;</span><br><span class="line">		vq-&gt;enabled = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;notify_ops-&gt;vring_state_changed)</span><br><span class="line">			dev-&gt;notify_ops-&gt;vring_state_changed(</span><br><span class="line">				dev-&gt;vid, file.index, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vq-&gt;kickfd &gt;= <span class="number">0</span>)</span><br><span class="line">		close(vq-&gt;kickfd);</span><br><span class="line">	vq-&gt;kickfd = file.fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vq_is_packed(dev)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vhost_check_queue_inflights_packed(dev, vq)) &#123;</span><br><span class="line">			RTE_LOG(ERR, VHOST_CONFIG,</span><br><span class="line">				<span class="string">&quot;failed to inflights for vq: %d\n&quot;</span>, file.index);</span><br><span class="line">			<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (vhost_check_queue_inflights_split(dev, vq)) &#123;</span><br><span class="line">			RTE_LOG(ERR, VHOST_CONFIG,</span><br><span class="line">				<span class="string">&quot;failed to inflights for vq: %d\n&quot;</span>, file.index);</span><br><span class="line">			<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_ERR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RTE_VHOST_MSG_RESULT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述交互使用 Poll 机制，也就是轮询，来不断驱动着数据的流动。</p>
<p>在网络 IO 的半虚拟中，vhost-user 是目前最优的解决方案。在 DPDK 中，同样也采用了这种方式。vhost-user 是为了解决内核状态数据操作复杂的情况提出的一种解决方式，通过在用户进程来替代内核进程来实现数据交互的最少化。在 vhost-user 在应用场景中，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%8C%96&spm=1001.2101.3001.7020">虚拟化</a>的容器支持是一个重点方向。起初的 virtio-user 就是为了支持容器内部与 DPDK 通信的。后来也发展到虚拟设备间的通信。<br>DPDK 与 Kernel 的通信也叫做 “exception path”，通常来说，这种通信方式主要有几种：<br>1、KNI，是目前 DPDK 中用户使用的主要方案。即通过虚拟网络接口，利用队列和 DPDK 应用交的数据，但无法实现 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=upstream&spm=1001.2101.3001.7020">upstream</a>(一种负载均衡的手段)<br>2、Tun&#x2F;Tap 或者 pcap PMD. 需要内核切换，效率差<br>3、Flow Bifurcation，虚拟多张网卡，依赖硬件，不灵活<br>4、virtio-user 和 vhost-net，这是比较好的一种实现机制。<br>virtio-user 在 DPDK 和虚拟场景下的应用还是非常多的。virtio-user 虚拟出的设备和真实的设备在上层看没有区别，这个非常重要。</p>
<p>下面看一下在 DPDK 中相关的数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_user_queue</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> used_idx;</span><br><span class="line">	<span class="type">bool</span> avail_wrap_counter;</span><br><span class="line">	<span class="type">bool</span> used_wrap_counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_user_dev</span> &#123;</span></span><br><span class="line">	<span class="comment">/* for vhost_user backend */</span></span><br><span class="line">	<span class="type">int</span>		vhostfd;</span><br><span class="line">	<span class="type">int</span>		listenfd;   <span class="comment">/* listening fd */</span></span><br><span class="line">	<span class="type">bool</span>		is_server;  <span class="comment">/* server or client mode */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for vhost_kernel backend */</span></span><br><span class="line">	<span class="type">char</span>		*ifname;</span><br><span class="line">	<span class="type">int</span>		*vhostfds;</span><br><span class="line">	<span class="type">int</span>		*tapfds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for both vhost_user and vhost_kernel */</span></span><br><span class="line">	<span class="type">int</span>		callfds[VIRTIO_MAX_VIRTQUEUES];</span><br><span class="line">	<span class="type">int</span>		kickfds[VIRTIO_MAX_VIRTQUEUES];</span><br><span class="line">	<span class="type">int</span>		mac_specified;</span><br><span class="line">	<span class="type">uint32_t</span>	max_queue_pairs;</span><br><span class="line">	<span class="type">uint32_t</span>	queue_pairs;</span><br><span class="line">	<span class="type">uint32_t</span>	queue_size;</span><br><span class="line">	<span class="type">uint64_t</span>	features; <span class="comment">/* the negotiated features with driver,</span></span><br><span class="line"><span class="comment">				   * and will be sync with device</span></span><br><span class="line"><span class="comment">				   */</span></span><br><span class="line">	<span class="type">uint64_t</span>	device_features; <span class="comment">/* supported features by device */</span></span><br><span class="line">	<span class="type">uint64_t</span>	frontend_features; <span class="comment">/* enabled frontend features */</span></span><br><span class="line">	<span class="type">uint64_t</span>	unsupported_features; <span class="comment">/* unsupported features mask */</span></span><br><span class="line">	<span class="type">uint8_t</span>		status;</span><br><span class="line">	<span class="type">uint16_t</span>	net_status;</span><br><span class="line">	<span class="type">uint16_t</span>	port_id;</span><br><span class="line">	<span class="type">uint8_t</span>		mac_addr[RTE_ETHER_ADDR_LEN];</span><br><span class="line">	<span class="type">char</span>		path[PATH_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring</span>		<span class="title">vrings</span>[<span class="title">VIRTIO_MAX_VIRTQUEUES</span>];</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed</span>	<span class="title">packed_vrings</span>[<span class="title">VIRTIO_MAX_VIRTQUEUES</span>];</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_user_queue</span> <span class="title">packed_queues</span>[<span class="title">VIRTIO_MAX_VIRTQUEUES</span>];</span></span><br><span class="line">	<span class="type">bool</span>		qp_enabled[VIRTIO_MAX_VIRTQUEUE_PAIRS];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_user_backend_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span>	mutex;</span><br><span class="line">	<span class="type">bool</span>		started;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了虚拟设备外，其实它主要是和 VHOST 以及相关数据队列的操作，而那些数据结构在前面已经基本都介绍过了。</p>
<p>其实在前面说了，virtio-user 在虚拟环境中应用非常广泛，在 virtio-user 文件夹（driver&#x2F;net&#x2F;virtio）下可以看到，其实最主要的就是那几个文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">virtio_user_dev_init</span><span class="params">(<span class="keyword">struct</span> virtio_user_dev *dev, <span class="type">char</span> *path, <span class="type">int</span> queues,</span></span><br><span class="line"><span class="params">		     <span class="type">int</span> cq, <span class="type">int</span> queue_size, <span class="type">const</span> <span class="type">char</span> *mac, <span class="type">char</span> **ifname,</span></span><br><span class="line"><span class="params">		     <span class="type">int</span> server, <span class="type">int</span> mrg_rxbuf, <span class="type">int</span> in_order, <span class="type">int</span> packed_vq)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_init(&amp;dev-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">	strlcpy(dev-&gt;path, path, PATH_MAX);</span><br><span class="line">	dev-&gt;started = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;max_queue_pairs = queues;</span><br><span class="line">	dev-&gt;queue_pairs = <span class="number">1</span>; <span class="comment">/* mq disabled by default */</span></span><br><span class="line">	dev-&gt;queue_size = queue_size;</span><br><span class="line">	dev-&gt;is_server = server;</span><br><span class="line">	dev-&gt;mac_specified = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;frontend_features = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;unsupported_features = ~VIRTIO_USER_SUPPORTED_FEATURES;</span><br><span class="line">	parse_mac(dev, mac);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*ifname) &#123;</span><br><span class="line">		dev-&gt;ifname = *ifname;</span><br><span class="line">		*ifname = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (virtio_user_dev_setup(dev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR, <span class="string">&quot;backend set up fails&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;is_server) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;ops-&gt;send_request(dev, VHOST_USER_SET_OWNER,</span><br><span class="line">					   <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			PMD_INIT_LOG(ERR, <span class="string">&quot;set_owner fails: %s&quot;</span>,</span><br><span class="line">				     strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;ops-&gt;send_request(dev, VHOST_USER_GET_FEATURES,</span><br><span class="line">					   &amp;dev-&gt;device_features) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			PMD_INIT_LOG(ERR, <span class="string">&quot;get_features failed: %s&quot;</span>,</span><br><span class="line">				     strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* We just pretend vhost-user can support all these features.</span></span><br><span class="line"><span class="comment">		 * Note that this could be problematic that if some feature is</span></span><br><span class="line"><span class="comment">		 * negotiated but not supported by the vhost-user which comes</span></span><br><span class="line"><span class="comment">		 * later.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev-&gt;device_features = VIRTIO_USER_SUPPORTED_FEATURES;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mrg_rxbuf)</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_MRG_RXBUF);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_order)</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_F_IN_ORDER);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!packed_vq)</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_F_RING_PACKED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;mac_specified)</span><br><span class="line">		dev-&gt;frontend_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_MAC);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_MAC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cq) &#123;</span><br><span class="line">		<span class="comment">/* device does not really need to know anything about CQ,</span></span><br><span class="line"><span class="comment">		 * so if necessary, we just claim to support CQ</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev-&gt;frontend_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_VQ);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_VQ);</span><br><span class="line">		<span class="comment">/* Also disable features that depend on VIRTIO_NET_F_CTRL_VQ */</span></span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_RX);</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_VLAN);</span><br><span class="line">		dev-&gt;unsupported_features |=</span><br><span class="line">			(<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_GUEST_ANNOUNCE);</span><br><span class="line">		dev-&gt;unsupported_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_MQ);</span><br><span class="line">		dev-&gt;unsupported_features |=</span><br><span class="line">			(<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_MAC_ADDR);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The backend will not report this feature, we add it explicitly */</span></span><br><span class="line">	<span class="keyword">if</span> (is_vhost_user_by_type(dev-&gt;path))</span><br><span class="line">		dev-&gt;frontend_features |= (<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_STATUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Device features =</span></span><br><span class="line"><span class="comment">	 *     (frontend_features | backend_features) &amp; ~unsupported_features;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev-&gt;device_features |= dev-&gt;frontend_features;</span><br><span class="line">	dev-&gt;device_features &amp;= ~dev-&gt;unsupported_features;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_mem_event_callback_register(VIRTIO_USER_MEM_EVENT_CLB_NAME,</span><br><span class="line">				virtio_user_mem_event_cb, dev)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rte_errno != ENOTSUP) &#123;</span><br><span class="line">			PMD_INIT_LOG(ERR, <span class="string">&quot;Failed to register mem event&quot;</span></span><br><span class="line">					<span class="string">&quot; callback\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是对设备的初始化，然后进行 Setup：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">virtio_user_dev_setup</span><span class="params">(<span class="keyword">struct</span> virtio_user_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> q;</span><br><span class="line"></span><br><span class="line">	dev-&gt;vhostfd = <span class="number">-1</span>;</span><br><span class="line">	dev-&gt;vhostfds = <span class="literal">NULL</span>;</span><br><span class="line">	dev-&gt;tapfds = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;is_server) &#123;</span><br><span class="line">		<span class="keyword">if</span> (access(dev-&gt;path, F_OK) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    !is_vhost_user_by_type(dev-&gt;path)) &#123;</span><br><span class="line">			PMD_DRV_LOG(ERR, <span class="string">&quot;Server mode doesn&#x27;t support vhost-kernel!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dev-&gt;ops = &amp;virtio_ops_user;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (is_vhost_user_by_type(dev-&gt;path)) &#123;</span><br><span class="line">			dev-&gt;ops = &amp;virtio_ops_user;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev-&gt;ops = &amp;virtio_ops_kernel;</span><br><span class="line"></span><br><span class="line">			dev-&gt;vhostfds = <span class="built_in">malloc</span>(dev-&gt;max_queue_pairs *</span><br><span class="line">					       <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			dev-&gt;tapfds = <span class="built_in">malloc</span>(dev-&gt;max_queue_pairs *</span><br><span class="line">					     <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;vhostfds || !dev-&gt;tapfds) &#123;</span><br><span class="line">				PMD_INIT_LOG(ERR, <span class="string">&quot;Failed to malloc&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; dev-&gt;max_queue_pairs; ++q) &#123;</span><br><span class="line">				dev-&gt;vhostfds[q] = <span class="number">-1</span>;</span><br><span class="line">				dev-&gt;tapfds[q] = <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;ops-&gt;setup(dev) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (virtio_user_dev_init_notify(dev) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (virtio_user_fill_intr_handle(dev) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在处理用户状态时可以启动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/net/virtio/virtio_user_ethdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">virtio_user_set_status</span><span class="params">(<span class="keyword">struct</span> virtio_hw *hw, <span class="type">uint8_t</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_user_dev</span> *<span class="title">dev</span> =</span> virtio_user_get_dev(hw);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status &amp; VIRTIO_CONFIG_STATUS_DRIVER_OK)</span><br><span class="line">		virtio_user_start_device(dev);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == VIRTIO_CONFIG_STATUS_RESET)</span><br><span class="line">		virtio_user_reset(hw);</span><br><span class="line">	dev-&gt;status = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">virtio_user_start_device</span><span class="params">(<span class="keyword">struct</span> virtio_user_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> features;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * XXX workaround!</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We need to make sure that the locks will be</span></span><br><span class="line"><span class="comment">	 * taken in the correct order to avoid deadlocks.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Before releasing this lock, this thread should</span></span><br><span class="line"><span class="comment">	 * not trigger any memory hotplug events.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is a temporary workaround, and should be</span></span><br><span class="line"><span class="comment">	 * replaced when we get proper supports from the</span></span><br><span class="line"><span class="comment">	 * memory subsystem in the future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rte_mcfg_mem_read_lock();</span><br><span class="line">	pthread_mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_vhost_user_by_type(dev-&gt;path) &amp;&amp; dev-&gt;vhostfd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 0: tell vhost to create queues */</span></span><br><span class="line">	<span class="keyword">if</span> (virtio_user_queue_setup(dev, virtio_user_create_queue) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: set features */</span></span><br><span class="line">	features = dev-&gt;features;</span><br><span class="line">	<span class="comment">/* Strip VIRTIO_NET_F_MAC, as MAC address is handled in vdev init */</span></span><br><span class="line">	features &amp;= ~(<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_MAC);</span><br><span class="line">	<span class="comment">/* Strip VIRTIO_NET_F_CTRL_VQ, as devices do not really need to know */</span></span><br><span class="line">	features &amp;= ~(<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_CTRL_VQ);</span><br><span class="line">	features &amp;= ~(<span class="number">1ull</span> &lt;&lt; VIRTIO_NET_F_STATUS);</span><br><span class="line">	ret = dev-&gt;ops-&gt;send_request(dev, VHOST_USER_SET_FEATURES, &amp;features);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	PMD_DRV_LOG(INFO, <span class="string">&quot;set features: %&quot;</span> PRIx64, features);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: share memory regions */</span></span><br><span class="line">	ret = dev-&gt;ops-&gt;send_request(dev, VHOST_USER_SET_MEM_TABLE, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: kick queues */</span></span><br><span class="line">	<span class="keyword">if</span> (virtio_user_queue_setup(dev, virtio_user_kick_queue) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: enable queues</span></span><br><span class="line"><span class="comment">	 * we enable the 1st queue pair by default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev-&gt;ops-&gt;enable_qp(dev, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;started = <span class="literal">true</span>;</span><br><span class="line">	pthread_mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	rte_mcfg_mem_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error:</span><br><span class="line">	pthread_mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	rte_mcfg_mem_read_unlock();</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> free resource here or caller to check */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实会调用 send_request(dev, VHOST_USER_SET_MEM_TABLE, NULL) 来传递内存数据（ops 中设置），如果后端为 vhost-user 时，即为 vhost_user_sock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/net/virtio/virtio-user</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">vhost_user_sock</span><span class="params">(<span class="keyword">struct</span> virtio_user_dev *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> vhost_user_request req,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_user_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vhost_vring_file</span> *<span class="title">file</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> need_reply = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> fds[VHOST_MEMORY_MAX_NREGIONS];</span><br><span class="line">	<span class="type">int</span> fd_num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> vhostfd = dev-&gt;vhostfd;</span><br><span class="line"></span><br><span class="line">	RTE_SET_USED(m);</span><br><span class="line"></span><br><span class="line">	PMD_DRV_LOG(INFO, <span class="string">&quot;%s&quot;</span>, vhost_msg_strings[req]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;is_server &amp;&amp; vhostfd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	msg.request = req;</span><br><span class="line">	msg.flags = VHOST_USER_VERSION;</span><br><span class="line">	msg.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_GET_FEATURES:</span><br><span class="line">		need_reply = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_FEATURES:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_LOG_BASE:</span><br><span class="line">		msg.payload.u64 = *((__u64 *)arg);</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.u64);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_OWNER:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_RESET_OWNER:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_MEM_TABLE:</span><br><span class="line">		<span class="keyword">if</span> (prepare_vhost_memory_user(&amp;msg, fds) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		fd_num = msg.payload.memory.nregions;</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.memory.nregions);</span><br><span class="line">		msg.size += <span class="keyword">sizeof</span>(m.payload.memory.padding);</span><br><span class="line">		msg.size += fd_num * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vhost_memory_region);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_LOG_FD:</span><br><span class="line">		fds[fd_num++] = *((<span class="type">int</span> *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_NUM:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_BASE:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_ENABLE:</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;msg.payload.state, arg, <span class="keyword">sizeof</span>(msg.payload.state));</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.state);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_GET_VRING_BASE:</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;msg.payload.state, arg, <span class="keyword">sizeof</span>(msg.payload.state));</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.state);</span><br><span class="line">		need_reply = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_ADDR:</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;msg.payload.addr, arg, <span class="keyword">sizeof</span>(msg.payload.addr));</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.addr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_KICK:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_CALL:</span><br><span class="line">	<span class="keyword">case</span> VHOST_USER_SET_VRING_ERR:</span><br><span class="line">		file = arg;</span><br><span class="line">		msg.payload.u64 = file-&gt;index &amp; VHOST_USER_VRING_IDX_MASK;</span><br><span class="line">		msg.size = <span class="keyword">sizeof</span>(m.payload.u64);</span><br><span class="line">		<span class="keyword">if</span> (file-&gt;fd &gt; <span class="number">0</span>)</span><br><span class="line">			fds[fd_num++] = file-&gt;fd;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msg.payload.u64 |= VHOST_USER_VRING_NOFD_MASK;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		PMD_DRV_LOG(ERR, <span class="string">&quot;trying to send unhandled msg type&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	len = VHOST_USER_HDR_SIZE + msg.size;</span><br><span class="line">	<span class="keyword">if</span> (vhost_user_write(vhostfd, &amp;msg, len, fds, fd_num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		PMD_DRV_LOG(ERR, <span class="string">&quot;%s failed: %s&quot;</span>,</span><br><span class="line">			    vhost_msg_strings[req], strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (need_reply) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vhost_user_read(vhostfd, &amp;msg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			PMD_DRV_LOG(ERR, <span class="string">&quot;Received msg failed: %s&quot;</span>,</span><br><span class="line">				    strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req != msg.request) &#123;</span><br><span class="line">			PMD_DRV_LOG(ERR, <span class="string">&quot;Received unexpected msg type&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">		<span class="keyword">case</span> VHOST_USER_GET_FEATURES:</span><br><span class="line">			<span class="keyword">if</span> (msg.size != <span class="keyword">sizeof</span>(m.payload.u64)) &#123;</span><br><span class="line">				PMD_DRV_LOG(ERR, <span class="string">&quot;Received bad msg size&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			*((__u64 *)arg) = msg.payload.u64;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> VHOST_USER_GET_VRING_BASE:</span><br><span class="line">			<span class="keyword">if</span> (msg.size != <span class="keyword">sizeof</span>(m.payload.state)) &#123;</span><br><span class="line">				PMD_DRV_LOG(ERR, <span class="string">&quot;Received bad msg size&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memcpy</span>(arg, &amp;msg.payload.state,</span><br><span class="line">			       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vhost_vring_state));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			PMD_DRV_LOG(ERR, <span class="string">&quot;Received unexpected msg type&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到相关的 VHOST_USER_SET_MEM_TABLE 选项设置就看了数据的准备，从调用函数就可以一路深入进去，明白整个过程。这里就不再做介绍。</p>
<p>通过上面的分析可以看出，virtio-user 既可以实现虚拟机前后端的通信，也可以实现不同设备间的通信，还可以实现与内核间的通信。所以一种新的技术被提出后，会不断的推动应用的向前发展，反过来，应用的发展又不断要求前者提供更好的支持。互相促进，就会形成一个新的应用场景并有可能暴发。</p>
<h1 id="virtio-1"><a href="#virtio-1" class="headerlink" title="virtio"></a>virtio</h1><p>virtio  做为半虚拟化的应用标准，在 DPDK 中最典型的应用其实就是 virtio-user，在前面的 vhost-user 一样，都是把工作放到了用户态。也就是说，virtio-user 把设备驱动搬到了用户态，在 virtio-net(网络半虚拟化) 中，这样做能够更好的提高应用效率。而在 DPDK 中把这种驱动称之为 virtio-pmd，而 DKDK 中的 virtio-user 既可以创建 virtio 设备并与后端的 vhost 完成初始化配置，又可以在没有 KVM&#x2F;QUEM 的参与的非虚拟环境下使用相关的 virtio 设备。<br>再次强调一次，DPDK 中 virtio-pmd 支持 vdev 虚拟设备。这在现在云技术应用中非常用用处。这种设备是 DPDK 自己在用户态虚拟的内部设备，由 DPDK 自己管理，这点要清楚，它是和由 KVM&#x2F;QUEM 模拟出的 virtio-pci 设备是两回事。<br>这里对 virtio-pmd 做一个说明：<br>virtio-pmd, 即 virtio 设备的 PMD，Poll Mode Driver，学过网络编程的应用知道啥 Poll，它通过 VFIO 接口实现对虚拟或者物理网卡（NIC）的用户态配置和数据处理。</p>
<h3 id="用户态驱动"><a href="#用户态驱动" class="headerlink" title="用户态驱动"></a>用户态驱动</h3><p>在大家的眼中，一般习惯的把驱动理解成内核态，毕竟从一开始学习牵扯硬件和 OS 的相关知识，都强调驱动的重要性。毕竟 OS 就是为了隔离用户直接和硬件打交道的，硬件的复杂性和安全性都不能随便开放给普通用户。但是，随着应用技术的不断发展，出现了一些新的需求。大规模的数据通信和处理被内核的性能和管理限制的条条框框太多。技术人员需要不断的压榨整条数据链上的所有的剩余价值，那么在某些情况就提出了把驱动做到用户态，减少数据链中的传送节点，少的中间节点越多，理论上传输速度一定会更快。<br>用户态驱动最主要的就是把原来内核态需要处理的中断和硬件地址等内核态才能访问的内容能映射到用户态来。用户态的驱动技术有两种即，UIO 和 VFIO。DPDK 中，20.02 版本前同时支持两类，但以 UIO 为主，更早期则只支持 UIO；但在此版本后，基于 UIO 框架的 igb_uio 模块不再进入默认编译选项。即 DPDK 不再建议使用 UIO。<br>在网上很多人都推荐使用版本 20 以前的做为入门学习的原因大概也是因此。</p>
<h2 id="DPDK-中实现机制"><a href="#DPDK-中实现机制" class="headerlink" title="DPDK 中实现机制"></a>DPDK 中实现机制</h2><p>DPDK 中也是上面的两种实现机制，即 UIO 和 VFIO：<br>1、UIO<br>UIO 是 “Userspace I&#x2F;O” 的缩写，它的基本原理就是为每个注册使用的 UIO 设备提供一个 &#x2F; DEV&#x2F;UIOx 的字符设备，通过这个字符设备可以实现设备映射（mmap）和设备中断开关以及中断获取得操作。UIO 是一个应用框架，使用它需要自己实现一个内核驱动模块。而在 DPDK 中，则 igb_uio。<br>igb_uio 是一个标准的 PCI 设备驱动，提供 Probe 接口来向内核接管相关设备。通过 UIO 的接口注册，提供 UIO 的用户态文件接口。也就是通过此框架，实现了从内核到用户态的一个操作转化。但由于其没有 IOMMU（Input&#x2F;Output Memory Management Unit），如果想使用相关的物理地址必须要进行映射并注册给 NIC。这种方式的应用有两个缺陷：<br>a、不支持 IOMMU，使用设备 DMA 比较复杂并县城需要 Root 权限。地址映射异常会引起崩溃。<br>b、一个设备只支持一个中断，对 Polling 模式的 DPDK 影响有限，但扩展受限。</p>
<p>2、VFIO<br>VFIO，即 “Virtual Function I&#x2F;O”，可以简单理解为对 UIO 的高级版本。其主要通过 IOMMU 来进行 DMA 设备的访问和中断重定向。知道 OS 中的 MMU 大概就会明白 IOMMU，其实就是一层抽象隔离，隔离就是为了更好的兼容性和扩展性。不过它也和 UIO 一样需要映射到指定的 &#x2F; dev&#x2F;vfio&#x2F;xx 中来进行实现相关驱动。VFIO 也是有接口层和具体的设备驱动模块，即 vfio,vfio-pci。NIC 绑定到 vfio-pci 驱动，再由 VFIO 提供的相关文件（即刚刚提到的 &#x2F; dev&#x2F;vfio&#x2F;xx）接口来操作。<br>VFIO 不需要 Root 权限，通过注册 eventfd 来提供中断 irq 的用户态揽收方式。</p>
<p>在 DPDK 中，virtio-user 实现的主要功能有：<br>1、在用户态实现了 virtio-net 设备，与传统的虚拟化技术不同，virtio-user 在用户态进程实现了 virtio-pmd 和其后端控制面配置。<br>2、实现了 virtio-user 在内部总线上与 vhost-net 或者 vhost-user 的通信。<br>这基本上是可以根据实际情况把 KVM&#x2F;QUEM 省略来实现高速的网络通信。</p>
<p>virtio-pmd 主要的应用场景就是在虚拟机中，可以更好的提高虚拟机中的网络通信效率；当然，它也支持 virtio 设备的 PF 和 VF 的物理网卡操作。而 virtio-user 除了上述与内核交互的应用外则在容器中应用，通过 virtio-user 与 vhost-net 或者 vhost-user 通信来更好的实现高性能的网络通信。  </p>
<h1 id="NFV"><a href="#NFV" class="headerlink" title="NFV"></a>NFV</h1><p>Virtual Network Function（VNF）虚拟网络功能，Network Function Virtualization（NFV），网络功能虚拟化。VNF 是 NFV 的重要组成部分之一。那么 NFV 是什么？其实很简明了，重点在虚拟化。虚拟化对谁来说是最重要的？对重设备厂商来说是最重要的。再换句话说，是云厂商。这样说当然不是特别准确，但基本上现在的主流就是这些。不知道大家对前些年电信公司对微信的占用信令的讨伐还有没有印象。可是现在为什么没有了？<br>当然直接的原因和 NFV 没有太大关系，但是 NFV 却是后来者居上。<br>云化，是未来发展的方向，所以云上一个重要的部分就是网络通信，那么 NFV 和提供 VNF，就是一种必然的选择。  </p>
<p>VNF，主要是通过软件来实现网络功能，也就前面反复提到的隔离硬件，它可以做为一个类似于网络中的一个节点，来实现节点的各种功能。可以认为这是一种新型的网络设备部署方式（NFV）中的一个实例（VNF）。这样，动态的根据实际情况进行伸缩，正是云厂商的一个痛点，大家广为理解的双 11 等促销时，对节点的渴求和之后对节点的浪费就容易消弥其中的代价了。<br>同样，NFV，提供了 VNF 所需的基础设施，通过软硬件的管理，实现对整体网络需求的一个系统支撑。也就是说，NFV 通过提供 VNF 来实现虚拟化功能后，可以更好的进行网络的弹性扩容并找到最佳的软硬件结合点，便于对不同平台的移植和提升资源的利用率。</p>
<p>DPDK 做为一个数据平台的开发套件，本身就已经成为 VNF 和 NFV 的一个重要组件。所以 VNF 的发展，其实 DPDK 可以在其中起到基础框架的作用。DPDK 跳过内核，而 VNF 隔离软硬件，通过不断的解耦，让二者可以更加良好的结合来达到高速网络通信。而通过前面的分析，DPDK 对主流的硬件主机和虚拟化主机（全虚拟化和半虚拟化）都已经支持的比较完善。<br>DPDK 对硬件虚拟化和基于 Virtio 的半虚拟化，都提供了用户态的加速方案即 DPDK PF 和 DPDK VF 驱动和基于 DPDK 的软件交换机。同样，针对云上应用的容器化，DPDK 也提供了 virtio-user，可以说实现了对容器支持的专门定制。对于硬真能方式，DPDK 驱动也实现了对网卡设备的支持的不断完善，几乎达到了和裸机效果一致。<br>DPDK 提供了对多种设备的抽象，实现了较好的 NFVi（网络功能的基础设施层）。目前来看，基于 DPDK 的优化 NFVi 方案是业内的主流形式，DPDK 的硬件抽象，大大降低了对硬件的差异导致的各种问题。<br>除此之外，DPDK 还在一些基础软件应用上，对 NFV 进行支持，比如网络应用中的数据压缩和数据加密等等，这些都是在网络应用中广泛采用的技术。同时，在一些虚拟的网络应用如网关、路由器等上都可以一展身手。</p>
<h1 id="DPDK-中的内存"><a href="#DPDK-中的内存" class="headerlink" title="DPDK 中的内存"></a>DPDK 中的内存</h1><p>一般来说，做为软件平台或者框架，要么直接应用 OS（或者一些公认的标准库）的内存管理，简单方便，但可能不太尽如人意；要么就得自己搞一套内存管理系统。而自己搞内存管理系统一般又有两类，一种是在原来 OS 内存管理系统的前提下，再抽象一层，为自己的框架所用，另外一种就比较狠了，直接修改底层（OS 或者标准库）的内存管理系统。<br>正常情况下，绝大数应用的开发都是第一大类，没人愿意搞内存管理。底层的框架或者一些大的平台软件愿意自己处理一下内存管理，但多数是再抽象一层。但是到了 OS 或者虚拟机，基本都会自己得写内存管理的手段和方法。在操作系统原理中，对内存管理的算法都有学习过，网上也有很多相关书籍这里不再展开。<br>上面说这么多，目的是为引入下面的话。DPDK，做为一个开发套件，一定会自己对内存管理进行处理。但是它与上面的都有不同，一是它确实是对现有内存管理的一种抽象，但它又节省了传统的内存处理的一些流程（使用了 DIDO），特别是在虚拟设备中；另外，它对大页和 NUMA 的内存处理也进行了优化。最后其对 IO 的 IOMMU 重新抽象后直接供上层应用，只不过 IOMMU 不同于 MMU 为 CPU 所用而为被设备使用。<br>同样，对内存管理涉及到的 Cache，对齐技术以及 DMA 这些已有的技术也不做重点分析，只在用到时带一下，如果有需要的翻阅一下相关的书籍或者网上查找一下资料。<br>DPDK 的老版本（17）和新版本（18）之间，内存的管理有着很大的不同，老版本的内存映射是静态的，而新版本的是动态的，同时其也支持外部内存。老版本 IOVA 中，VA 的地址是连续的，但新版本是不保证的或者说二者已经不再有严格的关联。同时，对内存的大小和模式的控制更灵活，也为此增加一些新的标志。在不使用新特性（新标志等）的情况下，新版本的 DPDK 是可以老的版本上跑的，或者说老的 DPDK 可以无感的升级到新的 DPDK 中来。</p>
<p>在 DPDK 中，内存可以看做三种情况，即 IO 内存，物理内存和虚拟内存。重点当然是虚拟内存，虚拟内存中比较容易理解的就是 DMA 和 Cache，而在 Cache 中就有内存对齐的要求。DPDK 从整体上来看，虚拟内存可以划分为内存池和大页内存管理；而 IO 可以为分 IOVA，IO 内存（物理或 VA）。<br>DPDK 中的内存管理主要有两个大的特点，第一，支持大页，目的是为了更好的增加 TLB 的命中率，提高内存的使用效率。另外，其可以提供对 NUMA 中的内存固定处理，提高内存的使用效率和安全性。这样就可以防止线程对不同 NUMA 节点内存的访问。最后，DPDK 可以 DMA 技术和大页技术来固定物理内存，从而允许硬件自己启动 DMA 来执行数据的 IO 访问，降低 CPU 和 DPDK 框架本身的开销。<br>DPDK 中的 IOVA 主要分为两种模式，即 PA 和 VA 模式，前者指物理地址后者指虚拟的地址。DPDK 利用自己对内存模式的了解可以根据实际情况，对内存进行优化。特别是使用 IOMMU，可以使 DPDK 更安全，效率更好。<br>在 DPDK 中，内存的管理（分配等）没有使用常见的系统内存分析 API 而是自己管理内存。DPDK 自己分配大页并利用堆来给用户程序提供内存的应用操作，这样就可以在原有的基础上，重点处理与 DPDK 相关的内存区域控制、大页内存管理、NUMA 内存的管理以及对 IOVA 和 DMA 的访问控制等。<br>DPDK 中的内存分配是安全的，这和基础库和 OS 有所加强（基础库一般情况下是线程安全的）。同时，其强制进行内存的对齐。DPDK 通过共享内存来进行不同进程中的数据资源（这个好像在底层很流行，像安卓等也是如此），这对于 DPDK 这种大数据量跨进程交互的框架来说异常重要。<br>更为关键的是，DPDK 对抽象的内存池进行了有针对性的优化，它可以让用户指定是否为线程安全和批量操作。不过这个线程池仍然没有摆脱普通线程池的问题，只能是固定大小的内存对象。结果肯定是速度快，内存碎片少。<br>另外需要说明的，在 NUMA 节点间处理内存分配可以平均分配也可以偏向分配，但总的内存不要超过实际的物理内存数量。</p>
<p>DPDK 说得粗浅不准确一些，其实就是一个高效的数据转发框架或者高效网络框架（肯定是不准确，人家叫 “数据平面开发套件”，也可以用在数据存储上）。说的再不准确一下，可以理解为一种网络开发模式。这样，就会有一个非常形象化的情况认知，然后再认真学习就可以明白了为啥不准确。<br>比较典型的有数据包的输入和输出、加密、事件调度和进程数据管理等等。DPDK 中的内存管理应用无处不在，毕竟跟数据相关的，离开内存基本就啥也别干了。<br>简单介绍一下 DIDO（Data Direct I&#x2F;O）技术，这是由 Intel 公司提出的，主要目的就是为了让网络接口数据的吞吐性更高。传统的网络通信，数据从网卡通过总线传输到内存，然后 CPU 再读取其到 Cache，处理后再写回 Cache，再写回内存，然后回到网卡（网卡读取），再由总线送到网卡内部并通过接口发送出去。这个过程中，CPU 和内存会参与进来，网卡也会多次读写内存。但学过计算机原理的都知道，CPU 和内存及 IO 的数据处理是不在一个量级上的，这样，就一定会浪费很多资源。这里，其实就是通过 LLC Cache 来直接略过内存，直接让网卡和 CPU 通信。</p>
<h3 id="DPDK-的整体内存层次结构"><a href="#DPDK-的整体内存层次结构" class="headerlink" title="DPDK 的整体内存层次结构"></a>DPDK 的整体内存层次结构</h3><p>前面提到了 DPDK 中自己对内存进行了抽象。那么既然 DPDK 决定自己伸手处理内存，那就得有自己的一套处理体系。肯定不能简单的一个链表就搞定。学过操作系统和计算机原理的都明白，计算机的内存管理是一个相当复杂的系统。退回来说，就在更上层中使用中 OS 中的内存管理，开发者能熟练的控制内存的能有多少？再退一步讲，直接操作内存的 C&#x2F;C++ 为什么会越来越多的被上层应用抛弃？其实，最典型的就是内存的管理很多开发者是搞不定的。一旦出了异常，实在是不好下手分析，甚至解决问题的时间超过了开发的时间。<br>为了更好的管理内存，DPDK 把内存划分成三层（如果物理层也算是四层），即 Zone（大块，区域）、Pool（池）和 Buf（缓冲区），而在每层中，又划分了基于功能或者逻辑不同的相关数据结构并提供了相关的 API 的管理控制。其实这个很好理解，举一个例子，家里想过个肥年，肯定是买一大块肉或者一大片肉，回来后再根据应用范围（炒菜、炖肉等等）切成不同的块，最后实际应用时，可能进一步分解成小块或者切成各种肉片，肉沫儿等等。不同的是，肉最终就吃了，而内存用完了还得收回去，不但要收回去，还要有效率的收回去，所以内存管理更复杂。</p>
<h3 id="相关的数据结构和-API"><a href="#相关的数据结构和-API" class="headerlink" title="相关的数据结构和 API"></a>相关的数据结构和 API</h3><p>既然 DPDK 分为三层来管理内存，这里的数据结构和接口也按照这种方式来说明：<br>1、membuf<br>这里需要注意，此处的 Buf 是给网络通信包准备的，不推荐使用这个，而是可以自定义内存池来处理。下面看一下相关的数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\lib\librte_mbuf\rte_mbuf.h</span></span><br><span class="line"><span class="comment">//\lib\librte_mbuf\rte_mbuf_core.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> &#123;</span></span><br><span class="line">	MARKER cacheline0;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *buf_addr;           <span class="comment">/**&lt; Virtual address of segment buffer. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Physical address of segment buffer.</span></span><br><span class="line"><span class="comment">	 * Force alignment to 8-bytes, so as to ensure we have the exact</span></span><br><span class="line"><span class="comment">	 * same mbuf cacheline0 layout for 32-bit and 64-bit. This makes</span></span><br><span class="line"><span class="comment">	 * working on vector drivers easier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rte_iova_t</span> buf_iova;</span><br><span class="line">		<span class="type">rte_iova_t</span> buf_physaddr; <span class="comment">/**&lt; deprecated */</span></span><br><span class="line">	&#125; __rte_aligned(<span class="keyword">sizeof</span>(<span class="type">rte_iova_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next 8 bytes are initialised on RX descriptor rearm */</span></span><br><span class="line">	MARKER64 rearm_data;</span><br><span class="line">	<span class="type">uint16_t</span> data_off;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_ext_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> dynfield1[<span class="number">2</span>]; <span class="comment">/**&lt; Reserved for dynamic fields. */</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br></pre></td></tr></table></figure>

<p>这个数据结构有点大，略过中间环节。更多的细节还是要看头文件和整个的这个文件下的相关源文件，其主要接口有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rte_pktmbuf_init</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> *opaque_arg, <span class="type">void</span> *m, <span class="type">unsigned</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_pktmbuf_pool_init</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> *opaque_arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rte_mempool *<span class="title function_">rte_pktmbuf_pool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">unsigned</span> n,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> cache_size, <span class="type">uint16_t</span> priv_size, <span class="type">uint16_t</span> data_room_size, <span class="type">int</span> socket_id)</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">struct</span> rte_mempool *<span class="title function_">rte_pktmbuf_pool_create_by_ops</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">unsigned</span> <span class="type">int</span> n,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> cache_size, <span class="type">uint16_t</span> priv_size, <span class="type">uint16_t</span> data_room_size, <span class="type">int</span> socket_id, <span class="type">const</span> <span class="type">char</span> * ops_name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_pktmbuf_attach_extbuf</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m, <span class="type">void</span> *buf_addr,</span></span><br><span class="line"><span class="params">  	<span class="type">rte_iova_t</span> buf_iova, <span class="type">uint16_t</span> buf_len, <span class="keyword">struct</span> rte_mbuf_ext_shared_info *shinfo)</span>;</span><br></pre></td></tr></table></figure>

<p>这个更多，毕竟在上层应用各种花式的处理也更多，内部的外部的，池子和缓冲区的初始化，块的，重置的等等都可以在 rte_mbuf.h 和相关的此文件夹下的源文件发现。详细的在后面再分析，这里就不展开了，太多了。</p>
<p>2、mempool<br>再看一下内存池的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\lib\librte_mempool\rte_mempool.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: this field kept the RTE_MEMZONE_NAMESIZE size due to ABI</span></span><br><span class="line"><span class="comment">	 * compatibility requirements, it could be changed to</span></span><br><span class="line"><span class="comment">	 * RTE_MEMPOOL_NAMESIZE next time the ABI changes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MEMZONE_NAMESIZE]; <span class="comment">/**&lt; Name of mempool. */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *pool_data;         <span class="comment">/**&lt; Ring or pool to store objects. */</span></span><br><span class="line">		<span class="type">uint64_t</span> pool_id;        <span class="comment">/**&lt; External mempool identifier. */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">void</span> *pool_config;               <span class="comment">/**&lt; optional args for ops alloc. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span>;</span>    <span class="comment">/**&lt; Memzone where pool is alloc&#x27;d. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;              <span class="comment">/**&lt; Flags of the mempool. */</span></span><br><span class="line">	<span class="type">int</span> socket_id;                   <span class="comment">/**&lt; Socket id passed at create. */</span></span><br><span class="line">	<span class="type">uint32_t</span> size;                   <span class="comment">/**&lt; Max size of the mempool. */</span></span><br><span class="line">	<span class="type">uint32_t</span> cache_size;</span><br><span class="line">	<span class="comment">/**&lt; Size of per-lcore default local cache. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> elt_size;               <span class="comment">/**&lt; Size of an element. */</span></span><br><span class="line">	<span class="type">uint32_t</span> header_size;            <span class="comment">/**&lt; Size of header (before elt). */</span></span><br><span class="line">	<span class="type">uint32_t</span> trailer_size;           <span class="comment">/**&lt; Size of trailer (after elt). */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> private_data_size;      <span class="comment">/**&lt; Size of private data. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Index into rte_mempool_ops_table array of mempool ops</span></span><br><span class="line"><span class="comment">	 * structs, which contain callback function pointers.</span></span><br><span class="line"><span class="comment">	 * We&#x27;re using an index here rather than pointers to the callbacks</span></span><br><span class="line"><span class="comment">	 * to facilitate any secondary processes that may want to use</span></span><br><span class="line"><span class="comment">	 * this mempool.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int32_t</span> ops_index;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_cache</span> *<span class="title">local_cache</span>;</span> <span class="comment">/**&lt; Per-lcore local cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> populated_size;         <span class="comment">/**&lt; Number of populated objects. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_objhdr_list</span> <span class="title">elt_list</span>;</span> <span class="comment">/**&lt; List of objects in pool */</span></span><br><span class="line">	<span class="type">uint32_t</span> nb_mem_chunks;          <span class="comment">/**&lt; Number of memory chunks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_memhdr_list</span> <span class="title">mem_list</span>;</span> <span class="comment">/**&lt; List of memory chunks */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_MEMPOOL_DEBUG</span></span><br><span class="line">	<span class="comment">/** Per-lcore statistics. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_debug_stats</span> <span class="title">stats</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;  __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_cache</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> size;	      <span class="comment">/**&lt; Size of the cache */</span></span><br><span class="line">	<span class="type">uint32_t</span> flushthresh; <span class="comment">/**&lt; Threshold before we flush excess elements */</span></span><br><span class="line">	<span class="type">uint32_t</span> len;	      <span class="comment">/**&lt; Current cache count */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Cache is allocated to this size to allow it to overflow in certain</span></span><br><span class="line"><span class="comment">	 * cases to avoid needless emptying of cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *objs[RTE_MEMPOOL_CACHE_MAX_SIZE * <span class="number">3</span>]; <span class="comment">/**&lt; Cache objects */</span></span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_objhdr</span> &#123;</span></span><br><span class="line">	STAILQ_ENTRY(rte_mempool_objhdr) next; <span class="comment">/**&lt; Next in list. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mp</span>;</span>          <span class="comment">/**&lt; The mempool owning the object. */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rte_iova_t</span> iova;         <span class="comment">/**&lt; IO address of the object. */</span></span><br><span class="line">		<span class="type">phys_addr_t</span> physaddr;    <span class="comment">/**&lt; deprecated - Physical address of the object. */</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_MEMPOOL_DEBUG</span></span><br><span class="line">	<span class="type">uint64_t</span> cookie;                 <span class="comment">/**&lt; Debug cookie. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_memhdr</span> &#123;</span></span><br><span class="line">	STAILQ_ENTRY(rte_mempool_memhdr) next; <span class="comment">/**&lt; Next in list. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mp</span>;</span>  <span class="comment">/**&lt; The mempool owning the chunk */</span></span><br><span class="line">	<span class="type">void</span> *addr;              <span class="comment">/**&lt; Virtual address of the chunk */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rte_iova_t</span> iova;       <span class="comment">/**&lt; IO address of the chunk */</span></span><br><span class="line">		<span class="type">phys_addr_t</span> phys_addr; <span class="comment">/**&lt; Physical address of the chunk */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">size_t</span> len;              <span class="comment">/**&lt; length of the chunk */</span></span><br><span class="line">	<span class="type">rte_mempool_memchunk_free_cb_t</span> *free_cb; <span class="comment">/**&lt; Free callback */</span></span><br><span class="line">	<span class="type">void</span> *opaque;            <span class="comment">/**&lt; Argument passed to the free callback */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实重点是要明白 rte_mempool_cache 在 Pool 中的作用和相关头 rte_mempool_memhdr 和 rte_mempool_objhdr 的作用。一个用来管理内存池对象，一个用来管理内存池的地址块。<br>它的主要接口有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\lib\librte_mempool\rte_mempool.h</span></span><br><span class="line"><span class="keyword">struct</span> rte_mempool * <span class="title function_">rte_mempool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">unsigned</span> n, <span class="type">unsigned</span> elt_size,</span></span><br><span class="line"><span class="params">		   <span class="type">unsigned</span> cache_size, <span class="type">unsigned</span> private_data_size,</span></span><br><span class="line"><span class="params">		   <span class="type">rte_mempool_ctor_t</span> * mp_init, <span class="type">void</span> * mp_init_arg,</span></span><br><span class="line"><span class="params">		   <span class="type">rte_mempool_obj_cb_t</span> * obj_init, <span class="type">void</span> * obj_init_arg,</span></span><br><span class="line"><span class="params">		   <span class="type">int</span> socket_id, <span class="type">unsigned</span> flags)</span>;</span><br><span class="line">		   </span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_mempool_free</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp)</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这个就不一一列举了，比较多，可以去列也的文件去看。在后面的具体的源码分析中，会对这些接口及流程里进行详细的说明。</p>
<p>3、memzone<br>在这个层次上的内存分配管理，相对就简单一些了，先看它的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMZONE_NAMESIZE 32       <span class="comment">/**&lt; Maximum length of memory zone name.*/</span></span></span><br><span class="line">	<span class="type">char</span> name[RTE_MEMZONE_NAMESIZE];  <span class="comment">/**&lt; Name of the memory zone. */</span></span><br><span class="line"></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">phys_addr_t</span> phys_addr;        <span class="comment">/**&lt; deprecated - Start physical address. */</span></span><br><span class="line">		<span class="type">rte_iova_t</span> iova;              <span class="comment">/**&lt; Start IO address. */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *addr;                   <span class="comment">/**&lt; Start virtual address. */</span></span><br><span class="line">		<span class="type">uint64_t</span> addr_64;             <span class="comment">/**&lt; Makes sure addr is always 64-bits */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">size_t</span> len;                       <span class="comment">/**&lt; Length of the memzone. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> hugepage_sz;             <span class="comment">/**&lt; The page size of underlying memory */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int32_t</span> socket_id;                <span class="comment">/**&lt; NUMA socket ID. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> flags;                   <span class="comment">/**&lt; Characteristics of this memzone. */</span></span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>在这段代码的上面有注释 “A structure describing a memzone, which is a contiguous portion of physical memory identified by a name”，说明它就是对物理内存的名称标识。看它的内部定义也是哪些，其实就是 uint64_t 长度的数据。<br>其实包括 ring、heap 等好多都分配在这个之上，所以也可以把这个 Zone 分为这几个类型，从逻辑上也是可以理解的。<br>它的几个接口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\lib\librte_eal\common\include</span></span><br><span class="line"><span class="comment">//\lib\librte_eal\common\eal_common_memzone.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> rte_memzone * <span class="title function_">rte_memzone_reserve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name,</span></span><br><span class="line"><span class="params">					      <span class="type">size_t</span> len, <span class="type">int</span> socket_id,<span class="type">unsigned</span> flags)</span>;</span><br><span class="line">					      </span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_memzone_free</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_memzone * mz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> rte_memzone * <span class="title function_">rte_memzone_lookup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_memzone_walk</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">const</span> <span class="keyword">struct</span> rte_memzone *, <span class="type">void</span> * arg),<span class="type">void</span> * arg)</span>;</span><br></pre></td></tr></table></figure>

<p>上面的接口没有全部列出来，可以在相关路径查找，接口不多，但介绍非常详细，所以引处就不再重复说明了。不过看接口，应该可以分析出这些接口的作用，基本上就是分配、对齐、查找、导出、释放和返回列表之类的。</p>
<p>正如前面分析说过，mempool 适合于固定大小的内存应用，而 Buf 适合于网络包的使用，Zone 提供了底层的封装支持，所以在一些常见的数据结构里都可以看到它的影子。而为了应用的方便，在每一种层次上，又设计了一些相关的具体的数据结构，综合起来让其使用更方便快捷。比如在内存池中，可以看到对象和内存的列表，可以看到 Pool 的头定义数据结构，在这些结构里可以轻松的对 Pool 进行查找处理。<br>这种设计思想其实是从最简单的底层数据处理开始，一步步的向上，为了逻辑应用和业务处理的一种内存数据封装。最终形成一套对外的业务接口数据结构，供上层应用开发者的使用。</p>
<h1 id="IOVA"><a href="#IOVA" class="headerlink" title="IOVA"></a>IOVA</h1><p>IOVA，IO 虚拟地址。在 DPDK 中上层的 EAL（环境抽象层）负责管理的一部分功能中就包含将硬件设备的寄存器映射到内存中，以供其它驱动程序来应用。也就是说，用户态的进程可以直接使用 IO 地址并执行 IO 操作。在前面已经提到过，这些地址可以分为物理地址（PA）和 IO 虚拟地址即 IOVA。上层并不对二者区分即对应用层来说，对二者是不敏感的。用户态进程中看到的都是 IOVA 地址。<br>PA 的 IOVA 模式的优势在于在内核空间的应用中并且对于所有硬件都可以使用，它的缺点就是如果对内存操作对权限有要求时，就麻烦了。同样如果内存碎片较多的情况下，可能无法分配内存，会导致整个 DPDK 初始化的失败。为了解决这些问题，一般来说，就会使用更大分页，比如 1G 并且在启动时就引导系统使用大页。可明眼人一眼就会看出，这只是一种治标的办法，正所谓头疼医了头，脚疼医了脚。<br>而 VA 的 IOVA 模式 ，就需要一个 IOMMU 来进行地址的转换和分析。它等于额外又抽象了一层，一般做过设计的都明白，抽象大多意味着效率的降低（零成本抽象除外）。它的优势在于，内存的处理不完全受限于真实的物理内存的限制，也不需要一些特殊的权限。特别在云环境下（虚拟环境下 IOMMU 更合适），应用 DPDK 就有了更广泛的应用方式。当然，它的缺点也不少：硬件不一定支持 IOMMU 或者干脆平台就没有这个，软件不支持或者 IOMMU 受限等等。<br>在正常的情况下，DPDK 默认是选择使用 PA 的 IOVA 模式，这样做一个是安全另外一个是适用性广，但如果条件允许还是建议使用 VA 的 IOVA 模式。在 DPDK17.11 更高以上版本，可以使用命令：  <code>–iova-mode</code>  来自动选择合适的模式。</p>
<p>既然是 IO 操作，理论上讲，这块就和传统的驱动的功能类似。DPDK 中，对硬件的中断映射和寄存器映射都需要内核的协助。它需要绑定到 PCI，这个玩儿过计算机的人基本都明白。而这个 PCI 一个特点是并未被绑定到特定的一些设备集中。写过硬件驱动都知道，一般在驱动中会写死一些设备的类型 ID。所以理论上讲它可以和任意此类型的设备通用。<br>DPDK 中，在用户空间（UIO）中，由于其本身的限制（其使用的为 igb_uio），只能使用 PA 的 IOVA 模式，这也就限定了 UIO 中的应用；而在高版本中推荐使用的 VFIO 内核驱动中（Linux3.6），它特地与 IOMMU 进行了开发，所以在 VFIO 中可以选择前面的两种模式来进行处理（但 PA 模式下的权限问题仍然存在）。等到了内核的更高版本（&gt;&#x3D;4.5）, 在设置了 enable_unsafe_noiommu_mode 选项后，可以在没有 IOMMU 的情况下使用 VFIO。这个就更有优势了。<br>当然，在 DPDK 中，PMD（软件轮询模式) 驱动程序及一些相关软件并不需要 PCI 来操作驱动，它们通过标准的内核基础架构来操作硬件，这样就可以忽略到上面提到的 IOVA，换句话说，这个就无所谓了。</p>
<h3 id="数据结构和源码"><a href="#数据结构和源码" class="headerlink" title="数据结构和源码"></a>数据结构和源码</h3><p>先看下相关的地址定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Physical address */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">phys_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_BAD_PHYS_ADDR ((phys_addr_t)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IO virtual address type.</span></span><br><span class="line"><span class="comment"> * When the physical addressing mode (IOVA as PA) is in use,</span></span><br><span class="line"><span class="comment"> * the translation from an IO virtual address (IOVA) to a physical address</span></span><br><span class="line"><span class="comment"> * is a direct mapping, i.e. the same value.</span></span><br><span class="line"><span class="comment"> * Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">rte_iova_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_BAD_IOVA ((rte_iova_t)-1)</span></span><br></pre></td></tr></table></figure>

<p>在前面分析包括在后面分析的数据结构中，都可以看这两个数据类型的应用。下面看一下相关的转换代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\dpdk-stable-19.11.14\lib\librte_eal\linux\eal\eal_memory.c</span></span><br><span class="line"><span class="type">rte_iova_t</span> <span class="title function_">rte_mem_virt2iova</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *virtaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (rte_eal_iova_mode() == RTE_IOVA_VA)</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">uintptr_t</span>)virtaddr;</span><br><span class="line">	<span class="keyword">return</span> rte_mem_virt2phy(virtaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 VFIO 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_mem_map</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> addr;</span><br><span class="line">	<span class="type">uint64_t</span> iova;</span><br><span class="line">	<span class="type">uint64_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//\lib\librte_eal\linux\eal\eal_vfio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> type_id;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">bool</span> partial_unmap;</span><br><span class="line">	<span class="type">vfio_dma_user_func_t</span> dma_user_map_func;</span><br><span class="line">	<span class="type">vfio_dma_func_t</span> dma_map_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再看一下模式判断相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IOMMU types we support */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type</span> <span class="title">iommu_types</span>[] =</span> &#123;</span><br><span class="line">	<span class="comment">/* x86 IOMMU, otherwise known as type 1 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type_id = RTE_VFIO_TYPE1,</span><br><span class="line">		.name = <span class="string">&quot;Type 1&quot;</span>,</span><br><span class="line">		.partial_unmap = <span class="literal">false</span>,</span><br><span class="line">		.dma_map_func = &amp;vfio_type1_dma_map,</span><br><span class="line">		.dma_user_map_func = &amp;vfio_type1_dma_mem_map</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/* ppc64 IOMMU, otherwise known as spapr */</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type_id = RTE_VFIO_SPAPR,</span><br><span class="line">		.name = <span class="string">&quot;sPAPR&quot;</span>,</span><br><span class="line">		.partial_unmap = <span class="literal">true</span>,</span><br><span class="line">		.dma_map_func = &amp;vfio_spapr_dma_map,</span><br><span class="line">		.dma_user_map_func = &amp;vfio_spapr_dma_mem_map</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/* IOMMU-less mode */</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type_id = RTE_VFIO_NOIOMMU,</span><br><span class="line">		.name = <span class="string">&quot;No-IOMMU&quot;</span>,</span><br><span class="line">		.partial_unmap = <span class="literal">true</span>,</span><br><span class="line">		.dma_map_func = &amp;vfio_noiommu_dma_map,</span><br><span class="line">		.dma_user_map_func = &amp;vfio_noiommu_dma_mem_map</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//4\lib\librte_eal\common\eal_common_bus.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get iommu class of devices on the bus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> rte_iova_mode <span class="title function_">rte_bus_get_iommu_class</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">mode</span> =</span> RTE_IOVA_DC;</span><br><span class="line">	<span class="type">bool</span> buses_want_va = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> buses_want_pa = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_bus</span> * <span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	TAILQ_FOREACH(bus, &amp;rte_bus_list, next) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">bus_iova_mode</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bus-&gt;get_iommu_class == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		bus_iova_mode = bus-&gt;get_iommu_class();</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Bus %s wants IOVA as &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">			bus-&gt;name,</span><br><span class="line">			bus_iova_mode == RTE_IOVA_DC ? <span class="string">&quot;DC&quot;</span> :</span><br><span class="line">			(bus_iova_mode == RTE_IOVA_PA ? <span class="string">&quot;PA&quot;</span> : <span class="string">&quot;VA&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (bus_iova_mode == RTE_IOVA_PA)</span><br><span class="line">			buses_want_pa = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (bus_iova_mode == RTE_IOVA_VA)</span><br><span class="line">			buses_want_va = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (buses_want_va &amp;&amp; !buses_want_pa) &#123;</span><br><span class="line">		mode = RTE_IOVA_VA;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (buses_want_pa &amp;&amp; !buses_want_va) &#123;</span><br><span class="line">		mode = RTE_IOVA_PA;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mode = RTE_IOVA_DC;</span><br><span class="line">		<span class="keyword">if</span> (buses_want_va) &#123;</span><br><span class="line">			RTE_LOG(WARNING, EAL, <span class="string">&quot;Some buses want &#x27;VA&#x27; but forcing &#x27;DC&#x27; because other buses want &#x27;PA&#x27;.\n&quot;</span>);</span><br><span class="line">			RTE_LOG(WARNING, EAL, <span class="string">&quot;Depending on the final decision by the EAL, not all buses may be able to initialize.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下内核中对 IOMMU 的支持：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\drivers\bus\pci\linux\pci.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RTE_ARCH_X86)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pci_device_iommu_support_va</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VTD_CAP_MGAW_SHIFT	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VTD_CAP_MGAW_MASK	(0x3fULL &lt;&lt; VTD_CAP_MGAW_SHIFT)</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_addr</span> *<span class="title">addr</span> =</span> &amp;dev-&gt;addr;</span><br><span class="line">	<span class="type">char</span> filename[PATH_MAX];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="type">uint64_t</span> mgaw, vtd_cap_reg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename),</span><br><span class="line">		 <span class="string">&quot;%s/&quot;</span> PCI_PRI_FMT <span class="string">&quot;/iommu/intel-iommu/cap&quot;</span>,</span><br><span class="line">		 rte_pci_get_sysfs_path(), addr-&gt;domain, addr-&gt;bus, addr-&gt;devid,</span><br><span class="line">		 addr-&gt;function);</span><br><span class="line"></span><br><span class="line">	fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* We don&#x27;t have an Intel IOMMU, assume VA supported */</span></span><br><span class="line">		<span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): can&#x27;t open %s: %s\n&quot;</span>,</span><br><span class="line">			__func__, filename, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have an Intel IOMMU */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%&quot;</span> PRIx64, &amp;vtd_cap_reg) != <span class="number">1</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): can&#x27;t read %s\n&quot;</span>, __func__, filename);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	mgaw = ((vtd_cap_reg &amp; VTD_CAP_MGAW_MASK) &gt;&gt; VTD_CAP_MGAW_SHIFT) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Assuming there is no limitation by now. We can not know at this point</span></span><br><span class="line"><span class="comment">	 * because the memory has not been initialized yet. Setting the dma mask</span></span><br><span class="line"><span class="comment">	 * will force a check once memory initialization is done. We can not do</span></span><br><span class="line"><span class="comment">	 * a fallback to IOVA PA now, but if the dma check fails, the error</span></span><br><span class="line"><span class="comment">	 * message should advice for using &#x27;--iova-mode pa&#x27; if IOVA VA is the</span></span><br><span class="line"><span class="comment">	 * current mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rte_mem_set_dma_mask(mgaw);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(RTE_ARCH_PPC_64)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pci_device_iommu_support_va</span><span class="params">(__rte_unused <span class="type">const</span> <span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pci_device_iommu_support_va</span><span class="params">(__rte_unused <span class="type">const</span> <span class="keyword">struct</span> rte_pci_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> rte_iova_mode <span class="title function_">pci_device_iova_mode</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_pci_driver *pdrv,</span></span><br><span class="line"><span class="params">		     <span class="type">const</span> <span class="keyword">struct</span> rte_pci_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span> =</span> RTE_IOVA_DC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdev-&gt;kdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> RTE_KDRV_VFIO: &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VFIO_PRESENT</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> is_vfio_noiommu_enabled = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_vfio_noiommu_enabled == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rte_vfio_noiommu_is_enabled() == <span class="number">1</span>)</span><br><span class="line">				is_vfio_noiommu_enabled = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				is_vfio_noiommu_enabled = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (is_vfio_noiommu_enabled != <span class="number">0</span>)</span><br><span class="line">			iova_mode = RTE_IOVA_PA;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((pdrv-&gt;drv_flags &amp; RTE_PCI_DRV_NEED_IOVA_AS_VA) != <span class="number">0</span>)</span><br><span class="line">			iova_mode = RTE_IOVA_VA;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> RTE_KDRV_IGB_UIO:</span><br><span class="line">	<span class="keyword">case</span> RTE_KDRV_UIO_GENERIC:</span><br><span class="line">		iova_mode = RTE_IOVA_PA;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> ((pdrv-&gt;drv_flags &amp; RTE_PCI_DRV_NEED_IOVA_AS_VA) != <span class="number">0</span>)</span><br><span class="line">			iova_mode = RTE_IOVA_VA;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> iova_mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 IOVA 和 IOMMU 这些东西就是一个地址的控制方式，IOMMU 可以更好的为 IOVA 服务。反正在上层应用眼里，没有物理和虚拟的一说，它只关心操作的地址，至于地址最终怎么处理，不是人家关心的事儿。就和把钱存储到银行一样，你只管把钱送进去，至于银行把钱干啥了，不要关心。</p>
<h1 id="网络传输中的分包"><a href="#网络传输中的分包" class="headerlink" title="网络传输中的分包"></a>网络传输中的分包</h1><p>有过网络编程经验的程序员都知道，一般在上层应用设计时，尽量保持数据包体的大小和 MTU（最小传输单元）保持一致，这样就可以保证一包数据的传输中的完整性。减少 IP 层出现问题导致传输层的重传机制启动（主要是指 UDP，TCP 自己已经处理）。一般来说 MTU 在传输过程中饰面还会加上开头结尾校验等单元，这样，使用抓包工具时的范围在 601514（MTU 实际是 461500）。那小于 46 个字节呢？老规矩，自动补齐呗。<br>DPDK 做一种直接和 IO 打交道的框架，自然有收发两种情况，也就是说既有从上层传入的完整的数据流需要 DPDK 框架来拆解成分片大小（MTU 可允许）又要可以将分片数据重组为完整的数据流。正反两个方向都是流畅清晰的，这是做为网络编程框架的一个基本要求。在这个分片和组装的过程中，就会用前面学习过的零拷贝技术。</p>
<p>再重复看一下 mbuf 的数据结构 (全部数据定义请查看源码)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The generic rte_mbuf, containing a packet mbuf.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> &#123;</span></span><br><span class="line">	MARKER cacheline0;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> * buf_addr;           <span class="comment">/**&lt; Virtual address of segment buffer. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Physical address of segment buffer.</span></span><br><span class="line"><span class="comment">	 * Force alignment to 8-bytes, so as to ensure we have the exact</span></span><br><span class="line"><span class="comment">	 * same mbuf cacheline0 layout for 32-bit and 64-bit. This makes</span></span><br><span class="line"><span class="comment">	 * working on vector drivers easier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rte_iova_t</span> buf_iova;</span><br><span class="line">		<span class="type">rte_iova_t</span> buf_physaddr; <span class="comment">/**&lt; deprecated */</span></span><br><span class="line">	&#125; __rte_aligned(<span class="keyword">sizeof</span>(<span class="type">rte_iova_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next 8 bytes are initialised on RX descriptor rearm */</span></span><br><span class="line">	MARKER64 rearm_data;</span><br><span class="line">	<span class="type">uint16_t</span> data_off;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* second cache line - fields only used in slow path or on TX */</span></span><br><span class="line">MARKER cacheline1 __rte_cache_min_aligned;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Size of the application private data. In case of an indirect</span></span><br><span class="line"><span class="comment">	 * mbuf, it stores the direct mbuf private data size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span> priv_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Timesync flags for use with IEEE1588. */</span></span><br><span class="line">	<span class="type">uint16_t</span> timesync;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Sequence number. See also rte_reorder_insert(). */</span></span><br><span class="line">	<span class="type">uint32_t</span> seqn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Shared data for external buffer attached to mbuf. See</span></span><br><span class="line"><span class="comment">	 * rte_pktmbuf_attach_extbuf().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_ext_shared_info</span> * <span class="title">shinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> dynfield1[<span class="number">2</span>]; <span class="comment">/**&lt; Reserved for dynamic fields. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个数据结构体里有两个奇怪的标记 MARKER cacheline1，和 MARKER cacheline0，看这个 MARKER 定义，这类似于汇编语言中的标签。MARKER 被定义为（void**），需要注意的是 MARKER[0], 是一个可扩展数组，是 GCC 支持的，但在 VS 编译器中会报错，可以使用 1 长度数组来代替。可以理解成一个数据结构里面有两个指针分别指向不同功能的域。<br>mbuf 虽然是传输网络包的，但是理论上缓冲存储何种数据都是可以的。其实主要看利用效率，所以把它分为两个域也是可以理解的。经常使用的放在第一个域内，扩展的数据放在第二个域内。mbuf 可以使用 next 指针指向下一个相同的数据结构形成链表。而 mbuf 本身也有两种方式来存储数据，一种是直接的，即元数据和数据在一个 mbuf 内，而另外一种是元数据和数据分别使用各自的缓冲区。两者的各自优势也很明显，前者类似于固定的内存池，操作容易但可能因为数据包大小不同导致有浪费；而后者则可能导致操作复杂，效率低。DPDK 为了效率，肯定是选用第一种了。不过，在巨型帧中，元信息只在第一帧中体现，其后帧该部分为空。<br>需要说明的是在 mbuf 内部的头部和实际的数据包之间是有一段控制信息的，也就是 headroom，用来存储一些交互信息，其起始的地址为 buf_addr 指针，可以用 RTE_PKTMBUF_HEADROOM 来调整大小。而数据帧的地址可以调用 rte_pktmbuf_mtod 宏来得到，看一下这个宏的定义就明白了，其实就是地址的偏移处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rte_pktmbuf_mtod_offset(m, t, o)	\</span></span><br><span class="line"><span class="meta">	((t)(void * )((char * )(m)-&gt;buf_addr + (m)-&gt;data_off + (o)))</span></span><br></pre></td></tr></table></figure>

<p>另外其还还有一个尾部的 tailroom，它们的定义有内核中的协议栈 skb_buf 有些类似。</p>
<p>相关的接口都是 rte_mbuf.h 中，包括创建、匹配、释放等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_mbuf_prefetch_part1</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	rte_prefetch0(&amp;m-&gt;cacheline0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_mbuf_prefetch_part2</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RTE_CACHE_LINE_SIZE == 64</span></span><br><span class="line">	rte_prefetch0(&amp;m-&gt;cacheline1);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	RTE_SET_USED(m);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">__rte_experimental</span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_pktmbuf_free_bulk</span><span class="params">(<span class="keyword">struct</span> rte_mbuf **mbufs, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rte_mbuf *<span class="title function_">rte_pktmbuf_clone</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *md, <span class="keyword">struct</span> rte_mempool *mp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_pktmbuf_headroom</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	__rte_mbuf_sanity_check(m, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> m-&gt;data_off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_pktmbuf_tailroom</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	__rte_mbuf_sanity_check(m, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">uint16_t</span>)(m-&gt;buf_len - rte_pktmbuf_headroom(m) -</span><br><span class="line">			  m-&gt;data_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">rte_pktmbuf_append</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> * tail;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">m_last</span>;</span></span><br><span class="line"></span><br><span class="line">	__rte_mbuf_sanity_check(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	m_last = rte_pktmbuf_lastseg(m);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; rte_pktmbuf_tailroom(m_last)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	tail = (<span class="type">char</span> * )m_last-&gt;buf_addr + m_last-&gt;data_off + m_last-&gt;data_len;</span><br><span class="line">	m_last-&gt;data_len = (<span class="type">uint16_t</span>)(m_last-&gt;data_len + len);</span><br><span class="line">	m-&gt;pkt_len  = (m-&gt;pkt_len + len);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">char</span>* ) tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rte_pktmbuf_trim</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> * <span class="title">m_last</span>;</span></span><br><span class="line"></span><br><span class="line">	__rte_mbuf_sanity_check(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	m_last = rte_pktmbuf_lastseg(m);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; m_last-&gt;data_len))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	m_last-&gt;data_len = (<span class="type">uint16_t</span>)(m_last-&gt;data_len - len);</span><br><span class="line">	m-&gt;pkt_len = (m-&gt;pkt_len - len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是举了几个典型的接口，更多的可以去查看相关源码。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>在 DPDK 中，网络数据会被存储在一个环形（ring）缓冲区内，同时，在 mbuf 的环形缓冲区内创建一个 mbuf 对象。因为是内存池，所以这都不需要申请新的内存，意思就是速度非常快。二者之间通过通道或者 RANK 进行对齐（其实就是补 0，有 C++ 开发经验的都知道对齐）。<br>上面的内存池是在 DPDK 中已经创建好了，不过这里面还有一个问题，当多核 CPU 同时访问一个缓冲区时，仍然有竞争的问题，虽然使用 CAS 减少了锁的压力，但仍然导致效率会降低。这时，就需要通过 DPDK 对每个核心进行缓存，这样通过减少访问内存池的次数来降低竞争。<br>mbuf 使用 mempool 来进行管理，在上面的数据结构定义中，可以看到一个指针向了 mempool。当然，在这里面为了提高效率也大量使用了汇编汇合编程如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_prefetch1</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;dcbt 0,%[p],0&quot;</span> : : [p] <span class="string">&quot;r&quot;</span> (p))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细的内存池会在相关部分详细分析，此处只是带过。</p>
<h3 id="网络中的控制"><a href="#网络中的控制" class="headerlink" title="网络中的控制"></a>网络中的控制</h3><p>在网络通信过程中，会产生很多控制数据，其实就是元数据，包括一些硬件和协议层的元数据，最典型的就是一些校验和，长度等等。另外，一些扩展数据可以在 mbuf 中自己定义，在其数据结构最后有一个 dynfield1 字段，它的说明就是 “保留的动态域”。这些都可以是 mbuf 的一种动态适应机制。</p>
<h1 id="DPDK-中的内存池"><a href="#DPDK-中的内存池" class="headerlink" title="DPDK 中的内存池"></a>DPDK 中的内存池</h1><p>内存池，那真是分析的太多了，几乎这玩意儿是所有的框架必备。哪有计算机框架不用内存的，哪有内存分配就直接扎楞楞的就 new,malloc 的。先不说是不是看上去让人觉得太 LOW，关键是内存确实是很难管理，应用场景的不同，内存池的管理也要有调整。你看有单一大小的，这算是入门版；有多个大小动态适应的，这算高级版；还有动态生成和静态分组管理的，这算是专家版。<br>总之，就是要让内存分配和管理回收之间达到一个效率与资源的平衡，这在不同场景下可能就有所不同，侧重点有所不一样，所以一切以实际应用为原则。</p>
<p>做为固定大小内存分配的一种管理方式，内存池 mempool 其实是预应对内存快速的分配和回收的。但是一般情况下，内存的大小是无法精确确定的，所以内存池往往的结果是浪费一小部分内存，这也是一种妥协。在 DPDK 的内存池中，由三个部分来实现：<br>1、内存池的节点对象。这些对象存储在全局队列中，可通过唯一标识来访问，当然它只是一个指针结构并不是真正的内存区。<br>2、内存的实际存储区。它在 rte_memzone 中分配出来的连续内存中，用来存储相关的内存池对象。<br>3、ring 无锁队列。无锁队列意味着多线程中是安全的，它可以用来管理 mempool 的对象。<br>整个内存池通过环形无锁队列映射进行内存池对象的存取，同时为了兼顾多核冲突而引入了 local_cache 对象缓冲区，尽量减少多核访问环形队列的并发处理。</p>
<p>在前面已经把内存池 rte_mempool 这个数据结构简单分析了一下，这里只给出相关的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> * pool_data;</span><br><span class="line">		<span class="type">uint64_t</span> pool_id;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">void</span> * pool_config;</span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_MEMPOOL_DEBUG</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_debug_stats</span> <span class="title">stats</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;  __rte_cache_aligned;</span><br></pre></td></tr></table></figure>

<p>1、创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create the mempool */</span></span><br><span class="line"><span class="keyword">struct</span> rte_mempool *</span><br><span class="line"><span class="title function_">rte_mempool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">unsigned</span> n, <span class="type">unsigned</span> elt_size,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> cache_size, <span class="type">unsigned</span> private_data_size,</span></span><br><span class="line"><span class="params">	<span class="type">rte_mempool_ctor_t</span> * mp_init, <span class="type">void</span> * mp_init_arg,</span></span><br><span class="line"><span class="params">	<span class="type">rte_mempool_obj_cb_t</span> * obj_init, <span class="type">void</span> * obj_init_arg,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> socket_id, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> * <span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">	mp = rte_mempool_create_empty(name, n, elt_size, cache_size,</span><br><span class="line">		private_data_size, socket_id, flags);</span><br><span class="line">	<span class="keyword">if</span> (mp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we have 4 combinations of the SP/SC/MP/MC examine the flags to</span></span><br><span class="line"><span class="comment">	 * set the correct index into the table of ops structs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; MEMPOOL_F_SP_PUT) &amp;&amp; (flags &amp; MEMPOOL_F_SC_GET))</span><br><span class="line">		ret = rte_mempool_set_ops_byname(mp, <span class="string">&quot;ring_sp_sc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MEMPOOL_F_SP_PUT)</span><br><span class="line">		ret = rte_mempool_set_ops_byname(mp, <span class="string">&quot;ring_sp_mc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MEMPOOL_F_SC_GET)</span><br><span class="line">		ret = rte_mempool_set_ops_byname(mp, <span class="string">&quot;ring_mp_sc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = rte_mempool_set_ops_byname(mp, <span class="string">&quot;ring_mp_mc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call the mempool priv initializer */</span></span><br><span class="line">	<span class="keyword">if</span> (mp_init)</span><br><span class="line">		mp_init(mp, mp_init_arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_mempool_populate_default(mp) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call the object initializers */</span></span><br><span class="line">	<span class="keyword">if</span> (obj_init)</span><br><span class="line">		rte_mempool_obj_iter(mp, obj_init, obj_init_arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mp;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">	rte_mempool_free(mp);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 rte_mempool_create_empty() 这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free a cache. It&#x27;s the responsibility of the user to make sure that any</span></span><br><span class="line"><span class="comment"> * remaining objects in the cache are flushed to the corresponding</span></span><br><span class="line"><span class="comment"> * mempool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rte_mempool_cache_free</span><span class="params">(<span class="keyword">struct</span> rte_mempool_cache *cache)</span></span><br><span class="line">&#123;</span><br><span class="line">	rte_free(cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create an empty mempool */</span></span><br><span class="line"><span class="keyword">struct</span> rte_mempool *</span><br><span class="line"><span class="title function_">rte_mempool_create_empty</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> n, <span class="type">unsigned</span> elt_size,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> cache_size, <span class="type">unsigned</span> private_data_size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> socket_id, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> mz_name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_list</span> *<span class="title">mempool_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span> *<span class="title">te</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> mempool_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mz_flags = RTE_MEMZONE_1GB|RTE_MEMZONE_SIZE_HINT_ONLY;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_objsz</span> <span class="title">objsz</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* compilation-time checks */</span></span><br><span class="line">	RTE_BUILD_BUG_ON((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_mempool) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line">	RTE_BUILD_BUG_ON((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_mempool_cache) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_MEMPOOL_DEBUG</span></span><br><span class="line">	RTE_BUILD_BUG_ON((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_mempool_debug_stats) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line">	RTE_BUILD_BUG_ON((offsetof(<span class="keyword">struct</span> rte_mempool, stats) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	mempool_list = RTE_TAILQ_CAST(rte_mempool_tailq.head, rte_mempool_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* asked for zero items */</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* asked cache too big */</span></span><br><span class="line">	<span class="keyword">if</span> (cache_size &gt; RTE_MEMPOOL_CACHE_MAX_SIZE ||</span><br><span class="line">	    CALC_CACHE_FLUSHTHRESH(cache_size) &gt; n) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &quot;no cache align&quot; imply &quot;no spread&quot; */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MEMPOOL_F_NO_CACHE_ALIGN)</span><br><span class="line">		flags |= MEMPOOL_F_NO_SPREAD;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calculate mempool object sizes. */</span></span><br><span class="line">	<span class="keyword">if</span> (!rte_mempool_calc_obj_size(elt_size, flags, &amp;objsz)) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_mcfg_mempool_write_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reserve a memory zone for this mempool: private data is</span></span><br><span class="line"><span class="comment">	 * cache-aligned</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	private_data_size = (private_data_size +</span><br><span class="line">			     RTE_MEMPOOL_ALIGN_MASK) &amp; (~RTE_MEMPOOL_ALIGN_MASK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try to allocate tailq entry */</span></span><br><span class="line">	te = rte_zmalloc(<span class="string">&quot;MEMPOOL_TAILQ_ENTRY&quot;</span>, <span class="keyword">sizeof</span>(*te), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, MEMPOOL, <span class="string">&quot;Cannot allocate tailq entry!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> exit_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mempool_size = MEMPOOL_HEADER_SIZE(mp, cache_size);</span><br><span class="line">	mempool_size += private_data_size;</span><br><span class="line">	mempool_size = RTE_ALIGN_CEIL(mempool_size, RTE_MEMPOOL_ALIGN);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">snprintf</span>(mz_name, <span class="keyword">sizeof</span>(mz_name), RTE_MEMPOOL_MZ_FORMAT, name);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> || ret &gt;= (<span class="type">int</span>)<span class="keyword">sizeof</span>(mz_name)) &#123;</span><br><span class="line">		rte_errno = ENAMETOOLONG;</span><br><span class="line">		<span class="keyword">goto</span> exit_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mz = rte_memzone_reserve(mz_name, mempool_size, socket_id, mz_flags);</span><br><span class="line">	<span class="keyword">if</span> (mz == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> exit_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init the mempool structure */</span></span><br><span class="line">	mp = mz-&gt;addr;</span><br><span class="line">	<span class="built_in">memset</span>(mp, <span class="number">0</span>, MEMPOOL_HEADER_SIZE(mp, cache_size));</span><br><span class="line">	ret = strlcpy(mp-&gt;name, name, <span class="keyword">sizeof</span>(mp-&gt;name));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> || ret &gt;= (<span class="type">int</span>)<span class="keyword">sizeof</span>(mp-&gt;name)) &#123;</span><br><span class="line">		rte_errno = ENAMETOOLONG;</span><br><span class="line">		<span class="keyword">goto</span> exit_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	mp-&gt;mz = mz;</span><br><span class="line">	mp-&gt;size = n;</span><br><span class="line">	mp-&gt;flags = flags;</span><br><span class="line">	mp-&gt;socket_id = socket_id;</span><br><span class="line">	mp-&gt;elt_size = objsz.elt_size;</span><br><span class="line">	mp-&gt;header_size = objsz.header_size;</span><br><span class="line">	mp-&gt;trailer_size = objsz.trailer_size;</span><br><span class="line">	<span class="comment">/* Size of default caches, zero means disabled. */</span></span><br><span class="line">	mp-&gt;cache_size = cache_size;</span><br><span class="line">	mp-&gt;private_data_size = private_data_size;</span><br><span class="line">	STAILQ_INIT(&amp;mp-&gt;elt_list);</span><br><span class="line">	STAILQ_INIT(&amp;mp-&gt;mem_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * local_cache pointer is set even if cache_size is zero.</span></span><br><span class="line"><span class="comment">	 * The local_cache points to just past the elt_pa[] array.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mp-&gt;local_cache = (<span class="keyword">struct</span> rte_mempool_cache *)</span><br><span class="line">		RTE_PTR_ADD(mp, MEMPOOL_HEADER_SIZE(mp, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init all default caches. */</span></span><br><span class="line">	<span class="keyword">if</span> (cache_size != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++)</span><br><span class="line">			mempool_cache_init(&amp;mp-&gt;local_cache[lcore_id],</span><br><span class="line">					   cache_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	te-&gt;data = mp;</span><br><span class="line"></span><br><span class="line">	rte_mcfg_tailq_write_lock();</span><br><span class="line">	TAILQ_INSERT_TAIL(mempool_list, te, next);</span><br><span class="line">	rte_mcfg_tailq_write_unlock();</span><br><span class="line">	rte_mcfg_mempool_write_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mp;</span><br><span class="line"></span><br><span class="line">exit_unlock:</span><br><span class="line">	rte_mcfg_mempool_write_unlock();</span><br><span class="line">	rte_free(te);</span><br><span class="line">	rte_mempool_free(mp);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面说过，在内存池的数据结构定义中有三个重要的部分 rte_mempool ， rte_mempool_cache 和 mempool private，它们都在上面的函数中创建。生成的对象都挂在 rte_tailq_elem 类型的静态变量 rte_mempool_tailq 中。<br>然后通过对三个数据结构体进行计算得到 mempool 的头大小并得到所有核的 Cache 的大小。<br>真正的内存，也就是实际的内存创建是在 rte_mempool_populate_default 这个函数中创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Default function to populate the mempool: allocate memory in memzones,</span></span><br><span class="line"><span class="comment"> * and populate them. Return the number of objects added, or a negative</span></span><br><span class="line"><span class="comment"> * value on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mempool_populate_default</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mz_flags = RTE_MEMZONE_1GB|RTE_MEMZONE_SIZE_HINT_ONLY;</span><br><span class="line">	<span class="type">char</span> mz_name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span>;</span></span><br><span class="line">	<span class="type">ssize_t</span> mem_size;</span><br><span class="line">	<span class="type">size_t</span> align, pg_sz, pg_shift = <span class="number">0</span>;</span><br><span class="line">	<span class="type">rte_iova_t</span> iova;</span><br><span class="line">	<span class="type">unsigned</span> mz_id, n;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">bool</span> need_iova_contig_obj;</span><br><span class="line">	<span class="type">size_t</span> max_alloc_size = SIZE_MAX;</span><br><span class="line"></span><br><span class="line">	ret = mempool_ops_alloc_once(mp);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mempool must not be populated */</span></span><br><span class="line">	<span class="keyword">if</span> (mp-&gt;nb_mem_chunks != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the following section calculates page shift and page size values.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * these values impact the result of calc_mem_size operation, which</span></span><br><span class="line"><span class="comment">	 * returns the amount of memory that should be allocated to store the</span></span><br><span class="line"><span class="comment">	 * desired number of objects. when not zero, it allocates more memory</span></span><br><span class="line"><span class="comment">	 * for the padding between objects, to ensure that an object does not</span></span><br><span class="line"><span class="comment">	 * cross a page boundary. in other words, page size/shift are to be set</span></span><br><span class="line"><span class="comment">	 * to zero if mempool elements won&#x27;t care about page boundaries.</span></span><br><span class="line"><span class="comment">	 * there are several considerations for page size and page shift here.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * if we don&#x27;t need our mempools to have physically contiguous objects,</span></span><br><span class="line"><span class="comment">	 * then just set page shift and page size to 0, because the user has</span></span><br><span class="line"><span class="comment">	 * indicated that there&#x27;s no need to care about anything.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * if we do need contiguous objects (if a mempool driver has its</span></span><br><span class="line"><span class="comment">	 * own calc_size() method returning min_chunk_size = mem_size),</span></span><br><span class="line"><span class="comment">	 * there is also an option to reserve the entire mempool memory</span></span><br><span class="line"><span class="comment">	 * as one contiguous block of memory.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * if we require contiguous objects, but not necessarily the entire</span></span><br><span class="line"><span class="comment">	 * mempool reserved space to be contiguous, pg_sz will be != 0,</span></span><br><span class="line"><span class="comment">	 * and the default ops-&gt;populate() will take care of not placing</span></span><br><span class="line"><span class="comment">	 * objects across pages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * if our IO addresses are physical, we may get memory from bigger</span></span><br><span class="line"><span class="comment">	 * pages, or we might get memory from smaller pages, and how much of it</span></span><br><span class="line"><span class="comment">	 * we require depends on whether we want bigger or smaller pages.</span></span><br><span class="line"><span class="comment">	 * However, requesting each and every memory size is too much work, so</span></span><br><span class="line"><span class="comment">	 * what we&#x27;ll do instead is walk through the page sizes available, pick</span></span><br><span class="line"><span class="comment">	 * the smallest one and set up page shift to match that one. We will be</span></span><br><span class="line"><span class="comment">	 * wasting some space this way, but it&#x27;s much nicer than looping around</span></span><br><span class="line"><span class="comment">	 * trying to reserve each and every page size.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If we fail to get enough contiguous memory, then we&#x27;ll go and</span></span><br><span class="line"><span class="comment">	 * reserve space in smaller chunks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	need_iova_contig_obj = !(mp-&gt;flags &amp; MEMPOOL_F_NO_IOVA_CONTIG);</span><br><span class="line">	ret = rte_mempool_get_page_size(mp, &amp;pg_sz);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pg_sz != <span class="number">0</span>)</span><br><span class="line">		pg_shift = rte_bsf32(pg_sz);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (mz_id = <span class="number">0</span>, n = mp-&gt;size; n &gt; <span class="number">0</span>; mz_id++, n -= ret) &#123;</span><br><span class="line">		<span class="type">size_t</span> min_chunk_size;</span><br><span class="line"></span><br><span class="line">		mem_size = rte_mempool_ops_calc_mem_size(</span><br><span class="line">			mp, n, pg_shift, &amp;min_chunk_size, &amp;align);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mem_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = mem_size;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = <span class="built_in">snprintf</span>(mz_name, <span class="keyword">sizeof</span>(mz_name),</span><br><span class="line">			RTE_MEMPOOL_MZ_FORMAT <span class="string">&quot;_%d&quot;</span>, mp-&gt;name, mz_id);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span> || ret &gt;= (<span class="type">int</span>)<span class="keyword">sizeof</span>(mz_name)) &#123;</span><br><span class="line">			ret = -ENAMETOOLONG;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if we&#x27;re trying to reserve contiguous memory, add appropriate</span></span><br><span class="line"><span class="comment">		 * memzone flag.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (min_chunk_size == (<span class="type">size_t</span>)mem_size)</span><br><span class="line">			mz_flags |= RTE_MEMZONE_IOVA_CONTIG;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Allocate a memzone, retrying with a smaller area on ENOMEM */</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			mz = rte_memzone_reserve_aligned(mz_name,</span><br><span class="line">				RTE_MIN((<span class="type">size_t</span>)mem_size, max_alloc_size),</span><br><span class="line">				mp-&gt;socket_id, mz_flags, align);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (mz != <span class="literal">NULL</span> || rte_errno != ENOMEM)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			max_alloc_size = RTE_MIN(max_alloc_size,</span><br><span class="line">						(<span class="type">size_t</span>)mem_size) / <span class="number">2</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (mz == <span class="literal">NULL</span> &amp;&amp; max_alloc_size &gt;= min_chunk_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ret = -rte_errno;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (need_iova_contig_obj)</span><br><span class="line">			iova = mz-&gt;iova;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			iova = RTE_BAD_IOVA;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pg_sz == <span class="number">0</span> || (mz_flags &amp; RTE_MEMZONE_IOVA_CONTIG))</span><br><span class="line">			ret = rte_mempool_populate_iova(mp, mz-&gt;addr,</span><br><span class="line">				iova, mz-&gt;len,</span><br><span class="line">				rte_mempool_memchunk_mz_free,</span><br><span class="line">				(<span class="type">void</span> *)(<span class="type">uintptr_t</span>)mz);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = rte_mempool_populate_virt(mp, mz-&gt;addr,</span><br><span class="line">				mz-&gt;len, pg_sz,</span><br><span class="line">				rte_mempool_memchunk_mz_free,</span><br><span class="line">				(<span class="type">void</span> *)(<span class="type">uintptr_t</span>)mz);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_memzone_free(mz);</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mp-&gt;size;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">	rte_mempool_free_memchunks(mp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中通过下面的函数来创建 Ring：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mempool_ops_alloc_once</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the internal ring if not already done */</span></span><br><span class="line">	<span class="keyword">if</span> ((mp-&gt;flags &amp; MEMPOOL_F_POOL_CREATED) == <span class="number">0</span>) &#123;</span><br><span class="line">		ret = rte_mempool_ops_alloc(mp);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		mp-&gt;flags |= MEMPOOL_F_POOL_CREATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wrapper to allocate an external mempool&#x27;s private (pool) data. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mempool_ops_alloc</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	ops = rte_mempool_get_ops(mp-&gt;ops_index);</span><br><span class="line">	<span class="keyword">return</span> ops-&gt;alloc(mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配就得看 rte_mempool_ops 中的这个 alloc 在哪里初始化了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following 4 declarations of mempool ops structs address</span></span><br><span class="line"><span class="comment"> * the need for the backward compatible mempool handlers for</span></span><br><span class="line"><span class="comment"> * single/multi producers and single/multi consumers as dictated by the</span></span><br><span class="line"><span class="comment"> * flags provided to the rte_mempool_create function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_ops</span> <span class="title">ops_mp_mc</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;ring_mp_mc&quot;</span>,</span><br><span class="line">	.alloc = common_ring_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = common_ring_free,</span><br><span class="line">	.enqueue = common_ring_mp_enqueue,</span><br><span class="line">	.dequeue = common_ring_mc_dequeue,</span><br><span class="line">	.get_count = common_ring_get_count,</span><br><span class="line">&#125;;</span><br><span class="line">MEMPOOL_REGISTER_OPS(ops_mp_mc);</span><br><span class="line">MEMPOOL_REGISTER_OPS(ops_sp_sc);</span><br><span class="line">MEMPOOL_REGISTER_OPS(ops_mp_sc);</span><br><span class="line">MEMPOOL_REGISTER_OPS(ops_sp_mc);</span><br></pre></td></tr></table></figure>

<p>这样基本注册宏的调用就可以明白流程了。这里面嵌套的很深，有兴趣可以逐一跟进。整体上就是 rte_ring_create_elem 函数创建后插入到全局的 rte_ring_tailq，然后再通过 rte_mempool_ops_populate 函数调用 mempool_add_elem 函数将申请的实际内存插入到链表中。<br>2、使用<br>使用是分配 Alloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是m_buf的调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rte_mbuf *<span class="title function_">rte_mbuf_raw_alloc</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_mempool_get(mp, (<span class="type">void</span> **)&amp;m) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	MBUF_RAW_ALLOC_CHECK(m);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是mempool的接口</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_mempool_get_bulk</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> **obj_table, <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	cache = rte_mempool_default_cache(mp, rte_lcore_id());</span><br><span class="line">	<span class="keyword">return</span> rte_mempool_generic_get(mp, obj_table, n, cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_mempool_get</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> **obj_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_mempool_get_bulk(mp, obj_p, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它最终会调用 rte_mempool_get_bulk 函数来获得内存对象。先从本地的 Cache 中获取，不够才会从 rte_ring 中获取 mbuf 并存储在本地的 local_cache 中。</p>
<p>3、回收<br>回收是 Free：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_mbuf_raw_free</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	RTE_ASSERT(RTE_MBUF_DIRECT(m));</span><br><span class="line">	RTE_ASSERT(rte_mbuf_refcnt_read(m) == <span class="number">1</span>);</span><br><span class="line">	RTE_ASSERT(m-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">	RTE_ASSERT(m-&gt;nb_segs == <span class="number">1</span>);</span><br><span class="line">	__rte_mbuf_sanity_check(m, <span class="number">0</span>);</span><br><span class="line">	rte_mempool_put(m-&gt;pool, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_mempool_put</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">	rte_mempool_put_bulk(mp, &amp;obj, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_mempool_put_bulk</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	cache = rte_mempool_default_cache(mp, rte_lcore_id());</span><br><span class="line">	rte_mempool_generic_put(mp, obj_table, n, cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一路下去就找到结果了。</p>
<h1 id="DPDK-中的-Cache-处理"><a href="#DPDK-中的-Cache-处理" class="headerlink" title="DPDK 中的 Cache 处理"></a>DPDK 中的 Cache 处理</h1><p>其实一直不想分析这个问题，主要是这个问题太多了。即使不学 DPDK，计算机的原理和操作系统，内存型框架等等中都回避不了这个问题，包括多线程的伪共享也提到了这个问题。可以说这个问题是绕不开的，老生常谈谈得都糊了。<br>所以这里重点不谈 Cache 这个原理，书和网上都多得看不过来了。这里重点分析一下在 DPDK 是怎么样使用 Cache 的，也就是说 DPDK 的 Cache 有什么用处？<br>1、减少对内存锁的并发的冲突，目的也是为提高读写速度<br>2、提高读写速度</p>
<p>1、对 Cache 的支持<br>大页内存：命中率提高<br>DIDO：直接和硬件缓冲打交道，略过内存<br>TLB：TLB 配合大页，仍然是提高 Cache 命中率的方法</p>
<p>2、预取指令<br>一般到 Cache 这个级别，都是硬件，最多 OS 操作处理一下，对上层一般是不开放的。但随着技术的发展，软件开发者也可以操作预取指令，同时底层也开放了这些软件预取的指令。DPDK 就可以利用这个技术来处理 Cache 的数据加载，提高执行效率。但需要注意的是，如果自己也软件也要这样做，就得考虑好策略，别到时候儿画虎不成反类其犬。<br>预取指令一般是汇编命令，但有些程序也提供了封装的上层 API 库。<br>在 DPDK 中，为了和数据处理保持时钟周期的匹配，即达到最大效率，就必须保证数据都可以在 Cache 中，否则性能会严重下降。而这个预取指令就是为了配合这个命中采用的一种手段。当然，在 DPDK 中还有其它的手段同样也可以达到这个目的，结果只有一个，让处理和数据读取保持一致。</p>
<p>3、DPDK 中预取一致性处理<br>现代计算机基本都是多核或者多 CPU 的，DPDK 如何处理当不同的核去访问同一 Cache 的冲突呢。也就是说，如何保证数据的一致性呢？解决的方法很简单粗暴，直接每个核给单独一个 Cache。这样读写只操作自己的数据队列，就不会有冲突的问题。但是，这也带来了数据的最终一致性问题，这个就需要设计来搞定了。尽量避免冲突，如果非要有，那么只好加锁或者用一些协议来解决。<br>另外为了保持冲突最小化 Cache Line（Cache 最小单元）直接在分配时对齐。这算是另外一个手段。换句话说，尽量保证能在一个 Cache Line 的不让他们分成两个。<br>那么一致性协议有几种呢：<br>目录协议 (Directory-based protocol) 和总线窥探协议 ( Bus snoopingprotocol)，这里不展开，有兴趣可以去查查资料。</p>
<p>下面看一下 Cache 的相关源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: this field kept the RTE_MEMZONE_NAMESIZE size due to ABI</span></span><br><span class="line"><span class="comment">	 * compatibility requirements, it could be changed to RTE_RING_NAMESIZE</span></span><br><span class="line"><span class="comment">	 * next time the ABI changes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MEMZONE_NAMESIZE] __rte_cache_aligned; <span class="comment">/**&lt; Name of the ring. */</span></span><br><span class="line">	<span class="type">int</span> flags;               <span class="comment">/**&lt; Flags supplied at creation. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">memzone</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Memzone, if any, containing the rte_ring */</span></span><br><span class="line">	<span class="type">uint32_t</span> size;           <span class="comment">/**&lt; Size of ring. */</span></span><br><span class="line">	<span class="type">uint32_t</span> mask;           <span class="comment">/**&lt; Mask (size-1) of ring. */</span></span><br><span class="line">	<span class="type">uint32_t</span> capacity;       <span class="comment">/**&lt; Usable size of ring */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> pad0 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Ring producer status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> <span class="title">prod</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="type">char</span> pad1 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Ring consumer status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> <span class="title">cons</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="type">char</span> pad2 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// librte_eal/common/include/rte_common.h</span></span><br><span class="line"><span class="comment">/* Force alignment to cache line. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rte_cache_aligned __rte_aligned(RTE_CACHE_LINE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rte_aligned(a) __attribute__((__aligned__(a)))</span></span><br></pre></td></tr></table></figure>

<p>在基础的数据结构中经常可以看到__rte_cache_aligned 这个宏，它其实就是对 Cache Line 的一种处理对齐方式。<br>再看一下为每个核的配置数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcore_conf</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rx_queue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lcore_rx_queue</span> <span class="title">rx_queue_list</span>[<span class="title">MAX_RX_QUEUE_PER_LCORE</span>];</span></span><br><span class="line">	<span class="type">uint16_t</span> tx_queue_id[RTE_MAX_ETHPORTS];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> <span class="title">tx_mbufs</span>[<span class="title">RTE_MAX_ETHPORTS</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipsec_ctx</span> <span class="title">inbound</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipsec_ctx</span> <span class="title">outbound</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_ctx</span> *<span class="title">rt4_ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_ctx</span> *<span class="title">rt6_ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_ip_frag_tbl</span> *<span class="title">tbl</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pool_dir</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pool_indir</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_ip_frag_death_row</span> <span class="title">dr</span>;</span></span><br><span class="line">	&#125; frag;</span><br><span class="line">&#125; __rte_cache_aligned;<span class="comment">//总是行对齐，防止跨Cache Line</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcore_conf</span> <span class="title">lcore_conf</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br></pre></td></tr></table></figure>

<p>RTE_MAX_LCORE 是当前的最大核心数量，通过编号来控制对核心的访问，避免出现多个核心访问同一个数据结构的问题。同样，现代的网卡一般都支持多队列网卡，DPDK 为其准备多个读写队列来应对这些问题，如果从前面的安装过来的读者可能会想起在安装时的配置。<br>看一下收的预取：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ixgbe_recv_pkts(<span class="keyword">void</span> *rx_queue, <span class="keyword">struct</span> rte_mbuf **rx_pkts, uint16_t nb_pkts)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> ixgbe_rx_queue *rxq;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">union</span> ixgbe_adv_rx_desc *rx_ring;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">union</span> ixgbe_adv_rx_desc *rxdp;</span><br><span class="line">	<span class="keyword">struct</span> ixgbe_rx_entry *sw_ring;</span><br><span class="line">	<span class="keyword">struct</span> ixgbe_rx_entry *rxe;</span><br><span class="line">	<span class="keyword">struct</span> rte_mbuf *rxm;</span><br><span class="line">	<span class="keyword">struct</span> rte_mbuf *nmb;</span><br><span class="line">	<span class="keyword">union</span> ixgbe_adv_rx_desc rxd;</span><br><span class="line">	uint64_t dma_addr;</span><br><span class="line">	uint32_t staterr;</span><br><span class="line">	uint32_t pkt_info;</span><br><span class="line">	uint16_t pkt_len;</span><br><span class="line">	uint16_t rx_id;</span><br><span class="line">	uint16_t nb_rx;</span><br><span class="line">	uint16_t nb_hold;</span><br><span class="line">	uint64_t pkt_flags;</span><br><span class="line">	uint64_t vlan_flags;</span><br><span class="line"></span><br><span class="line">	nb_rx = <span class="number">0</span>;</span><br><span class="line">	nb_hold = <span class="number">0</span>;</span><br><span class="line">	rxq = rx_queue;</span><br><span class="line">	rx_id = rxq-&gt;rx_tail;</span><br><span class="line">	rx_ring = rxq-&gt;rx_ring;</span><br><span class="line">	sw_ring = rxq-&gt;sw_ring;</span><br><span class="line">	vlan_flags = rxq-&gt;vlan_flags;</span><br><span class="line">	<span class="keyword">while</span> (nb_rx &lt; nb_pkts) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The order of operations here is important as the DD status</span></span><br><span class="line"><span class="comment">		 * bit must not be read after any other descriptor fields.</span></span><br><span class="line"><span class="comment">		 * rx_ring and rxdp are pointing to volatile data so the order</span></span><br><span class="line"><span class="comment">		 * of accesses cannot be reordered by the compiler. If they were</span></span><br><span class="line"><span class="comment">		 * not volatile, they could be reordered which could lead to</span></span><br><span class="line"><span class="comment">		 * using invalid descriptor fields when read from rxd.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rxdp = &amp;rx_ring[rx_id];</span><br><span class="line">		staterr = rxdp-&gt;wb.upper.status_error;</span><br><span class="line">		<span class="keyword">if</span> (!(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rxd = *rxdp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * End of packet.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If the IXGBE_RXDADV_STAT_EOP flag is not set, the RX packet</span></span><br><span class="line"><span class="comment">		 * is likely to be invalid and to be dropped by the various</span></span><br><span class="line"><span class="comment">		 * validation checks performed by the network stack.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Allocate a new mbuf to replenish the RX ring descriptor.</span></span><br><span class="line"><span class="comment">		 * If the allocation fails:</span></span><br><span class="line"><span class="comment">		 *    - arrange for that RX descriptor to be the first one</span></span><br><span class="line"><span class="comment">		 *      being parsed the next time the receive function is</span></span><br><span class="line"><span class="comment">		 *      invoked [on the same queue].</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *    - Stop parsing the RX ring and return immediately.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This policy do not drop the packet received in the RX</span></span><br><span class="line"><span class="comment">		 * descriptor for which the allocation of a new mbuf failed.</span></span><br><span class="line"><span class="comment">		 * Thus, it allows that packet to be later retrieved if</span></span><br><span class="line"><span class="comment">		 * mbuf have been freed in the mean time.</span></span><br><span class="line"><span class="comment">		 * As a side effect, holding RX descriptors instead of</span></span><br><span class="line"><span class="comment">		 * systematically giving them back to the NIC may lead to</span></span><br><span class="line"><span class="comment">		 * RX ring exhaustion situations.</span></span><br><span class="line"><span class="comment">		 * However, the NIC can gracefully prevent such situations</span></span><br><span class="line"><span class="comment">		 * to happen by sending specific &quot;back-pressure&quot; flow control</span></span><br><span class="line"><span class="comment">		 * frames to its peer(s).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_id=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;ext_err_stat=0x%08x pkt_len=%u&quot;</span>,</span><br><span class="line">			   (unsigned) rxq-&gt;port_id, (unsigned) rxq-&gt;queue_id,</span><br><span class="line">			   (unsigned) rx_id, (unsigned) staterr,</span><br><span class="line">			   (unsigned) rte_le_to_cpu_16(rxd.wb.upper.length));</span><br><span class="line"></span><br><span class="line">		nmb = rte_mbuf_raw_alloc(rxq-&gt;mb_pool);</span><br><span class="line">		<span class="keyword">if</span> (nmb == NULL) &#123;</span><br><span class="line">			PMD_RX_LOG(DEBUG, <span class="string">&quot;RX mbuf alloc failed port_id=%u &quot;</span></span><br><span class="line">				   <span class="string">&quot;queue_id=%u&quot;</span>, (unsigned) rxq-&gt;port_id,</span><br><span class="line">				   (unsigned) rxq-&gt;queue_id);</span><br><span class="line">			rte_eth_devices[rxq-&gt;port_id].data-&gt;rx_mbuf_alloc_failed++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nb_hold++;</span><br><span class="line">		rxe = &amp;sw_ring[rx_id];</span><br><span class="line">		rx_id++;</span><br><span class="line">		<span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc)</span><br><span class="line">			rx_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Prefetch next mbuf while processing current one. */</span></span><br><span class="line">		rte_ixgbe_prefetch(sw_ring[rx_id].mbuf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When next RX descriptor is on a cache-line boundary,</span></span><br><span class="line"><span class="comment">		 * prefetch the next 4 RX descriptors and the next 8 pointers</span></span><br><span class="line"><span class="comment">		 * to mbufs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((rx_id &amp; <span class="number">0</span>x3) == <span class="number">0</span>) &#123;</span><br><span class="line">			rte_ixgbe_prefetch(&amp;rx_ring[rx_id]);</span><br><span class="line">			rte_ixgbe_prefetch(&amp;sw_ring[rx_id]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rxm = rxe-&gt;mbuf;</span><br><span class="line">		rxe-&gt;mbuf = nmb;</span><br><span class="line">		dma_addr =</span><br><span class="line">			rte_cpu_to_le_64(rte_mbuf_data_iova_default(nmb));</span><br><span class="line">		rxdp-&gt;read.hdr_addr = <span class="number">0</span>;</span><br><span class="line">		rxdp-&gt;read.pkt_addr = dma_addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Initialize the returned mbuf.</span></span><br><span class="line"><span class="comment">		 * 1) setup generic mbuf fields:</span></span><br><span class="line"><span class="comment">		 *    - number of segments,</span></span><br><span class="line"><span class="comment">		 *    - next segment,</span></span><br><span class="line"><span class="comment">		 *    - packet length,</span></span><br><span class="line"><span class="comment">		 *    - RX port identifier.</span></span><br><span class="line"><span class="comment">		 * 2) integrate hardware offload data, if any:</span></span><br><span class="line"><span class="comment">		 *    - RSS flag &amp; hash,</span></span><br><span class="line"><span class="comment">		 *    - IP checksum flag,</span></span><br><span class="line"><span class="comment">		 *    - VLAN TCI, if any,</span></span><br><span class="line"><span class="comment">		 *    - error flags.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pkt_len = (uint16_t) (rte_le_to_cpu_16(rxd.wb.upper.length) -</span><br><span class="line">				      rxq-&gt;crc_len);</span><br><span class="line">		rxm-&gt;data_off = RTE_PKTMBUF_HEADROOM;</span><br><span class="line">		rte_packet_prefetch((<span class="built_in">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off);</span><br><span class="line">		rxm-&gt;nb_segs = <span class="number">1</span>;</span><br><span class="line">		rxm-&gt;next = NULL;</span><br><span class="line">		rxm-&gt;pkt_len = pkt_len;</span><br><span class="line">		rxm-&gt;data_len = pkt_len;</span><br><span class="line">		rxm-&gt;port = rxq-&gt;port_id;</span><br><span class="line"></span><br><span class="line">		pkt_info = rte_le_to_cpu_32(rxd.wb.lower.lo_dword.data);</span><br><span class="line">		<span class="comment">/* Only valid if PKT_RX_VLAN set in pkt_flags */</span></span><br><span class="line">		rxm-&gt;vlan_tci = rte_le_to_cpu_16(rxd.wb.upper.vlan);</span><br><span class="line"></span><br><span class="line">		pkt_flags = rx_desc_status_to_pkt_flags(staterr, vlan_flags);</span><br><span class="line">		pkt_flags = pkt_flags |</span><br><span class="line">			rx_desc_error_to_pkt_flags(staterr, (uint16_t)pkt_info,</span><br><span class="line">						   rxq-&gt;rx_udp_csum_zero_err);</span><br><span class="line">		pkt_flags = pkt_flags |</span><br><span class="line">			ixgbe_rxd_pkt_info_to_pkt_flags((uint16_t)pkt_info);</span><br><span class="line">		rxm-&gt;ol_flags = pkt_flags;</span><br><span class="line">		rxm-&gt;packet_type =</span><br><span class="line">			ixgbe_rxd_pkt_info_to_pkt_type(pkt_info,</span><br><span class="line">						       rxq-&gt;pkt_type_mask);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(pkt_flags &amp; PKT_RX_RSS_HASH))</span><br><span class="line">			rxm-&gt;hash.rss = rte_le_to_cpu_32(</span><br><span class="line">						rxd.wb.lower.hi_dword.rss);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pkt_flags &amp; PKT_RX_FDIR) &#123;</span><br><span class="line">			rxm-&gt;hash.fdir.hash = rte_le_to_cpu_16(</span><br><span class="line">					rxd.wb.lower.hi_dword.csum_ip.csum) &amp;</span><br><span class="line">					IXGBE_ATR_HASH_MASK;</span><br><span class="line">			rxm-&gt;hash.fdir.id = rte_le_to_cpu_16(</span><br><span class="line">					rxd.wb.lower.hi_dword.csum_ip.ip_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Store the mbuf address into the next entry of the array</span></span><br><span class="line"><span class="comment">		 * of returned packets.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rx_pkts[nb_rx++] = rxm;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;rx_tail = rx_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the number of free RX descriptors is greater than the RX free</span></span><br><span class="line"><span class="comment">	 * threshold of the queue, advance the Receive Descriptor Tail (RDT)</span></span><br><span class="line"><span class="comment">	 * register.</span></span><br><span class="line"><span class="comment">	 * Update the RDT with the value of the last processed RX descriptor</span></span><br><span class="line"><span class="comment">	 * minus 1, to guarantee that the RDT register is never equal to the</span></span><br><span class="line"><span class="comment">	 * RDH register, which creates a &quot;full&quot; ring situtation from the</span></span><br><span class="line"><span class="comment">	 * hardware point of view...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nb_hold = (uint16_t) (nb_hold + rxq-&gt;nb_rx_hold);</span><br><span class="line">	<span class="keyword">if</span> (nb_hold &gt; rxq-&gt;rx_free_thresh) &#123;</span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_tail=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;nb_hold=%u nb_rx=%u&quot;</span>,</span><br><span class="line">			   (unsigned) rxq-&gt;port_id, (unsigned) rxq-&gt;queue_id,</span><br><span class="line">			   (unsigned) rx_id, (unsigned) nb_hold,</span><br><span class="line">			   (unsigned) nb_rx);</span><br><span class="line">		rx_id = (uint16_t) ((rx_id == <span class="number">0</span>) ?</span><br><span class="line">				     (rxq-&gt;nb_rx_desc - <span class="number">1</span>) : (rx_id - <span class="number">1</span>));</span><br><span class="line">		IXGBE_PCI_REG_WRITE(rxq-&gt;rdt_reg_addr, rx_id);</span><br><span class="line">		nb_hold = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;nb_rx_hold = nb_hold;</span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的预取写得很清楚，看一下定义，源码中有三类平台的，这里只看 X86 的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_prefetch0</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;prefetcht0 %[p]&quot;</span> : : [p] <span class="string">&quot;m&quot;</span> (*(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">char</span> *)p))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_prefetch1</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;prefetcht1 %[p]&quot;</span> : : [p] <span class="string">&quot;m&quot;</span> (*(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">char</span> *)p))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_prefetch2</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;prefetcht2 %[p]&quot;</span> : : [p] <span class="string">&quot;m&quot;</span> (*(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">char</span> *)p))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_prefetch_non_temporal</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;prefetchnta %[p]&quot;</span> : : [p] <span class="string">&quot;m&quot;</span> (*(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">char</span> *)p))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它预取的可以搜索 rte_packet_prefetch，都 OK 了。这里不再赘述。</p>
<h1 id="DIDO"><a href="#DIDO" class="headerlink" title="DIDO"></a>DIDO</h1><p>随着计算机技术发展，特别是应用技术的快速发展。应用场景对计算机的处理速度几乎已经到了疯狂的地步。说句大白话，再快的 CPU 也嫌慢。没办法，CPU 和 IO 等技术基本目前都处在了瓶颈之处，大幅度提高，短时间内看不到希望。但是不可以在某些部分进行优化。而 DIDO 就是这么一项技术。<br>DIDO，Data Direct I&#x2F;O，数据直通 IO，网上和书上说得比较玄乎，其实就是一句话，缩短数据传输路径，减少数据拷贝次数。它的结果当然是提高敢吞吐量，减少了延迟。在传统的网络通信时，网络报文在到达网卡时，要把数据和相关元数据传输到内存，CPU 读内存到 Cache，然后进寄存器，处理再原路返回，最终通过网络发走。从上面的分析可以看到，数据不断的在内存和缓存中进行传输，而 CPU 的处理速度和内存的处理速度以及总线和 IO 的处理速度，这都是有量级的差别。<br>那么 DIDO 如何操作呢？它通过 LLC Cache 直接和网卡打交道，“不让中间商吃差价”。</p>
<h3 id="DIDO-的流程"><a href="#DIDO-的流程" class="headerlink" title="DIDO 的流程"></a>DIDO 的流程</h3><p>在 DPDK 中是如何进行 DIDO 的数据传输呢？看一下读的过程：<br>1、CPU 读取报文和相关元数据，并把内存中的缓冲区预取到 Cache 中。<br>2、NIC 将传送报文利用 DIDO 技术，通过 PCI 总线直接将 Cache 送到 PCI 总线。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/632454fce7e9f0ddb5edb63d9148775b.png"></p>
<p>再看一下写的过程：<br>1、报文及相关元数据通过总线直接送入 Cache 中，此时有两种情况：<br>a、缓存命中，即 Cache 有此段内存，则直接覆盖写<br>b、没有，则 Cache 分配一块区域，更新 Cache 表，写内容<br>2、通知报文到达，产生内存读操作，因为 Cache 原因，直接读 Cache，然后发走。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/7721ad9d5be5babcdd709d06bf46ed0b.png"></p>
<p>在 DPDK 中，本身就是一种整体上更强于 DIDO 的优化方式，可以把 DPDK 当成 DIDO 的放大版，功能上、数据处理上和传输上都做了一种整体上的 DIDO。即从用户态直接处理网卡，而不是绕道内核进行处理。<br>传统的数据传输：<br>硬中断——&gt; 取数据包分发至内核线程——&gt; 软中断——&gt; 内核线程在协议栈中处理数据包——&gt; 处理完成通知用户层 上层收包——&gt; 网络层——&gt; 逻辑层——&gt; 业务层<br>DPDK 中：<br>硬中断——&gt; 放弃中断流程，用户层从设备映射取数据包——&gt; 进入用户层协议栈——&gt; 逻辑层——&gt; 业务层<br>DIDO 在 DPDK 中也是一种数据处理手段。</p>
<h1 id="DPDK-启动分析"><a href="#DPDK-启动分析" class="headerlink" title="DPDK 启动分析"></a>DPDK 启动分析</h1><p>在前面对 DPDK 中的内存进行了各个模块的分析，这次开始整体流程的分析说明。重点是分析一下内存从开始准备到最终应用的过程，从而把各个分别讲的模板贯穿起来，从而能够更好的了解和认识 DPDK 中内存的使用。<br>DPDK 中，启动时对内存的处理如下：<br>1、大页内存的处理<br>这个在前面分析过，两种情况，一种是直接在 Linux 内核配置文件中处理；另外一种是使用用命令配置，临时就用 mount 挂载，一直第一次就用 nodev 命令找到挂载点设置。当然这有一个前提，就是在内核中已经预留了大页内存。<br>2、使用 mmap 进行多进程内存共享。也即 DPDK 的主进程通过 mmap 进行初始化并 mmap 巨页内存，然后再通过配置文件共享给其它进程。<br>看一下相关的配置文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global RTE configuration structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> master_lcore;       <span class="comment">/**&lt; Id of the master lcore */</span></span><br><span class="line">	<span class="type">uint32_t</span> lcore_count;        <span class="comment">/**&lt; Number of available logical cores. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_node_count;    <span class="comment">/**&lt; Number of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_nodes[RTE_MAX_NUMA_NODES]; <span class="comment">/**&lt; List of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> service_lcore_count;<span class="comment">/**&lt; Number of available service cores. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_role_t</span> <span class="title">lcore_role</span>[<span class="title">RTE_MAX_LCORE</span>];</span> <span class="comment">/**&lt; State of cores. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primary or secondary configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_proc_type_t</span> <span class="title">process_type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** PA or VA mapping mode */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Pointer to memory configuration, which may be shared across multiple</span></span><br><span class="line"><span class="comment">	 * DPDK instances</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mem_config</span>;</span></span><br><span class="line">&#125; __attribute__((__packed__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * internal configuration structure for the number, size and</span></span><br><span class="line"><span class="comment"> * mount points of hugepages</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> hugepage_sz;   <span class="comment">/**&lt; size of a huge page */</span></span><br><span class="line">	<span class="type">char</span> hugedir[PATH_MAX];    <span class="comment">/**&lt; dir where hugetlbfs is mounted */</span></span><br><span class="line">	<span class="type">uint32_t</span> num_pages[RTE_MAX_NUMA_NODES];</span><br><span class="line">	<span class="comment">/**&lt; number of hugepages of that size on each socket */</span></span><br><span class="line">	<span class="type">int</span> lock_descriptor;    <span class="comment">/**&lt; file descriptor for hugepage dir */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure used to store information about hugepages that we mapped</span></span><br><span class="line"><span class="comment"> * through the files in hugetlbfs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *orig_va;      <span class="comment">/**&lt; virtual addr of first mmap() */</span></span><br><span class="line">	<span class="type">void</span> *final_va;     <span class="comment">/**&lt; virtual addr of 2nd mmap() */</span></span><br><span class="line">	<span class="type">uint64_t</span> physaddr;  <span class="comment">/**&lt; physical addr */</span></span><br><span class="line">	<span class="type">size_t</span> size;        <span class="comment">/**&lt; the page size */</span></span><br><span class="line">	<span class="type">int</span> socket_id;      <span class="comment">/**&lt; NUMA socket ID */</span></span><br><span class="line">	<span class="type">int</span> file_id;        <span class="comment">/**&lt; the &#x27;%d&#x27; in HUGEFILE_FMT */</span></span><br><span class="line">	<span class="type">char</span> filepath[MAX_HUGEPAGE_PATH]; <span class="comment">/**&lt; path to backing file on filesystem */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Memory configuration shared across multiple processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint32_t</span> magic;   <span class="comment">/**&lt; Magic number - sanity check. */</span></span><br><span class="line">	<span class="type">uint32_t</span> version;</span><br><span class="line">	<span class="comment">/**&lt; Prevent secondary processes using different DPDK versions. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* memory topology */</span></span><br><span class="line">	<span class="type">uint32_t</span> nchannel;    <span class="comment">/**&lt; Number of channels (0 if unknown). */</span></span><br><span class="line">	<span class="type">uint32_t</span> nrank;       <span class="comment">/**&lt; Number of ranks (0 if unknown). */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * current lock nest order</span></span><br><span class="line"><span class="comment">	 *  - qlock-&gt;mlock (ring/hash/lpm)</span></span><br><span class="line"><span class="comment">	 *  - mplock-&gt;qlock-&gt;mlock (mempool)</span></span><br><span class="line"><span class="comment">	 * Notice:</span></span><br><span class="line"><span class="comment">	 *  *ALWAYS* obtain qlock first if having to obtain both qlock and mlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_rwlock_t</span> mlock;   <span class="comment">/**&lt; used by memzones for thread safety. */</span></span><br><span class="line">	<span class="type">rte_rwlock_t</span> qlock;   <span class="comment">/**&lt; used by tailqs for thread safety. */</span></span><br><span class="line">	<span class="type">rte_rwlock_t</span> mplock;  <span class="comment">/**&lt; used by mempool library for thread safety. */</span></span><br><span class="line">	<span class="type">rte_spinlock_t</span> tlock; <span class="comment">/**&lt; used by timer library for thread safety. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">rte_rwlock_t</span> memory_hotplug_lock;</span><br><span class="line">	<span class="comment">/**&lt; Indicates whether memory hotplug request is in progress. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* memory segments and zones */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_fbarray</span> <span class="title">memzones</span>;</span> <span class="comment">/**&lt; Memzone descriptors. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> <span class="title">memsegs</span>[<span class="title">RTE_MAX_MEMSEG_LISTS</span>];</span></span><br><span class="line">	<span class="comment">/**&lt; List of dynamic arrays holding memsegs */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span> <span class="title">tailq_head</span>[<span class="title">RTE_MAX_TAILQ</span>];</span></span><br><span class="line">	<span class="comment">/**&lt; Tailqs for objects */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_heap</span> <span class="title">malloc_heaps</span>[<span class="title">RTE_MAX_HEAPS</span>];</span></span><br><span class="line">	<span class="comment">/**&lt; DPDK malloc heaps */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> next_socket_id; <span class="comment">/**&lt; Next socket ID for external malloc heap */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* rte_mem_config has to be mapped at the exact same address in all</span></span><br><span class="line"><span class="comment">	 * processes, so we need to store it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint64_t</span> mem_cfg_addr; <span class="comment">/**&lt; Address of this structure in memory. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primary and secondary processes cannot run with different legacy or</span></span><br><span class="line"><span class="comment">	 * single file segments options, so to avoid having to specify these</span></span><br><span class="line"><span class="comment">	 * options to all processes, store them in shared config and update the</span></span><br><span class="line"><span class="comment">	 * internal config at init time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> legacy_mem; <span class="comment">/**&lt; stored legacy mem parameter. */</span></span><br><span class="line">	<span class="type">uint32_t</span> single_file_segments;</span><br><span class="line">	<span class="comment">/**&lt; stored single file segments parameter. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> tsc_hz;</span><br><span class="line">	<span class="comment">/**&lt; TSC rate */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> dma_maskbits; <span class="comment">/**&lt; Keeps the more restricted dma mask. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的四个数据结构，其实就是全局配置文件 rte_config 到 rte_mem_config，然后再有就是巨页内存的配置和相关信息的数据结构。其中的英文注释已经详细的不得了了。<br>再看一下 DPDK 对世面的管理数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**&lt; Prevent this segment from being freed back to the OS. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg</span> &#123;</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">phys_addr_t</span> phys_addr;  <span class="comment">/**&lt; deprecated - Start physical address. */</span></span><br><span class="line">		<span class="type">rte_iova_t</span> iova;        <span class="comment">/**&lt; Start IO address. */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *addr;         <span class="comment">/**&lt; Start virtual address. */</span></span><br><span class="line">		<span class="type">uint64_t</span> addr_64;   <span class="comment">/**&lt; Makes sure addr is always 64 bits */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">size_t</span> len;               <span class="comment">/**&lt; Length of the segment. */</span></span><br><span class="line">	<span class="type">uint64_t</span> hugepage_sz;       <span class="comment">/**&lt; The pagesize of underlying memory */</span></span><br><span class="line">	<span class="type">int32_t</span> socket_id;          <span class="comment">/**&lt; NUMA socket ID. */</span></span><br><span class="line">	<span class="type">uint32_t</span> nchannel;          <span class="comment">/**&lt; Number of channels. */</span></span><br><span class="line">	<span class="type">uint32_t</span> nrank;             <span class="comment">/**&lt; Number of ranks. */</span></span><br><span class="line">	<span class="type">uint32_t</span> flags;             <span class="comment">/**&lt; Memseg-specific flags */</span></span><br><span class="line">&#125; __rte_packed;</span><br></pre></td></tr></table></figure>

<p>DPDK 将同一 SOCKET 的大小相同并且地址连续的巨页存储在此结构中，方便管理和优化。</p>
<h3 id="分配初始化"><a href="#分配初始化" class="headerlink" title="分配初始化"></a>分配初始化</h3><p>从启动后就正式开始了初始化和相关分配的流程：<br>1、环境初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Launch threads, called at application init(). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (rte_config_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;Cannot init config&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">if</span> (internal_config.no_hugetlbfs == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* rte_config isn&#x27;t initialized yet */</span></span><br><span class="line">			ret = internal_config.process_type == RTE_PROC_PRIMARY ?</span><br><span class="line">			    eal_hugepage_info_init() :</span><br><span class="line">			    eal_hugepage_info_read();</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				rte_eal_init_alert(<span class="string">&quot;Cannot get hugepage information.&quot;</span>);</span><br><span class="line">				rte_errno = EACCES;</span><br><span class="line">				rte_atomic32_clear(&amp;run_once);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">/* in secondary processes, memory init may allocate additional fbarrays</span></span><br><span class="line"><span class="comment"> * not present in primary processes, so to avoid any potential issues,</span></span><br><span class="line"><span class="comment"> * initialize memzones first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		<span class="keyword">if</span> (rte_eal_memzone_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_eal_init_alert(<span class="string">&quot;Cannot init memzone&quot;</span>);</span><br><span class="line">			rte_errno = ENODEV;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">.........</span><br><span class="line">		<span class="keyword">if</span> (rte_eal_memory_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_eal_init_alert(<span class="string">&quot;Cannot init memory&quot;</span>);</span><br><span class="line">			rte_errno = ENOMEM;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数里主要包含了四个主要的初始化函数（即上面列出的）。当然这个函数里还包括了不少的参数分析、日志以及其它初始化动作，但分析内存重点还是看内存相关的。<br>2、全局配置初始化<br>看相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sets up rte_config structure with the pointer to shared memory config.*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rte_config_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rte_config.process_type = internal_config.process_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (rte_config.process_type)&#123;</span><br><span class="line">	<span class="keyword">case</span> RTE_PROC_PRIMARY:</span><br><span class="line">		<span class="keyword">if</span> (rte_eal_config_create() &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		eal_mcfg_update_from_internal();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> RTE_PROC_SECONDARY:</span><br><span class="line">		<span class="keyword">if</span> (rte_eal_config_attach() &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		eal_mcfg_wait_complete();</span><br><span class="line">		<span class="keyword">if</span> (eal_mcfg_check_version() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Primary and secondary process DPDK version mismatch\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (rte_eal_config_reattach() &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		eal_mcfg_update_internal();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> RTE_PROC_AUTO:</span><br><span class="line">	<span class="keyword">case</span> RTE_PROC_INVALID:</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Invalid process type %d\n&quot;</span>,</span><br><span class="line">			rte_config.process_type);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rte_eal_config_reattach 由从进程执行，而 rte_eal_config_create 由主进程执行，此处要进行前面提到的 mmap 映射过程即从 config 文件中的配置映射到所在进程的 ret_config.mem_config 数据结构中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create memory configuration in shared/mmap memory. Take out</span></span><br><span class="line"><span class="comment"> * a write lock on the memsegs, so we can auto-detect primary/secondary.</span></span><br><span class="line"><span class="comment"> * This means we never close the file while running (auto-close on exit).</span></span><br><span class="line"><span class="comment"> * We also don&#x27;t lock the whole file, so that in future we can use read-locks</span></span><br><span class="line"><span class="comment"> * on other parts, e.g. memzones, to detect if there are running secondary</span></span><br><span class="line"><span class="comment"> * processes. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rte_eal_config_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> page_sz = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">	<span class="type">size_t</span> cfg_len = <span class="keyword">sizeof</span>(*rte_config.mem_config);</span><br><span class="line">	<span class="type">size_t</span> cfg_len_aligned = RTE_ALIGN(cfg_len, page_sz);</span><br><span class="line">	<span class="type">void</span> *rte_mem_cfg_addr, *mapped_mem_cfg_addr;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *pathname = eal_runtime_config_path();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_shconf)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* map the config before hugepage address so that we don&#x27;t waste a page */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.base_virtaddr != <span class="number">0</span>)</span><br><span class="line">		rte_mem_cfg_addr = (<span class="type">void</span> *)</span><br><span class="line">			RTE_ALIGN_FLOOR(internal_config.base_virtaddr -</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_mem_config), page_sz);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rte_mem_cfg_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cfg_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		mem_cfg_fd = open(pathname, O_RDWR | O_CREAT, <span class="number">0600</span>);</span><br><span class="line">		<span class="keyword">if</span> (mem_cfg_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot open &#x27;%s&#x27; for rte_mem_config\n&quot;</span>,</span><br><span class="line">				pathname);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = ftruncate(mem_cfg_fd, cfg_len);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		close(mem_cfg_fd);</span><br><span class="line">		mem_cfg_fd = <span class="number">-1</span>;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot resize &#x27;%s&#x27; for rte_mem_config\n&quot;</span>,</span><br><span class="line">			pathname);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = fcntl(mem_cfg_fd, F_SETLK, &amp;wr_lock);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		close(mem_cfg_fd);</span><br><span class="line">		mem_cfg_fd = <span class="number">-1</span>;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot create lock on &#x27;%s&#x27;. Is another primary &quot;</span></span><br><span class="line">			<span class="string">&quot;process running?\n&quot;</span>, pathname);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reserve space for config */</span></span><br><span class="line">	rte_mem_cfg_addr = eal_get_virtual_area(rte_mem_cfg_addr,</span><br><span class="line">			&amp;cfg_len_aligned, page_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (rte_mem_cfg_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot mmap memory for rte_config\n&quot;</span>);</span><br><span class="line">		close(mem_cfg_fd);</span><br><span class="line">		mem_cfg_fd = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remap the actual file into the space we&#x27;ve just reserved */</span></span><br><span class="line">	mapped_mem_cfg_addr = mmap(rte_mem_cfg_addr,</span><br><span class="line">			cfg_len_aligned, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_FIXED, mem_cfg_fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (mapped_mem_cfg_addr == MAP_FAILED) &#123;</span><br><span class="line">		munmap(rte_mem_cfg_addr, cfg_len);</span><br><span class="line">		close(mem_cfg_fd);</span><br><span class="line">		mem_cfg_fd = <span class="number">-1</span>;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot remap memory for rte_config\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(rte_mem_cfg_addr, &amp;early_mem_config, <span class="keyword">sizeof</span>(early_mem_config));</span><br><span class="line">	rte_config.mem_config = rte_mem_cfg_addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* store address of the config in the config itself so that secondary</span></span><br><span class="line"><span class="comment">	 * processes could later map the config into this exact location */</span></span><br><span class="line">	rte_config.mem_config-&gt;mem_cfg_addr = (<span class="type">uintptr_t</span>) rte_mem_cfg_addr;</span><br><span class="line"></span><br><span class="line">	rte_config.mem_config-&gt;dma_maskbits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* attach to an existing shared memory config */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rte_eal_config_attach</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mem_config</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *pathname = eal_runtime_config_path();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_shconf)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cfg_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		mem_cfg_fd = open(pathname, O_RDWR);</span><br><span class="line">		<span class="keyword">if</span> (mem_cfg_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot open &#x27;%s&#x27; for rte_mem_config\n&quot;</span>,</span><br><span class="line">				pathname);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* map it as read-only first */</span></span><br><span class="line">	mem_config = (<span class="keyword">struct</span> rte_mem_config *) mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(*mem_config),</span><br><span class="line">			PROT_READ, MAP_SHARED, mem_cfg_fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (mem_config == MAP_FAILED) &#123;</span><br><span class="line">		close(mem_cfg_fd);</span><br><span class="line">		mem_cfg_fd = <span class="number">-1</span>;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot mmap memory for rte_config! error %i (%s)\n&quot;</span>,</span><br><span class="line">			errno, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_config.mem_config = mem_config;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看明白这个，需要有一些 mmap 的相关知识，其实一般共享内存会有两个入口，一个是创建并使用，一个是使用。如果对此不是很清楚的可以看看相关的知识，不难，不过需要指出的 Linux 中有两种内存映射，一种是 SystemV, 而此处使用的 Posix。</p>
<p>3、巨页内存信息配置初始化<br>其初始化代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eal_hugepage_info_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> *<span class="title">hpi</span>, *<span class="title">tmp_hpi</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hugepage_info_init() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for no shared files mode, we&#x27;re done */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_shconf)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	hpi = &amp;internal_config.hugepage_info[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	tmp_hpi = create_shared_memory(eal_hugepage_info_path(),</span><br><span class="line">			<span class="keyword">sizeof</span>(internal_config.hugepage_info));</span><br><span class="line">	<span class="keyword">if</span> (tmp_hpi == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Failed to create shared memory!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(tmp_hpi, hpi, <span class="keyword">sizeof</span>(internal_config.hugepage_info));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve copied file descriptors along with everything else, but they</span></span><br><span class="line"><span class="comment">	 * will be invalid in secondary process, so overwrite them</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_DIM(internal_config.hugepage_info); i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> *<span class="title">tmp</span> =</span> &amp;tmp_hpi[i];</span><br><span class="line">		tmp-&gt;lock_descriptor = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (munmap(tmp_hpi, <span class="keyword">sizeof</span>(internal_config.hugepage_info)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Failed to unmap shared memory!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hugepage_info_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	<span class="type">const</span> <span class="type">char</span> dirent_start_text[] = <span class="string">&quot;hugepages-&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> dirent_start_len = <span class="keyword">sizeof</span>(dirent_start_text) - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, num_sizes = <span class="number">0</span>;</span><br><span class="line">	DIR *dir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent</span>;</span></span><br><span class="line"></span><br><span class="line">	dir = opendir(sys_dir_path);</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL,</span><br><span class="line">			<span class="string">&quot;Cannot open directory %s to read system hugepage info\n&quot;</span>,</span><br><span class="line">			sys_dir_path);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (dirent = readdir(dir); dirent != <span class="literal">NULL</span>; dirent = readdir(dir)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> *<span class="title">hpi</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(dirent-&gt;d_name, dirent_start_text,</span><br><span class="line">			    dirent_start_len) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (num_sizes &gt;= MAX_HUGEPAGE_SIZES)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		hpi = &amp;internal_config.hugepage_info[num_sizes];</span><br><span class="line">		hpi-&gt;hugepage_sz =</span><br><span class="line">			rte_str_to_size(&amp;dirent-&gt;d_name[dirent_start_len]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* first, check if we have a mountpoint */</span></span><br><span class="line">		<span class="keyword">if</span> (get_hugepage_dir(hpi-&gt;hugepage_sz,</span><br><span class="line">			hpi-&gt;hugedir, <span class="keyword">sizeof</span>(hpi-&gt;hugedir)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">uint32_t</span> num_pages;</span><br><span class="line"></span><br><span class="line">			num_pages = get_num_hugepages(dirent-&gt;d_name);</span><br><span class="line">			<span class="keyword">if</span> (num_pages &gt; <span class="number">0</span>)</span><br><span class="line">				RTE_LOG(NOTICE, EAL,</span><br><span class="line">					<span class="string">&quot;%&quot;</span> PRIu32 <span class="string">&quot; hugepages of size &quot;</span></span><br><span class="line">					<span class="string">&quot;%&quot;</span> PRIu64 <span class="string">&quot; reserved, but no mounted &quot;</span></span><br><span class="line">					<span class="string">&quot;hugetlbfs found for that size\n&quot;</span>,</span><br><span class="line">					num_pages, hpi-&gt;hugepage_sz);</span><br><span class="line">			<span class="comment">/* if we have kernel support for reserving hugepages</span></span><br><span class="line"><span class="comment">			 * through mmap, and we&#x27;re in in-memory mode, treat this</span></span><br><span class="line"><span class="comment">			 * page size as valid. we cannot be in legacy mode at</span></span><br><span class="line"><span class="comment">			 * this point because we&#x27;ve checked this earlier in the</span></span><br><span class="line"><span class="comment">			 * init process.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGE_SHIFT</span></span><br><span class="line">			<span class="keyword">if</span> (internal_config.in_memory) &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;In-memory mode enabled, &quot;</span></span><br><span class="line">					<span class="string">&quot;hugepages of size %&quot;</span> PRIu64 <span class="string">&quot; bytes &quot;</span></span><br><span class="line">					<span class="string">&quot;will be allocated anonymously\n&quot;</span>,</span><br><span class="line">					hpi-&gt;hugepage_sz);</span><br><span class="line">				calc_num_pages(hpi, dirent);</span><br><span class="line">				num_sizes++;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* try to obtain a writelock */</span></span><br><span class="line">		hpi-&gt;lock_descriptor = open(hpi-&gt;hugedir, O_RDONLY);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if blocking lock failed */</span></span><br><span class="line">		<span class="keyword">if</span> (flock(hpi-&gt;lock_descriptor, LOCK_EX) == <span class="number">-1</span>) &#123;</span><br><span class="line">			RTE_LOG(CRIT, EAL,</span><br><span class="line">				<span class="string">&quot;Failed to lock hugepage directory!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* clear out the hugepages dir from unused pages */</span></span><br><span class="line">		<span class="keyword">if</span> (clear_hugedir(hpi-&gt;hugedir) == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		calc_num_pages(hpi, dirent);</span><br><span class="line"></span><br><span class="line">		num_sizes++;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* something went wrong, and we broke from the for loop above */</span></span><br><span class="line">	<span class="keyword">if</span> (dirent != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	internal_config.num_hugepage_sizes = num_sizes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sort the page directory entries by size, largest to smallest */</span></span><br><span class="line">	qsort(&amp;internal_config.hugepage_info[<span class="number">0</span>], num_sizes,</span><br><span class="line">	      <span class="keyword">sizeof</span>(internal_config.hugepage_info[<span class="number">0</span>]), compare_hpi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now we have all info, check we have at least one valid size */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_sizes; i++) &#123;</span><br><span class="line">		<span class="comment">/* pages may no longer all be on socket 0, so check all */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> j, num_pages = <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> *<span class="title">hpi</span> =</span> &amp;internal_config.hugepage_info[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RTE_MAX_NUMA_NODES; j++)</span><br><span class="line">			num_pages += hpi-&gt;num_pages[j];</span><br><span class="line">		<span class="keyword">if</span> (num_pages &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* no valid hugepage mounts available, return error */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实大概上面的代码分为几个过程</p>
<ul>
<li>首先准备巨页相关的数据结构然后进行巨页的 init，在 init 中通过读取配置文件中的信息对整个巨页的信息进行配置并加载。</li>
<li>其次，判断是否有共享文件 Mode，否则退出。再次根据前面得到的相关信息开始创建共享内存并拷贝 hpi 文件描述符到共享内存，这没啥可讲的。</li>
<li>最后处理从进程中无用的部分即可。</li>
</ul>
<p>4、内存 memzone 初始化<br>同样，在完成上述的内存处理动作后就开始了 memzone 的处理 (同样在 rte_eal_init 函数内)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in secondary processes, memory init may allocate additional fbarrays</span></span><br><span class="line"><span class="comment"> * not present in primary processes, so to avoid any potential issues,</span></span><br><span class="line"><span class="comment"> * initialize memzones first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (rte_eal_memzone_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	rte_eal_init_alert(<span class="string">&quot;Cannot init memzone&quot;</span>);</span><br><span class="line">	rte_errno = ENODEV;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eal_memory_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	rte_eal_init_alert(<span class="string">&quot;Cannot init memory&quot;</span>);</span><br><span class="line">	rte_errno = ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把下面的那个初始化也搞进来，这个在后头就不再拷贝了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Init the memzone subsystem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_memzone_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get pointer to global configuration */</span></span><br><span class="line">	mcfg = rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_lock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY &amp;&amp;</span><br><span class="line">			rte_fbarray_init(&amp;mcfg-&gt;memzones, <span class="string">&quot;memzone&quot;</span>,</span><br><span class="line">			RTE_MAX_MEMZONE, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_memzone))) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot allocate memzone list\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_SECONDARY &amp;&amp;</span><br><span class="line">			rte_fbarray_attach(&amp;mcfg-&gt;memzones)) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot attach to memzone list\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_unlock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fbarray_init</span><span class="params">(<span class="keyword">struct</span> rte_fbarray *arr, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> elt_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> page_sz, mmap_len;</span><br><span class="line">	<span class="type">char</span> path[PATH_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">used_mask</span> *<span class="title">msk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_area</span> *<span class="title">ma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fully_validate(name, elt_sz, len))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate mem area before doing anything */</span></span><br><span class="line">	ma = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ma));</span><br><span class="line">	<span class="keyword">if</span> (ma == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = ENOMEM;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page_sz = sysconf(_SC_PAGESIZE);</span><br><span class="line">	<span class="keyword">if</span> (page_sz == (<span class="type">size_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ma);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calculate our memory limits */</span></span><br><span class="line">	mmap_len = calc_data_size(page_sz, elt_sz, len);</span><br><span class="line"></span><br><span class="line">	data = eal_get_virtual_area(<span class="literal">NULL</span>, &amp;mmap_len, page_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ma);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_lock(&amp;mem_area_lock);</span><br><span class="line"></span><br><span class="line">	fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_shconf) &#123;</span><br><span class="line">		<span class="comment">/* remap virtual area as writable */</span></span><br><span class="line">		<span class="type">void</span> *new_data = mmap(data, mmap_len, PROT_READ | PROT_WRITE,</span><br><span class="line">				MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (new_data == MAP_FAILED) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;%s(): couldn&#x27;t remap anonymous memory: %s\n&quot;</span>,</span><br><span class="line">					__func__, strerror(errno));</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		eal_get_fbarray_path(path, <span class="keyword">sizeof</span>(path), name);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Each fbarray is unique to process namespace, i.e. the</span></span><br><span class="line"><span class="comment">		 * filename depends on process prefix. Try to take out a lock</span></span><br><span class="line"><span class="comment">		 * and see if we succeed. If we don&#x27;t, someone else is using it</span></span><br><span class="line"><span class="comment">		 * already.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		fd = open(path, O_CREAT | O_RDWR, <span class="number">0600</span>);</span><br><span class="line">		<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;%s(): couldn&#x27;t open %s: %s\n&quot;</span>,</span><br><span class="line">					__func__, path, strerror(errno));</span><br><span class="line">			rte_errno = errno;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flock(fd, LOCK_EX | LOCK_NB)) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;%s(): couldn&#x27;t lock %s: %s\n&quot;</span>,</span><br><span class="line">					__func__, path, strerror(errno));</span><br><span class="line">			rte_errno = EBUSY;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* take out a non-exclusive lock, so that other processes could</span></span><br><span class="line"><span class="comment">		 * still attach to it, but no other process could reinitialize</span></span><br><span class="line"><span class="comment">		 * it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (flock(fd, LOCK_SH | LOCK_NB)) &#123;</span><br><span class="line">			rte_errno = errno;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (resize_and_map(fd, path, data, mmap_len))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ma-&gt;addr = data;</span><br><span class="line">	ma-&gt;len = mmap_len;</span><br><span class="line">	ma-&gt;fd = fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do not close fd - keep it until detach/destroy */</span></span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;mem_area_tailq, ma, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize the data */</span></span><br><span class="line">	<span class="built_in">memset</span>(data, <span class="number">0</span>, mmap_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* populate data structure */</span></span><br><span class="line">	strlcpy(arr-&gt;name, name, <span class="keyword">sizeof</span>(arr-&gt;name));</span><br><span class="line">	arr-&gt;data = data;</span><br><span class="line">	arr-&gt;len = len;</span><br><span class="line">	arr-&gt;elt_sz = elt_sz;</span><br><span class="line">	arr-&gt;count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	msk = get_used_mask(data, elt_sz, len);</span><br><span class="line">	msk-&gt;n_masks = MASK_LEN_TO_IDX(RTE_ALIGN_CEIL(len, MASK_ALIGN));</span><br><span class="line"></span><br><span class="line">	rte_rwlock_init(&amp;arr-&gt;rwlock);</span><br><span class="line"></span><br><span class="line">	rte_spinlock_unlock(&amp;mem_area_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">		munmap(data, mmap_len);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">		close(fd);</span><br><span class="line">	<span class="built_in">free</span>(ma);</span><br><span class="line"></span><br><span class="line">	rte_spinlock_unlock(&amp;mem_area_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fbarray_attach</span><span class="params">(<span class="keyword">struct</span> rte_fbarray *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_area</span> *<span class="title">ma</span> =</span> <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> page_sz, mmap_len;</span><br><span class="line">	<span class="type">char</span> path[PATH_MAX];</span><br><span class="line">	<span class="type">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * we don&#x27;t need to synchronize attach as two values we need (element</span></span><br><span class="line"><span class="comment">	 * size and array length) are constant for the duration of life of</span></span><br><span class="line"><span class="comment">	 * the array, so the parts we care about will not race.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fully_validate(arr-&gt;name, arr-&gt;elt_sz, arr-&gt;len))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	ma = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ma));</span><br><span class="line">	<span class="keyword">if</span> (ma == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = ENOMEM;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page_sz = sysconf(_SC_PAGESIZE);</span><br><span class="line">	<span class="keyword">if</span> (page_sz == (<span class="type">size_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ma);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mmap_len = calc_data_size(page_sz, arr-&gt;elt_sz, arr-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check the tailq - maybe user has already mapped this address space */</span></span><br><span class="line">	rte_spinlock_lock(&amp;mem_area_lock);</span><br><span class="line"></span><br><span class="line">	TAILQ_FOREACH(tmp, &amp;mem_area_tailq, next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (overlap(tmp, arr-&gt;data, mmap_len)) &#123;</span><br><span class="line">			rte_errno = EEXIST;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we know this memory area is unique, so proceed */</span></span><br><span class="line"></span><br><span class="line">	data = eal_get_virtual_area(arr-&gt;data, &amp;mmap_len, page_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	eal_get_fbarray_path(path, <span class="keyword">sizeof</span>(path), arr-&gt;name);</span><br><span class="line"></span><br><span class="line">	fd = open(path, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_errno = errno;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lock the file, to let others know we&#x27;re using it */</span></span><br><span class="line">	<span class="keyword">if</span> (flock(fd, LOCK_SH | LOCK_NB)) &#123;</span><br><span class="line">		rte_errno = errno;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resize_and_map(fd, path, data, mmap_len))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* store our new memory area */</span></span><br><span class="line">	ma-&gt;addr = data;</span><br><span class="line">	ma-&gt;fd = fd; <span class="comment">/* keep fd until detach/destroy */</span></span><br><span class="line">	ma-&gt;len = mmap_len;</span><br><span class="line"></span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;mem_area_tailq, ma, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re done */</span></span><br><span class="line"></span><br><span class="line">	rte_spinlock_unlock(&amp;mem_area_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">		munmap(data, mmap_len);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">		close(fd);</span><br><span class="line">	<span class="built_in">free</span>(ma);</span><br><span class="line">	rte_spinlock_unlock(&amp;mem_area_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用 rte_fabarry_init 这个函数来分配 struct mem_area，这个数据结构用来处理创建和附加的内存区域，确保 API 调用的安全。</p>
<p>5、内存初始化<br>在上面把内存初始化的代码调用已经说明了，现在看一下其代码实现及其调用的两个主要函数 rte_eal_memseg_init 和 eal_memalloc_init：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init memory subsystem */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_memory_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span> =</span> rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	RTE_LOG(DEBUG, EAL, <span class="string">&quot;Setting up physically contiguous memory...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mcfg)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lock mem hotplug here, to prevent races while we init */</span></span><br><span class="line">	rte_mcfg_mem_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_memseg_init() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (eal_memalloc_init() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	retval = rte_eal_process_type() == RTE_PROC_PRIMARY ?</span><br><span class="line">			rte_eal_hugepage_init() :</span><br><span class="line">			rte_eal_hugepage_attach();</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_shconf == <span class="number">0</span> &amp;&amp; rte_eal_memdevice_init() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	rte_mcfg_mem_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_memseg_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* increase rlimit to maximum */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">lim</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;lim) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* set limit to maximum */</span></span><br><span class="line">		lim.rlim_cur = lim.rlim_max;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;lim) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Setting maximum number of open files failed: %s\n&quot;</span>,</span><br><span class="line">					strerror(errno));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Setting maximum number of open files to %&quot;</span></span><br><span class="line">					PRIu64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">					(<span class="type">uint64_t</span>)lim.rlim_cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot get current resource limits\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RTE_EAL_NUMA_AWARE_HUGEPAGES</span></span><br><span class="line">	<span class="keyword">if</span> (!internal_config.legacy_mem &amp;&amp; rte_socket_count() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		RTE_LOG(WARNING, EAL, <span class="string">&quot;DPDK is running on a NUMA system, but is compiled without NUMA support.\n&quot;</span>);</span><br><span class="line">		RTE_LOG(WARNING, EAL, <span class="string">&quot;This will have adverse consequences for performance and usability.\n&quot;</span>);</span><br><span class="line">		RTE_LOG(WARNING, EAL, <span class="string">&quot;Please use --&quot;</span>OPT_LEGACY_MEM<span class="string">&quot; option, or recompile with NUMA support.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rte_eal_process_type() == RTE_PROC_PRIMARY ?</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RTE_ARCH_64</span></span><br><span class="line">			memseg_primary_init_32() :</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			memseg_primary_init() :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			memseg_secondary_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eal_memalloc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_SECONDARY)</span><br><span class="line">		<span class="keyword">if</span> (rte_memseg_list_walk(secondary_msl_create_walk, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY &amp;&amp;</span><br><span class="line">			internal_config.in_memory) &#123;</span><br><span class="line">		<span class="type">int</span> mfd_res = test_memfd_create();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mfd_res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Unable to check if memfd is supported\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mfd_res == <span class="number">1</span>)</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Using memfd for anonymous memory\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			RTE_LOG(INFO, EAL, <span class="string">&quot;Using memfd is not supported, falling back to anonymous hugepages\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* we only support single-file segments mode with in-memory mode</span></span><br><span class="line"><span class="comment">		 * if we support hugetlbfs with memfd_create. this code will</span></span><br><span class="line"><span class="comment">		 * test if we do.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (internal_config.single_file_segments &amp;&amp;</span><br><span class="line">				mfd_res != <span class="number">1</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Single-file segments mode cannot be used without memfd support\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* this cannot ever happen but better safe than sorry */</span></span><br><span class="line">		<span class="keyword">if</span> (!anonymous_hugepages_supported) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Using anonymous memory is not supported\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize all of the fd lists */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_memseg_list_walk(fd_list_create_walk, <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">memseg_secondary_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span> =</span> rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line">	<span class="type">int</span> msl_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">msl</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (msl_idx = <span class="number">0</span>; msl_idx &lt; RTE_MAX_MEMSEG_LISTS; msl_idx++) &#123;</span><br><span class="line"></span><br><span class="line">		msl = &amp;mcfg-&gt;memsegs[msl_idx];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* skip empty and external memseg lists */</span></span><br><span class="line">		<span class="keyword">if</span> (msl-&gt;memseg_arr.len == <span class="number">0</span> || msl-&gt;external)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rte_fbarray_attach(&amp;msl-&gt;memseg_arr)) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot attach to primary process memseg lists\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* preallocate VA space */</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_va_space(msl)) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot preallocate VA space for hugepage memory\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内存初始化的函数中调用 rte_eal_memseg_init 实现主从进程中的内存段相关初始化。主进程使用 memseg_primary_init 函数，子进程使用 memseg_secondary_init 函数来实现。这其中通过 rte_memseg_list 结构体来描述其 mem segment 数量。从而进一步其分配虚拟的内存空间的大小。<br>从进程使用 memseg_secondary_init 来操作主进程分配的相关 memseglist 并 attach 过来。二者共享 memseg 空间。同时要做一些虚拟地址空间的大页保留动作。<br>而 rte_eal_memalloc 函数就比较简单了，同样分为主从进程，前者对所有的 memset 的文件描述符进行初始化，而后者初始化自己本地内存的映射并保存到本地：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">secondary_msl_create_walk</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_memseg_list *msl,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> *arg __rte_unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span> =</span> rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">primary_msl</span>, *<span class="title">local_msl</span>;</span></span><br><span class="line">	<span class="type">char</span> name[PATH_MAX];</span><br><span class="line">	<span class="type">int</span> msl_idx, ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msl-&gt;external)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	msl_idx = msl - mcfg-&gt;memsegs;</span><br><span class="line">	primary_msl = &amp;mcfg-&gt;memsegs[msl_idx];</span><br><span class="line">	local_msl = &amp;local_memsegs[msl_idx];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create distinct fbarrays for each secondary */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(name, RTE_FBARRAY_NAME_LEN, <span class="string">&quot;%s_%i&quot;</span>,</span><br><span class="line">		primary_msl-&gt;memseg_arr.name, getpid());</span><br><span class="line"></span><br><span class="line">	ret = rte_fbarray_init(&amp;local_msl-&gt;memseg_arr, name,</span><br><span class="line">		primary_msl-&gt;memseg_arr.len,</span><br><span class="line">		primary_msl-&gt;memseg_arr.elt_sz);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot initialize local memory map\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	local_msl-&gt;base_va = primary_msl-&gt;base_va;</span><br><span class="line">	local_msl-&gt;len = primary_msl-&gt;len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、大页内存初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rte_eal_memory_init函数内</span></span><br><span class="line">retval = rte_eal_process_type() == RTE_PROC_PRIMARY ?</span><br><span class="line">		rte_eal_hugepage_init() :</span><br><span class="line">		rte_eal_hugepage_attach();</span><br></pre></td></tr></table></figure>

<p>在前面的 eal_hugepage_info_init 函数中主要是处理大页内存外部配置的初始化动作，而在此处的 rte_eal_hugepage_init 则根据情况来实际完成初始化的动作。DPDK 中分为两类内存模式：<br>legacy mode：静态模式<br>即在程序初始化时分配内存并一直使用，它能保证内存空间的连续性（虚拟和物理）。但内存不足时，则不可再分配<br>dynamic mode：动态模式<br>即程序在初始化过程中逐步根据情况分配内存并一直持续到结束，但是在内存不足时，可以向 OS 申请并使用而且在使用完成后 Free 返回给 OS。但是这样内存地址就无法保证连续。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_hugepage_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> internal_config.legacy_mem ?</span><br><span class="line">			eal_legacy_hugepage_init() :</span><br><span class="line">			eal_hugepage_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_hugepage_attach</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> internal_config.legacy_mem ?</span><br><span class="line">			eal_legacy_hugepage_attach() :</span><br><span class="line">			eal_hugepage_attach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare physical memory mapping: fill configuration structure with</span></span><br><span class="line"><span class="comment"> * these infos, return 0 on success.</span></span><br><span class="line"><span class="comment"> *  1. map N huge pages in separate files in hugetlbfs</span></span><br><span class="line"><span class="comment"> *  2. find associated physical addr</span></span><br><span class="line"><span class="comment"> *  3. find associated NUMA socket ID</span></span><br><span class="line"><span class="comment"> *  4. sort all huge pages by physical address</span></span><br><span class="line"><span class="comment"> *  5. remap these N huge pages in the correct order</span></span><br><span class="line"><span class="comment"> *  6. unmap the first mapping</span></span><br><span class="line"><span class="comment"> *  7. fill memsegs in configuration with contiguous zones</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eal_legacy_hugepage_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> *<span class="title">hugepage</span> =</span> <span class="literal">NULL</span>, *tmp_hp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> <span class="title">used_hp</span>[<span class="title">MAX_HUGEPAGE_SIZES</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_fbarray</span> *<span class="title">arr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg</span> *<span class="title">ms</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> memory[RTE_MAX_NUMA_NODES];</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> hp_offset;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">int</span> nr_hugefiles, nr_hugepages = <span class="number">0</span>;</span><br><span class="line">	<span class="type">void</span> *addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(used_hp, <span class="number">0</span>, <span class="keyword">sizeof</span>(used_hp));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get pointer to global configuration */</span></span><br><span class="line">	mcfg = rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hugetlbfs can be disabled */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.no_hugetlbfs) &#123;</span><br><span class="line">		<span class="type">void</span> *prealloc_addr;</span><br><span class="line">		<span class="type">size_t</span> mem_sz;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">msl</span>;</span></span><br><span class="line">		<span class="type">int</span> n_segs, cur_seg, fd, flags;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MEMFD_SUPPORTED</span></span><br><span class="line">		<span class="type">int</span> memfd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="type">uint64_t</span> page_sz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* nohuge mode is legacy mode */</span></span><br><span class="line">		internal_config.legacy_mem = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* nohuge mode is single-file segments mode */</span></span><br><span class="line">		internal_config.single_file_segments = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* create a memseg list */</span></span><br><span class="line">		msl = &amp;mcfg-&gt;memsegs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		page_sz = RTE_PGSIZE_4K;</span><br><span class="line">		n_segs = internal_config.memory / page_sz;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rte_fbarray_init(&amp;msl-&gt;memseg_arr, <span class="string">&quot;nohugemem&quot;</span>, n_segs,</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_memseg))) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot allocate memseg list\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* set up parameters for anonymous mmap */</span></span><br><span class="line">		fd = <span class="number">-1</span>;</span><br><span class="line">		flags = MAP_PRIVATE | MAP_ANONYMOUS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MEMFD_SUPPORTED</span></span><br><span class="line">		<span class="comment">/* create a memfd and store it in the segment fd table */</span></span><br><span class="line">		memfd = memfd_create(<span class="string">&quot;nohuge&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (memfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Cannot create memfd: %s\n&quot;</span>,</span><br><span class="line">					strerror(errno));</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Falling back to anonymous map\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* we got an fd - now resize it */</span></span><br><span class="line">			<span class="keyword">if</span> (ftruncate(memfd, internal_config.memory) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot resize memfd: %s\n&quot;</span>,</span><br><span class="line">						strerror(errno));</span><br><span class="line">				RTE_LOG(ERR, EAL, <span class="string">&quot;Falling back to anonymous map\n&quot;</span>);</span><br><span class="line">				close(memfd);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* creating memfd-backed file was successful.</span></span><br><span class="line"><span class="comment">				 * we want changes to memfd to be visible to</span></span><br><span class="line"><span class="comment">				 * other processes (such as vhost backend), so</span></span><br><span class="line"><span class="comment">				 * map it as shared memory.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;Using memfd for anonymous memory\n&quot;</span>);</span><br><span class="line">				fd = memfd;</span><br><span class="line">				flags = MAP_SHARED;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="comment">/* preallocate address space for the memory, so that it can be</span></span><br><span class="line"><span class="comment">		 * fit into the DMA mask.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mem_sz = internal_config.memory;</span><br><span class="line">		prealloc_addr = eal_get_virtual_area(</span><br><span class="line">				<span class="literal">NULL</span>, &amp;mem_sz, page_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (prealloc_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL,</span><br><span class="line">					<span class="string">&quot;%s: reserving memory area failed: &quot;</span></span><br><span class="line">					<span class="string">&quot;%s\n&quot;</span>,</span><br><span class="line">					__func__, strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		addr = mmap(prealloc_addr, mem_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">				flags | MAP_FIXED, fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (addr == MAP_FAILED || addr != prealloc_addr) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;%s: mmap() failed: %s\n&quot;</span>, __func__,</span><br><span class="line">					strerror(errno));</span><br><span class="line">			munmap(prealloc_addr, mem_sz);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		msl-&gt;base_va = addr;</span><br><span class="line">		msl-&gt;page_sz = page_sz;</span><br><span class="line">		msl-&gt;socket_id = <span class="number">0</span>;</span><br><span class="line">		msl-&gt;len = mem_sz;</span><br><span class="line">		msl-&gt;heap = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* we&#x27;re in single-file segments mode, so only the segment list</span></span><br><span class="line"><span class="comment">		 * fd needs to be set up.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (eal_memalloc_set_seg_list_fd(<span class="number">0</span>, fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot set up segment list fd\n&quot;</span>);</span><br><span class="line">				<span class="comment">/* not a serious error, proceed */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* populate memsegs. each memseg is one page long */</span></span><br><span class="line">		<span class="keyword">for</span> (cur_seg = <span class="number">0</span>; cur_seg &lt; n_segs; cur_seg++) &#123;</span><br><span class="line">			arr = &amp;msl-&gt;memseg_arr;</span><br><span class="line"></span><br><span class="line">			ms = rte_fbarray_get(arr, cur_seg);</span><br><span class="line">			<span class="keyword">if</span> (rte_eal_iova_mode() == RTE_IOVA_VA)</span><br><span class="line">				ms-&gt;iova = (<span class="type">uintptr_t</span>)addr;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ms-&gt;iova = RTE_BAD_IOVA;</span><br><span class="line">			ms-&gt;addr = addr;</span><br><span class="line">			ms-&gt;hugepage_sz = page_sz;</span><br><span class="line">			ms-&gt;socket_id = <span class="number">0</span>;</span><br><span class="line">			ms-&gt;len = page_sz;</span><br><span class="line"></span><br><span class="line">			rte_fbarray_set_used(arr, cur_seg);</span><br><span class="line"></span><br><span class="line">			addr = RTE_PTR_ADD(addr, (<span class="type">size_t</span>)page_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mcfg-&gt;dma_maskbits &amp;&amp;</span><br><span class="line">		    rte_mem_check_dma_mask_thread_unsafe(mcfg-&gt;dma_maskbits)) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL,</span><br><span class="line">				<span class="string">&quot;%s(): couldn&#x27;t allocate memory due to IOVA exceeding limits of current DMA mask.\n&quot;</span>,</span><br><span class="line">				__func__);</span><br><span class="line">			<span class="keyword">if</span> (rte_eal_iova_mode() == RTE_IOVA_VA &amp;&amp;</span><br><span class="line">			    rte_eal_using_phys_addrs())</span><br><span class="line">				RTE_LOG(ERR, EAL,</span><br><span class="line">					<span class="string">&quot;%s(): Please try initializing EAL with --iova-mode=pa parameter.\n&quot;</span>,</span><br><span class="line">					__func__);</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calculate total number of hugepages available. at this point we haven&#x27;t</span></span><br><span class="line"><span class="comment">	 * yet started sorting them so they all are on socket 0 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) internal_config.num_hugepage_sizes; i++) &#123;</span><br><span class="line">		<span class="comment">/* meanwhile, also initialize used_hp hugepage sizes in used_hp */</span></span><br><span class="line">		used_hp[i].hugepage_sz = internal_config.hugepage_info[i].hugepage_sz;</span><br><span class="line"></span><br><span class="line">		nr_hugepages += internal_config.hugepage_info[i].num_pages[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * allocate a memory area for hugepage table.</span></span><br><span class="line"><span class="comment">	 * this isn&#x27;t shared memory yet. due to the fact that we need some</span></span><br><span class="line"><span class="comment">	 * processing done on these pages, shared memory will be created</span></span><br><span class="line"><span class="comment">	 * at a later stage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tmp_hp = <span class="built_in">malloc</span>(nr_hugepages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line">	<span class="keyword">if</span> (tmp_hp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(tmp_hp, <span class="number">0</span>, nr_hugepages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line"></span><br><span class="line">	hp_offset = <span class="number">0</span>; <span class="comment">/* where we start the current page size entries */</span></span><br><span class="line"></span><br><span class="line">	huge_register_sigbus();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make a copy of socket_mem, needed for balanced allocation. */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_NUMA_NODES; i++)</span><br><span class="line">		memory[i] = internal_config.socket_mem[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* map all hugepages and sort them */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)internal_config.num_hugepage_sizes; i ++)&#123;</span><br><span class="line">		<span class="type">unsigned</span> pages_old, pages_new;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> *<span class="title">hpi</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * we don&#x27;t yet mark hugepages as used at this stage, so</span></span><br><span class="line"><span class="comment">		 * we just map all hugepages available to the system</span></span><br><span class="line"><span class="comment">		 * all hugepages are still located on socket 0</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		hpi = &amp;internal_config.hugepage_info[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hpi-&gt;num_pages[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* map all hugepages available */</span></span><br><span class="line">		pages_old = hpi-&gt;num_pages[<span class="number">0</span>];</span><br><span class="line">		pages_new = map_all_hugepages(&amp;tmp_hp[hp_offset], hpi, memory);</span><br><span class="line">		<span class="keyword">if</span> (pages_new &lt; pages_old) &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL,</span><br><span class="line">				<span class="string">&quot;%d not %d hugepages of size %u MB allocated\n&quot;</span>,</span><br><span class="line">				pages_new, pages_old,</span><br><span class="line">				(<span class="type">unsigned</span>)(hpi-&gt;hugepage_sz / <span class="number">0x100000</span>));</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> pages = pages_old - pages_new;</span><br><span class="line"></span><br><span class="line">			nr_hugepages -= pages;</span><br><span class="line">			hpi-&gt;num_pages[<span class="number">0</span>] = pages_new;</span><br><span class="line">			<span class="keyword">if</span> (pages_new == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rte_eal_using_phys_addrs() &amp;&amp;</span><br><span class="line">				rte_eal_iova_mode() != RTE_IOVA_VA) &#123;</span><br><span class="line">			<span class="comment">/* find physical addresses for each hugepage */</span></span><br><span class="line">			<span class="keyword">if</span> (find_physaddrs(&amp;tmp_hp[hp_offset], hpi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;Failed to find phys addr &quot;</span></span><br><span class="line">					<span class="string">&quot;for %u MB pages\n&quot;</span>,</span><br><span class="line">					(<span class="type">unsigned</span> <span class="type">int</span>)(hpi-&gt;hugepage_sz / <span class="number">0x100000</span>));</span><br><span class="line">				<span class="keyword">goto</span> fail;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* set physical addresses for each hugepage */</span></span><br><span class="line">			<span class="keyword">if</span> (set_physaddrs(&amp;tmp_hp[hp_offset], hpi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL, <span class="string">&quot;Failed to set phys addr &quot;</span></span><br><span class="line">					<span class="string">&quot;for %u MB pages\n&quot;</span>,</span><br><span class="line">					(<span class="type">unsigned</span> <span class="type">int</span>)(hpi-&gt;hugepage_sz / <span class="number">0x100000</span>));</span><br><span class="line">				<span class="keyword">goto</span> fail;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (find_numasocket(&amp;tmp_hp[hp_offset], hpi) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;Failed to find NUMA socket for %u MB pages\n&quot;</span>,</span><br><span class="line">					(<span class="type">unsigned</span>)(hpi-&gt;hugepage_sz / <span class="number">0x100000</span>));</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		qsort(&amp;tmp_hp[hp_offset], hpi-&gt;num_pages[<span class="number">0</span>],</span><br><span class="line">		      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file), cmp_physaddr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* we have processed a num of hugepages of this size, so inc offset */</span></span><br><span class="line">		hp_offset += hpi-&gt;num_pages[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	huge_recover_sigbus();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (internal_config.memory == <span class="number">0</span> &amp;&amp; internal_config.force_sockets == <span class="number">0</span>)</span><br><span class="line">		internal_config.memory = eal_get_hugepage_mem_size();</span><br><span class="line"></span><br><span class="line">	nr_hugefiles = nr_hugepages;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean out the numbers of pages */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) internal_config.num_hugepage_sizes; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RTE_MAX_NUMA_NODES; j++)</span><br><span class="line">			internal_config.hugepage_info[i].num_pages[j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get hugepages for each socket */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_hugefiles; i++) &#123;</span><br><span class="line">		<span class="type">int</span> socket = tmp_hp[i].socket_id;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find a hugepage info with right size and increment num_pages */</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> nb_hpsizes = RTE_MIN(MAX_HUGEPAGE_SIZES,</span><br><span class="line">				(<span class="type">int</span>)internal_config.num_hugepage_sizes);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nb_hpsizes; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp_hp[i].size ==</span><br><span class="line">					internal_config.hugepage_info[j].hugepage_sz) &#123;</span><br><span class="line">				internal_config.hugepage_info[j].num_pages[socket]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make a copy of socket_mem, needed for number of pages calculation */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_NUMA_NODES; i++)</span><br><span class="line">		memory[i] = internal_config.socket_mem[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calculate final number of pages */</span></span><br><span class="line">	nr_hugepages = calc_num_pages_per_socket(memory,</span><br><span class="line">			internal_config.hugepage_info, used_hp,</span><br><span class="line">			internal_config.num_hugepage_sizes);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* error if not enough memory available */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_hugepages &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reporting in! */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) internal_config.num_hugepage_sizes; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RTE_MAX_NUMA_NODES; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (used_hp[i].num_pages[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL,</span><br><span class="line">					<span class="string">&quot;Requesting %u pages of size %uMB&quot;</span></span><br><span class="line">					<span class="string">&quot; from socket %i\n&quot;</span>,</span><br><span class="line">					used_hp[i].num_pages[j],</span><br><span class="line">					(<span class="type">unsigned</span>)</span><br><span class="line">					(used_hp[i].hugepage_sz / <span class="number">0x100000</span>),</span><br><span class="line">					j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create shared memory */</span></span><br><span class="line">	hugepage = create_shared_memory(eal_hugepage_data_path(),</span><br><span class="line">			nr_hugefiles * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hugepage == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Failed to create shared memory!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(hugepage, <span class="number">0</span>, nr_hugefiles * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * unmap pages that we won&#x27;t need (looks at used_hp).</span></span><br><span class="line"><span class="comment">	 * also, sets final_va to NULL on pages that were unmapped.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unmap_unneeded_hugepages(tmp_hp, used_hp,</span><br><span class="line">			internal_config.num_hugepage_sizes) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Unmapping and locking hugepages failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * copy stuff from malloc&#x27;d hugepage* to the actual shared memory.</span></span><br><span class="line"><span class="comment">	 * this procedure only copies those hugepages that have orig_va</span></span><br><span class="line"><span class="comment">	 * not NULL. has overflow protection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_hugepages_to_shared_mem(hugepage, nr_hugefiles,</span><br><span class="line">			tmp_hp, nr_hugefiles) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Copying tables to shared memory failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RTE_ARCH_64</span></span><br><span class="line">	<span class="comment">/* for legacy 32-bit mode, we did not preallocate VA space, so do it */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.legacy_mem &amp;&amp;</span><br><span class="line">			prealloc_segments(hugepage, nr_hugefiles)) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Could not preallocate VA space for hugepages\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remap all pages we do need into memseg list VA space, so that those</span></span><br><span class="line"><span class="comment">	 * pages become first-class citizens in DPDK memory subsystem</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_needed_hugepages(hugepage, nr_hugefiles)) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Couldn&#x27;t remap hugepage files into memseg lists\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free the hugepage backing files */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.hugepage_unlink &amp;&amp;</span><br><span class="line">		unlink_hugepage_files(tmp_hp, internal_config.num_hugepage_sizes) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Unlinking hugepage files failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free the temporary hugepage table */</span></span><br><span class="line">	<span class="built_in">free</span>(tmp_hp);</span><br><span class="line">	tmp_hp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	munmap(hugepage, nr_hugefiles * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line">	hugepage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re not going to allocate more pages, so release VA space for</span></span><br><span class="line"><span class="comment">	 * unused memseg lists</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_MEMSEG_LISTS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">msl</span> =</span> &amp;mcfg-&gt;memsegs[i];</span><br><span class="line">		<span class="type">size_t</span> mem_sz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* skip inactive lists */</span></span><br><span class="line">		<span class="keyword">if</span> (msl-&gt;base_va == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* skip lists where there is at least one page allocated */</span></span><br><span class="line">		<span class="keyword">if</span> (msl-&gt;memseg_arr.count &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* this is an unused list, deallocate it */</span></span><br><span class="line">		mem_sz = msl-&gt;len;</span><br><span class="line">		munmap(msl-&gt;base_va, mem_sz);</span><br><span class="line">		msl-&gt;base_va = <span class="literal">NULL</span>;</span><br><span class="line">		msl-&gt;heap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* destroy backing fbarray */</span></span><br><span class="line">		rte_fbarray_destroy(&amp;msl-&gt;memseg_arr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mcfg-&gt;dma_maskbits &amp;&amp;</span><br><span class="line">	    rte_mem_check_dma_mask_thread_unsafe(mcfg-&gt;dma_maskbits)) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL,</span><br><span class="line">			<span class="string">&quot;%s(): couldn&#x27;t allocate memory due to IOVA exceeding limits of current DMA mask.\n&quot;</span>,</span><br><span class="line">			__func__);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	huge_recover_sigbus();</span><br><span class="line">	<span class="built_in">free</span>(tmp_hp);</span><br><span class="line">	<span class="keyword">if</span> (hugepage != <span class="literal">NULL</span>)</span><br><span class="line">		munmap(hugepage, nr_hugefiles * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hugepage_file));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态模式下，会调用 eal_legacy_hugepage_init（）函数，相反则调用 eal_hugepage_init()。前者根据配置 internal_config-&gt;hugepage_info 来将相关 SOCKET_ID，PageSZ 对 rte_memseg_list 中的 rte_memseg 进行映射并排序。然后通过巨页内存文件的重映射来保证虚拟和物理地址二者同时的连续性。保存相关信息及描述符到巨页数据文件。并采用 read-ahead 做为技术保证。这样就可以保障相关数据操作的效率。<br>而后者则通过实际的需求来计算在不同的 Socket 上的分配，通过算法对内存 Segment 进行分配，它采用 preallocate 来保证整体的性能需求。<br>总之，各有各的好处，各有各的香。</p>
<h1 id="DPDK-中的大页内存管理"><a href="#DPDK-中的大页内存管理" class="headerlink" title="DPDK 中的大页内存管理"></a>DPDK 中的大页内存管理</h1><p>大页内存在前面已经分析过很多，但大多是在形式上进行说明。本篇主要对大页内存的特点和提高性能的原理以及优化的过程等进行分析说明。说大页内存，就得提到 X86 系列中对虚拟内存的管理：段和页。这里仅简单说明一下，如果有想更清楚的明白这两个定义的可以去看 OS 原理的相关已知或者汇编相关书籍。<br>段式管理：其主要的方式就是把程序按内容或者函数相关分成若干段，并给每个段命名。一个用户进程对应一个二维线性的虚拟内存空间（也就是段通过 base+offer 来查找）。可通过段表来查找。<br>页式管理：其主要的方式是把虚拟空间划分为若干相等子空间即页。然后每个页的虚拟地址与物理内存地址建立映射的页表。它需要有相应的硬件转换机构来进行地址变换。<br>段页式管理：上述二者的结合，但增加了复杂性。<br>在现在普遍使用的 x86-64 位操作系统上，除一些比较特殊的情况下，基本上已经不再使用段。换句话说主要使用页。而使用页时，一个经常遇到的问题是，如果发生缺页中断，会导致进程的延迟，进而导致整个性能的显著降低，在某些情况下，可能导致无法想到的后果。<br>缺页是 TLB（Translation Lookaside Buffer）快表没有命中的结果。可以简单理解成页的缓冲区。<br>引起页缺失有两大类可能，一种是软缺失，即内存中页存在，但没有向 MMU 注册；另外一种是硬缺失，即页没有加载到内存中（已经交换到硬盘）。软缺失的性能损失稍小，但硬缺则非常大。<br>其实这就是在前面不断提到的计算机资源比较少导致的，理论上讲内存越大，发生缺页的可能性就越小。也正因为资源紧张，OS 一般都设计成虚拟地址可共享，或者不常使用的页可以交换出去等等。<br>通过上面的分析可以知道，缺页的基本原理其实是缺少进程运行需要的内容（页较小），那直白想到，把页加大不就行了，甚至干脆就分一个页（回到早期的内存管理）。但这样又会有一个问题，如果内存不够怎么办（丧失了灵活性，多进程的处理也退步回到了早期）？<br>所以大家要明白，大页内存是有其应用场景的。也就是说对内存操作非常敏感的业务（1、内存使用量大 - 十几 G 以上；2、频繁且随机 - 局部性差；3、内存访问导致瓶颈）。否则就会大量浪费内存，反而导致整体性能的下降。<br>在 Linux 中，本身就带有一个大页内存的库 libhugetlbfs，可以通过配置使用。另外在一些大型的互联网公司，往往为了自身的实际应用场景或多或少的对一些大页内存进行处理形成自己的库，网上有原来字节内部人员的相关文章，有兴趣可以找一找。<br>下来重点分析一下 DPDK 中对大页内存的处理。</p>
<p>这里需要说明的是，在 DPDK 中对大页内存采用的是段页式管理，但有一个前提，这些大页必须是属于同一 CPU 且连续。要想使用自己的内存管理系统，就须要把原来系统自带的相关一套（如 malloc,free 等）系统调用替换。在 DPDK 中，其使用的是 rte_malloc 和 rte_free。<br>rte_malloc 实际上从 memzone 中得到内存，而 memzone 又从 rte_memseg（段内存）中获取得来。而段内存最终维护着一系列的大页内存。<br>大页内存的整体流程：</p>
<ul>
<li>1、初始化并进行共享配置映射<br>  这个在前面分析过，通过读取配置文件从根目录（&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;hugepages）加载，然后主进程申请共享内存，从进程映射。  </li>
<li>2、大页内存的映射<br>  主进程的大页映射其实就是在 &#x2F; mnt&#x2F;huge 目录下进行配置，然后将大页内存映射到刚刚建立好的共享内存中去。并维护页表记录大页内存的虚拟地址和物理地址的关系。大页内存要进行两次映射，两次映射的目的第一次是为了完善相关大页内存的信息，然后进行各种转换；第二次的目的是为了保持虚拟内存的连续性，并最终提供映射到共享内存。连续性是段页管理的前提。<br>在本项工作完成后，就可以提供抽象层的内存管理了（如刚刚提到的 rte_malloc 等）。  </li>
<li>3、段内存的管理<br>  段页式管理的优点很明显，就是提高效率，但缺点是复杂性增强。DPDK 之所以使用这种方式，就是为了提高效率。  </li>
<li>4、memzone 的实现<br>  在段里存储着可以使用的内存，但是在 memzone 中是对段内存所指的大页内存申请内存大小的一种管理。它相当于对内存池中对使用中内存的一种描述管理的链表，也就是每当向段申请一次内存就会生成一个 rte_memzone 对象。  </li>
<li>5、DPDK 内存的管理<br>  这就回到了本节开头的话，上层应用开始调用 rte_malloc, rte_free 来实现对内存的控制。这里需要注意的是，由 NUMA 的存在，DPDK 必须保证对每个 CPU 都进行堆内存的管理。而每个堆中又有一系列的空闲链表。这些空闲链表按被指向申请内存的大小来划分，更合理的使用内存，减少浪费，提高使用效率。</li>
</ul>
<p>至于链表管理内存分配这块，学过内存池的应该非常清楚，方法有很多。具体到 DPDK 中，取其中一条链表来说明的话就是查找空闲头，申请内存，通过 malloc_elem 数据结构将其划分成两部分，每部分都有一个 malloc_elem 的头（类似于一个双向队列，free_head 的 malloc_elem 的头不动，而尾的 malloc_elem 头不断的切割形成链表），然后分配使用。再次分配后，先查询此空闲链表头，分析是否够用，够用则在链表内存中分配，继续从已经跳转的尾部头向前跳跃。走到不够后，再申请内存，通过 free_head 形成链表，如此反复。<br>同样，释放时反向操作即可，需要注意的是，释放的内存 malloc_elem 的头指针仍然指向前一个位置，保证访问的连续。</p>
<p>1、段内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eal/eal_memory.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span></span><br><span class="line"><span class="title function_">map_all_hugepages</span><span class="params">(<span class="keyword">struct</span> hugepage_file *hugepg_tbl, <span class="keyword">struct</span> hugepage_info *hpi,</span></span><br><span class="line"><span class="params">		  <span class="type">uint64_t</span> *essential_memory __rte_unused)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hpi-&gt;num_pages[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> *<span class="title">hf</span> =</span> &amp;hugepg_tbl[i];</span><br><span class="line">  ...</span><br><span class="line">virtaddr = mmap(<span class="literal">NULL</span>, hugepage_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">    MAP_SHARED | MAP_POPULATE, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (virtaddr == MAP_FAILED) &#123;</span><br><span class="line">  RTE_LOG(DEBUG, EAL, <span class="string">&quot;%s(): mmap failed: %s\n&quot;</span>, __func__,</span><br><span class="line">      strerror(errno));</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hf-&gt;orig_va = virtaddr;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __rte_unused</span><br><span class="line"><span class="title function_">prealloc_segments</span><span class="params">(<span class="keyword">struct</span> hugepage_file *hugepages, <span class="type">int</span> n_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span> =</span> rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line">	<span class="type">int</span> cur_page, seg_start_page, end_seg, new_memseg;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hpi_idx, socket, i;</span><br><span class="line">	<span class="type">int</span> n_contig_segs, n_segs;</span><br><span class="line">	<span class="type">int</span> msl_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* before we preallocate segments, we need to free up our VA space.</span></span><br><span class="line"><span class="comment">	 * we&#x27;re not removing files, and we already have information about</span></span><br><span class="line"><span class="comment">	 * PA-contiguousness, so it is safe to unmap everything.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (cur_page = <span class="number">0</span>; cur_page &lt; n_pages; cur_page++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> *<span class="title">hpi</span> =</span> &amp;hugepages[cur_page];</span><br><span class="line">		munmap(hpi-&gt;orig_va, hpi-&gt;size);</span><br><span class="line">		hpi-&gt;orig_va = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we cannot know how many page sizes and sockets we have discovered, so</span></span><br><span class="line"><span class="comment">	 * loop over all of them</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (hpi_idx = <span class="number">0</span>; hpi_idx &lt; internal_config.num_hugepage_sizes;</span><br><span class="line">			hpi_idx++) &#123;</span><br><span class="line">		<span class="type">uint64_t</span> page_sz =</span><br><span class="line">			internal_config.hugepage_info[hpi_idx].hugepage_sz;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rte_socket_count(); i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">msl</span>;</span></span><br><span class="line"></span><br><span class="line">			socket = rte_socket_id_by_idx(i);</span><br><span class="line">			n_contig_segs = <span class="number">0</span>;</span><br><span class="line">			n_segs = <span class="number">0</span>;</span><br><span class="line">			seg_start_page = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (cur_page = <span class="number">0</span>; cur_page &lt; n_pages; cur_page++) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> *<span class="title">prev</span>, *<span class="title">cur</span>;</span></span><br><span class="line">				<span class="type">int</span> prev_seg_start_page = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">				cur = &amp;hugepages[cur_page];</span><br><span class="line">				prev = cur_page == <span class="number">0</span> ? <span class="literal">NULL</span> :</span><br><span class="line">						&amp;hugepages[cur_page - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">				new_memseg = <span class="number">0</span>;</span><br><span class="line">				end_seg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (cur-&gt;size == <span class="number">0</span>)</span><br><span class="line">					end_seg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;socket_id != (<span class="type">int</span>) socket)</span><br><span class="line">					end_seg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;size != page_sz)</span><br><span class="line">					end_seg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (cur_page == <span class="number">0</span>)</span><br><span class="line">					new_memseg = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ARCH_PPC_64</span></span><br><span class="line">				<span class="comment">/* On PPC64 architecture, the mmap always start</span></span><br><span class="line"><span class="comment">				 * from higher address to lower address. Here,</span></span><br><span class="line"><span class="comment">				 * physical addresses are in descending order.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((prev-&gt;physaddr - cur-&gt;physaddr) !=</span><br><span class="line">						cur-&gt;size)</span><br><span class="line">					new_memseg = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((cur-&gt;physaddr - prev-&gt;physaddr) !=</span><br><span class="line">						cur-&gt;size)</span><br><span class="line">					new_memseg = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				<span class="keyword">if</span> (new_memseg) &#123;</span><br><span class="line">					<span class="comment">/* if we&#x27;re already inside a segment,</span></span><br><span class="line"><span class="comment">					 * new segment means end of current one</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="keyword">if</span> (seg_start_page != <span class="number">-1</span>) &#123;</span><br><span class="line">						end_seg = <span class="number">1</span>;</span><br><span class="line">						prev_seg_start_page =</span><br><span class="line">								seg_start_page;</span><br><span class="line">					&#125;</span><br><span class="line">					seg_start_page = cur_page;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (end_seg) &#123;</span><br><span class="line">					<span class="keyword">if</span> (prev_seg_start_page != <span class="number">-1</span>) &#123;</span><br><span class="line">						<span class="comment">/* we&#x27;ve found a new segment */</span></span><br><span class="line">						n_contig_segs++;</span><br><span class="line">						n_segs += cur_page -</span><br><span class="line">							prev_seg_start_page;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg_start_page != <span class="number">-1</span>) &#123;</span><br><span class="line">						<span class="comment">/* we didn&#x27;t find new segment,</span></span><br><span class="line"><span class="comment">						 * but did end current one</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						n_contig_segs++;</span><br><span class="line">						n_segs += cur_page -</span><br><span class="line">								seg_start_page;</span><br><span class="line">						seg_start_page = <span class="number">-1</span>;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* we&#x27;re skipping this page */</span></span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* segment continues */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* check if we missed last segment */</span></span><br><span class="line">			<span class="keyword">if</span> (seg_start_page != <span class="number">-1</span>) &#123;</span><br><span class="line">				n_contig_segs++;</span><br><span class="line">				n_segs += cur_page - seg_start_page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* if no segments were found, do not preallocate */</span></span><br><span class="line">			<span class="keyword">if</span> (n_segs == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* we now have total number of pages that we will</span></span><br><span class="line"><span class="comment">			 * allocate for this segment list. add separator pages</span></span><br><span class="line"><span class="comment">			 * to the total count, and preallocate VA space.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			n_segs += n_contig_segs - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* now, preallocate VA space for these segments */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* first, find suitable memseg list for this */</span></span><br><span class="line">			<span class="keyword">for</span> (msl_idx = <span class="number">0</span>; msl_idx &lt; RTE_MAX_MEMSEG_LISTS;</span><br><span class="line">					msl_idx++) &#123;</span><br><span class="line">				msl = &amp;mcfg-&gt;memsegs[msl_idx];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (msl-&gt;base_va != <span class="literal">NULL</span>)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (msl_idx == RTE_MAX_MEMSEG_LISTS) &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL, <span class="string">&quot;Not enough space in memseg lists, please increase %s\n&quot;</span>,</span><br><span class="line">					RTE_STR(CONFIG_RTE_MAX_MEMSEG_LISTS));</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* now, allocate fbarray itself */</span></span><br><span class="line">			<span class="keyword">if</span> (alloc_memseg_list(msl, page_sz, n_segs, socket,</span><br><span class="line">						msl_idx) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* finally, allocate VA space */</span></span><br><span class="line">			<span class="keyword">if</span> (alloc_va_space(msl) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、memzone 的相关代码（初始化、申请等）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_memzone_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get pointer to global configuration */</span></span><br><span class="line">	mcfg = rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_lock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY &amp;&amp;</span><br><span class="line">			rte_fbarray_init(&amp;mcfg-&gt;memzones, <span class="string">&quot;memzone&quot;</span>,</span><br><span class="line">			RTE_MAX_MEMZONE, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_memzone))) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot allocate memzone list\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_SECONDARY &amp;&amp;</span><br><span class="line">			rte_fbarray_attach(&amp;mcfg-&gt;memzones)) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot attach to memzone list\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_unlock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fbarray_init</span><span class="params">(<span class="keyword">struct</span> rte_fbarray *arr, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> elt_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ma-&gt;addr = data;</span><br><span class="line">	ma-&gt;len = mmap_len;</span><br><span class="line">	ma-&gt;fd = fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do not close fd - keep it until detach/destroy */</span></span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;mem_area_tailq, ma, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize the data */</span></span><br><span class="line">	<span class="built_in">memset</span>(data, <span class="number">0</span>, mmap_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* populate data structure */</span></span><br><span class="line">	strlcpy(arr-&gt;name, name, <span class="keyword">sizeof</span>(arr-&gt;name));</span><br><span class="line">	arr-&gt;data = data;</span><br><span class="line">	arr-&gt;len = len;</span><br><span class="line">	arr-&gt;elt_sz = elt_sz;</span><br><span class="line">	arr-&gt;count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	msk = get_used_mask(data, elt_sz, len);</span><br><span class="line">	msk-&gt;n_masks = MASK_LEN_TO_IDX(RTE_ALIGN_CEIL(len, MASK_ALIGN));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> rte_memzone *</span><br><span class="line"><span class="title function_">rte_memzone_reserve_thread_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> len, <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">unsigned</span> <span class="type">int</span> bound)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get pointer to global configuration */</span></span><br><span class="line">	mcfg = rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_lock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	mz = memzone_reserve_aligned_thread_unsafe(</span><br><span class="line">		name, len, socket_id, flags, align, bound);</span><br><span class="line"></span><br><span class="line">	rte_rwlock_write_unlock(&amp;mcfg-&gt;mlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> rte_memzone *</span><br><span class="line"><span class="title function_">memzone_reserve_aligned_thread_unsafe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> socket_id, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> bound)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_fbarray</span> *<span class="title">arr</span>;</span></span><br><span class="line">	<span class="type">void</span> *mz_addr;</span><br><span class="line">	<span class="type">size_t</span> requested_len;</span><br><span class="line">	<span class="type">int</span> mz_idx;</span><br><span class="line">	<span class="type">bool</span> contig;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_elem</span> *<span class="title">elem</span> =</span> malloc_elem_from_data(mz_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill the zone in config */</span></span><br><span class="line">	mz_idx = rte_fbarray_find_next_free(arr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mz_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		mz = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rte_fbarray_set_used(arr, mz_idx);</span><br><span class="line">		mz = rte_fbarray_get(arr, mz_idx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): Cannot find free memzone\n&quot;</span>, __func__);</span><br><span class="line">		malloc_heap_free(elem);</span><br><span class="line">		rte_errno = ENOSPC;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strlcpy(mz-&gt;name, name, <span class="keyword">sizeof</span>(mz-&gt;name));</span><br><span class="line">	mz-&gt;iova = rte_malloc_virt2iova(mz_addr);</span><br><span class="line">	mz-&gt;addr = mz_addr;</span><br><span class="line">	mz-&gt;len = requested_len == <span class="number">0</span> ?</span><br><span class="line">			elem-&gt;size - elem-&gt;pad - MALLOC_ELEM_OVERHEAD :</span><br><span class="line">			requested_len;</span><br><span class="line">	mz-&gt;hugepage_sz = elem-&gt;msl-&gt;page_sz;</span><br><span class="line">	mz-&gt;socket_id = elem-&gt;msl-&gt;socket_id;</span><br><span class="line">	mz-&gt;flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、rte_malloc 和 rte_free</p>
<p>先看一下分配代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate memory on specified heap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">rte_malloc_socket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> socket_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* return NULL if size is 0 or alignment is not power-of-2 */</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span> || (align &amp;&amp; !rte_is_power_of_2(align)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if there are no hugepages and if we are not allocating from an</span></span><br><span class="line"><span class="comment">	 * external heap, use memory from any socket available. checking for</span></span><br><span class="line"><span class="comment">	 * socket being external may return -1 in case of invalid socket, but</span></span><br><span class="line"><span class="comment">	 * that&#x27;s OK - if there are no hugepages, it doesn&#x27;t matter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_malloc_heap_socket_is_external(socket_arg) != <span class="number">1</span> &amp;&amp;</span><br><span class="line">				!rte_eal_has_hugepages())</span><br><span class="line">		socket_arg = SOCKET_ID_ANY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> malloc_heap_alloc(type, size, socket_arg, <span class="number">0</span>,</span><br><span class="line">			align == <span class="number">0</span> ? <span class="number">1</span> : align, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate memory on default heap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">rte_malloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">size_t</span> size, <span class="type">unsigned</span> align)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_malloc_socket(type, size, align, SOCKET_ID_ANY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* this will try lower page sizes first */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">malloc_heap_alloc_on_heap_id</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> heap_id, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> bound, <span class="type">bool</span> contig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span> =</span> rte_eal_get_configuration()-&gt;mem_config;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_heap</span> *<span class="title">heap</span> =</span> &amp;mcfg-&gt;malloc_heaps[heap_id];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size_flags = flags &amp; ~RTE_MEMZONE_SIZE_HINT_ONLY;</span><br><span class="line">	<span class="type">int</span> socket_id;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_lock(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">	align = align == <span class="number">0</span> ? <span class="number">1</span> : align;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for legacy mode, try once and with all flags */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.legacy_mem) &#123;</span><br><span class="line">		ret = heap_alloc(heap, type, size, flags, align, bound, contig);</span><br><span class="line">		<span class="keyword">goto</span> alloc_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * we do not pass the size hint here, because even if allocation fails,</span></span><br><span class="line"><span class="comment">	 * we may still be able to allocate memory from appropriate page sizes,</span></span><br><span class="line"><span class="comment">	 * we just need to request more memory first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	socket_id = rte_socket_id_by_idx(heap_id);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if socket ID is negative, we cannot find a socket ID for this heap -</span></span><br><span class="line"><span class="comment">	 * which means it&#x27;s an external heap. those can have unexpected page</span></span><br><span class="line"><span class="comment">	 * sizes, so if the user asked to allocate from there - assume user</span></span><br><span class="line"><span class="comment">	 * knows what they&#x27;re doing, and allow allocating from there with any</span></span><br><span class="line"><span class="comment">	 * page size flags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (socket_id &lt; <span class="number">0</span>)</span><br><span class="line">		size_flags |= RTE_MEMZONE_SIZE_HINT_ONLY;</span><br><span class="line"></span><br><span class="line">	ret = heap_alloc(heap, type, size, size_flags, align, bound, contig);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> alloc_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if socket ID is invalid, this is an external heap */</span></span><br><span class="line">	<span class="keyword">if</span> (socket_id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> alloc_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_more_mem_on_socket(heap, size, socket_id, flags, align,</span><br><span class="line">			bound, contig)) &#123;</span><br><span class="line">		ret = heap_alloc(heap, type, size, flags, align, bound, contig);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* this should have succeeded */</span></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;Error allocating from heap\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">alloc_unlock:</span><br><span class="line">	rte_spinlock_unlock(&amp;(heap-&gt;lock));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">malloc_heap_alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">size_t</span> size, <span class="type">int</span> socket_arg,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">size_t</span> align, <span class="type">size_t</span> bound, <span class="type">bool</span> contig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> socket, heap_id, i;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* return NULL if size is 0 or alignment is not power-of-2 */</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span> || (align &amp;&amp; !rte_is_power_of_2(align)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_eal_has_hugepages() &amp;&amp; socket_arg &lt; RTE_MAX_NUMA_NODES)</span><br><span class="line">		socket_arg = SOCKET_ID_ANY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (socket_arg == SOCKET_ID_ANY)</span><br><span class="line">		socket = malloc_get_numa_socket();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		socket = socket_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* turn socket ID into heap ID */</span></span><br><span class="line">	heap_id = malloc_socket_to_heap_id(socket);</span><br><span class="line">	<span class="comment">/* if heap id is negative, socket ID was invalid */</span></span><br><span class="line">	<span class="keyword">if</span> (heap_id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ret = malloc_heap_alloc_on_heap_id(type, size, heap_id, flags, align,</span><br><span class="line">			bound, contig);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="literal">NULL</span> || socket_arg != SOCKET_ID_ANY)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try other heaps. we are only iterating through native DPDK sockets,</span></span><br><span class="line"><span class="comment">	 * so external heaps won&#x27;t be included.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) rte_socket_count(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == heap_id)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		ret = malloc_heap_alloc_on_heap_id(type, size, i, flags, align,</span><br><span class="line">				bound, contig);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">heap_alloc</span><span class="params">(<span class="keyword">struct</span> malloc_heap *heap, <span class="type">const</span> <span class="type">char</span> *type __rte_unused, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">size_t</span> align, <span class="type">size_t</span> bound, <span class="type">bool</span> contig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">	size = RTE_CACHE_LINE_ROUNDUP(size);</span><br><span class="line">	align = RTE_CACHE_LINE_ROUNDUP(align);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* roundup might cause an overflow */</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	elem = find_suitable_element(heap, size, flags, align, bound, contig);</span><br><span class="line">	<span class="keyword">if</span> (elem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		elem = malloc_elem_alloc(elem, size, align, bound, contig);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* increase heap&#x27;s count of allocated elements */</span></span><br><span class="line">		heap-&gt;alloc_count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> elem == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : (<span class="type">void</span> *)(&amp;elem[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> malloc_elem *</span><br><span class="line"><span class="title function_">malloc_elem_alloc</span><span class="params">(<span class="keyword">struct</span> malloc_elem *elem, <span class="type">size_t</span> size, <span class="type">unsigned</span> align,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> bound, <span class="type">bool</span> contig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_elem</span> *<span class="title">new_elem</span> =</span> elem_start_pt(elem, size, align, bound,</span><br><span class="line">			contig);</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> old_elem_size = (<span class="type">uintptr_t</span>)new_elem - (<span class="type">uintptr_t</span>)elem;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> trailer_size = elem-&gt;size - old_elem_size - size -</span><br><span class="line">		MALLOC_ELEM_OVERHEAD;</span><br><span class="line"></span><br><span class="line">	malloc_elem_free_list_remove(elem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (trailer_size &gt; MALLOC_ELEM_OVERHEAD + MIN_DATA_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* split it, too much free space after elem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">malloc_elem</span> *<span class="title">new_free_elem</span> =</span></span><br><span class="line">				RTE_PTR_ADD(new_elem, size + MALLOC_ELEM_OVERHEAD);</span><br><span class="line"></span><br><span class="line">		split_elem(elem, new_free_elem);</span><br><span class="line">		malloc_elem_free_list_insert(new_free_elem);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (elem == elem-&gt;heap-&gt;last)</span><br><span class="line">			elem-&gt;heap-&gt;last = new_free_elem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_elem_size &lt; MALLOC_ELEM_OVERHEAD + MIN_DATA_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* don&#x27;t split it, pad the element instead */</span></span><br><span class="line">		elem-&gt;state = ELEM_BUSY;</span><br><span class="line">		elem-&gt;pad = old_elem_size;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* put a dummy header in padding, to point to real element header */</span></span><br><span class="line">		<span class="keyword">if</span> (elem-&gt;pad &gt; <span class="number">0</span>) &#123; <span class="comment">/* pad will be at least 64-bytes, as everything</span></span><br><span class="line"><span class="comment">		                     * is cache-line aligned */</span></span><br><span class="line">			new_elem-&gt;pad = elem-&gt;pad;</span><br><span class="line">			new_elem-&gt;state = ELEM_PAD;</span><br><span class="line">			new_elem-&gt;size = elem-&gt;size - elem-&gt;pad;</span><br><span class="line">			set_header(new_elem);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> new_elem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we are going to split the element in two. The original element</span></span><br><span class="line"><span class="comment">	 * remains free, and the new element is the one allocated.</span></span><br><span class="line"><span class="comment">	 * Re-insert original element, in case its new size makes it</span></span><br><span class="line"><span class="comment">	 * belong on a different list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	split_elem(elem, new_elem);</span><br><span class="line">	new_elem-&gt;state = ELEM_BUSY;</span><br><span class="line">	malloc_elem_free_list_insert(elem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终回到了链表队列的操作上。</p>
<p>看一下释放的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the memory space back to heap */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_free</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (malloc_heap_free(malloc_elem_from_data(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Error: Invalid memory\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">malloc_heap_free</span><span class="params">(<span class="keyword">struct</span> malloc_elem *elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line">	<span class="type">void</span> *start, *aligned_start, *end, *aligned_end;</span><br><span class="line">	<span class="type">size_t</span> len, aligned_len, page_sz;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg_list</span> *<span class="title">msl</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, n_segs, before_space, after_space;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!malloc_elem_cookies_ok(elem) || elem-&gt;state != ELEM_BUSY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* elem may be merged with previous element, so keep heap address */</span></span><br><span class="line">	heap = elem-&gt;heap;</span><br><span class="line">	msl = elem-&gt;msl;</span><br><span class="line">	page_sz = (<span class="type">size_t</span>)msl-&gt;page_sz;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_lock(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mark element as free */</span></span><br><span class="line">	elem-&gt;state = ELEM_FREE;</span><br><span class="line"></span><br><span class="line">	elem = malloc_elem_free(elem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* anything after this is a bonus */</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ...of which we can&#x27;t avail if we are in legacy mode, or if this is an</span></span><br><span class="line"><span class="comment">	 * externally allocated segment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.legacy_mem || (msl-&gt;external &gt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check if we can free any memory back to the system */</span></span><br><span class="line">	<span class="keyword">if</span> (elem-&gt;size &lt; page_sz)</span><br><span class="line">		<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if user requested to match allocations, the sizes must match - if not,</span></span><br><span class="line"><span class="comment">	 * we will defer freeing these hugepages until the entire original allocation</span></span><br><span class="line"><span class="comment">	 * can be freed</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (internal_config.match_allocations &amp;&amp; elem-&gt;size != elem-&gt;orig_size)</span><br><span class="line">		<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* probably, but let&#x27;s make sure, as we may not be using up full page */</span></span><br><span class="line">	start = elem;</span><br><span class="line">	len = elem-&gt;size;</span><br><span class="line">	aligned_start = RTE_PTR_ALIGN_CEIL(start, page_sz);</span><br><span class="line">	end = RTE_PTR_ADD(elem, len);</span><br><span class="line">	aligned_end = RTE_PTR_ALIGN_FLOOR(end, page_sz);</span><br><span class="line"></span><br><span class="line">	aligned_len = RTE_PTR_DIFF(aligned_end, aligned_start);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* can&#x27;t free anything */</span></span><br><span class="line">	<span class="keyword">if</span> (aligned_len &lt; page_sz)</span><br><span class="line">		<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we can free something. however, some of these pages may be marked as</span></span><br><span class="line"><span class="comment">	 * unfreeable, so also check that as well</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	n_segs = aligned_len / page_sz;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_segs; i++) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memseg</span> *<span class="title">tmp</span> =</span></span><br><span class="line">				rte_mem_virt2memseg(aligned_start, msl);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;flags &amp; RTE_MEMSEG_FLAG_DO_NOT_FREE) &#123;</span><br><span class="line">			<span class="comment">/* this is an unfreeable segment, so move start */</span></span><br><span class="line">			aligned_start = RTE_PTR_ADD(tmp-&gt;addr, tmp-&gt;len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* recalculate length and number of segments */</span></span><br><span class="line">	aligned_len = RTE_PTR_DIFF(aligned_end, aligned_start);</span><br><span class="line">	n_segs = aligned_len / page_sz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check if we can still free some pages */</span></span><br><span class="line">	<span class="keyword">if</span> (n_segs == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re not done yet. We also have to check if by freeing space we will</span></span><br><span class="line"><span class="comment">	 * be leaving free elements that are too small to store new elements.</span></span><br><span class="line"><span class="comment">	 * Check if we have enough space in the beginning and at the end, or if</span></span><br><span class="line"><span class="comment">	 * start/end are exactly page aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	before_space = RTE_PTR_DIFF(aligned_start, elem);</span><br><span class="line">	after_space = RTE_PTR_DIFF(end, aligned_end);</span><br><span class="line">	<span class="keyword">if</span> (before_space != <span class="number">0</span> &amp;&amp;</span><br><span class="line">			before_space &lt; MALLOC_ELEM_OVERHEAD + MIN_DATA_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* There is not enough space before start, but we may be able to</span></span><br><span class="line"><span class="comment">		 * move the start forward by one page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (n_segs == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* move start */</span></span><br><span class="line">		aligned_start = RTE_PTR_ADD(aligned_start, page_sz);</span><br><span class="line">		aligned_len -= page_sz;</span><br><span class="line">		n_segs--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (after_space != <span class="number">0</span> &amp;&amp; after_space &lt;</span><br><span class="line">			MALLOC_ELEM_OVERHEAD + MIN_DATA_SIZE) &#123;</span><br><span class="line">		<span class="comment">/* There is not enough space after end, but we may be able to</span></span><br><span class="line"><span class="comment">		 * move the end backwards by one page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (n_segs == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> free_unlock;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* move end */</span></span><br><span class="line">		aligned_end = RTE_PTR_SUB(aligned_end, page_sz);</span><br><span class="line">		aligned_len -= page_sz;</span><br><span class="line">		n_segs--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now we can finally free us some pages */</span></span><br><span class="line"></span><br><span class="line">	rte_mcfg_mem_write_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * we allow secondary processes to clear the heap of this allocated</span></span><br><span class="line"><span class="comment">	 * memory because it is safe to do so, as even if notifications about</span></span><br><span class="line"><span class="comment">	 * unmapped pages don&#x27;t make it to other processes, heap is shared</span></span><br><span class="line"><span class="comment">	 * across all processes, and will become empty of this memory anyway,</span></span><br><span class="line"><span class="comment">	 * and nothing can allocate it back unless primary process will be able</span></span><br><span class="line"><span class="comment">	 * to deliver allocation message to every single running process.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	malloc_elem_free_list_remove(elem);</span><br><span class="line"></span><br><span class="line">	malloc_elem_hide_region(elem, (<span class="type">void</span> *) aligned_start, aligned_len);</span><br><span class="line"></span><br><span class="line">	heap-&gt;total_size -= aligned_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY) &#123;</span><br><span class="line">		<span class="comment">/* notify user about changes in memory map */</span></span><br><span class="line">		eal_memalloc_mem_event_notify(RTE_MEM_EVENT_FREE,</span><br><span class="line">				aligned_start, aligned_len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* don&#x27;t care if any of this fails */</span></span><br><span class="line">		malloc_heap_free_pages(aligned_start, aligned_len);</span><br><span class="line"></span><br><span class="line">		request_sync();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> malloc_mp_req req;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">		req.t = REQ_TYPE_FREE;</span><br><span class="line">		req.free_req.addr = aligned_start;</span><br><span class="line">		req.free_req.len = aligned_len;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * we request primary to deallocate pages, but we don&#x27;t do it</span></span><br><span class="line"><span class="comment">		 * in this thread. instead, we notify primary that we would like</span></span><br><span class="line"><span class="comment">		 * to deallocate pages, and this process will receive another</span></span><br><span class="line"><span class="comment">		 * request (in parallel) that will do it for us on another</span></span><br><span class="line"><span class="comment">		 * thread.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * we also don&#x27;t really care if this succeeds - the data is</span></span><br><span class="line"><span class="comment">		 * already removed from the heap, so it is, for all intents and</span></span><br><span class="line"><span class="comment">		 * purposes, hidden from the rest of DPDK even if some other</span></span><br><span class="line"><span class="comment">		 * process (including this one) may have these pages mapped.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * notifications about deallocated memory happen during sync.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		request_to_primary(&amp;req);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RTE_LOG(DEBUG, EAL, <span class="string">&quot;Heap on socket %d was shrunk by %zdMB\n&quot;</span>,</span><br><span class="line">		msl-&gt;socket_id, aligned_len &gt;&gt; <span class="number">20ULL</span>);</span><br><span class="line"></span><br><span class="line">	rte_mcfg_mem_write_unlock();</span><br><span class="line">free_unlock:</span><br><span class="line">	rte_spinlock_unlock(&amp;(heap-&gt;lock));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也要回到链表的操作上了。</p>
<h1 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h1><p>环形队列是数据结构里一个常用的数据结构。一般来说，开发者对其基本都清楚，即使不清楚的翻翻书也就明白了。这里重点不再于讲环形队列的基本实现，那个资料太多了，这里也不再狗尾续貂。<br>环形队列在实际应用中最常用的方法是一个数组（或者链表），把尾和头在某种条件下连接起来。可以用取余的方式，也可以用指针的方式。但一般都会有一个置空位，防止 front 和 rear 指针的相遇（目的是为了明确的判断全空载和满载的不同）。这样，当指针 read+1 &#x3D;&#x3D; front 时，环形队列就是满的。因此，环形队列的容量是固定的。<br>也就是说，环形队列是逻辑上的环形，不是一个真正的环形，计算机的内存都是平坦的，怎么可能拐个弯儿？<br>但在实际应用中还有另外一种情况，就是做为一种数据缓冲区时，对数据的位置不敏感，数据被定时刷新时，就可以不留置空区。直接 front &#x3D;&#x3D; rear++%N, 这样做的好处是，处理会更简单方便。每次给数据只要从下一个序号开始到本序号截止，即为缓冲区内的全部数据。</p>
<p>在 DPDK 中的环形缓冲队列是什么样的呢？DPDK 的环形队列是一个无锁的环形队列，它借鉴了 Linux 内核中的 kfifo 无锁队列，听名字就可以大概判断出，DPDK 的 rte_ring 是一个无锁的 FIFO（先进先出）队列。它有下面一些特点：<br>1、多对多队列，即可以多生产者或单生产者入队；多消费者或单消费者出队<br>2、无锁，即使用 CAS 实现无锁进出<br>3、批量出入队列<br>4、支持突发出入队列。<br>当然，环形队列本身的一些特点它也都具有。下面重点说一下环形队列的出入队，rte_ring 的出入队看似复杂，其实有规律可寻，网上的很多资料，其实只是对官网的一种简单翻译，这里进行一下初步的总结：  </p>
<ul>
<li>1、在队列中有两对头尾指针，一个指向生产者的头尾，一个指向消费者的头尾。为什么不是两个而是两对？其实很容易理解，因为要批量插入，如果是一个一个的插入，就不需要两对了。这也是为什么一个个入队时，单对的头尾指针相同的原因。  </li>
<li>2、为什么开始生产操作时，只操作生产者那对指针中的头指针（反之，消费者只操作尾）？因为头指针会移动插入的数量大小，始终保持前进（反之，尾始终保持后退）。这样，如果是一个逻辑环形的队列时，可以看到它们都是朝着一个方向在前进（顺时针），形成 FIFO。然后另外的两个指针可以根据实际的生产和消费过程推导出来。  </li>
<li>3、需要注意的是，循环队列需要一个哨兵（置空区），官网的说明应该是头指针不存储数据做为哨兵。  </li>
<li>4、多核的入队出队，涉及到局部变量和 rte_ring 的相关变量的更新问题，使用 CAS 来实现（CAS 有不明白的可以查找一下相关资料）。这里分析一下，如果只是一个核心（一个进程或线程），那么问题就简单了，更新一下，就结束了。可以把 CAS 理解成一把硬件锁（本身也是），两个核（上的进程或线程）同时入队（出队）完成后更新状态时，1 核更新成功时，2 核不可能成功，但 1 核成功后 2 核更新状态后可以导致 2 核再次 CAS 时成功（这个要不明白，就得翻 CAS 的相关资料了）。推理可到 N 个核，所以这里 CAS 也需要 N 次。  </li>
<li>5、环形队列为什么有 Mask 码，目的其实就是为了方便快捷的处理溢出的情况下自动取模。官网的例子中：(uint16) (6000-59000)%65536 &#x3D; 12536（其实就是溢出时让 65535 减去计算值的反向正值，上面就是 65536-（59000-6000）&#x3D;12536）; 就是这个意思。</li>
</ul>
<p>弄明白了上面的逻辑，再看代码就明白很多了。<br>先看一下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* structure to hold a pair of head/tail values and other metadata */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint32_t</span> head;  <span class="comment">/**&lt; Prod/consumer head. */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint32_t</span> tail;  <span class="comment">/**&lt; Prod/consumer tail. */</span></span><br><span class="line">	<span class="type">uint32_t</span> single;         <span class="comment">/**&lt; True if single prod/cons */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An RTE ring structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The producer and the consumer have a head and a tail index. The particularity</span></span><br><span class="line"><span class="comment"> * of these index is that they are not between 0 and size(ring). These indexes</span></span><br><span class="line"><span class="comment"> * are between 0 and 2^32, and we mask their value when we access the ring[]</span></span><br><span class="line"><span class="comment"> * field. Thanks to this assumption, we can do subtractions between 2 index</span></span><br><span class="line"><span class="comment"> * values in a modulo-32bit base: that&#x27;s why the overflow of the indexes is not</span></span><br><span class="line"><span class="comment"> * a problem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: this field kept the RTE_MEMZONE_NAMESIZE size due to ABI</span></span><br><span class="line"><span class="comment">	 * compatibility requirements, it could be changed to RTE_RING_NAMESIZE</span></span><br><span class="line"><span class="comment">	 * next time the ABI changes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MEMZONE_NAMESIZE] __rte_cache_aligned; <span class="comment">/**&lt; Name of the ring. */</span></span><br><span class="line">	<span class="type">int</span> flags;               <span class="comment">/**&lt; Flags supplied at creation. */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">memzone</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Memzone, if any, containing the rte_ring */</span></span><br><span class="line">	<span class="type">uint32_t</span> size;           <span class="comment">/**&lt; Size of ring. */</span></span><br><span class="line">	<span class="type">uint32_t</span> mask;           <span class="comment">/**&lt; Mask (size-1) of ring. */</span></span><br><span class="line">	<span class="type">uint32_t</span> capacity;       <span class="comment">/**&lt; Usable size of ring */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> pad0 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Ring producer status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> <span class="title">prod</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="type">char</span> pad1 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Ring consumer status. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> <span class="title">cons</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="type">char</span> pad2 __rte_cache_aligned; <span class="comment">/**&lt; empty cache line */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再看一下创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_ring_init</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* compilation-time checks */</span></span><br><span class="line">	RTE_BUILD_BUG_ON((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ring) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line">	RTE_BUILD_BUG_ON((offsetof(<span class="keyword">struct</span> rte_ring, cons) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line">	RTE_BUILD_BUG_ON((offsetof(<span class="keyword">struct</span> rte_ring, prod) &amp;</span><br><span class="line">			  RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init the ring structure */</span></span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line">	ret = strlcpy(r-&gt;name, name, <span class="keyword">sizeof</span>(r-&gt;name));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> || ret &gt;= (<span class="type">int</span>)<span class="keyword">sizeof</span>(r-&gt;name))</span><br><span class="line">		<span class="keyword">return</span> -ENAMETOOLONG;</span><br><span class="line">	r-&gt;flags = flags;</span><br><span class="line">	r-&gt;prod.single = (flags &amp; RING_F_SP_ENQ) ? __IS_SP : __IS_MP;</span><br><span class="line">	r-&gt;cons.single = (flags &amp; RING_F_SC_DEQ) ? __IS_SC : __IS_MC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; RING_F_EXACT_SZ) &#123;</span><br><span class="line">		r-&gt;size = rte_align32pow2(count + <span class="number">1</span>);</span><br><span class="line">		r-&gt;mask = r-&gt;size - <span class="number">1</span>;</span><br><span class="line">		r-&gt;capacity = count;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((!POWEROF2(count)) || (count &gt; RTE_RING_SZ_MASK)) &#123;</span><br><span class="line">			RTE_LOG(ERR, RING,</span><br><span class="line">				<span class="string">&quot;Requested size is invalid, must be power of 2, and not exceed the size limit %u\n&quot;</span>,</span><br><span class="line">				RTE_RING_SZ_MASK);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		r-&gt;size = count;</span><br><span class="line">		r-&gt;mask = count - <span class="number">1</span>;</span><br><span class="line">		r-&gt;capacity = r-&gt;mask;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;prod.head = r-&gt;cons.head = <span class="number">0</span>;</span><br><span class="line">	r-&gt;prod.tail = r-&gt;cons.tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the ring */</span></span><br><span class="line"><span class="keyword">struct</span> rte_ring * <span class="title function_">rte_ring_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> count, <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> mz_name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span> *<span class="title">te</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span>;</span></span><br><span class="line">	<span class="type">ssize_t</span> ring_size;</span><br><span class="line">	<span class="type">int</span> mz_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_list</span>* <span class="title">ring_list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> requested_count = count;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ring_list = RTE_TAILQ_CAST(rte_ring_tailq.head, rte_ring_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for an exact size ring, round up from count to a power of two */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; RING_F_EXACT_SZ)</span><br><span class="line">		count = rte_align32pow2(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ring_size = rte_ring_get_memsize(count);</span><br><span class="line">	<span class="keyword">if</span> (ring_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rte_errno = -ring_size;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">snprintf</span>(mz_name, <span class="keyword">sizeof</span>(mz_name), <span class="string">&quot;%s%s&quot;</span>,</span><br><span class="line">		RTE_RING_MZ_PREFIX, name);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> || ret &gt;= (<span class="type">int</span>)<span class="keyword">sizeof</span>(mz_name)) &#123;</span><br><span class="line">		rte_errno = ENAMETOOLONG;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	te = rte_zmalloc(<span class="string">&quot;RING_TAILQ_ENTRY&quot;</span>, <span class="keyword">sizeof</span>(*te), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, RING, <span class="string">&quot;Cannot reserve memory for tailq\n&quot;</span>);</span><br><span class="line">		rte_errno = ENOMEM;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_mcfg_tailq_write_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reserve a memory zone for this ring. If we can&#x27;t get rte_config or</span></span><br><span class="line"><span class="comment">	 * we are secondary process, the memzone_reserve function will set</span></span><br><span class="line"><span class="comment">	 * rte_errno for us appropriately - hence no check in this this function */</span></span><br><span class="line">	mz = rte_memzone_reserve_aligned(mz_name, ring_size, socket_id,</span><br><span class="line">					 mz_flags, __alignof__(*r));</span><br><span class="line">	<span class="keyword">if</span> (mz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		r = mz-&gt;addr;</span><br><span class="line">		<span class="comment">/* no need to check return value here, we already checked the</span></span><br><span class="line"><span class="comment">		 * arguments above */</span></span><br><span class="line">		rte_ring_init(r, name, requested_count, flags);</span><br><span class="line"></span><br><span class="line">		te-&gt;data = (<span class="type">void</span> *) r;</span><br><span class="line">		r-&gt;memzone = mz;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(ring_list, te, next);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r = <span class="literal">NULL</span>;</span><br><span class="line">		RTE_LOG(ERR, RING, <span class="string">&quot;Cannot reserve memory\n&quot;</span>);</span><br><span class="line">		rte_free(te);</span><br><span class="line">	&#125;</span><br><span class="line">	rte_mcfg_tailq_write_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看一下出入队列，即生产和消费（lib&#x2F;librte_ring.h）：<br>1、看一下单生产入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue one object on a ring (NOT multi-producers safe).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> *   A pointer to the object to be added.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects enqueued.</span></span><br><span class="line"><span class="comment"> *   - -ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_sp_enqueue</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_ring_sp_enqueue_bulk(r, &amp;obj, <span class="number">1</span>, <span class="literal">NULL</span>) ? <span class="number">0</span> : -ENOBUFS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_sp_enqueue_bulk</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __rte_ring_do_enqueue(r, obj_table, n, RTE_RING_QUEUE_FIXED,</span><br><span class="line">			__IS_SP, free_space);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_do_enqueue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span><br><span class="line">		 <span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">		 <span class="type">unsigned</span> <span class="type">int</span> is_sp, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> prod_head, prod_next;</span><br><span class="line">	<span class="type">uint32_t</span> free_entries;</span><br><span class="line"></span><br><span class="line">	n = __rte_ring_move_prod_head(r, is_sp, n, behavior,</span><br><span class="line">			&amp;prod_head, &amp;prod_next, &amp;free_entries);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">	ENQUEUE_PTRS(r, &amp;r[<span class="number">1</span>], prod_head, obj_table, n, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">	update_tail(&amp;r-&gt;prod, prod_head, prod_next, is_sp, <span class="number">1</span>);</span><br><span class="line">end:</span><br><span class="line">	<span class="keyword">if</span> (free_space != <span class="literal">NULL</span>)</span><br><span class="line">		*free_space = free_entries - n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENQUEUE_PTRS(r, ring_start, prod_head, obj_table, n, obj_type) do &#123; \</span></span><br><span class="line"><span class="meta">	unsigned int i; \</span></span><br><span class="line"><span class="meta">	const uint32_t size = (r)-&gt;size; \</span></span><br><span class="line"><span class="meta">	uint32_t idx = prod_head &amp; (r)-&gt;mask; \</span></span><br><span class="line"><span class="meta">	obj_type *ring = (obj_type *)ring_start; \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (likely(idx + n &lt; size)) &#123; \</span></span><br><span class="line"><span class="meta">		for (i = 0; i &lt; (n &amp; ((~(unsigned)0x3))); i+=4, idx+=4) &#123; \</span></span><br><span class="line"><span class="meta">			ring[idx] = obj_table[i]; \</span></span><br><span class="line"><span class="meta">			ring[idx+1] = obj_table[i+1]; \</span></span><br><span class="line"><span class="meta">			ring[idx+2] = obj_table[i+2]; \</span></span><br><span class="line"><span class="meta">			ring[idx+3] = obj_table[i+3]; \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">		switch (n &amp; 0x3) &#123; \</span></span><br><span class="line"><span class="meta">		case 3: \</span></span><br><span class="line"><span class="meta">			ring[idx++] = obj_table[i++]; <span class="comment">/* fallthrough */</span> \</span></span><br><span class="line"><span class="meta">		case 2: \</span></span><br><span class="line"><span class="meta">			ring[idx++] = obj_table[i++]; <span class="comment">/* fallthrough */</span> \</span></span><br><span class="line"><span class="meta">		case 1: \</span></span><br><span class="line"><span class="meta">			ring[idx++] = obj_table[i++]; \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">	&#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">		for (i = 0; idx &lt; size; i++, idx++)\</span></span><br><span class="line"><span class="meta">			ring[idx] = obj_table[i]; \</span></span><br><span class="line"><span class="meta">		for (idx = 0; i &lt; n; i++, idx++) \</span></span><br><span class="line"><span class="meta">			ring[idx] = obj_table[i]; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>上面的代码最终调用宏代码中，其实是将插入的数量以四个为基准，分批插入，不足的在后面的 switch 中再完成。</p>
<p>2、单消费者出队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dequeue one object from a ring (NOT multi-consumers safe).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj_p</span></span><br><span class="line"><span class="comment"> *   A pointer to a void * pointer (object) that will be filled.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects dequeued.</span></span><br><span class="line"><span class="comment"> *   - -ENOENT: Not enough entries in the ring to dequeue, no object is</span></span><br><span class="line"><span class="comment"> *     dequeued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_sc_dequeue</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_ring_sc_dequeue_bulk(r, obj_p, <span class="number">1</span>, <span class="literal">NULL</span>) ? <span class="number">0</span> : -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_sc_dequeue_bulk</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_table,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *available)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __rte_ring_do_dequeue(r, obj_table, n, RTE_RING_QUEUE_FIXED,</span><br><span class="line">			__IS_SC, available);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_do_dequeue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_table,</span><br><span class="line">		 <span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">		 <span class="type">unsigned</span> <span class="type">int</span> is_sc, <span class="type">unsigned</span> <span class="type">int</span> *available)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cons_head, cons_next;</span><br><span class="line">	<span class="type">uint32_t</span> entries;</span><br><span class="line"></span><br><span class="line">	n = __rte_ring_move_cons_head(r, (<span class="type">int</span>)is_sc, n, behavior,</span><br><span class="line">			&amp;cons_head, &amp;cons_next, &amp;entries);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">	DEQUEUE_PTRS(r, &amp;r[<span class="number">1</span>], cons_head, obj_table, n, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">	update_tail(&amp;r-&gt;cons, cons_head, cons_next, is_sc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="keyword">if</span> (available != <span class="literal">NULL</span>)</span><br><span class="line">		*available = entries - n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEQUEUE_PTRS(r, ring_start, cons_head, obj_table, n, obj_type) do &#123; \</span></span><br><span class="line"><span class="meta">	unsigned int i; \</span></span><br><span class="line"><span class="meta">	uint32_t idx = cons_head &amp; (r)-&gt;mask; \</span></span><br><span class="line"><span class="meta">	const uint32_t size = (r)-&gt;size; \</span></span><br><span class="line"><span class="meta">	obj_type *ring = (obj_type *)ring_start; \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (likely(idx + n &lt; size)) &#123; \</span></span><br><span class="line"><span class="meta">		for (i = 0; i &lt; (n &amp; (~(unsigned)0x3)); i+=4, idx+=4) &#123;\</span></span><br><span class="line"><span class="meta">			obj_table[i] = ring[idx]; \</span></span><br><span class="line"><span class="meta">			obj_table[i+1] = ring[idx+1]; \</span></span><br><span class="line"><span class="meta">			obj_table[i+2] = ring[idx+2]; \</span></span><br><span class="line"><span class="meta">			obj_table[i+3] = ring[idx+3]; \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">		switch (n &amp; 0x3) &#123; \</span></span><br><span class="line"><span class="meta">		case 3: \</span></span><br><span class="line"><span class="meta">			obj_table[i++] = ring[idx++]; <span class="comment">/* fallthrough */</span> \</span></span><br><span class="line"><span class="meta">		case 2: \</span></span><br><span class="line"><span class="meta">			obj_table[i++] = ring[idx++]; <span class="comment">/* fallthrough */</span> \</span></span><br><span class="line"><span class="meta">		case 1: \</span></span><br><span class="line"><span class="meta">			obj_table[i++] = ring[idx++]; \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">	&#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">		for (i = 0; idx &lt; size; i++, idx++) \</span></span><br><span class="line"><span class="meta">			obj_table[i] = ring[idx]; \</span></span><br><span class="line"><span class="meta">		for (idx = 0; i &lt; n; i++, idx++) \</span></span><br><span class="line"><span class="meta">			obj_table[i] = ring[idx]; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>3、多生产入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue one object on a ring (multi-producers safe).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function uses a &quot;compare and set&quot; instruction to move the</span></span><br><span class="line"><span class="comment"> * producer index atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> *   A pointer to the object to be added.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects enqueued.</span></span><br><span class="line"><span class="comment"> *   - -ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_mp_enqueue</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_ring_mp_enqueue_bulk(r, &amp;obj, <span class="number">1</span>, <span class="literal">NULL</span>) ? <span class="number">0</span> : -ENOBUFS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_mp_enqueue_bulk</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __rte_ring_do_enqueue(r, obj_table, n, RTE_RING_QUEUE_FIXED,</span><br><span class="line">			__IS_MP, free_space);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终 mp,sp 的处理走到了一起。</p>
<p>4、多消费者出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_mc_dequeue</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_ring_mc_dequeue_bulk(r, obj_p, <span class="number">1</span>, <span class="literal">NULL</span>)  ? <span class="number">0</span> : -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_mc_dequeue_bulk</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_table,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *available)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __rte_ring_do_dequeue(r, obj_table, n, RTE_RING_QUEUE_FIXED,</span><br><span class="line">			__IS_MC, available);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>突传的几个函数自己看一看就 OK 了。<br>重点看一下那个入队时的 mp 和 sp 的标记导致的代码不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_move_prod_head(<span class="keyword">struct</span> rte_ring *r, <span class="type">unsigned</span> <span class="type">int</span> is_sp,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">		<span class="type">uint32_t</span> *old_head, <span class="type">uint32_t</span> *new_head,</span><br><span class="line">		<span class="type">uint32_t</span> *free_entries)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">uint32_t</span> capacity = r-&gt;capacity;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max = n;</span><br><span class="line">	<span class="type">int</span> success;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* Reset n to the initial burst count */</span></span><br><span class="line">		n = max;</span><br><span class="line"></span><br><span class="line">		*old_head = r-&gt;prod.head;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* add rmb barrier to avoid load/load reorder in weak</span></span><br><span class="line"><span class="comment">		 * memory model. It is noop on x86</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rte_smp_rmb();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">		 * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">		 * *old_head &gt; cons_tail). So &#x27;free_entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">		 * and capacity (which is &lt; size).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*free_entries = (capacity + r-&gt;cons.tail - *old_head);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check that we have enough room in ring */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(n &gt; *free_entries))</span><br><span class="line">			n = (behavior == RTE_RING_QUEUE_FIXED) ?</span><br><span class="line">					<span class="number">0</span> : *free_entries;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		*new_head = *old_head + n;</span><br><span class="line">		<span class="keyword">if</span> (is_sp)</span><br><span class="line">			r-&gt;prod.head = *new_head, success = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			success = rte_atomic32_cmpset(&amp;r-&gt;prod.head,</span><br><span class="line">					*old_head, *new_head);</span><br><span class="line">	&#125; <span class="keyword">while</span> (unlikely(success == <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">update_tail</span><span class="params">(<span class="keyword">struct</span> rte_ring_headtail *ht, <span class="type">uint32_t</span> old_val, <span class="type">uint32_t</span> new_val,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> single, <span class="type">uint32_t</span> enqueue)</span></span><br><span class="line">&#123;</span><br><span class="line">	RTE_SET_USED(enqueue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there are other enqueues/dequeues in progress that preceded us,</span></span><br><span class="line"><span class="comment">	 * we need to wait for them to complete</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!single)</span><br><span class="line">		<span class="keyword">while</span> (unlikely(ht-&gt;tail != old_val))</span><br><span class="line">			rte_pause();</span><br><span class="line"></span><br><span class="line">	__atomic_store_n(&amp;ht-&gt;tail, new_val, __ATOMIC_RELEASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中对 is_sp 的处理和对! single 的处理就体现了 CAS。消费者最终也有类似的处理，这里就不再多贴代码了。</p>
<h1 id="DPDK并行机制"><a href="#DPDK并行机制" class="headerlink" title="DPDK并行机制"></a>DPDK并行机制</h1><p>什么是并行机制？这个很多开发者的眼中，其实是模糊的。可能说起来头头是道，但是细一查究竟，发现都是飘在空中的东西。在前面的 “多核和多 CPU编程” 中，对并行机制已经进行了较深入的分析，这里只简单说明一下。<br>说起并行（parallelism），就不得不提并发（concurrent）。并发一般是指多线 (进) 程在一个执行单元上进行轮流执行（时间片），而并行指多线（进）程在多个执行单元上同时执行。大多数开发者一个最明显的谬误往往就在于把并发和并行混淆。当然，有的书籍中，把二者说的不太清楚，甚至从某个角度上有意无意的误导了学习者也是一个重要原因。之所以产生这个现象，一个最重要的原因在于大学课程中的操作系统和计算机原理为了更容易说明进程线程的机制，而简化了很多东西。这样，就导致很多开发者在一开始就把学习的知识想当然的扩展了，这在国外的教科书中就做的比较好（所以搞计算机，教科书尽量用国外的，技术尽量上国外的官网）。<br>另外一个就是在计算机普及的过程中，并发比并行更简单，实现成本更低。这也导致很多老的开发者，如果技术没有跟进，也会产生这种误解。起初的大型机和小型机上，多 CPU 的很正常，所以并行编程其实出现的很早。而并发编程，也就是现在开发者理解的多线（进）程（早期的多道程排除出去），其实比并行编程要出现的晚，就一如线程这个概念一样。  </p>
<p>需要注意的是：<br>上面虽然以多线（进）程为例说明，但一定要记清楚，这是任务分配（前端），到底决定是并行还是并发，还是看执行（后端）是同一执行单元还是多执行单元。另外不要混淆并行和并发混合（M:N：M 个线程，N 个执行单元，M&gt;N 这种情况）。<br>还有一个说明点，所谓异步和协程（Java21 的虚拟线程这些都算）这些都是在以此为基础的另外一种抽象的应用，不要硬夹杂进来。</p>
<p>明白了什么是并行机制后，现在看一下 DPDK 中是如何引入并行机制的。<br>从宏观上来看, 提高执行效率不外乎以下几点：<br>1、执行（计算等）单元的数量。从简单理论（不考虑竞态）上理解，越多越好（人多好干活嘛）。<br>2、线（进）程的调度。简单来说，没有调度这种理想状态效率最好（人多更要合理分工）。<br>3、动态的扩展性。即运行过程中动态的增减来达到效率的最高，否则一个单元执行足以应付，即有九十九个线程闲置也是低效，即达到线性的伸缩（人员需求动态可调配）。<br>而算法等的完善和优化（提高人员素质），这属于计算机提高效率的细节了或者说具体的业务范畴，这里暂时不做讨论。<br>在 DPDK 中应对上面的这些解决方式有：<br>1、支持多 CPU 和多核心，并进一步支持以此演进的 NUMA。<br>现代的 CPU 一般可以有多个安装在一台服务器上，一个 CPU 上有多个 Core，而一个 Core 又会有多个逻辑核心（超线程技术）。甚至从宏观上看，分布式的系统都可以看做一个大型的计算机，这个扯远了。扯回来，这样，通过多个 CPU（含核心），可以最大限度保持非关联的并行度。而多个 CPU 又进一步衍生出 NUMA，保证内存访问的安全和快捷，用来保持内存访问的效率。</p>
<p>2、支持线程亲和性和线程独占，这个有点类似于减少调度（尽量减少线程开销提高 Cache 命中率）。<br>多个核心就很容易保持着不相关的线程的并行执行，这其实就是干活的人多了，假如你做为一个包工头，如何保证这些多的人产生出更高的结果？那么最简单的一种办法，如果某个人擅长打字，你就让他专职打字，而不是打一会字就去搬砖。有些人有力气，你非要让他搬一会砖就去打字，除了让这两人感到痛苦，还会直线降低工作效率。这就是 CPU 的亲和性，这在 NUMA 的机器上非常重要。同样，亲和性只是让任务偏重于少调度而不是不调度。所以就又有线程独占，也就是绑定到 CPU（核心）上，也就是说，这个核心不会再调度，只和绑定的线程快乐的玩耍。<br>当然，这些是有条件的，如果你的任务需要密集性的计算或者非常复杂和对实时性要求非常高等，才会要求这样做。这和大页内存的限制条件原理是类似的。</p>
<p>3、可扩展性<br>DPDK 通过配置等手段可以实现对 CPU 核心数量的支持来实现计算的可扩展性，同样利用内存的管理实现内存的可扩展性操作，其它也是如此，特别是虚拟化的支持，其实已经从底层更好的支持了可扩展性。</p>
<p>之所以这样做，和整体任务计划中的局部性、减少互斥访问和避免多核调度以及锁的粒度尽量小（或者尽快通过临界区）是密不可分的。但即使如此，在实际的应用中，不可避免的会出现并行的并行控制问题。这其实又重新回到了一个数学概率的问题以及具体到某个场景的数学概率问题。</p>
<p>在 DPDK 中，在代码分析中可以知道其通过 POSIX 库创建线程的方式来 Spawn 线程并且通过上述的方式来绑定到具体的核心，来实现 DPDK 的高效率真通信的目标。它分为主从两类，分布在主从核心上。一般控制线程做为主线程，而数据线程做为从线程。<br>其实 DPDK 也是针对上面的几个方面进行了实现，只不过在逻辑上划分出来主从，来区分管理和业务，能够更好的满足实际的需求。</p>
<p>DPDK 的内存机制基本告一段落，那么高效的另外一个重点就是并行。以目前的计算机资源的使用来看，没有一个高效的并行框架基本上是无法达到榨干资源的可能的。就如资本一样，不浪费每一个资源，每一个资源的每一部分，是计算机开发者的终极目标。整体上要推进资源的技术进步，在无法短时间内实现技术进步的前提下，组合应用各种技术把对资源的利用达到极致，这就是计算机技术的宏观的目的。<br>DPDK 就是这其中一个典型的代表，所以，这个并行的机制，就不得直面对待。</p>
<h1 id="DPDK-中并行机制及弹性扩展"><a href="#DPDK-中并行机制及弹性扩展" class="headerlink" title="DPDK 中并行机制及弹性扩展"></a>DPDK 中并行机制及弹性扩展</h1><p>在前面的简介中对并行机制进行了一个初步的分析，在 DPDK 中，对并行的支持是一个整体的流程。在外面，有多核心并行和绑定等的支持，在内部有多线程和多队列网卡以及无锁编程的应用。而从一些算法上则提供了负载均衡等自动控制，从而才能保证在整体上达到最优的并行效果。<br>也正是通过上面的一系列手段的综合运用，打开了千万并发的突破口。</p>
<p>1、CPU 亲和性和独占<br>在 Linux 内核中，会通过位的掩码来控制进程的 CPU 亲合力，为此内核提供了相关的 API 接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched_set_affinity()   <span class="comment">//设置位掩码</span></span><br><span class="line">sched_get_affinity()  <span class="comment">//获取当前位掩码</span></span><br></pre></td></tr></table></figure>

<p>而在 DPDK 的使用 POSIX 库中的线程可以通过下面的手段来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="type">rte_cpuset_t</span> *cpuset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (override) &#123;</span><br><span class="line">		<span class="comment">/* we only allow affinity with a single CPU */</span></span><br><span class="line">		<span class="keyword">if</span> (CPU_COUNT(cpuset) != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> POSIX_ERRNO(EINVAL);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* we only allow the current thread to sets its own affinity */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">lthread</span> *<span class="title">lt</span> =</span> (<span class="keyword">struct</span> lthread *)thread;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lthread_current() != lt)</span><br><span class="line">			<span class="keyword">return</span> POSIX_ERRNO(EINVAL);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* determine the CPU being requested */</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LTHREAD_MAX_LCORES; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!CPU_ISSET(i, cpuset))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* check requested core is allowed */</span></span><br><span class="line">		<span class="keyword">if</span> (i == LTHREAD_MAX_LCORES)</span><br><span class="line">			<span class="keyword">return</span> POSIX_ERRNO(EINVAL);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* finally we can set affinity to the requested lcore */</span></span><br><span class="line">		lthread_set_affinity(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _sys_pthread_funcs.f_pthread_setaffinity_np(thread, cpusetsize,</span><br><span class="line">							   cpuset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * migrate the current thread to another scheduler running</span></span><br><span class="line"><span class="comment"> * on the specified lcore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lthread_set_affinity</span><span class="params">(<span class="type">unsigned</span> lcoreid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lthread</span> *<span class="title">lt</span> =</span> THIS_LTHREAD;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lthread_sched</span> *<span class="title">dest_sched</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(lcoreid &gt;= LTHREAD_MAX_LCORES))</span><br><span class="line">		<span class="keyword">return</span> POSIX_ERRNO(EINVAL);</span><br><span class="line"></span><br><span class="line">	DIAG_EVENT(lt, LT_DIAG_LTHREAD_AFFINITY, lcoreid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	dest_sched = schedcore[lcoreid];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dest_sched == <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> POSIX_ERRNO(EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(dest_sched != THIS_SCHED)) &#123;</span><br><span class="line">		lt-&gt;sched = dest_sched;</span><br><span class="line">		lt-&gt;pending_wr_queue = dest_sched-&gt;pready;</span><br><span class="line">		_affinitize();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">compute_ctrl_threads_cpuset</span><span class="params">(<span class="keyword">struct</span> internal_config *internal_cfg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">rte_cpuset_t</span> *cpuset = &amp;internal_cfg-&gt;ctrl_cpuset;</span><br><span class="line">	<span class="type">rte_cpuset_t</span> default_set;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lcore_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rte_lcore_has_role(lcore_id, ROLE_OFF))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		RTE_CPU_OR(cpuset, cpuset, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line">	&#125;</span><br><span class="line">	RTE_CPU_NOT(cpuset, cpuset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pthread_getaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(<span class="type">rte_cpuset_t</span>),</span><br><span class="line">				&amp;default_set))</span><br><span class="line">		CPU_ZERO(&amp;default_set);</span><br><span class="line"></span><br><span class="line">	RTE_CPU_AND(cpuset, cpuset, &amp;default_set);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no remaining cpu, use master lcore cpu affinity */</span></span><br><span class="line">	<span class="keyword">if</span> (!CPU_COUNT(cpuset)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(cpuset, &amp;lcore_config[rte_get_master_lcore()].cpuset,</span><br><span class="line">			<span class="keyword">sizeof</span>(*cpuset));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外为了实现绑定需要，DPDK 提供了配置文件和相关的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> __cpu_mask</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __cpu_mask __bits[<span class="number">16</span>];</span><br><span class="line">&#125; <span class="type">cpu_set_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">cpu_set_t</span> <span class="type">rte_cpuset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure storing internal configuration (per-lcore)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> &#123;</span></span><br><span class="line">	<span class="type">pthread_t</span> thread_id;       <span class="comment">/**&lt; pthread identifier */</span></span><br><span class="line">	<span class="type">int</span> pipe_master2slave[<span class="number">2</span>];  <span class="comment">/**&lt; communication pipe with master */</span></span><br><span class="line">	<span class="type">int</span> pipe_slave2master[<span class="number">2</span>];  <span class="comment">/**&lt; communication pipe with master */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">lcore_function_t</span> * <span class="keyword">volatile</span> f; <span class="comment">/**&lt; function to call */</span></span><br><span class="line">	<span class="type">void</span> * <span class="keyword">volatile</span> arg;       <span class="comment">/**&lt; argument of function */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> ret;          <span class="comment">/**&lt; return value of function */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_state_t</span> <span class="title">state</span>;</span> <span class="comment">/**&lt; lcore state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id;    <span class="comment">/**&lt; physical socket id for this lcore */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> core_id;      <span class="comment">/**&lt; core number on socket for this lcore */</span></span><br><span class="line">	<span class="type">int</span> core_index;            <span class="comment">/**&lt; relative index, starting from 0 */</span></span><br><span class="line">	<span class="type">uint8_t</span> core_role;         <span class="comment">/**&lt; role of core eg: OFF, RTE, SERVICE */</span></span><br><span class="line">	<span class="type">uint8_t</span> detected;          <span class="comment">/**&lt; true if lcore was detected */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">rte_cpuset_t</span> cpuset;       <span class="comment">/**&lt; cpu set which the lcore affinity to */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcore_config</span> <span class="title">lcore_config</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global RTE configuration structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> master_lcore;       <span class="comment">/**&lt; Id of the master lcore */</span></span><br><span class="line">	<span class="type">uint32_t</span> lcore_count;        <span class="comment">/**&lt; Number of available logical cores. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_node_count;    <span class="comment">/**&lt; Number of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> numa_nodes[RTE_MAX_NUMA_NODES]; <span class="comment">/**&lt; List of detected NUMA nodes. */</span></span><br><span class="line">	<span class="type">uint32_t</span> service_lcore_count;<span class="comment">/**&lt; Number of available service cores. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_lcore_role_t</span> <span class="title">lcore_role</span>[<span class="title">RTE_MAX_LCORE</span>];</span> <span class="comment">/**&lt; State of cores. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primary or secondary configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_proc_type_t</span> <span class="title">process_type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** PA or VA mapping mode */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_iova_mode</span> <span class="title">iova_mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Pointer to memory configuration, which may be shared across multiple</span></span><br><span class="line"><span class="comment">	 * DPDK instances</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mem_config</span>;</span></span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>上面的这些数据结构的变量将会在 rte_eal_cpu_init 函数中对其进行处理。通过这些配置，来确定相关的核心和线程的具体的工作情况。<br>而 DPDK 中的线程独占采用了内核提供的启动参数 isolcpus，通过配置参数来处理。</p>
<p>2、管理和调度<br>在前面分析过，在 DPDK 中，既可以实现静态的配置文件管理，也可以在实际运行中进行通过 API 动态的设置管理。这更得适应实际环境。EAL 中封装了 lcore 这层抽象，可以更好的管理相关的并行控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that every SLAVE lcores are in WAIT state, then call</span></span><br><span class="line"><span class="comment"> * rte_eal_remote_launch() for all of them. If call_master is true</span></span><br><span class="line"><span class="comment"> * (set to CALL_MASTER), also call the function on the master lcore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_eal_mp_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span> *), <span class="type">void</span> *arg,</span></span><br><span class="line"><span class="params">			 <span class="keyword">enum</span> <span class="type">rte_rmt_call_master_t</span> call_master)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lcore_id;</span><br><span class="line">	<span class="type">int</span> master = rte_get_master_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check state of lcores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].state != WAIT)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send messages to cores */</span></span><br><span class="line">	RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">		rte_eal_remote_launch(f, arg, lcore_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (call_master == CALL_MASTER) &#123;</span><br><span class="line">		lcore_config[master].ret = f(arg);<span class="comment">// callback处理注册</span></span><br><span class="line">		lcore_config[master].state = FINISHED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过任务的注册来保证管理调度，然后在回调的线程中执行相关任务。</p>
<p>3、弹性扩展</p>
<p>在初始化中可以通过配置文件来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Launch threads, called at application init(). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_init</span><span class="params">(<span class="type">int</span> argc __rte_unused, <span class="type">char</span> **argv __rte_unused)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* create a map of all processors in the system */</span></span><br><span class="line"> eal_create_cpu_map();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (rte_eal_cpu_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   rte_eal_init_alert(<span class="string">&quot;Cannot detect lcores.&quot;</span>);</span><br><span class="line">   rte_errno = ENOTSUP;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> eal_thread_init_master(rte_config.master_lcore);</span><br><span class="line"></span><br><span class="line"> RTE_LCORE_FOREACH_SLAVE(i) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * create communication pipes between master thread</span></span><br><span class="line"><span class="comment">    * and children</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (_pipe(lcore_config[i].pipe_master2slave,</span><br><span class="line">     <span class="keyword">sizeof</span>(<span class="type">char</span>), _O_BINARY) &lt; <span class="number">0</span>)</span><br><span class="line">     rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (_pipe(lcore_config[i].pipe_slave2master,</span><br><span class="line">     <span class="keyword">sizeof</span>(<span class="type">char</span>), _O_BINARY) &lt; <span class="number">0</span>)</span><br><span class="line">     rte_panic(<span class="string">&quot;Cannot create pipe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   lcore_config[i].state = WAIT;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* create a thread for each lcore */</span></span><br><span class="line">   <span class="keyword">if</span> (eal_thread_create(&amp;lcore_config[i].thread_id) != <span class="number">0</span>)</span><br><span class="line">     rte_panic(<span class="string">&quot;Cannot create thread\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Launch a dummy function on all slave lcores, so that master lcore</span></span><br><span class="line"><span class="comment">  * knows they are all ready when this function returns.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> rte_eal_mp_remote_launch(sync_func, <span class="literal">NULL</span>, SKIP_MASTER);</span><br><span class="line"> rte_eal_mp_wait_lcore();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a map of all processors and associated cores on the system</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eal_create_cpu_map</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	wcpu_map.total_procs =</span><br><span class="line">		GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);</span><br><span class="line"></span><br><span class="line">	LOGICAL_PROCESSOR_RELATIONSHIP lprocRel;</span><br><span class="line">	DWORD lprocInfoSize = <span class="number">0</span>;</span><br><span class="line">	BOOL ht_enabled = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First get the processor package information */</span></span><br><span class="line">	lprocRel = RelationProcessorPackage;</span><br><span class="line">	<span class="comment">/* Determine the size of buffer we need (pass NULL) */</span></span><br><span class="line">	GetLogicalProcessorInformationEx(lprocRel, <span class="literal">NULL</span>, &amp;lprocInfoSize);</span><br><span class="line">	wcpu_map.proc_sockets = lprocInfoSize / <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">	lprocInfoSize = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Next get the processor core information */</span></span><br><span class="line">	lprocRel = RelationProcessorCore;</span><br><span class="line">	GetLogicalProcessorInformationEx(lprocRel, <span class="literal">NULL</span>, &amp;lprocInfoSize);</span><br><span class="line">	wcpu_map.proc_cores = lprocInfoSize / <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wcpu_map.total_procs &gt; wcpu_map.proc_cores)</span><br><span class="line">		ht_enabled = TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Distribute the socket and core ids appropriately</span></span><br><span class="line"><span class="comment">	 * across the logical cores. For now, split the cores</span></span><br><span class="line"><span class="comment">	 * equally across the sockets.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lcore = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> socket = <span class="number">0</span>; socket &lt;</span><br><span class="line">			wcpu_map.proc_sockets; ++socket) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> core = <span class="number">0</span>;</span><br><span class="line">			core &lt; (wcpu_map.proc_cores / wcpu_map.proc_sockets);</span><br><span class="line">			++core) &#123;</span><br><span class="line">			wcpu_map.wlcore_map[lcore]</span><br><span class="line">					.socket_id = socket;</span><br><span class="line">			wcpu_map.wlcore_map[lcore]</span><br><span class="line">					.core_id = core;</span><br><span class="line">			lcore++;</span><br><span class="line">			<span class="keyword">if</span> (ht_enabled) &#123;</span><br><span class="line">				wcpu_map.wlcore_map[lcore]</span><br><span class="line">					.socket_id = socket;</span><br><span class="line">				wcpu_map.wlcore_map[lcore]</span><br><span class="line">					.core_id = core;</span><br><span class="line">				lcore++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parse /sys/devices/system/cpu to get the number of physical and logical</span></span><br><span class="line"><span class="comment"> * processors on the machine. The function will fill the cpu_info</span></span><br><span class="line"><span class="comment"> * structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_cpu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* pointer to global configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">config</span> =</span> rte_eal_get_configuration();</span><br><span class="line">	<span class="type">unsigned</span> lcore_id;</span><br><span class="line">	<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> socket_id, prev_socket_id;</span><br><span class="line">	<span class="type">int</span> lcore_to_socket_id[RTE_MAX_LCORE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Parse the maximum set of logical cores, detect the subset of running</span></span><br><span class="line"><span class="comment">	 * ones and enable them by default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		lcore_config[lcore_id].core_index = count;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* init cpuset for per lcore config */</span></span><br><span class="line">		CPU_ZERO(&amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find socket first */</span></span><br><span class="line">		socket_id = eal_cpu_socket_id(lcore_id);</span><br><span class="line">		lcore_to_socket_id[lcore_id] = socket_id;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* in 1:1 mapping, record related cpu detected state */</span></span><br><span class="line">		lcore_config[lcore_id].detected = eal_cpu_detected(lcore_id);</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[lcore_id].detected == <span class="number">0</span>) &#123;</span><br><span class="line">			config-&gt;lcore_role[lcore_id] = ROLE_OFF;</span><br><span class="line">			lcore_config[lcore_id].core_index = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, lcore 1:1 map to cpu id */</span></span><br><span class="line">		CPU_SET(lcore_id, &amp;lcore_config[lcore_id].cpuset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, each detected core is enabled */</span></span><br><span class="line">		config-&gt;lcore_role[lcore_id] = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_role = ROLE_RTE;</span><br><span class="line">		lcore_config[lcore_id].core_id = eal_cpu_core_id(lcore_id);</span><br><span class="line">		lcore_config[lcore_id].socket_id = socket_id;</span><br><span class="line">		RTE_LOG(DEBUG, EAL, <span class="string">&quot;Detected lcore %u as &quot;</span></span><br><span class="line">				<span class="string">&quot;core %u on socket %u\n&quot;</span>,</span><br><span class="line">				lcore_id, lcore_config[lcore_id].core_id,</span><br><span class="line">				lcore_config[lcore_id].socket_id);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Set the count of enabled logical cores of the EAL configuration */</span></span><br><span class="line">	config-&gt;lcore_count = count;</span><br><span class="line">	RTE_LOG(DEBUG, EAL,</span><br><span class="line">		<span class="string">&quot;Support maximum %u logical core(s) by configuration.\n&quot;</span>,</span><br><span class="line">		RTE_MAX_LCORE);</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u lcore(s)\n&quot;</span>, config-&gt;lcore_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sort all socket id&#x27;s in ascending order */</span></span><br><span class="line">	qsort(lcore_to_socket_id, RTE_DIM(lcore_to_socket_id),</span><br><span class="line">			<span class="keyword">sizeof</span>(lcore_to_socket_id[<span class="number">0</span>]), socket_id_cmp);</span><br><span class="line"></span><br><span class="line">	prev_socket_id = <span class="number">-1</span>;</span><br><span class="line">	config-&gt;numa_node_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">		socket_id = lcore_to_socket_id[lcore_id];</span><br><span class="line">		<span class="keyword">if</span> (socket_id != prev_socket_id)</span><br><span class="line">			config-&gt;numa_nodes[config-&gt;numa_node_count++] =</span><br><span class="line">					socket_id;</span><br><span class="line">		prev_socket_id = socket_id;</span><br><span class="line">	&#125;</span><br><span class="line">	RTE_LOG(INFO, EAL, <span class="string">&quot;Detected %u NUMA nodes\n&quot;</span>, config-&gt;numa_node_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU 的配置文件一般在 &#x2F; sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpuX &#x2F; 目录下。<br>当然，也可以通过命令参数来实现参 lcore 的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--lcores=<span class="string">&#x27; &lt;lcore_set&gt;&#x27;</span>[@cpu_set][,&lt;lcore_set&gt;[@cpu_set],...]&#x27;</span><br></pre></td></tr></table></figure>

<p>在 DPDK 中利用了 Linux 内核中的 cgroup(control group) 与 pthread 良好的配合，实现了 CPU 的动态管理。有过 Docker 经验的知道，Docker 中也是利用了 Cgroup 机制来实现的资源管理。有兴趣的可以查看一下相关的技术资料。</p>
<h1 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h1><p>在前面介绍了 DPDK 中的上层对并行的支持，特别是对多核的支持。但是，大家都知道，再怎么好的设计和架构，再优秀的编码，最终都要落到硬件和固件对整个上层应用的支持。单纯的硬件好处理，一个核不够多个核，在可能的情况下把 CPU 的频率增加，加大缓存等等。在现有水平的范围内，这些都是可以比较容易做到的。<br>但是另外一个，就是在 CPU 上如何最终运行指令（也可以叫做固件设计），这个就需要设计人员动脑子了。一般来说，IPC（Instruction Per Clock，一个时钟周期内执行的指令数量，可不要看成进程间通信）的数量越高，CPU 运行性能越高（频率和核数相同）。<br>现代 CPU 基本使用了越标量（superscalar）体系结构，通过以空间换时间的方式实行了指令级并行运算。不同的架构的处理器，可能在硬件设计本身有所不同，但在追求并行度上，原理基本相同。<br>在前面的多核编程中，介绍过几种指令，目前常用的基本以 SIMD（单指令流多数据流）和 MIMD（多指令流多数据流）为主。后者一般是多核和多 CPU（当然更高层次的多计算机也算），但在分析本文中更倾向的是 SIMD，毕竟一个核心能处理多少更能体现性能和效率。<br>SIMD 其实很容易理解，可以认为是一种并行的批处理。原来只能一次取一条指令处理一条数据，这次可以一条指令处理多条数据。举个最简单的例子，加指令，需要有两次读操作数，而如果使用 SIMD, 则一次就可以都读进来。其后的处理周期也是如此，那么效率至少增加了一倍。<br>而这些指令设计和处理会形成一个指令集，它的发展也有一个过程，intel 的 SIMD 指令集主要有 MMX, SSE, AVX, AVX-512，主流就是 SSE&#x2F;AVX。AMD 的比较复杂，有兴趣可以查找看一下。</p>
<p>在 DPDK 中对 SIMD 的应用体现在数据的处理上，DPDK 提供了一个化化的拷贝 memcpy 函数，它充分利用了 SIMD 指令集：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">rte_memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(((<span class="type">uintptr_t</span>)dst | (<span class="type">uintptr_t</span>)src) &amp; ALIGNMENT_MASK))</span><br><span class="line">		<span class="keyword">return</span> rte_memcpy_aligned(dst, src, n);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> rte_memcpy_generic(dst, src, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">rte_memcpy_aligned</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = dst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy size &lt; 16 bytes */</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">16</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> rte_mov15_or_less(dst, src, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy 16 &lt;= size &lt;= 32 bytes */</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n,</span><br><span class="line">				(<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy 32 &lt; size &lt;= 64 bytes */</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">64</span>) &#123;</span><br><span class="line">		rte_mov32((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		rte_mov32((<span class="type">uint8_t</span> *)dst - <span class="number">32</span> + n,</span><br><span class="line">				(<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">32</span> + n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy 64 bytes blocks */</span></span><br><span class="line">	<span class="keyword">for</span> (; n &gt;= <span class="number">64</span>; n -= <span class="number">64</span>) &#123;</span><br><span class="line">		rte_mov64((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		dst = (<span class="type">uint8_t</span> *)dst + <span class="number">64</span>;</span><br><span class="line">		src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">64</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy whatever left */</span></span><br><span class="line">	rte_mov64((<span class="type">uint8_t</span> *)dst - <span class="number">64</span> + n,</span><br><span class="line">			(<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">64</span> + n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">rte_memcpy_generic</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	__m128i xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8;</span><br><span class="line">	<span class="type">void</span> *ret = dst;</span><br><span class="line">	<span class="type">size_t</span> dstofss;</span><br><span class="line">	<span class="type">size_t</span> srcofs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Copy less than 16 bytes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">16</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> rte_mov15_or_less(dst, src, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Fast way when copy size doesn&#x27;t exceed 512 bytes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n, (<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">48</span>) &#123;</span><br><span class="line">		rte_mov32((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n, (<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">64</span>) &#123;</span><br><span class="line">		rte_mov32((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst + <span class="number">32</span>, (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">32</span>);</span><br><span class="line">		rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n, (<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">128</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> COPY_BLOCK_128_BACK15;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">			n -= <span class="number">256</span>;</span><br><span class="line">			rte_mov128((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			rte_mov128((<span class="type">uint8_t</span> *)dst + <span class="number">128</span>, (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">128</span>);</span><br><span class="line">			src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">256</span>;</span><br><span class="line">			dst = (<span class="type">uint8_t</span> *)dst + <span class="number">256</span>;</span><br><span class="line">		&#125;</span><br><span class="line">COPY_BLOCK_255_BACK15:</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">			n -= <span class="number">128</span>;</span><br><span class="line">			rte_mov128((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">128</span>;</span><br><span class="line">			dst = (<span class="type">uint8_t</span> *)dst + <span class="number">128</span>;</span><br><span class="line">		&#125;</span><br><span class="line">COPY_BLOCK_128_BACK15:</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">			n -= <span class="number">64</span>;</span><br><span class="line">			rte_mov64((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">64</span>;</span><br><span class="line">			dst = (<span class="type">uint8_t</span> *)dst + <span class="number">64</span>;</span><br><span class="line">		&#125;</span><br><span class="line">COPY_BLOCK_64_BACK15:</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">			n -= <span class="number">32</span>;</span><br><span class="line">			rte_mov32((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">32</span>;</span><br><span class="line">			dst = (<span class="type">uint8_t</span> *)dst + <span class="number">32</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">16</span>) &#123;</span><br><span class="line">			rte_mov16((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n, (<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_mov16((<span class="type">uint8_t</span> *)dst - <span class="number">16</span> + n, (<span class="type">const</span> <span class="type">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Make store aligned when copy size exceeds 512 bytes,</span></span><br><span class="line"><span class="comment">	 * and make sure the first 15 bytes are copied, because</span></span><br><span class="line"><span class="comment">	 * unaligned copy functions require up to 15 bytes</span></span><br><span class="line"><span class="comment">	 * backwards access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dstofss = (<span class="type">uintptr_t</span>)dst &amp; <span class="number">0x0F</span>;</span><br><span class="line">	<span class="keyword">if</span> (dstofss &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		dstofss = <span class="number">16</span> - dstofss + <span class="number">16</span>;</span><br><span class="line">		n -= dstofss;</span><br><span class="line">		rte_mov32((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">		src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + dstofss;</span><br><span class="line">		dst = (<span class="type">uint8_t</span> *)dst + dstofss;</span><br><span class="line">	&#125;</span><br><span class="line">	srcofs = ((<span class="type">uintptr_t</span>)src &amp; <span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * For aligned copy</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (srcofs == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Copy 256-byte blocks</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (; n &gt;= <span class="number">256</span>; n -= <span class="number">256</span>) &#123;</span><br><span class="line">			rte_mov256((<span class="type">uint8_t</span> *)dst, (<span class="type">const</span> <span class="type">uint8_t</span> *)src);</span><br><span class="line">			dst = (<span class="type">uint8_t</span> *)dst + <span class="number">256</span>;</span><br><span class="line">			src = (<span class="type">const</span> <span class="type">uint8_t</span> *)src + <span class="number">256</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Copy whatever left</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">goto</span> COPY_BLOCK_255_BACK15;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * For copy with unaligned load</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MOVEUNALIGNED_LEFT47(dst, src, n, srcofs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Copy whatever left</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">goto</span> COPY_BLOCK_64_BACK15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多相关的代码在 rte_memcpy.h 和 rte_memcpy.c 中，注意，它包含不同 CPU 架构平台的多个版本，不要搞混。<br>从上面的代码可以看到，影响拷贝速度的有以下几点：<br>1、字节对齐和数据的加载存储。<br>这个大家都明白，除了字节对齐速度加快外，而且 DPDK 中还对不同的字节对齐以及长度进行了控制，充分发挥 SIMD 的优势（说直白一点就是在条件允许的情况下，一次拷贝数量多【16 字节：128 位】，这个和平台支持有关）<br>2、函数和库调用开销，库函数需要调用过程，这个也浪费时间。这个库调用过程在编译选择优化的过程中，优化难度也比较大，不如在 DPDK 中直接调用，特别是使用<br><code>static __rte_always_inline</code>（静态内联）时，这在网上有很多优化的比较，自己也可以试一试。<br>3、整体上来说，数据量越大，上面的优化越优势越大；否则优势则不明显。<br>上述的比较是针对库 glibc 以及 DPDK 相比而言的，至于个人优化过的则不在此范畴之内。另外，随着技术的进步，如果用高版本的 glibc 并开启优化后，可能效果差别也不大，这个没有进行比较。<br>有兴趣可以看看 rte_mov256 等几个函数。<br>需要说明的是，对于某一类函数，没有普遍最优之说。只有场景条件限制下的最合适。也就是说，DPDK 的拷贝函数不代表此函数比 glibc 中的拷贝函数优秀，只是说明此函数在 DPDK 的应用场景下更合适。<br>最后总结一下，针对内存拷贝的优化点：<br>1、减少拷贝过程中的附加处理如字节对齐<br>2、在平台允许情况下使用最大带宽（拷贝最大数量）<br>3、使用平坦顺序内存并使用分支预测（减少分支跳转，如是否有范围重叠等）<br>4、有可能的情况下使用 non-temporal 访存执令<br>5、使用加速拷贝的一些指令（string 操作指令等）。<br>6、处理大内存（M 以上）和小内存（K 以下）的不同场景（这个在一些常用框架中都会处理）</p>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>Synchronization，同步。很好理解，简单的可以认为是同一个节奏。引申到计算机，其实就是多任务保持一致性。这个一致性一般是指数据，也可能会是操作。在单任务单线（进）程中，同步是天然的。在多任务无共同操作条件下，同步没有意义。<br>同步一般是在多线（进）程（多任务）且这些线程之间必须有共同操作部分时，才会有意义。<br>以前说过，计算机中的应用和现实的应用是映射。什么意思呢？如果计算机解决的问题，在现实世界上都可以找到原型。比如同步，举一个例子：如果测试学生做操的成绩，各自单独测试即可。可要测试班级操的成绩，这个即使每个学生做的都非常好，但各自做各自的，那么成绩也不一定好。只有同一班的学生保持一致（同步），这样才成绩更优秀。</p>
<h3 id="并行和并发中的同步"><a href="#并行和并发中的同步" class="headerlink" title="并行和并发中的同步"></a>并行和并发中的同步</h3><p>刚刚说过，在单线程和多线程的某些情况下，同步是没有意义的。所以，同步一定是在并发和并行中且有交互的情况下，才有意义。而并发和并行，又增加了同步的复杂性。但是当把同步抽象出来，其实就是具体到某一个粒度是串行的。也就是说，如何保证这个粒度是最合适的。也就引出了后面，使用哪种锁是最合适的话题。<br>在开发者们学习多线程编程时，最先接触的同步方式一般是互斥体（Mutex）。它是一种重量级锁，既支持进程间的同步又支持线程间的同步方式。然后才是其它的如信号量、条件变量、临界区等等。使用互斥锁缺点主要是太耗费时间，而且一不小心还有可能产生死锁。  </p>
<p>那么，就产生了一种读写锁，读写锁其实是一种对锁机制的平衡，在正常的情况下，如果只是读取的话，其实数据自然是同步的，而且事实是在某些场合下，读是一种非常频繁的操作（比如缓存），所以这就可以不进行排它的读，减少锁的时间耗费。当然，如果判断一个线程要写数据时，需要启动排它性，只能它一个操作了。在 Linux 中设计了一个读写锁 ReadWriteLock 。但是，一定要知道在什么情况下使用读写锁。比如，一个场景就是十个线程抢占式写一个数据区，那么读写锁反而没啥意义了。读写锁其实是两部分，一部分是读锁，需要支持多个持有者，一个是写锁，排它。在内核中使用提把一个 int 型分成高低两位，一部分用来处理读（两个字节，最多 65535 个读锁持有者），一部分用来处理写。读部分因为是共同持有，所以需要使用 CAS 进行处理。</p>
<p>而在 c++11 中推出了 automic，原子操作。当然，别的语言和别的情况下也各自有各自的原子操作的方式。所谓原子操作，就是不可再分解的意思。也就是说，这是串行化的，操作它，只能一个个轮流来，不能说你读一下我写一下乱序执行。原子操作其实就基本涉及到了硬件操作了，通过汇编的指令接口，来影响具体的执行过程。一般为说，原子操作和内存顺序也是有一定的关系的，需要大家注意。同时，不同的架构的 CPU 和不同的架构体系（SMP NUMA MPP）也有不同的处理方式，都需要根据实际情况来分析。原子操作只能操作一个变量，当然一个位操作也算一个变量，也就是原子位操作。  </p>
<p>还有一种比较常见的，也是目前在无锁编程中用得比较多的，自旋锁。自旋锁，就是自个儿旋转的锁？表面上看就是这么一个玩意儿。它底层其实是通过 CAS 不断的尝试去读取锁（表现出来就是一个循环，但其实底层如果支持 PAUSE 指令，则可以使用其），获取了就操作不获取就继续。<br>CAS 有几个经典的问题，ABA 问题，时间耗费问题和只能操作一个变量（这也是前面把一个 int 分成高低两部分的原因）。但它也有闪光点啊。一般来说，在多线程编程中，当线程达到一定数量后，线程上下文的切换就成为了一个需要重视的点。互斥锁等会引起线程的切换及线程的睡眠，而 CAS 只是阻塞 CPU 而不会引起线程的退让，这在某些场景下，优势还是非常明显的。  </p>
<p>那么就可以明白，在只有一颗 CPU 一个核心的情况下，自旋锁没有意义，已经退化为普通的互斥体类似的机制，只有在多核多 CPU 的情况下才有意义。同时，自旋锁持有 CPU 不放，所以只能短时间使用，如果长时间需要锁住一个数据，就不能使用自旋锁。所以早期的自旋锁，基本都只是在内核中使用，后期才渐渐在应用层开始使用。同时为了安全，应用层使用自旋锁往往会提供一些安全机制，比如回退到某个时间点上会退化为普通锁。自旋锁在使用过程中是不允许递归的，同样在自旋锁的源码中可以看到其屏蔽了中断请求的函数（中断中如果也有自旋锁，这事儿就难办了）。 </p>
<p>当然，还有一些其它的同步操作方式，如内存栅栏等，它们之间或多或少都有一些相通之处。这里不再赘述。<br>最后，所有的有锁编程，当然不如无锁编程更好。无锁并不是真正意义上的无锁，而把锁进一步下移到非上层控制，在上层表现为无传统意义上锁机制。可以简单的理解成使用指令级操作通过硬件来进行锁操作，速度更快。  </p>
<p>DPDK 中同样也引入原子操作、读写锁和自旋锁三种方式。<br>1、原子操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rte_atomic.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	rte_mb() _mm_mfence()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	rte_wmb() _mm_sfence()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	rte_rmb() _mm_lfence()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rte_smp_wmb() rte_compiler_barrier()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rte_smp_rmb() rte_compiler_barrier()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compiler barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Guarantees that operation reordering does not occur at compile time</span></span><br><span class="line"><span class="comment"> * for operations directly before and after the barrier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	rte_compiler_barrier() do &#123;		\</span></span><br><span class="line"><span class="meta">	asm volatile (<span class="string">&quot;&quot;</span> : : : <span class="string">&quot;memory&quot;</span>);	\</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_add</span><span class="params">(<span class="type">rte_atomic64_t</span> *v, <span class="type">int64_t</span> inc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_FORCE_INTRINSICS</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_add</span><span class="params">(<span class="type">rte_atomic64_t</span> *v, <span class="type">int64_t</span> inc)</span></span><br><span class="line">&#123;</span><br><span class="line">	__sync_fetch_and_add(&amp;v-&gt;cnt, inc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically subtract a 64-bit value from a counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param dec</span></span><br><span class="line"><span class="comment"> *   The value to be subtracted from the counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_sub</span><span class="params">(<span class="type">rte_atomic64_t</span> *v, <span class="type">int64_t</span> dec)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_FORCE_INTRINSICS</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_sub</span><span class="params">(<span class="type">rte_atomic64_t</span> *v, <span class="type">int64_t</span> dec)</span></span><br><span class="line">&#123;</span><br><span class="line">	__sync_fetch_and_sub(&amp;v-&gt;cnt, dec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increment a 64-bit counter by one and test.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_inc</span><span class="params">(<span class="type">rte_atomic64_t</span> *v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_FORCE_INTRINSICS</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_atomic64_inc</span><span class="params">(<span class="type">rte_atomic64_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	rte_atomic64_add(v, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、读写锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rte_rwlock.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The rte_rwlock_t type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cnt is -1 when write lock is held, and &gt; 0 when read locks are held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int32_t</span> cnt; <span class="comment">/**&lt; -1 when W lock held, &gt; 0 when R locks held. */</span></span><br><span class="line">&#125; <span class="type">rte_rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A static rwlock initializer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_RWLOCK_INITIALIZER &#123; 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the rwlock to an unlocked state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rwl</span></span><br><span class="line"><span class="comment"> *   A pointer to the rwlock structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_rwlock_init</span><span class="params">(<span class="type">rte_rwlock_t</span> *rwl)</span></span><br><span class="line">&#123;</span><br><span class="line">	rwl-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Take a read lock. Loop until the lock is held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rwl</span></span><br><span class="line"><span class="comment"> *   A pointer to a rwlock structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_rwlock_read_lock</span><span class="params">(<span class="type">rte_rwlock_t</span> *rwl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> x;</span><br><span class="line">	<span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (success == <span class="number">0</span>) &#123;</span><br><span class="line">		x = __atomic_load_n(&amp;rwl-&gt;cnt, __ATOMIC_RELAXED);</span><br><span class="line">		<span class="comment">/* write lock is held */</span></span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			rte_pause();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		success = __atomic_compare_exchange_n(&amp;rwl-&gt;cnt, &amp;x, x + <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">					__ATOMIC_ACQUIRE, __ATOMIC_RELAXED);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @warning</span></span><br><span class="line"><span class="comment"> * @b EXPERIMENTAL: this API may change without prior notice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * try to take a read lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rwl</span></span><br><span class="line"><span class="comment"> *   A pointer to a rwlock structure.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   - zero if the lock is successfully taken</span></span><br><span class="line"><span class="comment"> *   - -EBUSY if lock could not be acquired for reading because a</span></span><br><span class="line"><span class="comment"> *     writer holds the lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__rte_experimental <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_rwlock_read_trylock</span><span class="params">(<span class="type">rte_rwlock_t</span> *rwl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> x;</span><br><span class="line">	<span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (success == <span class="number">0</span>) &#123;</span><br><span class="line">		x = __atomic_load_n(&amp;rwl-&gt;cnt, __ATOMIC_RELAXED);</span><br><span class="line">		<span class="comment">/* write lock is held */</span></span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		success = __atomic_compare_exchange_n(&amp;rwl-&gt;cnt, &amp;x, x + <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">					__ATOMIC_ACQUIRE, __ATOMIC_RELAXED);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ret_spinlock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_spinlock_lock</span><span class="params">(<span class="type">rte_spinlock_t</span> *sl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lock_val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">			<span class="string">&quot;1:\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;xchg %[locked], %[lv]\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;test %[lv], %[lv]\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;jz 3f\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;2:\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;pause\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;cmpl $0, %[locked]\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;jnz 2b\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;jmp 1b\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;3:\n&quot;</span></span></span><br><span class="line"><span class="params">			: [locked] <span class="string">&quot;=m&quot;</span> (sl-&gt;locked), [lv] <span class="string">&quot;=q&quot;</span> (lock_val)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;[lv]&quot;</span> (lock_val)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_spinlock_unlock</span> <span class="params">(<span class="type">rte_spinlock_t</span> *sl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> unlock_val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">			<span class="string">&quot;xchg %[locked], %[ulv]\n&quot;</span></span></span><br><span class="line"><span class="params">			: [locked] <span class="string">&quot;=m&quot;</span> (sl-&gt;locked), [ulv] <span class="string">&quot;=q&quot;</span> (unlock_val)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;[ulv]&quot;</span> (unlock_val)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rte_spinlock_trylock</span> <span class="params">(<span class="type">rte_spinlock_t</span> *sl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lockval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">			<span class="string">&quot;xchg %[locked], %[lockval]&quot;</span></span></span><br><span class="line"><span class="params">			: [locked] <span class="string">&quot;=m&quot;</span> (sl-&gt;locked), [lockval] <span class="string">&quot;=q&quot;</span> (lockval)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;[lockval]&quot;</span> (lockval)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lockval == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rte_rtm_supported;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rte_tm_supported</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_rtm_supported;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rte_try_tm</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, retries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_rtm_supported)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	retries = RTE_RTM_MAX_RETRIES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (likely(retries--)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> status = rte_xbegin();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(RTE_XBEGIN_STARTED == status)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(*lock))</span><br><span class="line">				rte_xabort(RTE_XABORT_LOCK_BUSY);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (*lock)</span><br><span class="line">			rte_pause();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((status &amp; RTE_XABORT_CONFLICT) ||</span><br><span class="line">		   ((status &amp; RTE_XABORT_EXPLICIT) &amp;&amp;</span><br><span class="line">		    (RTE_XABORT_CODE(status) == RTE_XABORT_LOCK_BUSY))) &#123;</span><br><span class="line">			<span class="comment">/* add a small delay before retrying, basing the</span></span><br><span class="line"><span class="comment">			 * delay on the number of times we&#x27;ve already tried,</span></span><br><span class="line"><span class="comment">			 * to give a back-off type of behaviour. We</span></span><br><span class="line"><span class="comment">			 * randomize trycount by taking bits from the tsc count</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">int</span> try_count = RTE_RTM_MAX_RETRIES - retries;</span><br><span class="line">			<span class="type">int</span> pause_count = (rte_rdtsc() &amp; <span class="number">0x7</span>) | <span class="number">1</span>;</span><br><span class="line">			pause_count &lt;&lt;= try_count;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pause_count; i++)</span><br><span class="line">				rte_pause();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((status &amp; RTE_XABORT_RETRY) == <span class="number">0</span>) <span class="comment">/* do not retry */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_spinlock_lock_tm</span><span class="params">(<span class="type">rte_spinlock_t</span> *sl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(rte_try_tm(&amp;sl-&gt;locked)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rte_spinlock_lock(sl); <span class="comment">/* fall-back */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DPDK 无锁队列<br>这里多说一句，DPDK 的无锁队列是通过 CAS 来实现的，目前无锁队列也是应用 CAS 最广泛的一种应用。这个队列在前面分析过，这里就不再重贴代码了。</p>
<h1 id="DPDK-对网络数据的处理"><a href="#DPDK-对网络数据的处理" class="headerlink" title="DPDK 对网络数据的处理"></a>DPDK 对网络数据的处理</h1><p>DPDK 中对网络数据的处理主要有以下几个方面，涉及到从硬件（网卡等）到数据通信（DMA 等）；从基础数据包到上层分发处理队列；从 IO 处理到性能优化等等多个方面。<br>1、基础数据包的转发<br>也就是数据报文的转发就是最基础的网络数据的转发，它涉及到报文的输入、输出、调度、缓存等方方面面。  </p>
<p>2、IO 处理<br>在计算机中，目前 PCIe 是 CPU 和 IO 通信的重要总线。一般来说，在计算机，限制 IO 速度的除了 IO 通信本身的速度外，计算机总线的带宽也是一个重要的瓶颈。在 DPDK 中对其进行了淡民的优化并且使用 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=DMA&spm=1001.2101.3001.7020">DMA</a> 等技术尽量减少中间环节提高通信效率。  </p>
<p>3、硬件优化<br>特别是网卡的优化，是重中之重。在计算软件的设计中，有一个原则，就是最小功能原则，自己只管自己的事。这从设计一般来说是最优的，但在性能角度未必。DPDK 就是抓住了这一点，把网卡等硬件整体来看，通过一系列的软件设计和硬件优化达到了一个整体的最优的效果。  </p>
<p>4、流分类和多队列技术<br>网卡多队列技术是指一个网卡上的 DMA 队列有多个，即网卡有基于多个 DMA 队列分配的机制。而流分类则是指网卡可根据具体的网络数据包的性质将其分成不同的类型的技术。前者很好理解，多队列意味着数据包转发可以并行进行；而后者稍微难以理解，其实分析后就明白了。流分类和多队列技术是一个衔接匹配的流程，只有将原始数据包可以根据一定类别进行分类，才可以有针对性的对某些数据进行加速或者优化。比如实时控制数据，就可以专门分流出来引导入一个专门的队列进行数据处理。</p>
<p>5、软件定义网络和硬件加速和卸载<br>软件定义网络（SDN）是指抽象出控制平面、数据平面、管理平面三个不同的层，通过分层实现网络流量的灵活控制，使网络更加智能并提供一个应用创新的良好平台。它其实就是网络虚拟化的一种实现形式。<br>硬件卸载是指将某些任务或计算从计算机的 CPU 转移到专用硬件组件（例如 NIC 或 GPU 等硬件专门芯片）的过程，以提高系统性能和效率。<br>软件定义网络相当抽象，大家可以简单理解为一种网络虚拟化，和硬件虚拟化有些类似，只是抽象的层次更高一些。而硬件卸载主要是不要被名字卸载误导，硬件卸载指的是对主流的混合处理单元（如 CPU 等）进行功能卸载，卸载的功能由于处理呢？即专门的硬件芯片也就是刚刚提到的网卡或者 GPU 等。<br>前者的意义不必多说，后者主要是降低了 CPU 与网卡等的来回通信浪费的时间，一种很好的优化手段。</p>
<h1 id="网络报文处理"><a href="#网络报文处理" class="headerlink" title="网络报文处理"></a>网络报文处理</h1><p>学过网络通信的都知道，其实在网络的底层数据就是一包（帧）包的。换句话说，所有的网络设备转发的其实就是一包包的二进制流数据。对设备或者驱动来说，这些数据没有什么任何意义，它们只是负责进行检验、处理、转发。说白了就像一个个的物流中转站，它只管看看包裹是否损坏，发往何地，然后扔到指定的传送带上即可。网络上的数据包也是如此。<br>现实世界中，当双 11 时，包裹量大增，物流中心也得搞一些处理的方法，或者加人加机器或者改善流程，更或者直接升级物流设备采用机器人自动仓储。同样，对于网络世界，也是如此，它会从软件到硬件有一个完整的数据处理的流程，包括应用框架，算法以及后面要提到的硬件的处理等等。<br>那么首先这里要先弄明白网络处理模块有哪些：  </p>
<p>1、首先得有输入输出模块，这是网络吞吐的接口即：<br>Packet input： 报文输入<br>Packet output： 硬件发出  </p>
<p>2、然后需要对报文进行处理：<br>Pre-processing： 报文比较粗粒度处理<br>Input classification： 报文较细粒度分流  </p>
<p>3、然后是数据管理和控制模块：<br>Ingress queuing： 提供基于描述符的队列 FIFO<br>Delivery&#x2F;Scheduling： 根据队列优先级和 CPU 状态进行调度<br>Accelerator： 提供加解密和压缩 &#x2F; 解压缩等硬件功能<br>Egress queueing： 在出口上根据 QOS 等级进行调度  </p>
<p>4、完成后清扫现场<br>Post processing： 后期报文处理释放缓存<br>其实把这些模块按功能逻辑一划分，立刻就明白了，这比画张图还好理解。</p>
<h2 id="转发应用框架"><a href="#转发应用框架" class="headerlink" title="转发应用框架"></a>转发应用框架</h2><p>说到应该框架就要谈到转发模型，一提到模型，大家就基本可以明白了，如果没有明显的技术突破，模型基本是不会动的。所以这里用到的模型有两种：  </p>
<h3 id="Pipleline-模型（Packet-Framework）"><a href="#Pipleline-模型（Packet-Framework）" class="headerlink" title="Pipleline 模型（Packet Framework）"></a>Pipleline 模型（Packet Framework）</h3><p>Pipeline 很好理解，计算机的 CPU 中使用就是这种流水模型。流水模型非常适合于一些有节奏的有规律的工作。比如对 CPU 密集型应用和 IO 密集型应用可以分别用不同的引擎来处理。在 DPDK 中，其可以按功能分成 zoom out（多核应用框架）和 zoom in（单个流水线模块）。<br>在这些模块中，通过使用三部分即逻辑端口、查找表和处理逻辑单元来实现对 Pipeline 的报文处理。端口做为每流水单元的模块输入，而通过查找表来确定处理方法，而处理逻辑则决定了报文的处理和最终流向。这样，一层层的堆叠，就形成了一个 Pipeline。<br>DPDK 支持的 Pipeline 有以下几种：<br>Packet I&#x2F;O<br>Flow classification<br>Firewall<br>Routing<br>Metering<br>Traffic Mgmt<br>这些 Pipeline 都可以简单的通过配置文件来使用其进行应用。但是这种模型由于流水的限制，不容易进行扩展，对多核支持的也不如 RTC 好。</p>
<h3 id="run-to-completion-模型（RTC）"><a href="#run-to-completion-模型（RTC）" class="headerlink" title="run to completion 模型（RTC）"></a>run to completion 模型（RTC）</h3><p>看到这个模型，写过网络编程的小伙伴是不是想到了 IOCP，完成端口，这两还真得非常类似，说白了都是为了充分挖掘多核的优势。它对于处理一些上下文逻辑关系并行的数据流则非常有优势，它可以充分使用各个核心动态的分配处理各个逻辑层，并且很容易进行扩展。<br>在 DPDK 中可以通过参数指令将核心绑定到线程上，这样，不同的数据收发队列就可以与逻辑核心，从而保证一个报文只能在一个线程中进行处理。同时，通用的处理器单元使得编程也变得更简单。</p>
<p>通过上面分析，其实可以总结出来，对于并行度要求高但优化处理不高的报文，可以使用 RTC 模型；反之可以使用 Pipeline 模型。前者更适合于高并发的短连接后者更适合于长连接连续数据处理，方便进行优化动作。</p>
<h3 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h3><p>相关的算法就比较简单了，主要有以下几种：<br>1、精确匹配算法<br>从名字就可以看出来，直接就可以匹配上，精确配对。在网络中常用的就是哈希。不管你是哪种哈希，反正是哈希。应用哈希就需要解决哈希冲突的问题，常用的还是两种，链表和开放地址。这些都是老生常谈，不再赘述。<br>同样在 DPDK 中对哈希的校验也进行了优化，对字节对齐进行了处理。然后使用不同的硬件指令一次处理相关校验或者在无法使用硬件时使用查表的方法进行，这是典型的空间换时间。  </p>
<p>2、最长匹配算法<br>最长前缀匹配（Longest Prefix Matching, LPM）算法是指在 IP 协议中被路由器用于在路由表中进行选择的一个算法。这个算法也很常见，在密码学和网络中经常可以用到。一般比较常用的是 LPM 算法。</p>
<p>3、ACL 算法<br>ACL 算法其实就是通过访问一个控制库，利用分类规则来对输入的数据包进行处理分类。ACL 库利用 N 元组的匹配规则进行类型匹配，提供如下操作：<br>创建 AC（access domain） 的上下文<br>加规则到 AC 的上下文中<br>对于所有规则创建相关的结构体<br>进行入方向报文分类<br>销毁 AC 相关的资源</p>
<h3 id="报文分发"><a href="#报文分发" class="headerlink" title="报文分发"></a>报文分发</h3><p>DPDK 中提供了一套报文转发的库和 API，它的原理基本上就是通过 distributor 分发给不同的工作者 Worker。而 distributor 则从 Mbuf 中拿到相关数据。这样，就形成了一个完整的分发流程。</p>
<p>下面看一下 DPDK 中相关的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dpdk-stable-19.11.14\lib\librte_eventdev</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rte_eventdev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rte_eventdev_pmd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> <span class="title">rte_event_devices</span>[<span class="title">RTE_EVENT_MAX_DEVS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">rte_eventdevs</span> =</span> rte_event_devices;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev_global</span> <span class="title">eventdev_globals</span> =</span> &#123;</span><br><span class="line">	.nb_devs		= <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Event dev north bound API implementation */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">rte_event_dev_count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> eventdev_globals.nb_devs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_dev_get_dev_id</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">uint8_t</span> cmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eventdev_globals.nb_devs; i++) &#123;</span><br><span class="line">		cmp = (<span class="built_in">strncmp</span>(rte_event_devices[i].data-&gt;name, name,</span><br><span class="line">				RTE_EVENTDEV_NAME_MAX_LEN) == <span class="number">0</span>) ||</span><br><span class="line">			(rte_event_devices[i].dev ? (<span class="built_in">strncmp</span>(</span><br><span class="line">				rte_event_devices[i].dev-&gt;driver-&gt;name, name,</span><br><span class="line">					 RTE_EVENTDEV_NAME_MAX_LEN) == <span class="number">0</span>) : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (cmp &amp;&amp; (rte_event_devices[i].attached ==</span><br><span class="line">					RTE_EVENTDEV_ATTACHED))</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_dev_socket_id</span><span class="params">(<span class="type">uint8_t</span> dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERR_RET(dev_id, -EINVAL);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;data-&gt;socket_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_dev_info_get</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="keyword">struct</span> rte_event_dev_info *dev_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERR_RET(dev_id, -EINVAL);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dev_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_event_dev_info));</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;dev_infos_get, -ENOTSUP);</span><br><span class="line">	(*dev-&gt;dev_ops-&gt;dev_infos_get)(dev, dev_info);</span><br><span class="line"></span><br><span class="line">	dev_info-&gt;dequeue_timeout_ns = dev-&gt;data-&gt;dev_conf.dequeue_timeout_ns;</span><br><span class="line"></span><br><span class="line">	dev_info-&gt;dev = dev-&gt;dev;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_port_link</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint8_t</span> port_id,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="type">uint8_t</span> queues[], <span class="type">const</span> <span class="type">uint8_t</span> priorities[],</span></span><br><span class="line"><span class="params">		    <span class="type">uint16_t</span> nb_links)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">uint8_t</span> queues_list[RTE_EVENT_MAX_QUEUES_PER_DEV];</span><br><span class="line">	<span class="type">uint8_t</span> priorities_list[RTE_EVENT_MAX_QUEUES_PER_DEV];</span><br><span class="line">	<span class="type">uint16_t</span> *links_map;</span><br><span class="line">	<span class="type">int</span> i, diag;</span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERRNO_RET(dev_id, EINVAL, <span class="number">0</span>);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*dev-&gt;dev_ops-&gt;port_link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Function not supported\n&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_port(dev, port_id)) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Invalid port_id=%&quot;</span> PRIu8, port_id);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queues == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_queues; i++)</span><br><span class="line">			queues_list[i] = i;</span><br><span class="line"></span><br><span class="line">		queues = queues_list;</span><br><span class="line">		nb_links = dev-&gt;data-&gt;nb_queues;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priorities == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_links; i++)</span><br><span class="line">			priorities_list[i] = RTE_EVENT_DEV_PRIORITY_NORMAL;</span><br><span class="line"></span><br><span class="line">		priorities = priorities_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_links; i++)</span><br><span class="line">		<span class="keyword">if</span> (queues[i] &gt;= dev-&gt;data-&gt;nb_queues) &#123;</span><br><span class="line">			rte_errno = EINVAL;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;port_link)(dev, dev-&gt;data-&gt;ports[port_id],</span><br><span class="line">						queues, priorities, nb_links);</span><br><span class="line">	<span class="keyword">if</span> (diag &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> diag;</span><br><span class="line"></span><br><span class="line">	links_map = dev-&gt;data-&gt;links_map;</span><br><span class="line">	<span class="comment">/* Point links_map to this port specific area */</span></span><br><span class="line">	links_map += (port_id * RTE_EVENT_MAX_QUEUES_PER_DEV);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; diag; i++)</span><br><span class="line">		links_map[queues[i]] = (<span class="type">uint8_t</span>)priorities[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_port_unlink</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint8_t</span> port_id,</span></span><br><span class="line"><span class="params">		      <span class="type">uint8_t</span> queues[], <span class="type">uint16_t</span> nb_unlinks)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">uint8_t</span> all_queues[RTE_EVENT_MAX_QUEUES_PER_DEV];</span><br><span class="line">	<span class="type">int</span> i, diag, j;</span><br><span class="line">	<span class="type">uint16_t</span> *links_map;</span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERRNO_RET(dev_id, EINVAL, <span class="number">0</span>);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*dev-&gt;dev_ops-&gt;port_unlink == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Function not supported&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_port(dev, port_id)) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Invalid port_id=%&quot;</span> PRIu8, port_id);</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	links_map = dev-&gt;data-&gt;links_map;</span><br><span class="line">	<span class="comment">/* Point links_map to this port specific area */</span></span><br><span class="line">	links_map += (port_id * RTE_EVENT_MAX_QUEUES_PER_DEV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queues == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_queues; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (links_map[i] !=</span><br><span class="line">					EVENT_QUEUE_SERVICE_PRIORITY_INVALID) &#123;</span><br><span class="line">				all_queues[j] = i;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		queues = all_queues;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nb_unlinks; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (links_map[queues[j]] ==</span><br><span class="line">					EVENT_QUEUE_SERVICE_PRIORITY_INVALID)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nb_unlinks = j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_unlinks; i++)</span><br><span class="line">		<span class="keyword">if</span> (queues[i] &gt;= dev-&gt;data-&gt;nb_queues) &#123;</span><br><span class="line">			rte_errno = EINVAL;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;port_unlink)(dev, dev-&gt;data-&gt;ports[port_id],</span><br><span class="line">					queues, nb_unlinks);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (diag &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> diag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; diag; i++)</span><br><span class="line">		links_map[queues[i]] = EVENT_QUEUE_SERVICE_PRIORITY_INVALID;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_port_unlinks_in_progress</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint8_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERR_RET(dev_id, -EINVAL);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line">	<span class="keyword">if</span> (!is_valid_port(dev, port_id)) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Invalid port_id=%&quot;</span> PRIu8, port_id);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return 0 if the PMD does not implement unlinks in progress.</span></span><br><span class="line"><span class="comment">	 * This allows PMDs which handle unlink synchronously to not implement</span></span><br><span class="line"><span class="comment">	 * this function at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;port_unlinks_in_progress, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_ops-&gt;port_unlinks_in_progress)(dev,</span><br><span class="line">			dev-&gt;data-&gt;ports[port_id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_port_links_get</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint8_t</span> port_id,</span></span><br><span class="line"><span class="params">			 <span class="type">uint8_t</span> queues[], <span class="type">uint8_t</span> priorities[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> *links_map;</span><br><span class="line">	<span class="type">int</span> i, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERR_RET(dev_id, -EINVAL);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line">	<span class="keyword">if</span> (!is_valid_port(dev, port_id)) &#123;</span><br><span class="line">		RTE_EDEV_LOG_ERR(<span class="string">&quot;Invalid port_id=%&quot;</span> PRIu8, port_id);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	links_map = dev-&gt;data-&gt;links_map;</span><br><span class="line">	<span class="comment">/* Point links_map to this port specific area */</span></span><br><span class="line">	links_map += (port_id * RTE_EVENT_MAX_QUEUES_PER_DEV);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_queues; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (links_map[i] != EVENT_QUEUE_SERVICE_PRIORITY_INVALID) &#123;</span><br><span class="line">			queues[count] = i;</span><br><span class="line">			priorities[count] = (<span class="type">uint8_t</span>)links_map[i];</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_event_dequeue_timeout_ticks</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint64_t</span> ns,</span></span><br><span class="line"><span class="params">				 <span class="type">uint64_t</span> *timeout_ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eventdev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_EVENTDEV_VALID_DEVID_OR_ERR_RET(dev_id, -EINVAL);</span><br><span class="line">	dev = &amp;rte_eventdevs[dev_id];</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;timeout_ticks, -ENOTSUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeout_ticks == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_ops-&gt;timeout_ticks)(dev, ns, timeout_ticks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实其核心的两组 API 一个在 rte_eventdev.c 和 rte_service.c 中，上面是前者，下面看看后者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;eal_private.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_SERVICE_NUM_MAX 64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_REGISTERED    (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_STATS_ENABLED (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_START_CHECK   (1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* runstates for services and lcores, denoting if they are active or not */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNSTATE_STOPPED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNSTATE_RUNNING 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal representation of a service */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec_impl</span> &#123;</span></span><br><span class="line">	<span class="comment">/* public part of the struct */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec</span> <span class="title">spec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* atomic lock that when set indicates a service core is currently</span></span><br><span class="line"><span class="comment">	 * running this service callback. When not set, a core may take the</span></span><br><span class="line"><span class="comment">	 * lock and then run the service callback.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_atomic32_t</span> execute_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* API set/get-able variables */</span></span><br><span class="line">	<span class="type">int8_t</span> app_runstate;</span><br><span class="line">	<span class="type">int8_t</span> comp_runstate;</span><br><span class="line">	<span class="type">uint8_t</span> internal_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* per service statistics */</span></span><br><span class="line">	<span class="comment">/* Indicates how many cores the service is mapped to run on.</span></span><br><span class="line"><span class="comment">	 * It does not indicate the number of cores the service is running</span></span><br><span class="line"><span class="comment">	 * on currently.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_atomic32_t</span> num_mapped_cores;</span><br><span class="line">	<span class="type">uint64_t</span> calls;</span><br><span class="line">	<span class="type">uint64_t</span> cycles_spent;</span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the internal values of a service core */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> &#123;</span></span><br><span class="line">	<span class="comment">/* map of services IDs are run on this core */</span></span><br><span class="line">	<span class="type">uint64_t</span> service_mask;</span><br><span class="line">	<span class="type">uint8_t</span> runstate; <span class="comment">/* running or stopped */</span></span><br><span class="line">	<span class="type">uint8_t</span> is_service_core; <span class="comment">/* set if core is currently a service core */</span></span><br><span class="line">	<span class="type">uint8_t</span> service_active_on_lcore[RTE_SERVICE_NUM_MAX];</span><br><span class="line">	<span class="type">uint64_t</span> loops;</span><br><span class="line">	<span class="type">uint64_t</span> calls_per_service[RTE_SERVICE_NUM_MAX];</span><br><span class="line">&#125; __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> rte_service_count;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec_impl</span> *<span class="title">rte_services</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">lcore_states</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> rte_service_library_initialized;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (rte_service_library_initialized) &#123;</span><br><span class="line">		RTE_LOG(NOTICE, EAL,</span><br><span class="line">			<span class="string">&quot;service library init() called, init flag %d\n&quot;</span>,</span><br><span class="line">			rte_service_library_initialized);</span><br><span class="line">		<span class="keyword">return</span> -EALREADY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_services = rte_calloc(<span class="string">&quot;rte_services&quot;</span>, RTE_SERVICE_NUM_MAX,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_service_spec_impl),</span><br><span class="line">			RTE_CACHE_LINE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!rte_services) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;error allocating rte services array\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lcore_states = rte_calloc(<span class="string">&quot;rte_service_core_states&quot;</span>, RTE_MAX_LCORE,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> core_state), RTE_CACHE_LINE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!lcore_states) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;error allocating core states array\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail_mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">cfg</span> =</span> rte_eal_get_configuration();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_LCORE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_config[i].core_role == ROLE_SERVICE) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)i == cfg-&gt;master_lcore)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			rte_service_lcore_add(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_service_library_initialized = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_mem:</span><br><span class="line">	rte_free(rte_services);</span><br><span class="line">	rte_free(lcore_states);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">service_runner_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	RTE_SET_USED(arg);</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> lcore = rte_lcore_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">cs</span> =</span> &amp;lcore_states[lcore];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cs-&gt;runstate == RUNSTATE_RUNNING) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">uint64_t</span> service_mask = cs-&gt;service_mask;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_SERVICE_NUM_MAX; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!service_valid(i))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">/* return value ignored as no change to code flow */</span></span><br><span class="line">			service_run(i, cs, service_mask, service_get(i), <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cs-&gt;loops++;</span><br><span class="line"></span><br><span class="line">		rte_smp_rmb();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Switch off this core for all services, to ensure that future</span></span><br><span class="line"><span class="comment">	 * calls to may_be_active() know this core is switched off.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_SERVICE_NUM_MAX; i++)</span><br><span class="line">		cs-&gt;service_active_on_lcore[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_LCORE; i++)</span><br><span class="line">		count += lcore_states[i].is_service_core;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_list</span><span class="params">(<span class="type">uint32_t</span> <span class="built_in">array</span>[], <span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> count = rte_service_lcore_count();</span><br><span class="line">	<span class="keyword">if</span> (count &gt; n)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="type">uint32_t</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_LCORE; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">cs</span> =</span> &amp;lcore_states[i];</span><br><span class="line">		<span class="keyword">if</span> (cs-&gt;is_service_core) &#123;</span><br><span class="line">			<span class="built_in">array</span>[idx] = i;</span><br><span class="line">			idx++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_count_services</span><span class="params">(<span class="type">uint32_t</span> lcore)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">cs</span> =</span> &amp;lcore_states[lcore];</span><br><span class="line">	<span class="keyword">if</span> (!cs-&gt;is_service_core)</span><br><span class="line">		<span class="keyword">return</span> -ENOTSUP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __builtin_popcountll(cs-&gt;service_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_start_with_defaults</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* create a default mapping from cores to services, then start the</span></span><br><span class="line"><span class="comment">	 * services to make them transparent to unaware applications.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">uint32_t</span> count = rte_service_get_count();</span><br><span class="line"></span><br><span class="line">	<span class="type">int32_t</span> lcore_iter = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> ids[RTE_MAX_LCORE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int32_t</span> lcore_count = rte_service_lcore_list(ids, RTE_MAX_LCORE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lcore_count == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOTSUP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; (<span class="type">int</span>)i &lt; lcore_count; i++)</span><br><span class="line">		rte_service_lcore_start(ids[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="comment">/* do 1:1 core mapping here, with each service getting</span></span><br><span class="line"><span class="comment">		 * assigned a single core by default. Adding multiple services</span></span><br><span class="line"><span class="comment">		 * should multiplex to a single core, or 1:1 if there are the</span></span><br><span class="line"><span class="comment">		 * same amount of services as service-cores</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = rte_service_map_lcore_set(i, ids[lcore_iter], <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">		lcore_iter++;</span><br><span class="line">		<span class="keyword">if</span> (lcore_iter &gt;= lcore_count)</span><br><span class="line">			lcore_iter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ret = rte_service_runstate_set(i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> -ENOEXEC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">service_update</span><span class="params">(<span class="keyword">struct</span> rte_service_spec *service, <span class="type">uint32_t</span> lcore,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> *<span class="built_in">set</span>, <span class="type">uint32_t</span> *enabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="type">int32_t</span> sid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_SERVICE_NUM_MAX; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">struct</span> rte_service_spec *)&amp;rte_services[i] == service &amp;&amp;</span><br><span class="line">				service_valid(i)) &#123;</span><br><span class="line">			sid = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sid == <span class="number">-1</span> || lcore &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!lcore_states[lcore].is_service_core)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> sid_mask = UINT64_C(<span class="number">1</span>) &lt;&lt; sid;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">set</span>) &#123;</span><br><span class="line">		<span class="type">uint64_t</span> lcore_mapped = lcore_states[lcore].service_mask &amp;</span><br><span class="line">			sid_mask;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*<span class="built_in">set</span> &amp;&amp; !lcore_mapped) &#123;</span><br><span class="line">			lcore_states[lcore].service_mask |= sid_mask;</span><br><span class="line">			rte_atomic32_inc(&amp;rte_services[sid].num_mapped_cores);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!*<span class="built_in">set</span> &amp;&amp; lcore_mapped) &#123;</span><br><span class="line">			lcore_states[lcore].service_mask &amp;= ~(sid_mask);</span><br><span class="line">			rte_atomic32_dec(&amp;rte_services[sid].num_mapped_cores);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (enabled)</span><br><span class="line">		*enabled = !!(lcore_states[lcore].service_mask &amp; (sid_mask));</span><br><span class="line"></span><br><span class="line">	rte_smp_wmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_map_lcore_set</span><span class="params">(<span class="type">uint32_t</span> id, <span class="type">uint32_t</span> lcore, <span class="type">uint32_t</span> enabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec_impl</span> *<span class="title">s</span>;</span></span><br><span class="line">	SERVICE_VALID_GET_OR_ERR_RET(id, s, -EINVAL);</span><br><span class="line">	<span class="type">uint32_t</span> on = enabled &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> service_update(&amp;s-&gt;spec, lcore, &amp;on, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_map_lcore_get</span><span class="params">(<span class="type">uint32_t</span> id, <span class="type">uint32_t</span> lcore)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec_impl</span> *<span class="title">s</span>;</span></span><br><span class="line">	SERVICE_VALID_GET_OR_ERR_RET(id, s, -EINVAL);</span><br><span class="line">	<span class="type">uint32_t</span> enabled;</span><br><span class="line">	<span class="type">int</span> ret = service_update(&amp;s-&gt;spec, lcore, <span class="number">0</span>, &amp;enabled);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> enabled;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_lcore_state</span><span class="params">(<span class="type">uint32_t</span> lcore, <span class="type">int32_t</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* mark core state in hugepage backed config */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_config</span> *<span class="title">cfg</span> =</span> rte_eal_get_configuration();</span><br><span class="line">	cfg-&gt;lcore_role[lcore] = state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mark state in process local lcore_config */</span></span><br><span class="line">	lcore_config[lcore].core_role = state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update per-lcore optimized state tracking */</span></span><br><span class="line">	lcore_states[lcore].is_service_core = (state == ROLE_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_reset_all</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* loop over cores, reset all to mask 0 */</span></span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_MAX_LCORE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcore_states[i].is_service_core) &#123;</span><br><span class="line">			lcore_states[i].service_mask = <span class="number">0</span>;</span><br><span class="line">			set_lcore_state(i, ROLE_RTE);</span><br><span class="line">			lcore_states[i].runstate = RUNSTATE_STOPPED;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_SERVICE_NUM_MAX; i++)</span><br><span class="line">		rte_atomic32_set(&amp;rte_services[i].num_mapped_cores, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rte_smp_wmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_add</span><span class="params">(<span class="type">uint32_t</span> lcore)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (lcore_states[lcore].is_service_core)</span><br><span class="line">		<span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line">	set_lcore_state(lcore, ROLE_SERVICE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ensure that after adding a core the mask and state are defaults */</span></span><br><span class="line">	lcore_states[lcore].service_mask = <span class="number">0</span>;</span><br><span class="line">	lcore_states[lcore].runstate = RUNSTATE_STOPPED;</span><br><span class="line"></span><br><span class="line">	rte_smp_wmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rte_eal_wait_lcore(lcore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_del</span><span class="params">(<span class="type">uint32_t</span> lcore)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">cs</span> =</span> &amp;lcore_states[lcore];</span><br><span class="line">	<span class="keyword">if</span> (!cs-&gt;is_service_core)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cs-&gt;runstate != RUNSTATE_STOPPED)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	set_lcore_state(lcore, ROLE_RTE);</span><br><span class="line"></span><br><span class="line">	rte_smp_wmb();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_start</span><span class="params">(<span class="type">uint32_t</span> lcore)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lcore &gt;= RTE_MAX_LCORE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">cs</span> =</span> &amp;lcore_states[lcore];</span><br><span class="line">	<span class="keyword">if</span> (!cs-&gt;is_service_core)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cs-&gt;runstate == RUNSTATE_RUNNING)</span><br><span class="line">		<span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set core to run state first, and then launch otherwise it will</span></span><br><span class="line"><span class="comment">	 * return immediately as runstate keeps it in the service poll loop</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cs-&gt;runstate = RUNSTATE_RUNNING;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = rte_eal_remote_launch(service_runner_func, <span class="number">0</span>, lcore);</span><br><span class="line">	<span class="comment">/* returns -EBUSY if the core is already launched, 0 on success */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>





<h1 id="PCIe-总线和-DMA-及缓存"><a href="#PCIe-总线和-DMA-及缓存" class="headerlink" title="PCIe 总线和 DMA 及缓存"></a>PCIe 总线和 DMA 及缓存</h1><p>如果一条通信链路要想达到最优的效果，一定是整体上每个环节都要有最佳的节奏协调控制而不一定是每个环节都是最优。这个在计算机的数据处理上就更是明显。一般来说，IO 的速度是最低的，至少在可见的时光里要想超越 CPU 和内存还是很难的。<br>以网卡通信为例，网卡本身就 IO 传输，然后通过总线传输进入内存，内存进缓存，缓存到 CPU，然后再原路一个反馈。学过计算机的一般都知道，这里面涉及到的几个部分，数据的处理速度那是有着量层级上的差异的。所以在处理问题上有三条思路：<br>一是把短板补齐，也就是那个慢把哪个速度提起来。这其中就包含着近些年来，不断提高的 IO 处理速度和总线处理速度（CPU 的速度提高反而不太明显，主要是横向扩展）；二是把不必要的中间环节去除，也就是本来是 ABCD，是不是有可能把 BC 去除，直接让 AD 通信；三是通过软件优化，最大化的利用硬件资源（并行等）。<br>一般来说，这就是目前优化的三个主要的思路，在 DPDK 中，基本也是延着这两条思路前进的。不过，前者可能不是 DPDK 所能控制的，其更重要的是朝着后二种前进。</p>
<p>PCI Express,Peripheral Component Interconnect Express(PCIe), 是一种高速串联通信标准。目前的最新版本是 7.0, 但主流的标准应该 3.0 和 4.0 居多。PCIe 主要用来连接显卡、固态硬盘以及采集卡和无线网卡等外设，用来为高速外设进行数据传输。<br>直接内存访问（DMA，Direct Memory Access），主要是绕过 CPU，直接与 IO 进行数据通信。<br>缓存就更好理解了，Cache 一般使用 SRAM 静态存储器，用来做为主存与 CPU 速度不匹配的一种缓冲存储（缓存的速度已经很接近 CPU 的处理速度），其重要指标就是命中率。</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>这里不展开具体的 PCIe 及相关的 DMA 等的数据传输细节。一般来说，支持的 PCIe 的版本越高，其数据传输的速度越快，即使扣除相关的协议开销和控制指令等的开销后，其对数据传输的瓶颈解决越明显。但光其一个最优不行，中间的其它传输也要共同优化，节奏相同。<br>DMA 是通过环形队列与 CPU 交互（利用 DDIO 技术减少对主存的访问次数），环形队列一般学过算法的都清楚怎么回事。而为了提高数据访问的速度，环形队列缓冲区的大小必须是网卡支持最大 Cache line（128B）的整数倍，这样做的目的当然是为了方便内存对齐，即提高访问效率，效率高了自然速度就上来了。<br>正常的网卡驱动通信一般是以下几步：<br>1、将缓冲地址写到地址描述符<br>2、移动队列尾指针到指定位置<br>3、判断描述符中的状态位是否完成，如果是接收还要申请新的缓冲区；发送则需要释放已发送缓冲区；这些其实都是一些头尾的动作<br>4、一些处理操作，如描述符的内容更新和控制头的解析等</p>
<h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><p>刚刚提到了，某个局部最优并不一定是整体的最优解，所以要处理好数据传输，一个重要的问题是要处理好数据在各个环节的转发的问题。在网卡通信中，最重的是将 CPU 中的缓存与 IO 的通信整体协调好。<br>那么，首先要理顺一下，在这个通信过程中需要哪几个环节协调。首先，CPU 面对的主存和外部寄存器。而对 DMA 来说就是主存和 Cache。而它们之间的数据需要 PCIe 来传输，所以优化的手段就明晰了：<br>1、减少对外部寄存器 MMIO 的读取<br>2、提高 PCIe 的效率，即在固定的带宽下，如何最大程度的利用满<br>3、减少 Cache 的部分写<br>这都比较好理解，先从最后一个说起，Cache 的内存未对齐，也就是部分写，会导致对缓存的二次操作，效率至少降低一半。而余下二者其实类似于批处理，把单次的操作改成多次合成，减少相关的控制和协议处理，自然可以提高数据的传输速度。<br>在 DPDK 中，使用 Mbuf 来处理网络数据帧。而在网络帧的处理上有两种情况，一种是将元数据和数据同时存放；另外一个是将二者分开存放。这样说有点不直白，其实就是空间利用率和时间利用率（效率）的二者的权衡。前者又更好的利用内存空间而后者则能够在浪费一部分内存的情况下更好的提高数据转发效率。DPDK 当然选择了后者。<br>而为了更好的利用内存，将 Mbuf 形成一个内存池（双环形缓冲区），DPDK 为应对多核的情况，允许每个 CPU 缓存一部分缓冲区。然后在写时进行 CAS 操作处理。当然，这样做的缺点和上面一样，也会浪费一部分缓存。</p>
<p>上面把相关的内容理顺了一下，这样再和源码匹配就好理解了。前面的队列和 Mbuf 等进行过分析，这里只讲一些整体上的源码流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dpdk-stable-19.11.14\lib\librte_eal\linux\eal\eal_vfio.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">vfio_type1_dma_mem_map</span><span class="params">(<span class="type">int</span> vfio_container_fd, <span class="type">uint64_t</span> vaddr, <span class="type">uint64_t</span> iova,</span></span><br><span class="line"><span class="params">		<span class="type">uint64_t</span> len, <span class="type">int</span> do_map)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type1_dma_map</span> <span class="title">dma_map</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type1_dma_unmap</span> <span class="title">dma_unmap</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (do_map != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;dma_map, <span class="number">0</span>, <span class="keyword">sizeof</span>(dma_map));</span><br><span class="line">		dma_map.argsz = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vfio_iommu_type1_dma_map);</span><br><span class="line">		dma_map.vaddr = vaddr;</span><br><span class="line">		dma_map.size = len;</span><br><span class="line">		dma_map.iova = iova;</span><br><span class="line">		dma_map.flags = VFIO_DMA_MAP_FLAG_READ |</span><br><span class="line">				VFIO_DMA_MAP_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line">		ret = ioctl(vfio_container_fd, VFIO_IOMMU_MAP_DMA, &amp;dma_map);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * In case the mapping was already done EEXIST will be</span></span><br><span class="line"><span class="comment">			 * returned from kernel.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (errno == EEXIST) &#123;</span><br><span class="line">				RTE_LOG(DEBUG, EAL,</span><br><span class="line">					<span class="string">&quot; Memory segment is already mapped,&quot;</span></span><br><span class="line">					<span class="string">&quot; skipping&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL,</span><br><span class="line">					<span class="string">&quot;  cannot set up DMA remapping,&quot;</span></span><br><span class="line">					<span class="string">&quot; error %i (%s)\n&quot;</span>,</span><br><span class="line">					errno, strerror(errno));</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;dma_unmap, <span class="number">0</span>, <span class="keyword">sizeof</span>(dma_unmap));</span><br><span class="line">		dma_unmap.argsz = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vfio_iommu_type1_dma_unmap);</span><br><span class="line">		dma_unmap.size = len;</span><br><span class="line">		dma_unmap.iova = iova;</span><br><span class="line"></span><br><span class="line">		ret = ioctl(vfio_container_fd, VFIO_IOMMU_UNMAP_DMA,</span><br><span class="line">				&amp;dma_unmap);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;  cannot clear DMA remapping, error %i (%s)\n&quot;</span>,</span><br><span class="line">					errno, strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dma_unmap.size != len) &#123;</span><br><span class="line">			RTE_LOG(ERR, EAL, <span class="string">&quot;  unexpected size %&quot;</span>PRIu64<span class="string">&quot; of DMA &quot;</span></span><br><span class="line">				<span class="string">&quot;remapping cleared instead of %&quot;</span>PRIu64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">				(<span class="type">uint64_t</span>)dma_unmap.size, len);</span><br><span class="line">			rte_errno = EIO;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vfio_type1_dma_map</span><span class="params">(<span class="type">int</span> vfio_container_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (rte_eal_iova_mode() == RTE_IOVA_VA) &#123;</span><br><span class="line">		<span class="comment">/* with IOVA as VA mode, we can get away with mapping contiguous</span></span><br><span class="line"><span class="comment">		 * chunks rather than going page-by-page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">int</span> ret = rte_memseg_contig_walk(type1_map_contig,</span><br><span class="line">				&amp;vfio_container_fd);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="comment">/* we have to continue the walk because we&#x27;ve skipped the</span></span><br><span class="line"><span class="comment">		 * external segments during the config walk.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rte_memseg_walk(type1_map, &amp;vfio_container_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会在最初始的函数 rte_eal_init 这个函数中调用，这个函数不陌生吧，在最初的文章里就介绍过。它主要用来在初始时对固定内存的 DMA 地址映射，而若是对小的临时的地址映射可以使用下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dpdk-stable-19.11.14\lib\librte_eal\common\eal_common_dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_dev_dma_map</span><span class="params">(<span class="keyword">struct</span> rte_device *dev, <span class="type">void</span> *addr, <span class="type">uint64_t</span> iova,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;dma_map == <span class="literal">NULL</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Memory must be registered through rte_extmem_* APIs */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_mem_virt2memseg_list(addr) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;bus-&gt;dma_map(dev, addr, iova, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_dev_dma_unmap</span><span class="params">(<span class="keyword">struct</span> rte_device *dev, <span class="type">void</span> *addr, <span class="type">uint64_t</span> iova,</span></span><br><span class="line"><span class="params">		  <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;dma_unmap == <span class="literal">NULL</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Memory must be registered through rte_extmem_* APIs */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_mem_virt2memseg_list(addr) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;bus-&gt;dma_unmap(dev, addr, iova, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不细节展开在使用虚地址和实地址以及自定义地址时，DMA 对其的各自处理的细节，有兴趣可以自己查看源码。DMA 中对数据的传输，其实就是对缓冲池和 Mbuf 的处理。在更高的版本中，DPDK 在库单独对 dmadev 进行了封装。<br>DMA 处理数据的过程将在后面的整体流程源码分析中，进行说明。<br>再看一下 PCIe 相关，首先是扫描（对于一些基础的 PCIe 相关的应用知识需要懂一些，否则代码看不看也没啥意义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pci_scan_one</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirname, <span class="type">const</span> <span class="keyword">struct</span> rte_pci_addr *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> filename[PATH_MAX];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">char</span> driver[PATH_MAX];</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	dev = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line">	<span class="keyword">if</span> (dev == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">	dev-&gt;device.bus = &amp;rte_pci_bus.bus;</span><br><span class="line">	dev-&gt;addr = *addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get vendor id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/vendor&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.vendor_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get device id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/device&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.device_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get subsystem_vendor id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/subsystem_vendor&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.subsystem_vendor_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get subsystem_device id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/subsystem_device&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;id.subsystem_device_id = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get class_id */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/class&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line">	<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* the least 24 bits are valid: class, subclass, program interface */</span></span><br><span class="line">	dev-&gt;id.class_id = (<span class="type">uint32_t</span>)tmp &amp; RTE_CLASS_ANY_ID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get max_vfs */</span></span><br><span class="line">	dev-&gt;max_vfs = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/max_vfs&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (!access(filename, F_OK) &amp;&amp;</span><br><span class="line">	    eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">		dev-&gt;max_vfs = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* for non igb_uio driver, need kernel version &gt;= 3.8 */</span></span><br><span class="line">		<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename),</span><br><span class="line">			 <span class="string">&quot;%s/sriov_numvfs&quot;</span>, dirname);</span><br><span class="line">		<span class="keyword">if</span> (!access(filename, F_OK) &amp;&amp;</span><br><span class="line">		    eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">			dev-&gt;max_vfs = (<span class="type">uint16_t</span>)tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get numa node, default to 0 if not present */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/numa_node&quot;</span>,</span><br><span class="line">		 dirname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (access(filename, F_OK) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eal_parse_sysfs_value(filename, &amp;tmp) == <span class="number">0</span>)</span><br><span class="line">			dev-&gt;device.numa_node = tmp;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev-&gt;device.numa_node = <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;device.numa_node = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pci_name_set(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse resources */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/resource&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">if</span> (pci_parse_sysfs_resource(filename, dev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;%s(): cannot parse resource\n&quot;</span>, __func__);</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse driver */</span></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s/driver&quot;</span>, dirname);</span><br><span class="line">	ret = pci_get_kernel_driver_by_path(filename, driver, <span class="keyword">sizeof</span>(driver));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;Fail to get kernel driver\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;vfio-pci&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_VFIO;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;igb_uio&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_IGB_UIO;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(driver, <span class="string">&quot;uio_pci_generic&quot;</span>))</span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_UIO_GENERIC;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev-&gt;kdrv = RTE_KDRV_UNKNOWN;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		dev-&gt;kdrv = RTE_KDRV_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* device is valid, add in list (sorted) */</span></span><br><span class="line">	<span class="keyword">if</span> (TAILQ_EMPTY(&amp;rte_pci_bus.device_list)) &#123;</span><br><span class="line">		rte_pci_add_device(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> rte_pci_device *dev2;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		TAILQ_FOREACH(dev2, &amp;rte_pci_bus.device_list, next) &#123;</span><br><span class="line">			ret = rte_pci_addr_cmp(&amp;dev-&gt;addr, &amp;dev2-&gt;addr);</span><br><span class="line">			<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				rte_pci_insert_device(dev2, dev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* already registered */</span></span><br><span class="line">				<span class="keyword">if</span> (!rte_dev_is_probed(&amp;dev2-&gt;device)) &#123;</span><br><span class="line">					dev2-&gt;kdrv = dev-&gt;kdrv;</span><br><span class="line">					dev2-&gt;max_vfs = dev-&gt;max_vfs;</span><br><span class="line">					pci_name_set(dev2);</span><br><span class="line">					memmove(dev2-&gt;mem_resource,</span><br><span class="line">						dev-&gt;mem_resource,</span><br><span class="line">						<span class="keyword">sizeof</span>(dev-&gt;mem_resource));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					 * If device is plugged and driver is</span></span><br><span class="line"><span class="comment">					 * probed already, (This happens when</span></span><br><span class="line"><span class="comment">					 * we call rte_dev_probe which will</span></span><br><span class="line"><span class="comment">					 * scan all device on the bus) we don&#x27;t</span></span><br><span class="line"><span class="comment">					 * need to do anything here unless...</span></span><br><span class="line"><span class="comment">					 **/</span></span><br><span class="line">					<span class="keyword">if</span> (dev2-&gt;kdrv != dev-&gt;kdrv ||</span><br><span class="line">						dev2-&gt;max_vfs != dev-&gt;max_vfs)</span><br><span class="line">						<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 * This should not happens.</span></span><br><span class="line"><span class="comment">						 * But it is still possible if</span></span><br><span class="line"><span class="comment">						 * we unbind a device from</span></span><br><span class="line"><span class="comment">						 * vfio or uio before hotplug</span></span><br><span class="line"><span class="comment">						 * remove and rebind it with</span></span><br><span class="line"><span class="comment">						 * a different configure.</span></span><br><span class="line"><span class="comment">						 * So we just print out the</span></span><br><span class="line"><span class="comment">						 * error as an alarm.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						RTE_LOG(ERR, EAL, <span class="string">&quot;Unexpected device scan at %s!\n&quot;</span>,</span><br><span class="line">							filename);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (dev2-&gt;device.devargs !=</span><br><span class="line">						 dev-&gt;device.devargs) &#123;</span><br><span class="line">						rte_devargs_remove(dev2-&gt;device.devargs);</span><br><span class="line">						pci_name_set(dev2);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">free</span>(dev);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rte_pci_add_device(dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描并增加相关设备后，就可以将其位于 “&#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:xxxx:xx&#x2F;resouce” 的每个 PCI 设备对应的文件中保存的 pci 设备 bar 寄存器的地址映射信息在这个设备启动加载时将映射的物理内存地址信息保存在 bar 寄存器中同时写入到此文件。而 UIO 就是通过这个文件来使用 mmap 对其的物理地址进行映射，然后就可以在应用层对此设备进行访问了。<br>cache 等的代码在前面分析过，这里就不再重复，如果需要可以翻翻前面的文章。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h3 id="网卡优化"><a href="#网卡优化" class="headerlink" title="网卡优化"></a>网卡优化</h3><p>一般来说，对某个设备的优化，除了涉及到硬件设备本身，也要兼顾着上下游的软硬件，协调优化，才可能达到最优。同样，对于 DPDK 来讲，除了要考虑软件层面还要考虑硬件平台及相关设置置的控制。将其看成一个整体入手，才能真正的把优化做到最好。</p>
<h3 id="软件层面"><a href="#软件层面" class="headerlink" title="软件层面"></a>软件层面</h3><p>在实际的应用场景中，可能存在着收发包较少的情况；也可能存在着连续的大数据量吞吐的情况；而更多的情况可能是上面的两种情况交互。最典型的可能是某个时间段上网的人很多，可有一段时间又没什么人上网。比如上下班时间，和交通拥堵一样，也会有这种高峰低谷的情况。这就需要 DPDK 根据情况来进行动态的控制，软件层面做这种设计还是比较方便的。实际上，DPDK 提供了三种模式来分别适应上述<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%B8%8D%E5%90%8C%E7%9A%84&spm=1001.2101.3001.7020">不同的</a>场景：<br>1、异步中断模式<br>其实中断都是异步的。好像没听说过同步中断的情况。此模式比较适合于收发较少的情况，能更好的利用硬件资源<br>2、轮询模式<br>其实就是反复的去操作接口，特别适合于大数据量的吞吐的情况。<br>3、混合模式<br>这个其实就是一种对上述二者场景进行兼容的一种情况，可能在实际情况中更合适。</p>
<h3 id="IO-优化"><a href="#IO-优化" class="headerlink" title="IO 优化"></a>IO 优化</h3><p>这个其实就涉及到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">数据处理</a>过程，数据本身的粒度大小，处理数据的批量数量，缓存的对齐以及特定硬件的一个 SIMD 的指令优化控制等等。DPDK 中采用 Burst 的方式来收发包，减少对内存或 Cache 的访问次数。同时利用批处理来提高对时延和吞吐的优化。</p>
<h3 id="平台及配置优化"><a href="#平台及配置优化" class="headerlink" title="平台及配置优化"></a>平台及配置优化</h3><p>这个就比较多了，一般来说，它和技术本身没有什么太大关系，更和硬件、OS 及相关的具体的提供的功能有关。同时，可能还要涉及到一些 BIOS 的支持，诸如大页内存、电源设置、硬件本身固件的一些支持以及总线的控制等等。</p>
<h3 id="相关设置适配"><a href="#相关设置适配" class="headerlink" title="相关设置适配"></a>相关设置适配</h3><p>相关设置的适配，涉及到收、发包队列的长度，以及队列中的可释放描述符的数量阈值。这都需要根据文档的说明，按照实际场景的需求来进行安排。从而能更好的发挥整个软件层面的适配性，更好的协调软件和网卡的数据收发，达到最优。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>了解了相关的优化措施后，看一下 DPDK 中相关的源码，在 DPDK 中的轮询模式中，有 Gigabit、10Gigabit 及 40Gigabit 和半虚拟化 IO 的轮询模式驱动程序，它支持 RTC 和管道两种情况，这里不展开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\lib\librte_ethdev\rte_ethdev.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;rx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_rx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid RX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;post_rx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_rx = cb-&gt;fn.rx(port_id, queue_id, rx_pkts, nb_rx,</span><br><span class="line">						nb_pkts, cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **tx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;tx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_tx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid TX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;pre_tx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_pkts = cb-&gt;fn.tx(port_id, queue_id, tx_pkts, nb_pkts,</span><br><span class="line">					cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;tx_pkt_burst)(dev-&gt;data-&gt;tx_queues[queue_id], tx_pkts, nb_pkts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 burst 中的 rx 的接收函数中，有行代码要注意，一个是通过 rx_pkt_burst 真正处理数据，另外一个就是循环查找有无数据的回调函数。这两个函数在 PMD 层可以通过不断的循环来调用，就可以达到轮询的目的。在前者的 <code>eth_rx_burst_t rx_pkt_burst</code> 中，源码中注释说明其指向 PMD 接收函数，这下就明白了吧。可以在 eth_em_rx_init(drivers&#x2F;net&#x2F;e1000&#x2F;em_rxtx.c)中看到相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eth_em_rx_init</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev * dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span>;</span></span><br><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac.type == e1000_82573)</span><br><span class="line">		E1000_WRITE_REG(hw, E1000_RDTR, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;rx_pkt_burst = (<span class="type">eth_rx_burst_t</span>)eth_em_recv_pkts;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">eth_em_recv_pkts</span><span class="params">(<span class="type">void</span> *rx_queue, <span class="keyword">struct</span> rte_mbuf **rx_pkts,</span></span><br><span class="line"><span class="params">		<span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rx_ring</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rxdp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_rx_entry</span> *<span class="title">sw_ring</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_rx_entry</span> *<span class="title">rxe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">rxm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">nmb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> <span class="title">rxd</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> dma_addr;</span><br><span class="line">	<span class="type">uint16_t</span> pkt_len;</span><br><span class="line">	<span class="type">uint16_t</span> rx_id;</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line">	<span class="type">uint16_t</span> nb_hold;</span><br><span class="line">	<span class="type">uint8_t</span> status;</span><br><span class="line"></span><br><span class="line">	rxq = rx_queue;</span><br><span class="line"></span><br><span class="line">	nb_rx = <span class="number">0</span>;</span><br><span class="line">	nb_hold = <span class="number">0</span>;</span><br><span class="line">	rx_id = rxq-&gt;rx_tail;</span><br><span class="line">	rx_ring = rxq-&gt;rx_ring;</span><br><span class="line">	sw_ring = rxq-&gt;sw_ring;</span><br><span class="line">	<span class="keyword">while</span> (nb_rx &lt; nb_pkts) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The order of operations here is important as the DD status</span></span><br><span class="line"><span class="comment">		 * bit must not be read after any other descriptor fields.</span></span><br><span class="line"><span class="comment">		 * rx_ring and rxdp are pointing to volatile data so the order</span></span><br><span class="line"><span class="comment">		 * of accesses cannot be reordered by the compiler. If they were</span></span><br><span class="line"><span class="comment">		 * not volatile, they could be reordered which could lead to</span></span><br><span class="line"><span class="comment">		 * using invalid descriptor fields when read from rxd.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rxdp = &amp;rx_ring[rx_id];</span><br><span class="line">		status = rxdp-&gt;status;</span><br><span class="line">		<span class="keyword">if</span> (! (status &amp; E1000_RXD_STAT_DD))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rxd = *rxdp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * End of packet.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If the E1000_RXD_STAT_EOP flag is not set, the RX packet is</span></span><br><span class="line"><span class="comment">		 * likely to be invalid and to be dropped by the various</span></span><br><span class="line"><span class="comment">		 * validation checks performed by the network stack.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Allocate a new mbuf to replenish the RX ring descriptor.</span></span><br><span class="line"><span class="comment">		 * If the allocation fails:</span></span><br><span class="line"><span class="comment">		 *    - arrange for that RX descriptor to be the first one</span></span><br><span class="line"><span class="comment">		 *      being parsed the next time the receive function is</span></span><br><span class="line"><span class="comment">		 *      invoked [on the same queue].</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *    - Stop parsing the RX ring and return immediately.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This policy do not drop the packet received in the RX</span></span><br><span class="line"><span class="comment">		 * descriptor for which the allocation of a new mbuf failed.</span></span><br><span class="line"><span class="comment">		 * Thus, it allows that packet to be later retrieved if</span></span><br><span class="line"><span class="comment">		 * mbuf have been freed in the mean time.</span></span><br><span class="line"><span class="comment">		 * As a side effect, holding RX descriptors instead of</span></span><br><span class="line"><span class="comment">		 * systematically giving them back to the NIC may lead to</span></span><br><span class="line"><span class="comment">		 * RX ring exhaustion situations.</span></span><br><span class="line"><span class="comment">		 * However, the NIC can gracefully prevent such situations</span></span><br><span class="line"><span class="comment">		 * to happen by sending specific &quot;back-pressure&quot; flow control</span></span><br><span class="line"><span class="comment">		 * frames to its peer(s).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_id=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;status=0x%x pkt_len=%u&quot;</span>,</span><br><span class="line">			   (<span class="type">unsigned</span>) rxq-&gt;port_id, (<span class="type">unsigned</span>) rxq-&gt;queue_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) rx_id, (<span class="type">unsigned</span>) status,</span><br><span class="line">			   (<span class="type">unsigned</span>) rte_le_to_cpu_16(rxd.length));</span><br><span class="line"></span><br><span class="line">		nmb = rte_mbuf_raw_alloc(rxq-&gt;mb_pool);</span><br><span class="line">		<span class="keyword">if</span> (nmb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			PMD_RX_LOG(DEBUG, <span class="string">&quot;RX mbuf alloc failed port_id=%u &quot;</span></span><br><span class="line">				   <span class="string">&quot;queue_id=%u&quot;</span>,</span><br><span class="line">				   (<span class="type">unsigned</span>) rxq-&gt;port_id,</span><br><span class="line">				   (<span class="type">unsigned</span>) rxq-&gt;queue_id);</span><br><span class="line">			rte_eth_devices[rxq-&gt;port_id].data-&gt;rx_mbuf_alloc_failed++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nb_hold++;</span><br><span class="line">		rxe = &amp;sw_ring[rx_id];</span><br><span class="line">		rx_id++;</span><br><span class="line">		<span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc)</span><br><span class="line">			rx_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Prefetch next mbuf while processing current one. */</span></span><br><span class="line">		rte_em_prefetch(sw_ring[rx_id].mbuf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When next RX descriptor is on a cache-line boundary,</span></span><br><span class="line"><span class="comment">		 * prefetch the next 4 RX descriptors and the next 8 pointers</span></span><br><span class="line"><span class="comment">		 * to mbufs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			rte_em_prefetch(&amp;rx_ring[rx_id]);</span><br><span class="line">			rte_em_prefetch(&amp;sw_ring[rx_id]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Rearm RXD: attach new mbuf and reset status to zero. */</span></span><br><span class="line"></span><br><span class="line">		rxm = rxe-&gt;mbuf;</span><br><span class="line">		rxe-&gt;mbuf = nmb;</span><br><span class="line">		dma_addr =</span><br><span class="line">			rte_cpu_to_le_64(rte_mbuf_data_iova_default(nmb));</span><br><span class="line">		rxdp-&gt;buffer_addr = dma_addr;</span><br><span class="line">		rxdp-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Initialize the returned mbuf.</span></span><br><span class="line"><span class="comment">		 * 1) setup generic mbuf fields:</span></span><br><span class="line"><span class="comment">		 *    - number of segments,</span></span><br><span class="line"><span class="comment">		 *    - next segment,</span></span><br><span class="line"><span class="comment">		 *    - packet length,</span></span><br><span class="line"><span class="comment">		 *    - RX port identifier.</span></span><br><span class="line"><span class="comment">		 * 2) integrate hardware offload data, if any:</span></span><br><span class="line"><span class="comment">		 *    - RSS flag &amp; hash,</span></span><br><span class="line"><span class="comment">		 *    - IP checksum flag,</span></span><br><span class="line"><span class="comment">		 *    - VLAN TCI, if any,</span></span><br><span class="line"><span class="comment">		 *    - error flags.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pkt_len = (<span class="type">uint16_t</span>) (rte_le_to_cpu_16(rxd.length) -</span><br><span class="line">				rxq-&gt;crc_len);</span><br><span class="line">		rxm-&gt;data_off = RTE_PKTMBUF_HEADROOM;</span><br><span class="line">		rte_packet_prefetch((<span class="type">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off);</span><br><span class="line">		rxm-&gt;nb_segs = <span class="number">1</span>;</span><br><span class="line">		rxm-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		rxm-&gt;pkt_len = pkt_len;</span><br><span class="line">		rxm-&gt;data_len = pkt_len;</span><br><span class="line">		rxm-&gt;port = rxq-&gt;port_id;</span><br><span class="line"></span><br><span class="line">		rxm-&gt;ol_flags = rx_desc_status_to_pkt_flags(status);</span><br><span class="line">		rxm-&gt;ol_flags = rxm-&gt;ol_flags |</span><br><span class="line">				rx_desc_error_to_pkt_flags(rxd.errors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Only valid if PKT_RX_VLAN set in pkt_flags */</span></span><br><span class="line">		rxm-&gt;vlan_tci = rte_le_to_cpu_16(rxd.special);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Store the mbuf address into the next entry of the array</span></span><br><span class="line"><span class="comment">		 * of returned packets.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rx_pkts[nb_rx++] = rxm;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;rx_tail = rx_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the number of free RX descriptors is greater than the RX free</span></span><br><span class="line"><span class="comment">	 * threshold of the queue, advance the Receive Descriptor Tail (RDT)</span></span><br><span class="line"><span class="comment">	 * register.</span></span><br><span class="line"><span class="comment">	 * Update the RDT with the value of the last processed RX descriptor</span></span><br><span class="line"><span class="comment">	 * minus 1, to guarantee that the RDT register is never equal to the</span></span><br><span class="line"><span class="comment">	 * RDH register, which creates a &quot;full&quot; ring situtation from the</span></span><br><span class="line"><span class="comment">	 * hardware point of view...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nb_hold = (<span class="type">uint16_t</span>) (nb_hold + rxq-&gt;nb_rx_hold);</span><br><span class="line">	<span class="keyword">if</span> (nb_hold &gt; rxq-&gt;rx_free_thresh) &#123;</span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_tail=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;nb_hold=%u nb_rx=%u&quot;</span>,</span><br><span class="line">			   (<span class="type">unsigned</span>) rxq-&gt;port_id, (<span class="type">unsigned</span>) rxq-&gt;queue_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) rx_id, (<span class="type">unsigned</span>) nb_hold,</span><br><span class="line">			   (<span class="type">unsigned</span>) nb_rx);</span><br><span class="line">		rx_id = (<span class="type">uint16_t</span>) ((rx_id == <span class="number">0</span>) ?</span><br><span class="line">			(rxq-&gt;nb_rx_desc - <span class="number">1</span>) : (rx_id - <span class="number">1</span>));</span><br><span class="line">		E1000_PCI_REG_WRITE(rxq-&gt;rdt_reg_addr, rx_id);</span><br><span class="line">		nb_hold = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;nb_rx_hold = nb_hold;</span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是轮询机制中的主要的代码。代码整体比较容易理解，DMA 操作将报文写到相关的内存即 m_buf 中（ring），rxq-&gt;rx_tail &#x3D; rx_id; 这行代码是不是有点熟悉，类似于计数器。它控制着不断拿到新的 m_buf 并写入到 ring 中。<br>轮询的方式也比较好理解，通过 UIO 略过内核然后 PMD 拦截了硬中断，直接操作。<br>DPDK 实现了 uio、 定时器 alarm, 和 vfio 三种中断。中断操作可以理解成线程正在忙着，突然来了一个信号，让线程别干了去忙别的。那么 CPU 为了安全调度，需要处理上下文的堆栈，数据等等，然后才能进行相关的操作。这个过程需要耗费非常多的时钟周期，如果中断比较多的话，可以想象数据的吞吐量会下降多少。这部分代码待后面的文章再展开分析。</p>
<h1 id="多队列技术"><a href="#多队列技术" class="headerlink" title="多队列技术"></a>多队列技术</h1><p>DPDK 中的 Pack I&#x2F;O 是天然支持多队列技术的。通过一系列的配置，可以绑定与 CPU 核心、队列等。而网卡报文的队列分配一般是使用 RSS 和 Flow Director 技术。RSS 其实就是哈希均匀分配到队列，而后者则是使用查找的精确匹配方式将包发送到指定队列。另外还需要注意的是优先给，毕竟有的包命令是处理一些控制状态的，需要优先处理，这都需要在包分配时有一些应对机制。</p>
<h2 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h2><p>为了实现多队列和提到的优先级，就需要对包的种类进行分类。比如常见的 TCP、IP 以及自定义或者云等虚拟包等。有两种处理的方式即上面提到的 RSS 和 Flow Director。<br>1、RSS（Receive-Side Scaling），接收方向扩展<br>负载均衡，这个光看名字都知道什么意思，特别是这些年来开发技术的普及，基本上搞后台搞网络的都懂这个技术。简单来说就是不分彼此，不厚此薄彼，每个队列享受相同的待遇。这里面的重点是哈希计算的对应值怎么取？可以是网络四元组也可以是其它，这个根据实际情况来定。</p>
<p>2、Flow Director<br>精确字段匹配，可以将报文数据转到相应的队列中。在网卡上会有一个表，表中会有相关的关键字和动作。此表由驱动来进行管理，每当数据从网卡进入，就可以通过查询此表来进行相关的动作。  </p>
<p>3、QoS - 服务质量<br>其实就是对于些特定的业务需求进行调度，划分类型并确定优先级。  </p>
<p>4、虚拟场景下的分类<br>现在的实际业务中，云虚拟化的业务占有非常大的比重，所以会有一组队列与 SRIOV VF&#x2F;VMDQ POOL 等相对应进行数据处理。  </p>
<p>5、流过滤<br>主要是通过分类进行合法性验证。过滤的方法有 MAC 地址过滤、VLAN 标签过滤和管理数据包过滤。当然，在不同的网卡上也提供了多种规则供调用，它们包括：N tuple filter（N 元组指定队列）、EtherType Filter（以太网报文的 EtherType 指定队列）、Cloud Filter（云应用中的 VXLAN 等隧道报文指定队列）等。</p>
<p>如果实现流分类，那么必须明白流是哪种类型，可这种类型从哪里得到呢？就需要解析数据报文的头，而在网卡中可以使用接收描述符来快速确定包的类型。在 DPDK 中的 m_buf 中定义有相关的对应字段来映射类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet type, which is the combination of outer/inner L2, L3, L4</span></span><br><span class="line"><span class="comment">	 * and tunnel types. The packet_type is about data really present in the</span></span><br><span class="line"><span class="comment">	 * mbuf. Example: if vlan stripping is enabled, a received vlan packet</span></span><br><span class="line"><span class="comment">	 * would have RTE_PTYPE_L2_ETHER and not RTE_PTYPE_L2_VLAN because the</span></span><br><span class="line"><span class="comment">	 * vlan is stripped from the data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_STD_C11</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> packet_type; <span class="comment">/**&lt; L2/L3/L4 and tunnel information. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">uint32_t</span> l2_type:<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L2 type. */</span></span><br><span class="line">			<span class="type">uint32_t</span> l3_type:<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L3 type. */</span></span><br><span class="line">			<span class="type">uint32_t</span> l4_type:<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L4 type. */</span></span><br><span class="line">			<span class="type">uint32_t</span> tun_type:<span class="number">4</span>; <span class="comment">/**&lt; Tunnel type. */</span></span><br><span class="line">			RTE_STD_C11</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="type">uint8_t</span> inner_esp_next_proto;</span><br><span class="line">				<span class="comment">/**&lt; ESP next protocol type, valid if</span></span><br><span class="line"><span class="comment">				 * RTE_PTYPE_TUNNEL_ESP tunnel type is set</span></span><br><span class="line"><span class="comment">				 * on both Tx and Rx.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				__extension__</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					<span class="type">uint8_t</span> inner_l2_type:<span class="number">4</span>;</span><br><span class="line">					<span class="comment">/**&lt; Inner L2 type. */</span></span><br><span class="line">					<span class="type">uint8_t</span> inner_l3_type:<span class="number">4</span>;</span><br><span class="line">					<span class="comment">/**&lt; Inner L3 type. */</span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="type">uint32_t</span> inner_l4_type:<span class="number">4</span>; <span class="comment">/**&lt; Inner L4 type. */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有这个类型的处理就可以动态的快速把报文转到相关队列。不过需要注意的是，虽然主流的网卡都支持多队列，但并不是所有的都支持此功能。同样，即使支持，支持的程度也有不同。<br>DPDK 中遇到的场景非常复杂，可能有的需要数据㔹发，有的需要命令处理有的需要逻辑转发等等不一而足。那么，对数据队列就可以动态的根据实际情况来进行定制。DPDK 可以通过 RSS 实现负载均衡，然后再通过 Flow Director 实现报文的定向分配，通过绑定的专门的核心进行特定的数据队列处理。<br>另外 DPDK 中还可以通过虚拟化网卡来进行工作，实现动态的资源利用。</p>
<p>先看一下相关的配置数据结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\dpdk-stable-19.11.14\lib\librte_ethdev</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A structure used to configure an Ethernet port.</span></span><br><span class="line"><span class="comment"> * Depending upon the RX multi-queue mode, extra advanced</span></span><br><span class="line"><span class="comment"> * configuration settings may be needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> link_speeds; <span class="comment">/**&lt; bitmap of ETH_LINK_SPEED_XXX of speeds to be</span></span><br><span class="line"><span class="comment">				used. ETH_LINK_SPEED_FIXED disables link</span></span><br><span class="line"><span class="comment">				autonegotiation, and a unique speed shall be</span></span><br><span class="line"><span class="comment">				set. Otherwise, the bitmap defines the set of</span></span><br><span class="line"><span class="comment">				speeds to be advertised. If the special value</span></span><br><span class="line"><span class="comment">				ETH_LINK_SPEED_AUTONEG (0) is used, all speeds</span></span><br><span class="line"><span class="comment">				supported are advertised. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> <span class="title">rxmode</span>;</span> <span class="comment">/**&lt; Port RX configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txmode</span> <span class="title">txmode</span>;</span> <span class="comment">/**&lt; Port TX configuration. */</span></span><br><span class="line">	<span class="type">uint32_t</span> lpbk_mode; <span class="comment">/**&lt; Loopback operation mode. By default the value</span></span><br><span class="line"><span class="comment">			         is 0, meaning the loopback mode is disabled.</span></span><br><span class="line"><span class="comment">				 Read the datasheet of given ethernet controller</span></span><br><span class="line"><span class="comment">				 for details. The possible values of this field</span></span><br><span class="line"><span class="comment">				 are defined in implementation of each driver. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rss_conf</span> <span class="title">rss_conf</span>;</span> <span class="comment">/**&lt; Port RSS configuration */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_conf</span> <span class="title">vmdq_dcb_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq+dcb configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_rx_conf</span> <span class="title">dcb_rx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port dcb RX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_rx_conf</span> <span class="title">vmdq_rx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq RX configuration. */</span></span><br><span class="line">	&#125; rx_adv_conf; <span class="comment">/**&lt; Port RX filtering configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_tx_conf</span> <span class="title">vmdq_dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq+dcb TX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_tx_conf</span> <span class="title">dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port dcb TX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_tx_conf</span> <span class="title">vmdq_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq TX configuration. */</span></span><br><span class="line">	&#125; tx_adv_conf; <span class="comment">/**&lt; Port TX DCB configuration (union). */</span></span><br><span class="line">	<span class="comment">/** Currently,Priority Flow Control(PFC) are supported,if DCB with PFC</span></span><br><span class="line"><span class="comment">	    is needed,and the variable must be set ETH_DCB_PFC_SUPPORT. */</span></span><br><span class="line">	<span class="type">uint32_t</span> dcb_capability_en;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_fdir_conf</span> <span class="title">fdir_conf</span>;</span> <span class="comment">/**&lt; FDIR configuration. DEPRECATED */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_conf</span> <span class="title">intr_conf</span>;</span> <span class="comment">/**&lt; Interrupt mode configuration. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个结构定义中，可以看到 intr_conf、fdir_conf 和 rx_adv_conf 以及 rxmode。而 fdir_conf 和 rx_adv_conf 就涉及 Flow Director 和 RSS 的配置。RSS 分为三种即单一队列的 RSS、带有硬件队列的 RSS 和还有消息中断的 RSS（其实还是硬件不匹配造成的）。<br>在 DPDK 提供的例程 l3fwd 中，可以看到相关的配置代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//配置相关的RSS或FD</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">local_port_conf</span> =</span> port_conf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* skip ports that are not enabled */</span></span><br><span class="line">  <span class="keyword">if</span> ((enabled_port_mask &amp; (<span class="number">1</span> &lt;&lt; portid)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nSkipping disabled port %d\n&quot;</span>, portid);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init port */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Initializing port %d ... &quot;</span>, portid );</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  nb_rx_queue = get_port_n_rx_queues(portid);</span><br><span class="line">  n_tx_queue = nb_lcores;</span><br><span class="line">  <span class="keyword">if</span> (n_tx_queue &gt; MAX_TX_QUEUE_PER_PORT)</span><br><span class="line">    n_tx_queue = MAX_TX_QUEUE_PER_PORT;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Creating queues: nb_rxq=%d nb_txq=%u... &quot;</span>,</span><br><span class="line">    nb_rx_queue, (<span class="type">unsigned</span>)n_tx_queue );</span><br><span class="line"></span><br><span class="line">  ret = rte_eth_dev_info_get(portid, &amp;dev_info);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    rte_exit(EXIT_FAILURE,</span><br><span class="line">      <span class="string">&quot;Error during getting device (port %u) info: %s\n&quot;</span>,</span><br><span class="line">      portid, strerror(-ret));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dev_info.tx_offload_capa &amp; DEV_TX_OFFLOAD_MBUF_FAST_FREE)</span><br><span class="line">    local_port_conf.txmode.offloads |=</span><br><span class="line">      DEV_TX_OFFLOAD_MBUF_FAST_FREE;</span><br><span class="line"></span><br><span class="line">  local_port_conf.rx_adv_conf.rss_conf.rss_hf &amp;=</span><br><span class="line">    dev_info.flow_type_rss_offloads;</span><br><span class="line">  <span class="keyword">if</span> (local_port_conf.rx_adv_conf.rss_conf.rss_hf !=</span><br><span class="line">      port_conf.rx_adv_conf.rss_conf.rss_hf) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Port %u modified RSS hash function based on hardware support,&quot;</span></span><br><span class="line">      <span class="string">&quot;requested:%#&quot;</span>PRIx64<span class="string">&quot; configured:%#&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">      portid,</span><br><span class="line">      port_conf.rx_adv_conf.rss_conf.rss_hf,</span><br><span class="line">      local_port_conf.rx_adv_conf.rss_conf.rss_hf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = rte_eth_dev_configure(portid, nb_rx_queue,</span><br><span class="line">        (<span class="type">uint16_t</span>)n_tx_queue, &amp;local_port_conf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置收发队列</span></span><br><span class="line">  <span class="keyword">for</span> (lcore_id = <span class="number">0</span>; lcore_id &lt; RTE_MAX_LCORE; lcore_id++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rte_lcore_is_enabled(lcore_id) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numa_on)</span><br><span class="line">    socketid =</span><br><span class="line">    (<span class="type">uint8_t</span>)rte_lcore_to_socket_id(lcore_id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    socketid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;txq=%u,%d,%d &quot;</span>, lcore_id, queueid, socketid);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  txconf = &amp;dev_info.default_txconf;</span><br><span class="line">  txconf-&gt;offloads = local_port_conf.txmode.offloads;</span><br><span class="line">  ret = rte_eth_tx_queue_setup(portid, queueid, nb_txd,</span><br><span class="line">             socketid, txconf);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    rte_exit(EXIT_FAILURE,</span><br><span class="line">      <span class="string">&quot;rte_eth_tx_queue_setup: err=%d, &quot;</span></span><br><span class="line">      <span class="string">&quot;port=%d\n&quot;</span>, ret, portid);</span><br><span class="line"></span><br><span class="line">  qconf = &amp;lcore_conf[lcore_id];</span><br><span class="line">  qconf-&gt;tx_queue_id[portid] = queueid;</span><br><span class="line">  queueid++;</span><br><span class="line"></span><br><span class="line">  qconf-&gt;tx_port_id[qconf-&gt;n_tx_port] = portid;</span><br><span class="line">  qconf-&gt;n_tx_port++;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">queue</span> = <span class="number">0</span>; <span class="built_in">queue</span> &lt; qconf-&gt;n_rx_queue; ++<span class="built_in">queue</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxconf</span> <span class="title">rxq_conf</span>;</span></span><br><span class="line"></span><br><span class="line">  portid = qconf-&gt;rx_queue_list[<span class="built_in">queue</span>].port_id;</span><br><span class="line">  queueid = qconf-&gt;rx_queue_list[<span class="built_in">queue</span>].queue_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numa_on)</span><br><span class="line">    socketid =</span><br><span class="line">    (<span class="type">uint8_t</span>)rte_lcore_to_socket_id(lcore_id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    socketid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;rxq=%d,%d,%d &quot;</span>, portid, queueid, socketid);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  ret = rte_eth_dev_info_get(portid, &amp;dev_info);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    rte_exit(EXIT_FAILURE,</span><br><span class="line">      <span class="string">&quot;Error during getting device (port %u) info: %s\n&quot;</span>,</span><br><span class="line">      portid, strerror(-ret));</span><br><span class="line"></span><br><span class="line">  rxq_conf = dev_info.default_rxconf;</span><br><span class="line">  rxq_conf.offloads = port_conf.rxmode.offloads;</span><br><span class="line">  <span class="keyword">if</span> (!per_port_pool)</span><br><span class="line">    ret = rte_eth_rx_queue_setup(portid, queueid,</span><br><span class="line">        nb_rxd, socketid,</span><br><span class="line">        &amp;rxq_conf,</span><br><span class="line">        pktmbuf_pool[<span class="number">0</span>][socketid]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ret = rte_eth_rx_queue_setup(portid, queueid,</span><br><span class="line">        nb_rxd, socketid,</span><br><span class="line">        &amp;rxq_conf,</span><br><span class="line">        pktmbuf_pool[portid][socketid]);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    rte_exit(EXIT_FAILURE,</span><br><span class="line">    <span class="string">&quot;rte_eth_rx_queue_setup: err=%d, port=%d\n&quot;</span>,</span><br><span class="line">    ret, portid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动设备</span></span><br><span class="line"><span class="comment">/* Start device */</span></span><br><span class="line">ret = rte_eth_dev_start(portid);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动设备的函数在 rte_ethdev.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_start</span><span class="params">(<span class="type">uint16_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line">	<span class="type">int</span> diag;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -EINVAL);</span><br><span class="line"></span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;dev_start, -ENOTSUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_started != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(INFO,</span><br><span class="line">			<span class="string">&quot;Device with port_id=%&quot;</span>PRIu16<span class="string">&quot; already started\n&quot;</span>,</span><br><span class="line">			port_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = rte_eth_dev_info_get(port_id, &amp;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lets restore MAC now if device does not support live change */</span></span><br><span class="line">	<span class="keyword">if</span> (*dev_info.dev_flags &amp; RTE_ETH_DEV_NOLIVE_MAC_ADDR)</span><br><span class="line">		rte_eth_dev_mac_restore(dev, &amp;dev_info);</span><br><span class="line"></span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;dev_start)(dev);</span><br><span class="line">	<span class="keyword">if</span> (diag == <span class="number">0</span>)</span><br><span class="line">		dev-&gt;data-&gt;dev_started = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> eth_err(port_id, diag);</span><br><span class="line"></span><br><span class="line">	ret = rte_eth_dev_config_restore(dev, &amp;dev_info, port_id);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Error during restoring configuration for device (port %u): %s\n&quot;</span>,</span><br><span class="line">			port_id, rte_strerror(-ret));</span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.intr_conf.lsc == <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;link_update, -ENOTSUP);</span><br><span class="line">		(*dev-&gt;dev_ops-&gt;link_update)(dev, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DPDK 使用 RSS：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span> =</span> &#123;</span><br><span class="line">	.rxmode = &#123;</span><br><span class="line">		.mq_mode = ETH_MQ_RX_RSS,</span><br><span class="line">		.max_rx_pkt_len = RTE_ETHER_MAX_LEN,</span><br><span class="line">		.split_hdr_size = <span class="number">0</span>,</span><br><span class="line">		.offloads = DEV_RX_OFFLOAD_CHECKSUM,</span><br><span class="line">	&#125;,</span><br><span class="line">	.rx_adv_conf = &#123;</span><br><span class="line">		.rss_conf = &#123;</span><br><span class="line">			.rss_key = <span class="literal">NULL</span>,</span><br><span class="line">			.rss_hf = ETH_RSS_IP,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.txmode = &#123;</span><br><span class="line">		.mq_mode = ETH_MQ_TX_NONE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 Flow Director:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\app\test-pmd</span></span><br><span class="line"><span class="comment">//cmd_flow_director_filter_parsed函数中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_fdir_filter</span> <span class="title">entry</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* set to report FD ID by default */</span></span><br><span class="line">entry.action.report_status = RTE_ETH_FDIR_REPORT_ID;</span><br><span class="line">entry.action.rx_queue = res-&gt;queue_id;</span><br><span class="line">entry.soft_id = res-&gt;fd_id_value;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(res-&gt;ops, <span class="string">&quot;add&quot;</span>))</span><br><span class="line">  ret = rte_eth_dev_filter_ctrl(res-&gt;port_id, RTE_ETH_FILTER_FDIR,</span><br><span class="line">             RTE_ETH_FILTER_ADD, &amp;entry);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(res-&gt;ops, <span class="string">&quot;del&quot;</span>))</span><br><span class="line">  ret = rte_eth_dev_filter_ctrl(res-&gt;port_id, RTE_ETH_FILTER_FDIR,</span><br><span class="line">             RTE_ETH_FILTER_DELETE, &amp;entry);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ret = rte_eth_dev_filter_ctrl(res-&gt;port_id, RTE_ETH_FILTER_FDIR,</span><br><span class="line">             RTE_ETH_FILTER_UPDATE, &amp;entry);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，在 DPDK21.11 以上版本已经由 Flow API 代替了 Flow Director 接口。细节请参看相关文档。<br>通过上面的分析就可以明白队列的控制相关流程，另外一些配置相关的，就需要大家自己多看相关文档了。</li>
</ul>
<h1 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h1><p>硬件加速，听名字就是明白是利用硬件加速。不太准确，硬件加速其实更有效进行硬件的分工，通过分工实现硬件的整体的效率的提升。其实硬件卸载就是硬件加速，而实现硬件加速就需要进行功能卸载，整体上就可以叫做硬件卸载。<br>硬件卸载是指将某些任务或计算从计算机的主处理器 (CPU) 或一些软件功能转移到专用硬件组件（例如网络接口卡 (NIC) 或图形处理单元 (GPU)）的过程，以提高系统性能和效率。而提到硬件卸载就不得提到软件定义网络：<br>软件定义网络的主流的解决方案是从传统的包含专用硬件与控制平面相结合并提供选定的功能的交换机等单个设备，转移到软件定义网络抽象出的控制平面、数据平面、管理平面三个不同的层。<br>第一层是管理层或管理平面。它包括像 OpenStack 这类应用所在的位置，可以将一些配置应用于网络并将其用于虚拟化等领域。下一层是控制平面。最下面是数据平面。它由硬件（例如白盒交换机）和软件（软件数据平面）组成，数据平面就是硬件卸载所在的地方。而软件定义网络一般是指通过某种技术将网络设备的控制面与数据面分离开，形成灵活智能的网络。<br>软件数据平面是一个常用的术语，用来描述处理网络数据包中用户数据的应用程序。DPDK，数据平面开发套件，这下明白了吧。</p>
<p>DPDK 主要是应对网络应用开发，所以其主要和网卡打交道。DPDK 为了支持网卡的硬件卸载，需要提供相关的软件接口，具体到实际情况，网卡的硬件卸载可能是基于端口设置也可能是基于每个包设置使能。DPDK 的 mbuf 可能是对应着一个包也可能多个 mbuf 对应着一个包，这在 mbuf 中都有对应的标识来标定（ol_flags）。在 “\dpdk-stable-19.11.14\lib\librte_mbuf\rte_mbuf_core.h” 中有这些具体的定义，如 “PKT_RX_IP_CKSUM_NONE” 等等。在相同文件夹下，还有其它一些具体的宏定义，大家也可以参考。<br>相关的硬件卸载功能主要是与实际的网卡的实现情况有关，其主要有以下几种情况：<br>1、硬件与更新功能卸载<br>它根据实际情况又可以分为：<br>a.VLAN 硬件卸载，通过报文中 Tag 标识来进行标识控制。通过硬件卸载可以直接使用硬件操作而非软件利用 CPU 来进行操作，减轻了 CPU 的负荷。<br>b.IEEE1588 硬件卸载功能，PTP（Precision Timing Protocol，精准时间同步协议），这个用硬件实现更便捷准确<br>c.IP TCP&#x2F;UDP&#x2F;SCTP checksum 硬件卸载功能，这个就不用说了，硬件更快捷高效<br>d.Tunnel 硬件卸载功能，这个更好理解，其实就是纯粹的协议的控制，隧道，就是一个安全通道，一个专门的通道，可以将不同的协议连接起来。类似于集装箱，直接把原始包扔进去做负载。这种简单的封装其实更适合用硬件来完成。</p>
<p>2、分片功能卸载<br>分片说得有点高级，其实也很好理解，一个大城市不好管理，划成一个个小片不就好管理了，这就是分片。在网络通信中，上层应用可能不会顾及底层的硬件和驱动的缓冲大小，向下输出大量数据，可实际的 TCP 的传输是有大小控制的，这就需要将上层的数据分片成合适的大小。而这个分片的过程软件其实是不如硬件更容易实现。因为这种机械的固定的功能最是硬件的擅长的了。</p>
<p>3、组包功能卸载<br>组包其实就上面分片的逆操作。毕竟数据最终还是回流到上层应用，必须保持数据的一致性呈现，这就需要把在数据传输过程中的一系列辅助的动作恢复原样。这就和在网上购物一样，可能是一个很小的物件，但在实际传输中可能不断的被打包，验证，然后装箱，运输。等到达目的地时再逆向操作，最终原样送到购买者手中。</p>
<h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>在 DPDK 提供了对 IEEE1588 的功能支持：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_timesync_enable</span><span class="params">(<span class="type">uint16_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);</span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;timesync_enable, -ENOTSUP);</span><br><span class="line">	<span class="keyword">return</span> eth_err(port_id, (*dev-&gt;dev_ops-&gt;timesync_enable)(dev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_timesync_disable</span><span class="params">(<span class="type">uint16_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);</span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;timesync_disable, -ENOTSUP);</span><br><span class="line">	<span class="keyword">return</span> eth_err(port_id, (*dev-&gt;dev_ops-&gt;timesync_disable)(dev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_timesync_read_rx_timestamp</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="keyword">struct</span> timespec *timestamp,</span></span><br><span class="line"><span class="params">				   <span class="type">uint32_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);</span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;timesync_read_rx_timestamp, -ENOTSUP);</span><br><span class="line">	<span class="keyword">return</span> eth_err(port_id, (*dev-&gt;dev_ops-&gt;timesync_read_rx_timestamp)</span><br><span class="line">				(dev, timestamp, flags));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_timesync_read_tx_timestamp</span><span class="params">(<span class="type">uint16_t</span> port_id,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> timespec *timestamp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);</span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;timesync_read_tx_timestamp, -ENOTSUP);</span><br><span class="line">	<span class="keyword">return</span> eth_err(port_id, (*dev-&gt;dev_ops-&gt;timesync_read_tx_timestamp)</span><br><span class="line">				(dev, timestamp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很清晰就是使能和读取双向的时间戳。而在 app&#x2F;test-pmd 中有计算 checksum 的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if possible, calculate the checksum of a packet in hw or sw,</span></span><br><span class="line"><span class="comment"> * depending on the testpmd command line configuration */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">process_inner_cksums</span><span class="params">(<span class="type">void</span> *l3_hdr, <span class="type">const</span> <span class="keyword">struct</span> testpmd_offload_info *info,</span></span><br><span class="line"><span class="params">	<span class="type">uint64_t</span> tx_offloads)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">ipv4_hdr</span> =</span> l3_hdr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_udp_hdr</span> *<span class="title">udp_hdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_tcp_hdr</span> *<span class="title">tcp_hdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_sctp_hdr</span> *<span class="title">sctp_hdr</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> ol_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> max_pkt_len, tso_segsz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ensure packet is large enough to require tso */</span></span><br><span class="line">	<span class="keyword">if</span> (!info-&gt;is_tunnel) &#123;</span><br><span class="line">		max_pkt_len = info-&gt;l2_len + info-&gt;l3_len + info-&gt;l4_len +</span><br><span class="line">			info-&gt;tso_segsz;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;tso_segsz != <span class="number">0</span> &amp;&amp; info-&gt;pkt_len &gt; max_pkt_len)</span><br><span class="line">			tso_segsz = info-&gt;tso_segsz;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		max_pkt_len = info-&gt;outer_l2_len + info-&gt;outer_l3_len +</span><br><span class="line">			info-&gt;l2_len + info-&gt;l3_len + info-&gt;l4_len +</span><br><span class="line">			info-&gt;tunnel_tso_segsz;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;tunnel_tso_segsz != <span class="number">0</span> &amp;&amp; info-&gt;pkt_len &gt; max_pkt_len)</span><br><span class="line">			tso_segsz = info-&gt;tunnel_tso_segsz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;ethertype == _htons(RTE_ETHER_TYPE_IPV4)) &#123;</span><br><span class="line">		ipv4_hdr = l3_hdr;</span><br><span class="line"></span><br><span class="line">		ol_flags |= PKT_TX_IPV4;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;l4_proto == IPPROTO_TCP &amp;&amp; tso_segsz) &#123;</span><br><span class="line">			ol_flags |= PKT_TX_IP_CKSUM;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx_offloads &amp; DEV_TX_OFFLOAD_IPV4_CKSUM) &#123;</span><br><span class="line">				ol_flags |= PKT_TX_IP_CKSUM;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ipv4_hdr-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line">				ipv4_hdr-&gt;hdr_checksum =</span><br><span class="line">					rte_ipv4_cksum(ipv4_hdr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;ethertype == _htons(RTE_ETHER_TYPE_IPV6))</span><br><span class="line">		ol_flags |= PKT_TX_IPV6;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* packet type not supported, nothing to do */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;l4_proto == IPPROTO_UDP) &#123;</span><br><span class="line">		udp_hdr = (<span class="keyword">struct</span> rte_udp_hdr *)((<span class="type">char</span> *)l3_hdr + info-&gt;l3_len);</span><br><span class="line">		<span class="comment">/* do not recalculate udp cksum if it was 0 */</span></span><br><span class="line">		<span class="keyword">if</span> (udp_hdr-&gt;dgram_cksum != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx_offloads &amp; DEV_TX_OFFLOAD_UDP_CKSUM) &#123;</span><br><span class="line">				ol_flags |= PKT_TX_UDP_CKSUM;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				udp_hdr-&gt;dgram_cksum = <span class="number">0</span>;</span><br><span class="line">				udp_hdr-&gt;dgram_cksum =</span><br><span class="line">					get_udptcp_checksum(l3_hdr, udp_hdr,</span><br><span class="line">						info-&gt;ethertype);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;gso_enable)</span><br><span class="line">			ol_flags |= PKT_TX_UDP_SEG;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;l4_proto == IPPROTO_TCP) &#123;</span><br><span class="line">		tcp_hdr = (<span class="keyword">struct</span> rte_tcp_hdr *)((<span class="type">char</span> *)l3_hdr + info-&gt;l3_len);</span><br><span class="line">		<span class="keyword">if</span> (tso_segsz)</span><br><span class="line">			ol_flags |= PKT_TX_TCP_SEG;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tx_offloads &amp; DEV_TX_OFFLOAD_TCP_CKSUM) &#123;</span><br><span class="line">			ol_flags |= PKT_TX_TCP_CKSUM;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tcp_hdr-&gt;cksum = <span class="number">0</span>;</span><br><span class="line">			tcp_hdr-&gt;cksum =</span><br><span class="line">				get_udptcp_checksum(l3_hdr, tcp_hdr,</span><br><span class="line">					info-&gt;ethertype);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;gso_enable)</span><br><span class="line">			ol_flags |= PKT_TX_TCP_SEG;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;l4_proto == IPPROTO_SCTP) &#123;</span><br><span class="line">		sctp_hdr = (<span class="keyword">struct</span> rte_sctp_hdr *)</span><br><span class="line">			((<span class="type">char</span> *)l3_hdr + info-&gt;l3_len);</span><br><span class="line">		<span class="comment">/* sctp payload must be a multiple of 4 to be</span></span><br><span class="line"><span class="comment">		 * offloaded */</span></span><br><span class="line">		<span class="keyword">if</span> ((tx_offloads &amp; DEV_TX_OFFLOAD_SCTP_CKSUM) &amp;&amp;</span><br><span class="line">			((ipv4_hdr-&gt;total_length &amp; <span class="number">0x3</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">			ol_flags |= PKT_TX_SCTP_CKSUM;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sctp_hdr-&gt;cksum = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">/* XXX implement CRC32c, example available in</span></span><br><span class="line"><span class="comment">			 * RFC3309 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ol_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下组包的支持：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line">* Initializes Receive Unit.</span><br><span class="line">*/</span><br><span class="line"><span class="type">int</span> __attribute__((cold)) ixgbe_dev_rx_init(<span class="keyword">struct</span> rte_eth_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span>     *<span class="title">hw</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line"> <span class="type">uint64_t</span> bus_addr;</span><br><span class="line"> <span class="type">uint32_t</span> rxctrl;</span><br><span class="line"> <span class="type">uint32_t</span> fctrl;</span><br><span class="line"> <span class="type">uint32_t</span> hlreg0;</span><br><span class="line"> <span class="type">uint32_t</span> maxfrs;</span><br><span class="line"> <span class="type">uint32_t</span> srrctl;</span><br><span class="line"> <span class="type">uint32_t</span> rdrxctl;</span><br><span class="line"> <span class="type">uint32_t</span> rxcsum;</span><br><span class="line"> <span class="type">uint16_t</span> buf_size;</span><br><span class="line"> <span class="type">uint16_t</span> i;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> *<span class="title">rx_conf</span> =</span> &amp;dev-&gt;data-&gt;dev_conf.rxmode;</span><br><span class="line"> <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"> PMD_INIT_FUNC_TRACE();</span><br><span class="line"> hw = IXGBE_DEV_PRIVATE_TO_HW(dev-&gt;data-&gt;dev_private);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Make sure receives are disabled while setting</span></span><br><span class="line"><span class="comment">  * up the RX context (registers, descriptor rings, etc.).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);</span><br><span class="line"> IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Enable receipt of broadcasted frames */</span></span><br><span class="line"> fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);</span><br><span class="line"> fctrl |= IXGBE_FCTRL_BAM;</span><br><span class="line"> fctrl |= IXGBE_FCTRL_DPF;</span><br><span class="line"> fctrl |= IXGBE_FCTRL_PMCF;</span><br><span class="line"> IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Configure CRC stripping, if any.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);</span><br><span class="line"> <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">   hlreg0 &amp;= ~IXGBE_HLREG0_RXCRCSTRP;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   hlreg0 |= IXGBE_HLREG0_RXCRCSTRP;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Configure jumbo frame support, if any.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_JUMBO_FRAME) &#123;</span><br><span class="line">   hlreg0 |= IXGBE_HLREG0_JUMBOEN;</span><br><span class="line">   maxfrs = IXGBE_READ_REG(hw, IXGBE_MAXFRS);</span><br><span class="line">   maxfrs &amp;= <span class="number">0x0000FFFF</span>;</span><br><span class="line">   maxfrs |= (rx_conf-&gt;max_rx_pkt_len &lt;&lt; <span class="number">16</span>);</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_MAXFRS, maxfrs);</span><br><span class="line"> &#125; <span class="keyword">else</span></span><br><span class="line">   hlreg0 &amp;= ~IXGBE_HLREG0_JUMBOEN;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * If loopback mode is configured, set LPBK bit.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.lpbk_mode != <span class="number">0</span>) &#123;</span><br><span class="line">   rc = ixgbe_check_supported_loopback_mode(dev);</span><br><span class="line">   <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     PMD_INIT_LOG(ERR, <span class="string">&quot;Unsupported loopback mode&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> rc;</span><br><span class="line">   &#125;</span><br><span class="line">   hlreg0 |= IXGBE_HLREG0_LPBK;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   hlreg0 &amp;= ~IXGBE_HLREG0_LPBK;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Assume no header split and no VLAN strip support</span></span><br><span class="line"><span class="comment">  * on any Rx queue first .</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> rx_conf-&gt;offloads &amp;= ~DEV_RX_OFFLOAD_VLAN_STRIP;</span><br><span class="line"> <span class="comment">/* Setup RX queues */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_rx_queues; i++) &#123;</span><br><span class="line">   rxq = dev-&gt;data-&gt;rx_queues[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Reset crc_len in case it was changed after queue setup by a</span></span><br><span class="line"><span class="comment">    * call to configure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">     rxq-&gt;crc_len = RTE_ETHER_CRC_LEN;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     rxq-&gt;crc_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Setup the Base and Length of the Rx Descriptor Rings */</span></span><br><span class="line">   bus_addr = rxq-&gt;rx_ring_phys_addr;</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDBAL(rxq-&gt;reg_idx),</span><br><span class="line">       (<span class="type">uint32_t</span>)(bus_addr &amp; <span class="number">0x00000000ffffffff</span>ULL));</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDBAH(rxq-&gt;reg_idx),</span><br><span class="line">       (<span class="type">uint32_t</span>)(bus_addr &gt;&gt; <span class="number">32</span>));</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDLEN(rxq-&gt;reg_idx),</span><br><span class="line">       rxq-&gt;nb_rx_desc * <span class="keyword">sizeof</span>(<span class="keyword">union</span> ixgbe_adv_rx_desc));</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDH(rxq-&gt;reg_idx), <span class="number">0</span>);</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDT(rxq-&gt;reg_idx), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Configure the SRRCTL register */</span></span><br><span class="line">   srrctl = IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Set if packets are dropped when no descriptors available */</span></span><br><span class="line">   <span class="keyword">if</span> (rxq-&gt;drop_en)</span><br><span class="line">     srrctl |= IXGBE_SRRCTL_DROP_EN;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Configure the RX buffer size in the BSIZEPACKET field of</span></span><br><span class="line"><span class="comment">    * the SRRCTL register of the queue.</span></span><br><span class="line"><span class="comment">    * The value is in 1 KB resolution. Valid values can be from</span></span><br><span class="line"><span class="comment">    * 1 KB to 16 KB.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   buf_size = (<span class="type">uint16_t</span>)(rte_pktmbuf_data_room_size(rxq-&gt;mb_pool) -</span><br><span class="line">     RTE_PKTMBUF_HEADROOM);</span><br><span class="line">   srrctl |= ((buf_size &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT) &amp;</span><br><span class="line">        IXGBE_SRRCTL_BSIZEPKT_MASK);</span><br><span class="line"></span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(rxq-&gt;reg_idx), srrctl);</span><br><span class="line"></span><br><span class="line">   buf_size = (<span class="type">uint16_t</span>) ((srrctl &amp; IXGBE_SRRCTL_BSIZEPKT_MASK) &lt;&lt;</span><br><span class="line">              IXGBE_SRRCTL_BSIZEPKT_SHIFT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* It adds dual VLAN length for supporting dual VLAN */</span></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len +</span><br><span class="line">             <span class="number">2</span> * IXGBE_VLAN_TAG_SIZE &gt; buf_size)</span><br><span class="line">     dev-&gt;data-&gt;scattered_rx = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (rxq-&gt;offloads &amp; DEV_RX_OFFLOAD_VLAN_STRIP)</span><br><span class="line">     rx_conf-&gt;offloads |= DEV_RX_OFFLOAD_VLAN_STRIP;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_SCATTER)</span><br><span class="line">   dev-&gt;data-&gt;scattered_rx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Device configured with multiple RX queues.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> ixgbe_dev_mq_rx_configure(dev);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Setup the Checksum Register.</span></span><br><span class="line"><span class="comment">  * Disable Full-Packet Checksum which is mutually exclusive with RSS.</span></span><br><span class="line"><span class="comment">  * Enable IP/L4 checkum computation by hardware if requested to do so.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> rxcsum = IXGBE_READ_REG(hw, IXGBE_RXCSUM);</span><br><span class="line"> rxcsum |= IXGBE_RXCSUM_PCSD;</span><br><span class="line"> <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_CHECKSUM)</span><br><span class="line">   rxcsum |= IXGBE_RXCSUM_IPPCSE;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   rxcsum &amp;= ~IXGBE_RXCSUM_IPPCSE;</span><br><span class="line"></span><br><span class="line"> IXGBE_WRITE_REG(hw, IXGBE_RXCSUM, rxcsum);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB ||</span><br><span class="line">     hw-&gt;mac.type == ixgbe_mac_X540) &#123;</span><br><span class="line">   rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);</span><br><span class="line">   <span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">     rdrxctl &amp;= ~IXGBE_RDRXCTL_CRCSTRIP;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     rdrxctl |= IXGBE_RDRXCTL_CRCSTRIP;</span><br><span class="line">   rdrxctl &amp;= ~IXGBE_RDRXCTL_RSCFRSTSIZE;</span><br><span class="line">   IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rdrxctl);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rc = ixgbe_set_rsc(dev);</span><br><span class="line"> <span class="keyword">if</span> (rc)</span><br><span class="line">   <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line"> ixgbe_set_rx_function(dev);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ixgbe_set_rsc - configure RSC related port HW registers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configures the port&#x27;s RSC related registers according to the 4.6.7.2 chapter</span></span><br><span class="line"><span class="comment"> * of 82599 Spec (x540 configuration is virtually the same).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev port handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 in case of success or a non-zero error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ixgbe_set_rsc</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> *<span class="title">rx_conf</span> =</span> &amp;dev-&gt;data-&gt;dev_conf.rxmode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span> *<span class="title">hw</span> =</span> IXGBE_DEV_PRIVATE_TO_HW(dev-&gt;data-&gt;dev_private);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">bool</span> rsc_capable = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="type">uint32_t</span> rdrxctl;</span><br><span class="line">	<span class="type">uint32_t</span> rfctl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity check */</span></span><br><span class="line">	dev-&gt;dev_ops-&gt;dev_infos_get(dev, &amp;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (dev_info.rx_offload_capa &amp; DEV_RX_OFFLOAD_TCP_LRO)</span><br><span class="line">		rsc_capable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rsc_capable &amp;&amp; (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_TCP_LRO)) &#123;</span><br><span class="line">		PMD_INIT_LOG(CRIT, <span class="string">&quot;LRO is requested on HW that doesn&#x27;t &quot;</span></span><br><span class="line">				   <span class="string">&quot;support it&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RSC global configuration (chapter 4.6.7.2.1 of 82599 Spec) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC) &amp;&amp;</span><br><span class="line">	     (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_TCP_LRO)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * According to chapter of 4.6.7.2.1 of the Spec Rev.</span></span><br><span class="line"><span class="comment">		 * 3.0 RSC configuration requires HW CRC stripping being</span></span><br><span class="line"><span class="comment">		 * enabled. If user requested both HW CRC stripping off</span></span><br><span class="line"><span class="comment">		 * and RSC on - return an error.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PMD_INIT_LOG(CRIT, <span class="string">&quot;LRO can&#x27;t be enabled when HW CRC &quot;</span></span><br><span class="line">				    <span class="string">&quot;is disabled&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RFCTL configuration  */</span></span><br><span class="line">	rfctl = IXGBE_READ_REG(hw, IXGBE_RFCTL);</span><br><span class="line">	<span class="keyword">if</span> ((rsc_capable) &amp;&amp; (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_TCP_LRO))</span><br><span class="line">		rfctl &amp;= ~IXGBE_RFCTL_RSC_DIS;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rfctl |= IXGBE_RFCTL_RSC_DIS;</span><br><span class="line">	<span class="comment">/* disable NFS filtering */</span></span><br><span class="line">	rfctl |= IXGBE_RFCTL_NFSW_DIS | IXGBE_RFCTL_NFSR_DIS;</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RFCTL, rfctl);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If LRO hasn&#x27;t been requested - we are done here. */</span></span><br><span class="line">	<span class="keyword">if</span> (!(rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_TCP_LRO))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set RDRXCTL.RSCACKC bit */</span></span><br><span class="line">	rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);</span><br><span class="line">	rdrxctl |= IXGBE_RDRXCTL_RSCACKC;</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rdrxctl);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-queue RSC configuration (chapter 4.6.7.2.2 of 82599 Spec) */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_rx_queues; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span> =</span> dev-&gt;data-&gt;rx_queues[i];</span><br><span class="line">		<span class="type">uint32_t</span> srrctl =</span><br><span class="line">			IXGBE_READ_REG(hw, IXGBE_SRRCTL(rxq-&gt;reg_idx));</span><br><span class="line">		<span class="type">uint32_t</span> rscctl =</span><br><span class="line">			IXGBE_READ_REG(hw, IXGBE_RSCCTL(rxq-&gt;reg_idx));</span><br><span class="line">		<span class="type">uint32_t</span> psrtype =</span><br><span class="line">			IXGBE_READ_REG(hw, IXGBE_PSRTYPE(rxq-&gt;reg_idx));</span><br><span class="line">		<span class="type">uint32_t</span> eitr =</span><br><span class="line">			IXGBE_READ_REG(hw, IXGBE_EITR(rxq-&gt;reg_idx));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ixgbe PMD doesn&#x27;t support header-split at the moment.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Following the 4.6.7.2.1 chapter of the 82599/x540</span></span><br><span class="line"><span class="comment">		 * Spec if RSC is enabled the SRRCTL[n].BSIZEHEADER</span></span><br><span class="line"><span class="comment">		 * should be configured even if header split is not</span></span><br><span class="line"><span class="comment">		 * enabled. We will configure it 128 bytes following the</span></span><br><span class="line"><span class="comment">		 * recommendation in the spec.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		srrctl &amp;= ~IXGBE_SRRCTL_BSIZEHDR_MASK;</span><br><span class="line">		srrctl |= (<span class="number">128</span> &lt;&lt; IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT) &amp;</span><br><span class="line">					    IXGBE_SRRCTL_BSIZEHDR_MASK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">TODO:</span> Consider setting the Receive Descriptor Minimum</span></span><br><span class="line"><span class="comment">		 * Threshold Size for an RSC case. This is not an obviously</span></span><br><span class="line"><span class="comment">		 * beneficiary option but the one worth considering...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		rscctl |= IXGBE_RSCCTL_RSCEN;</span><br><span class="line">		rscctl |= ixgbe_get_rscctl_maxdesc(rxq-&gt;mb_pool);</span><br><span class="line">		psrtype |= IXGBE_PSRTYPE_TCPHDR;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * RSC: Set ITR interval corresponding to 2K ints/s.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Full-sized RSC aggregations for a 10Gb/s link will</span></span><br><span class="line"><span class="comment">		 * arrive at about 20K aggregation/s rate.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 2K inst/s rate will make only 10% of the</span></span><br><span class="line"><span class="comment">		 * aggregations to be closed due to the interrupt timer</span></span><br><span class="line"><span class="comment">		 * expiration for a streaming at wire-speed case.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * For a sparse streaming case this setting will yield</span></span><br><span class="line"><span class="comment">		 * at most 500us latency for a single RSC aggregation.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		eitr &amp;= ~IXGBE_EITR_ITR_INT_MASK;</span><br><span class="line">		eitr |= IXGBE_EITR_INTERVAL_US(IXGBE_QUEUE_ITR_INTERVAL_DEFAULT);</span><br><span class="line">		eitr |= IXGBE_EITR_CNT_WDIS;</span><br><span class="line"></span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(rxq-&gt;reg_idx), srrctl);</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(rxq-&gt;reg_idx), rscctl);</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(rxq-&gt;reg_idx), psrtype);</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_EITR(rxq-&gt;reg_idx), eitr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * RSC requires the mapping of the queue to the</span></span><br><span class="line"><span class="comment">		 * interrupt vector.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ixgbe_set_ivar(dev, rxq-&gt;reg_idx, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;data-&gt;lro = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_LOG(DEBUG, <span class="string">&quot;enabling LRO mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ixgbe_set_rsc 会对 DEV_RX_OFFLOAD_TCP_LRO 进行判断来决定是否组包，这个 LRO（Large Receive Offload）其实是 RSC（Receive Side Coalescing）的另外一种描述方式。</p>
<h1 id="数据包流程"><a href="#数据包流程" class="headerlink" title="数据包流程"></a>数据包流程</h1><p>在前面详细分析过数据包的转运流程，其实做一种 IO 接口，一定是分成两部分，即数据的接收和发送。从宏观上看，无论数据的接收和发送，都需要网卡到队列（Ring）然后到应用层的这么一个过程。DPDK 的特点是尽量不打扰内核，并通过 DMA（RDMA）的方式将数据利用队列将应用层与网卡进行交互。<br>而在这个交互的过程中，又有几种方式，如轮询、中断和混合三种方式。明白了这些，再加上前面的相关文章的分析，那么整体的流程和细节的程序大致已经把握了，那么最重要的就是看 DPDK 的源码是如何实现这些的。</p>
<h3 id="三、源码分析-1"><a href="#三、源码分析-1" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>闲言少叙，直接进入正题 <code>examples/skeleton/basicfwd.c</code>：<br>先看入口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The main function, which does initialization and calls the per-lcore</span></span><br><span class="line"><span class="comment"> * functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> nb_ports;</span><br><span class="line">	<span class="type">uint16_t</span> portid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the Environment Abstraction Layer (EAL). */</span></span><br><span class="line">	<span class="type">int</span> ret = rte_eal_init(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL initialization\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	argc -= ret;</span><br><span class="line">	argv += ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check that there is an even number of ports to send/receive on. */</span></span><br><span class="line">	nb_ports = rte_eth_dev_count_avail();</span><br><span class="line">	<span class="keyword">if</span> (nb_ports &lt; <span class="number">2</span> || (nb_ports &amp; <span class="number">1</span>))</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error: number of ports must be even\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Creates a new mempool in memory to hold the mbufs. */</span></span><br><span class="line">	mbuf_pool = rte_pktmbuf_pool_create(<span class="string">&quot;MBUF_POOL&quot;</span>, NUM_MBUFS * nb_ports,</span><br><span class="line">		MBUF_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot create mbuf pool\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize all ports. */</span></span><br><span class="line">	RTE_ETH_FOREACH_DEV(portid)</span><br><span class="line">		<span class="keyword">if</span> (port_init(portid, mbuf_pool) != <span class="number">0</span>)</span><br><span class="line">			rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot init port %&quot;</span>PRIu16 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">					portid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_lcore_count() &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nWARNING: Too many lcores enabled. Only 1 used.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call lcore_main on the master core only. */</span></span><br><span class="line">	lcore_main();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean up the EAL */</span></span><br><span class="line">	rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上看，首先是主函数中需要调用 rte_eal_init 对所有的相关参数和设置进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Launch threads, called at application init(). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* checks if the machine is adequate */</span></span><br><span class="line">	<span class="keyword">if</span> (!rte_cpu_is_supported()) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;unsupported cpu type.&quot;</span>);</span><br><span class="line">		rte_errno = ENOTSUP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_atomic32_test_and_set(&amp;run_once)) &#123;</span><br><span class="line">		rte_eal_init_alert(<span class="string">&quot;already called initialization.&quot;</span>);</span><br><span class="line">		rte_errno = EALREADY;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call each registered callback, if enabled */</span></span><br><span class="line">	rte_option_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fctret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数已经分析过多次了，但是其中其实还有很多的细节没有分析到位，这个只有真正的用到哪块才会认真的去看每一行代码。这个代码其实就是大量的参数、配置、大页内存等待的初始化。反正代码里大量的 init 估计即使不明白初始化啥也知道是初始化的功能。<br>其下就是检查偶数个端的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">rte_eth_dev_count_avail</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> p;</span><br><span class="line">	<span class="type">uint16_t</span> count;</span><br><span class="line"></span><br><span class="line">	count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	RTE_ETH_FOREACH_DEV(p)</span><br><span class="line">		count++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始创建内存池：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* helper to create a mbuf pool */</span></span><br><span class="line"><span class="keyword">struct</span> rte_mempool * <span class="title function_">rte_pktmbuf_pool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> n,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> cache_size, <span class="type">uint16_t</span> priv_size, <span class="type">uint16_t</span> data_room_size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> socket_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rte_pktmbuf_pool_create_by_ops(name, n, cache_size, priv_size,</span><br><span class="line">			data_room_size, socket_id, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用端口初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* basicfwd.c: Basic DPDK skeleton forwarding example. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initializes a given port using global settings and with the RX buffers</span></span><br><span class="line"><span class="comment"> * coming from the mbuf_pool passed as a parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">port_init</span><span class="params">(<span class="type">uint16_t</span> port, <span class="keyword">struct</span> rte_mempool *mbuf_pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span> =</span> port_conf_default;</span><br><span class="line">	<span class="type">const</span> <span class="type">uint16_t</span> rx_rings = <span class="number">1</span>, tx_rings = <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable RX in promiscuous mode for the Ethernet device. */</span></span><br><span class="line">	retval = rte_eth_promiscuous_enable(port);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过 rte_lcore_count() 来判断逻辑核心的数量，如果多于 1 个，在本程序其实没啥意义。<br>最后调用函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((<span class="keyword">noreturn</span>)) <span class="type">void</span> <span class="title function_">lcore_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check that the port is on the same NUMA node as the polling thread</span></span><br><span class="line"><span class="comment">	 * for best performance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ETH_FOREACH_DEV(port)</span><br><span class="line">		<span class="keyword">if</span> (rte_eth_dev_socket_id(port) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">				rte_eth_dev_socket_id(port) !=</span><br><span class="line">						(<span class="type">int</span>)rte_socket_id())</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;WARNING, port %u is on remote NUMA node to &quot;</span></span><br><span class="line">					<span class="string">&quot;polling thread.\n\tPerformance will &quot;</span></span><br><span class="line">					<span class="string">&quot;not be optimal.\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nCore %u forwarding packets. [Ctrl+C to quit]\n&quot;</span>,</span><br><span class="line">			rte_lcore_id());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Run until the application is quit or killed. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Receive packets on a port and forward them on the paired</span></span><br><span class="line"><span class="comment">		 * port. The mapping is 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2, etc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RTE_ETH_FOREACH_DEV(port) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Get burst of RX packets, from first port of pair. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">bufs</span>[<span class="title">BURST_SIZE</span>];</span></span><br><span class="line">			<span class="type">const</span> <span class="type">uint16_t</span> nb_rx = rte_eth_rx_burst(port, <span class="number">0</span>,</span><br><span class="line">					bufs, BURST_SIZE);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(nb_rx == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Send burst of TX packets, to second port of pair. */</span></span><br><span class="line">			<span class="type">const</span> <span class="type">uint16_t</span> nb_tx = rte_eth_tx_burst(port ^ <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">					bufs, nb_rx);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Free any unsent packets. */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(nb_tx &lt; nb_rx)) &#123;</span><br><span class="line">				<span class="type">uint16_t</span> buf;</span><br><span class="line">				<span class="keyword">for</span> (buf = nb_tx; buf &lt; nb_rx; buf++)</span><br><span class="line">					rte_pktmbuf_free(bufs[buf]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的处理数据收发，如果退出，则需要调用 rte_eal_cleanup() 来清理现场，并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* if we&#x27;re in a primary process, we need to mark hugepages as freeable</span></span><br><span class="line"><span class="comment">	 * so that finalization can release them back to the system.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rte_eal_process_type() == RTE_PROC_PRIMARY)</span><br><span class="line">		rte_memseg_walk(mark_freeable, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	rte_service_finalize();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VFIO_PRESENT</span></span><br><span class="line">	vfio_mp_sync_cleanup();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	rte_mp_channel_cleanup();</span><br><span class="line">	eal_cleanup_config(&amp;internal_config);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序相对简单，又对数据流进行了网口的转发，这样，对数据包正好有收有接，容易分析理解。在这个简单的服务代码中，开始展开对 DPDK 中数据流程的整体流转的源码分析。</p>
<p>调用的数据结构和相关函数源码在上半部分，port_init 函数在其后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A structure used to configure an Ethernet port.</span></span><br><span class="line"><span class="comment"> * Depending upon the RX multi-queue mode, extra advanced</span></span><br><span class="line"><span class="comment"> * configuration settings may be needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> link_speeds; <span class="comment">/**&lt; bitmap of ETH_LINK_SPEED_XXX of speeds to be</span></span><br><span class="line"><span class="comment">				used. ETH_LINK_SPEED_FIXED disables link</span></span><br><span class="line"><span class="comment">				autonegotiation, and a unique speed shall be</span></span><br><span class="line"><span class="comment">				set. Otherwise, the bitmap defines the set of</span></span><br><span class="line"><span class="comment">				speeds to be advertised. If the special value</span></span><br><span class="line"><span class="comment">				ETH_LINK_SPEED_AUTONEG (0) is used, all speeds</span></span><br><span class="line"><span class="comment">				supported are advertised. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> <span class="title">rxmode</span>;</span> <span class="comment">/**&lt; Port RX configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txmode</span> <span class="title">txmode</span>;</span> <span class="comment">/**&lt; Port TX configuration. */</span></span><br><span class="line">	<span class="type">uint32_t</span> lpbk_mode; <span class="comment">/**&lt; Loopback operation mode. By default the value</span></span><br><span class="line"><span class="comment">			         is 0, meaning the loopback mode is disabled.</span></span><br><span class="line"><span class="comment">				 Read the datasheet of given ethernet controller</span></span><br><span class="line"><span class="comment">				 for details. The possible values of this field</span></span><br><span class="line"><span class="comment">				 are defined in implementation of each driver. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rss_conf</span> <span class="title">rss_conf</span>;</span> <span class="comment">/**&lt; Port RSS configuration */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_conf</span> <span class="title">vmdq_dcb_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq+dcb configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_rx_conf</span> <span class="title">dcb_rx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port dcb RX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_rx_conf</span> <span class="title">vmdq_rx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq RX configuration. */</span></span><br><span class="line">	&#125; rx_adv_conf; <span class="comment">/**&lt; Port RX filtering configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_tx_conf</span> <span class="title">vmdq_dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq+dcb TX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_tx_conf</span> <span class="title">dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port dcb TX configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_tx_conf</span> <span class="title">vmdq_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/**&lt; Port vmdq TX configuration. */</span></span><br><span class="line">	&#125; tx_adv_conf; <span class="comment">/**&lt; Port TX DCB configuration (union). */</span></span><br><span class="line">	<span class="comment">/** Currently,Priority Flow Control(PFC) are supported,if DCB with PFC</span></span><br><span class="line"><span class="comment">	    is needed,and the variable must be set ETH_DCB_PFC_SUPPORT. */</span></span><br><span class="line">	<span class="type">uint32_t</span> dcb_capability_en;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_fdir_conf</span> <span class="title">fdir_conf</span>;</span> <span class="comment">/**&lt; FDIR configuration. DEPRECATED */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_conf</span> <span class="title">intr_conf</span>;</span> <span class="comment">/**&lt; Interrupt mode configuration. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_is_valid_port</span><span class="params">(<span class="type">uint16_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (port_id &gt;= RTE_MAX_ETHPORTS ||</span><br><span class="line">	    (rte_eth_devices[port_id].state == RTE_ETH_DEV_UNUSED))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_info_get</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="keyword">struct</span> rte_eth_dev_info *dev_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_desc_lim</span> <span class="title">lim</span> =</span> &#123;</span><br><span class="line">		.nb_max = UINT16_MAX,</span><br><span class="line">		.nb_min = <span class="number">0</span>,</span><br><span class="line">		.nb_align = <span class="number">1</span>,</span><br><span class="line">		.nb_seg_max = UINT16_MAX,</span><br><span class="line">		.nb_mtu_seg_max = UINT16_MAX,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> diag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Init dev_info before port_id check since caller does not have</span></span><br><span class="line"><span class="comment">	 * return status and does not know if get is successful or not.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(dev_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_eth_dev_info));</span><br><span class="line">	dev_info-&gt;switch_info.domain_id = RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID;</span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);</span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	dev_info-&gt;rx_desc_lim = lim;</span><br><span class="line">	dev_info-&gt;tx_desc_lim = lim;</span><br><span class="line">	dev_info-&gt;device = dev-&gt;device;</span><br><span class="line">	dev_info-&gt;min_mtu = RTE_ETHER_MIN_MTU;</span><br><span class="line">	dev_info-&gt;max_mtu = UINT16_MAX;</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;dev_infos_get, -ENOTSUP);</span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;dev_infos_get)(dev, dev_info);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Cleanup already filled in device information */</span></span><br><span class="line">		<span class="built_in">memset</span>(dev_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_eth_dev_info));</span><br><span class="line">		<span class="keyword">return</span> eth_err(port_id, diag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Maximum number of queues should be &lt;= RTE_MAX_QUEUES_PER_PORT */</span></span><br><span class="line">	dev_info-&gt;max_rx_queues = RTE_MIN(dev_info-&gt;max_rx_queues,</span><br><span class="line">			RTE_MAX_QUEUES_PER_PORT);</span><br><span class="line">	dev_info-&gt;max_tx_queues = RTE_MIN(dev_info-&gt;max_tx_queues,</span><br><span class="line">			RTE_MAX_QUEUES_PER_PORT);</span><br><span class="line"></span><br><span class="line">	dev_info-&gt;driver_name = dev-&gt;device-&gt;driver-&gt;name;</span><br><span class="line">	dev_info-&gt;nb_rx_queues = dev-&gt;data-&gt;nb_rx_queues;</span><br><span class="line">	dev_info-&gt;nb_tx_queues = dev-&gt;data-&gt;nb_tx_queues;</span><br><span class="line"></span><br><span class="line">	dev_info-&gt;dev_flags = &amp;dev-&gt;data-&gt;dev_flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================================================================================================================</span></span><br><span class="line"><span class="comment">/*调用代码及数据结构体在上方*/</span></span><br><span class="line"><span class="comment">//=======================================================================================================================</span></span><br><span class="line"><span class="comment">/* basicfwd.c: Basic DPDK skeleton forwarding example. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initializes a given port using global settings and with the RX buffers</span></span><br><span class="line"><span class="comment"> * coming from the mbuf_pool passed as a parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">port_init</span><span class="params">(<span class="type">uint16_t</span> port, <span class="keyword">struct</span> rte_mempool *mbuf_pool)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//使用默认配置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span> =</span> port_conf_default;<span class="comment">//一个默认的数据结构</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint16_t</span> rx_rings = <span class="number">1</span>, tx_rings = <span class="number">1</span>;<span class="comment">//收发环形队列数量</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_rxd = RX_RING_SIZE;</span><br><span class="line">	<span class="type">uint16_t</span> nb_txd = TX_RING_SIZE;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">uint16_t</span> q;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">txconf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//端口是否可用</span></span><br><span class="line">	<span class="keyword">if</span> (!rte_eth_dev_is_valid_port(port))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由端口获得设备信息</span></span><br><span class="line">	retval = rte_eth_dev_info_get(port, &amp;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error during getting device (port %u) info: %s\n&quot;</span>,</span><br><span class="line">				port, strerror(-retval));</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_info.tx_offload_capa &amp; DEV_TX_OFFLOAD_MBUF_FAST_FREE)</span><br><span class="line">		port_conf.txmode.offloads |=</span><br><span class="line">			DEV_TX_OFFLOAD_MBUF_FAST_FREE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Configure the Ethernet device. */</span></span><br><span class="line">	retval = rte_eth_dev_configure(port, rx_rings, tx_rings, &amp;port_conf);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对收发描述符数量进行合格检查</span></span><br><span class="line">	retval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &amp;nb_rxd, &amp;nb_txd);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate and set up 1 RX queue per Ethernet port. */</span></span><br><span class="line">	<span class="comment">//rte_eth_dev_socket_id:如果为NUMA架构则使用这个函数得到port对应的以太网设备ID，否则为</span></span><br><span class="line">	<span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; rx_rings; q++) &#123;</span><br><span class="line">		retval = rte_eth_rx_queue_setup(port, q, nb_rxd,</span><br><span class="line">				rte_eth_dev_socket_id(port), <span class="literal">NULL</span>, mbuf_pool);<span class="comment">//NULL表示使用默认设备，否则指向RX 的队列</span></span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txconf = dev_info.default_txconf;</span><br><span class="line">	txconf.offloads = port_conf.txmode.offloads;</span><br><span class="line">	<span class="comment">/* Allocate and set up 1 TX queue per Ethernet port. */</span></span><br><span class="line">	<span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; tx_rings; q++) &#123;</span><br><span class="line">		retval = rte_eth_tx_queue_setup(port, q, nb_txd,</span><br><span class="line">				rte_eth_dev_socket_id(port), &amp;txconf);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start the Ethernet port. */</span></span><br><span class="line">	<span class="comment">//启动设备</span></span><br><span class="line">	retval = rte_eth_dev_start(port);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Display the port MAC address. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">	retval = rte_eth_macaddr_get(port, &amp;addr);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Port %u MAC: %02&quot;</span> PRIx8 <span class="string">&quot; %02&quot;</span> PRIx8 <span class="string">&quot; %02&quot;</span> PRIx8</span><br><span class="line">			   <span class="string">&quot; %02&quot;</span> PRIx8 <span class="string">&quot; %02&quot;</span> PRIx8 <span class="string">&quot; %02&quot;</span> PRIx8 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">			port,</span><br><span class="line">			addr.addr_bytes[<span class="number">0</span>], addr.addr_bytes[<span class="number">1</span>],</span><br><span class="line">			addr.addr_bytes[<span class="number">2</span>], addr.addr_bytes[<span class="number">3</span>],</span><br><span class="line">			addr.addr_bytes[<span class="number">4</span>], addr.addr_bytes[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable RX in promiscuous mode for the Ethernet device. */</span></span><br><span class="line">	<span class="comment">//设置网卡为混杂模式，即接收所有网卡接收到的数据</span></span><br><span class="line">	retval = rte_eth_promiscuous_enable(port);</span><br><span class="line">	<span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很重要的一个函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_configure</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> nb_rx_q, <span class="type">uint16_t</span> nb_tx_q,</span></span><br><span class="line"><span class="params">		      <span class="type">const</span> <span class="keyword">struct</span> rte_eth_conf *dev_conf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">orig_conf</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> overhead_len;</span><br><span class="line">	<span class="type">int</span> diag;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">uint16_t</span> old_mtu;</span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -EINVAL);</span><br><span class="line"></span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;dev_configure, -ENOTSUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_started) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Port %u must be stopped to allow configuration\n&quot;</span>,</span><br><span class="line">			port_id);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Store original config, as rollback required on failure */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;orig_conf, &amp;dev-&gt;data-&gt;dev_conf, <span class="keyword">sizeof</span>(dev-&gt;data-&gt;dev_conf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the dev_conf parameter into the dev structure.</span></span><br><span class="line"><span class="comment">	 * rte_eth_dev_info_get() requires dev_conf, copy it before dev_info get</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_conf != &amp;dev-&gt;data-&gt;dev_conf)</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;dev-&gt;data-&gt;dev_conf, dev_conf,</span><br><span class="line">		       <span class="keyword">sizeof</span>(dev-&gt;data-&gt;dev_conf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Backup mtu for rollback */</span></span><br><span class="line">	old_mtu = dev-&gt;data-&gt;mtu;</span><br><span class="line"></span><br><span class="line">	ret = rte_eth_dev_info_get(port_id, &amp;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the real Ethernet overhead length */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_info.max_mtu != UINT16_MAX &amp;&amp;</span><br><span class="line">	    dev_info.max_rx_pktlen &gt; dev_info.max_mtu)</span><br><span class="line">		overhead_len = dev_info.max_rx_pktlen - dev_info.max_mtu;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		overhead_len = RTE_ETHER_HDR_LEN + RTE_ETHER_CRC_LEN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If number of queues specified by application for both Rx and Tx is</span></span><br><span class="line"><span class="comment">	 * zero, use driver preferred values. This cannot be done individually</span></span><br><span class="line"><span class="comment">	 * as it is valid for either Tx or Rx (but not both) to be zero.</span></span><br><span class="line"><span class="comment">	 * If driver does not provide any preferred valued, fall back on</span></span><br><span class="line"><span class="comment">	 * EAL defaults.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nb_rx_q == <span class="number">0</span> &amp;&amp; nb_tx_q == <span class="number">0</span>) &#123;</span><br><span class="line">		nb_rx_q = dev_info.default_rxportconf.nb_queues;</span><br><span class="line">		<span class="keyword">if</span> (nb_rx_q == <span class="number">0</span>)</span><br><span class="line">			nb_rx_q = RTE_ETH_DEV_FALLBACK_RX_NBQUEUES;</span><br><span class="line">		nb_tx_q = dev_info.default_txportconf.nb_queues;</span><br><span class="line">		<span class="keyword">if</span> (nb_tx_q == <span class="number">0</span>)</span><br><span class="line">			nb_tx_q = RTE_ETH_DEV_FALLBACK_TX_NBQUEUES;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nb_rx_q &gt; RTE_MAX_QUEUES_PER_PORT) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Number of RX queues requested (%u) is greater than max supported(%d)\n&quot;</span>,</span><br><span class="line">			nb_rx_q, RTE_MAX_QUEUES_PER_PORT);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nb_tx_q &gt; RTE_MAX_QUEUES_PER_PORT) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Number of TX queues requested (%u) is greater than max supported(%d)\n&quot;</span>,</span><br><span class="line">			nb_tx_q, RTE_MAX_QUEUES_PER_PORT);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check that the numbers of RX and TX queues are not greater</span></span><br><span class="line"><span class="comment">	 * than the maximum number of RX and TX queues supported by the</span></span><br><span class="line"><span class="comment">	 * configured device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nb_rx_q &gt; dev_info.max_rx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Ethdev port_id=%u nb_rx_queues=%u &gt; %u\n&quot;</span>,</span><br><span class="line">			port_id, nb_rx_q, dev_info.max_rx_queues);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nb_tx_q &gt; dev_info.max_tx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Ethdev port_id=%u nb_tx_queues=%u &gt; %u\n&quot;</span>,</span><br><span class="line">			port_id, nb_tx_q, dev_info.max_tx_queues);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check that the device supports requested interrupts */</span></span><br><span class="line">	<span class="keyword">if</span> ((dev_conf-&gt;intr_conf.lsc == <span class="number">1</span>) &amp;&amp;</span><br><span class="line">			(!(dev-&gt;data-&gt;dev_flags &amp; RTE_ETH_DEV_INTR_LSC))) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Driver %s does not support lsc\n&quot;</span>,</span><br><span class="line">			dev-&gt;device-&gt;driver-&gt;name);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((dev_conf-&gt;intr_conf.rmv == <span class="number">1</span>) &amp;&amp;</span><br><span class="line">			(!(dev-&gt;data-&gt;dev_flags &amp; RTE_ETH_DEV_INTR_RMV))) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Driver %s does not support rmv\n&quot;</span>,</span><br><span class="line">			dev-&gt;device-&gt;driver-&gt;name);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If jumbo frames are enabled, check that the maximum RX packet</span></span><br><span class="line"><span class="comment">	 * length is supported by the configured device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_conf-&gt;rxmode.offloads &amp; DEV_RX_OFFLOAD_JUMBO_FRAME) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev_conf-&gt;rxmode.max_rx_pkt_len &gt; dev_info.max_rx_pktlen) &#123;</span><br><span class="line">			RTE_ETHDEV_LOG(ERR,</span><br><span class="line">				<span class="string">&quot;Ethdev port_id=%u max_rx_pkt_len %u &gt; max valid value %u\n&quot;</span>,</span><br><span class="line">				port_id, dev_conf-&gt;rxmode.max_rx_pkt_len,</span><br><span class="line">				dev_info.max_rx_pktlen);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> rollback;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev_conf-&gt;rxmode.max_rx_pkt_len &lt; RTE_ETHER_MIN_LEN) &#123;</span><br><span class="line">			RTE_ETHDEV_LOG(ERR,</span><br><span class="line">				<span class="string">&quot;Ethdev port_id=%u max_rx_pkt_len %u &lt; min valid value %u\n&quot;</span>,</span><br><span class="line">				port_id, dev_conf-&gt;rxmode.max_rx_pkt_len,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">int</span>)RTE_ETHER_MIN_LEN);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> rollback;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Scale the MTU size to adapt max_rx_pkt_len */</span></span><br><span class="line">		dev-&gt;data-&gt;mtu = dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len -</span><br><span class="line">				overhead_len;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">uint16_t</span> pktlen = dev_conf-&gt;rxmode.max_rx_pkt_len;</span><br><span class="line">		<span class="keyword">if</span> (pktlen &lt; RTE_ETHER_MIN_MTU + overhead_len ||</span><br><span class="line">		    pktlen &gt; RTE_ETHER_MTU + overhead_len)</span><br><span class="line">			<span class="comment">/* Use default value */</span></span><br><span class="line">			dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len =</span><br><span class="line">						RTE_ETHER_MTU + overhead_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If LRO is enabled, check that the maximum aggregated packet</span></span><br><span class="line"><span class="comment">	 * size is supported by the configured device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_conf-&gt;rxmode.offloads &amp; DEV_RX_OFFLOAD_TCP_LRO) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev_conf-&gt;rxmode.max_lro_pkt_size == <span class="number">0</span>)</span><br><span class="line">			dev-&gt;data-&gt;dev_conf.rxmode.max_lro_pkt_size =</span><br><span class="line">				dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len;</span><br><span class="line">		ret = check_lro_pkt_size(port_id,</span><br><span class="line">				dev-&gt;data-&gt;dev_conf.rxmode.max_lro_pkt_size,</span><br><span class="line">				dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len,</span><br><span class="line">				dev_info.max_lro_pkt_size);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Any requested offloading must be within its device capabilities */</span></span><br><span class="line">	<span class="keyword">if</span> ((dev_conf-&gt;rxmode.offloads &amp; dev_info.rx_offload_capa) !=</span><br><span class="line">	     dev_conf-&gt;rxmode.offloads) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Ethdev port_id=%u requested Rx offloads 0x%&quot;</span>PRIx64<span class="string">&quot; doesn&#x27;t match Rx offloads &quot;</span></span><br><span class="line">			<span class="string">&quot;capabilities 0x%&quot;</span>PRIx64<span class="string">&quot; in %s()\n&quot;</span>,</span><br><span class="line">			port_id, dev_conf-&gt;rxmode.offloads,</span><br><span class="line">			dev_info.rx_offload_capa,</span><br><span class="line">			__func__);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((dev_conf-&gt;txmode.offloads &amp; dev_info.tx_offload_capa) !=</span><br><span class="line">	     dev_conf-&gt;txmode.offloads) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Ethdev port_id=%u requested Tx offloads 0x%&quot;</span>PRIx64<span class="string">&quot; doesn&#x27;t match Tx offloads &quot;</span></span><br><span class="line">			<span class="string">&quot;capabilities 0x%&quot;</span>PRIx64<span class="string">&quot; in %s()\n&quot;</span>,</span><br><span class="line">			port_id, dev_conf-&gt;txmode.offloads,</span><br><span class="line">			dev_info.tx_offload_capa,</span><br><span class="line">			__func__);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;data-&gt;dev_conf.rx_adv_conf.rss_conf.rss_hf =</span><br><span class="line">		rte_eth_rss_hf_refine(dev_conf-&gt;rx_adv_conf.rss_conf.rss_hf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check that device supports requested rss hash functions. */</span></span><br><span class="line">	<span class="keyword">if</span> ((dev_info.flow_type_rss_offloads |</span><br><span class="line">	     dev_conf-&gt;rx_adv_conf.rss_conf.rss_hf) !=</span><br><span class="line">	    dev_info.flow_type_rss_offloads) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Ethdev port_id=%u invalid rss_hf: 0x%&quot;</span>PRIx64<span class="string">&quot;, valid value: 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">			port_id, dev_conf-&gt;rx_adv_conf.rss_conf.rss_hf,</span><br><span class="line">			dev_info.flow_type_rss_offloads);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if Rx RSS distribution is disabled but RSS hash is enabled. */</span></span><br><span class="line">	<span class="keyword">if</span> (((dev_conf-&gt;rxmode.mq_mode &amp; ETH_MQ_RX_RSS_FLAG) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">	    (dev_conf-&gt;rxmode.offloads &amp; DEV_RX_OFFLOAD_RSS_HASH)) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Ethdev port_id=%u config invalid Rx mq_mode without RSS but %s offload is requested\n&quot;</span>,</span><br><span class="line">			port_id,</span><br><span class="line">			rte_eth_dev_rx_offload_name(DEV_RX_OFFLOAD_RSS_HASH));</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setup new number of RX/TX queues and reconfigure device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	diag = rte_eth_dev_rx_queue_config(dev, nb_rx_q);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Port%u rte_eth_dev_rx_queue_config = %d\n&quot;</span>,</span><br><span class="line">			port_id, diag);</span><br><span class="line">		ret = diag;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	diag = rte_eth_dev_tx_queue_config(dev, nb_tx_q);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Port%u rte_eth_dev_tx_queue_config = %d\n&quot;</span>,</span><br><span class="line">			port_id, diag);</span><br><span class="line">		rte_eth_dev_rx_queue_config(dev, <span class="number">0</span>);</span><br><span class="line">		ret = diag;</span><br><span class="line">		<span class="keyword">goto</span> rollback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;dev_configure)(dev);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Port%u dev_configure = %d\n&quot;</span>,</span><br><span class="line">			port_id, diag);</span><br><span class="line">		ret = eth_err(port_id, diag);</span><br><span class="line">		<span class="keyword">goto</span> reset_queues;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize Rx profiling if enabled at compilation time. */</span></span><br><span class="line">	diag = __rte_eth_dev_profile_init(port_id, dev);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Port%u __rte_eth_dev_profile_init = %d\n&quot;</span>,</span><br><span class="line">			port_id, diag);</span><br><span class="line">		ret = eth_err(port_id, diag);</span><br><span class="line">		<span class="keyword">goto</span> reset_queues;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate Rx offloads. */</span></span><br><span class="line">	diag = validate_offloads(port_id,</span><br><span class="line">			dev_conf-&gt;rxmode.offloads,</span><br><span class="line">			dev-&gt;data-&gt;dev_conf.rxmode.offloads, <span class="string">&quot;Rx&quot;</span>,</span><br><span class="line">			rte_eth_dev_rx_offload_name);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		ret = diag;</span><br><span class="line">		<span class="keyword">goto</span> reset_queues;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate Tx offloads. */</span></span><br><span class="line">	diag = validate_offloads(port_id,</span><br><span class="line">			dev_conf-&gt;txmode.offloads,</span><br><span class="line">			dev-&gt;data-&gt;dev_conf.txmode.offloads, <span class="string">&quot;Tx&quot;</span>,</span><br><span class="line">			rte_eth_dev_tx_offload_name);</span><br><span class="line">	<span class="keyword">if</span> (diag != <span class="number">0</span>) &#123;</span><br><span class="line">		ret = diag;</span><br><span class="line">		<span class="keyword">goto</span> reset_queues;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">reset_queues:</span><br><span class="line">	rte_eth_dev_rx_queue_config(dev, <span class="number">0</span>);</span><br><span class="line">	rte_eth_dev_tx_queue_config(dev, <span class="number">0</span>);</span><br><span class="line">rollback:</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dev-&gt;data-&gt;dev_conf, &amp;orig_conf, <span class="keyword">sizeof</span>(dev-&gt;data-&gt;dev_conf));</span><br><span class="line">	<span class="keyword">if</span> (old_mtu != dev-&gt;data-&gt;mtu)</span><br><span class="line">		dev-&gt;data-&gt;mtu = old_mtu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是启动设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_start</span><span class="params">(<span class="type">uint16_t</span> port_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line">	<span class="type">int</span> diag;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -EINVAL);</span><br><span class="line"></span><br><span class="line">	dev = &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;dev_start, -ENOTSUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_started != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(INFO,</span><br><span class="line">			<span class="string">&quot;Device with port_id=%&quot;</span>PRIu16<span class="string">&quot; already started\n&quot;</span>,</span><br><span class="line">			port_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = rte_eth_dev_info_get(port_id, &amp;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lets restore MAC now if device does not support live change */</span></span><br><span class="line">	<span class="keyword">if</span> (*dev_info.dev_flags &amp; RTE_ETH_DEV_NOLIVE_MAC_ADDR)</span><br><span class="line">		rte_eth_dev_mac_restore(dev, &amp;dev_info);</span><br><span class="line"></span><br><span class="line">	diag = (*dev-&gt;dev_ops-&gt;dev_start)(dev);</span><br><span class="line">	<span class="keyword">if</span> (diag == <span class="number">0</span>)</span><br><span class="line">		dev-&gt;data-&gt;dev_started = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> eth_err(port_id, diag);</span><br><span class="line"></span><br><span class="line">	ret = rte_eth_dev_config_restore(dev, &amp;dev_info, port_id);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR,</span><br><span class="line">			<span class="string">&quot;Error during restoring configuration for device (port %u): %s\n&quot;</span>,</span><br><span class="line">			port_id, rte_strerror(-ret));</span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.intr_conf.lsc == <span class="number">0</span>) &#123;</span><br><span class="line">		RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;dev_ops-&gt;link_update, -ENOTSUP);</span><br><span class="line">		(*dev-&gt;dev_ops-&gt;link_update)(dev, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一切准备就绪后就可以进行收发数据了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run until the application is quit or killed. */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Receive packets on a port and forward them on the paired</span></span><br><span class="line"><span class="comment">	 * port. The mapping is 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2, etc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ETH_FOREACH_DEV(port) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get burst of RX packets, from first port of pair. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">bufs</span>[<span class="title">BURST_SIZE</span>];</span></span><br><span class="line">		<span class="type">const</span> <span class="type">uint16_t</span> nb_rx = rte_eth_rx_burst(port, <span class="number">0</span>,</span><br><span class="line">				bufs, BURST_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(nb_rx == <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Send burst of TX packets, to second port of pair. */</span></span><br><span class="line">		<span class="type">const</span> <span class="type">uint16_t</span> nb_tx = rte_eth_tx_burst(port ^ <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">				bufs, nb_rx);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Free any unsent packets. */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(nb_tx &lt; nb_rx)) &#123;</span><br><span class="line">			<span class="type">uint16_t</span> buf;</span><br><span class="line">			<span class="keyword">for</span> (buf = nb_tx; buf &lt; nb_rx; buf++)</span><br><span class="line">				rte_pktmbuf_free(bufs[buf]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的当然是两个 burst 函数，先看接收 rte_eth_rx_burst：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Retrieve a burst of input packets from a receive queue of an Ethernet</span></span><br><span class="line"><span class="comment"> * device. The retrieved packets are stored in *rte_mbuf* structures whose</span></span><br><span class="line"><span class="comment"> * pointers are supplied in the *rx_pkts* array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The rte_eth_rx_burst() function loops, parsing the RX ring of the</span></span><br><span class="line"><span class="comment"> * receive queue, up to *nb_pkts* packets, and for each completed RX</span></span><br><span class="line"><span class="comment"> * descriptor in the ring, it performs the following operations:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Initialize the *rte_mbuf* data structure associated with the</span></span><br><span class="line"><span class="comment"> *   RX descriptor according to the information provided by the NIC into</span></span><br><span class="line"><span class="comment"> *   that RX descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Store the *rte_mbuf* data structure into the next entry of the</span></span><br><span class="line"><span class="comment"> *   *rx_pkts* array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Replenish the RX descriptor with a new *rte_mbuf* buffer</span></span><br><span class="line"><span class="comment"> *   allocated from the memory pool associated with the receive queue at</span></span><br><span class="line"><span class="comment"> *   initialization time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When retrieving an input packet that was scattered by the controller</span></span><br><span class="line"><span class="comment"> * into multiple receive descriptors, the rte_eth_rx_burst() function</span></span><br><span class="line"><span class="comment"> * appends the associated *rte_mbuf* buffers to the first buffer of the</span></span><br><span class="line"><span class="comment"> * packet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The rte_eth_rx_burst() function returns the number of packets</span></span><br><span class="line"><span class="comment"> * actually retrieved, which is the number of *rte_mbuf* data structures</span></span><br><span class="line"><span class="comment"> * effectively supplied into the *rx_pkts* array.</span></span><br><span class="line"><span class="comment"> * A return value equal to *nb_pkts* indicates that the RX queue contained</span></span><br><span class="line"><span class="comment"> * at least *rx_pkts* packets, and this is likely to signify that other</span></span><br><span class="line"><span class="comment"> * received packets remain in the input queue. Applications implementing</span></span><br><span class="line"><span class="comment"> * a &quot;retrieve as much received packets as possible&quot; policy can check this</span></span><br><span class="line"><span class="comment"> * specific case and keep invoking the rte_eth_rx_burst() function until</span></span><br><span class="line"><span class="comment"> * a value less than *nb_pkts* is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This receive method has the following advantages:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - It allows a run-to-completion network stack engine to retrieve and</span></span><br><span class="line"><span class="comment"> *   to immediately process received packets in a fast burst-oriented</span></span><br><span class="line"><span class="comment"> *   approach, avoiding the overhead of unnecessary intermediate packet</span></span><br><span class="line"><span class="comment"> *   queue/dequeue operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Conversely, it also allows an asynchronous-oriented processing</span></span><br><span class="line"><span class="comment"> *   method to retrieve bursts of received packets and to immediately</span></span><br><span class="line"><span class="comment"> *   queue them for further parallel processing by another logical core,</span></span><br><span class="line"><span class="comment"> *   for instance. However, instead of having received packets being</span></span><br><span class="line"><span class="comment"> *   individually queued by the driver, this approach allows the caller</span></span><br><span class="line"><span class="comment"> *   of the rte_eth_rx_burst() function to queue a burst of retrieved</span></span><br><span class="line"><span class="comment"> *   packets at a time and therefore dramatically reduce the cost of</span></span><br><span class="line"><span class="comment"> *   enqueue/dequeue operations per packet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - It allows the rte_eth_rx_burst() function of the driver to take</span></span><br><span class="line"><span class="comment"> *   advantage of burst-oriented hardware features (CPU cache,</span></span><br><span class="line"><span class="comment"> *   prefetch instructions, and so on) to minimize the number of CPU</span></span><br><span class="line"><span class="comment"> *   cycles per packet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To summarize, the proposed receive API enables many</span></span><br><span class="line"><span class="comment"> * burst-oriented optimizations in both synchronous and asynchronous</span></span><br><span class="line"><span class="comment"> * packet processing environments with no overhead in both cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The rte_eth_rx_burst() function does not provide any error</span></span><br><span class="line"><span class="comment"> * notification to avoid the corresponding overhead. As a hint, the</span></span><br><span class="line"><span class="comment"> * upper-level application might check the status of the device link once</span></span><br><span class="line"><span class="comment"> * being systematically returned a 0 value for a given number of tries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param port_id</span></span><br><span class="line"><span class="comment"> *   The port identifier of the Ethernet device.</span></span><br><span class="line"><span class="comment"> * @param queue_id</span></span><br><span class="line"><span class="comment"> *   The index of the receive queue from which to retrieve input packets.</span></span><br><span class="line"><span class="comment"> *   The value must be in the range [0, nb_rx_queue - 1] previously supplied</span></span><br><span class="line"><span class="comment"> *   to rte_eth_dev_configure().</span></span><br><span class="line"><span class="comment"> * @param rx_pkts</span></span><br><span class="line"><span class="comment"> *   The address of an array of pointers to *rte_mbuf* structures that</span></span><br><span class="line"><span class="comment"> *   must be large enough to store *nb_pkts* pointers in it.</span></span><br><span class="line"><span class="comment"> * @param nb_pkts</span></span><br><span class="line"><span class="comment"> *   The maximum number of packets to retrieve.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   The number of packets actually retrieved, which is the number</span></span><br><span class="line"><span class="comment"> *   of pointers to *rte_mbuf* structures effectively supplied to the</span></span><br><span class="line"><span class="comment"> *   *rx_pkts* array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line">	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line">	RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;rx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_rx_queues) &#123;</span><br><span class="line">		RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid RX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	nb_rx = (*dev-&gt;rx_pkt_burst)(dev-&gt;data-&gt;rx_queues[queue_id],</span><br><span class="line">				     rx_pkts, nb_pkts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	 * call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	 * Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	 * cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	 * not required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cb = __atomic_load_n(&amp;dev-&gt;post_rx_burst_cbs[queue_id],</span><br><span class="line">				__ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			nb_rx = cb-&gt;fn.rx(port_id, queue_id, rx_pkts, nb_rx,</span><br><span class="line">						nb_pkts, cb-&gt;param);</span><br><span class="line">			cb = cb-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下发送 rte_eth_tx_burst 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Send a burst of output packets on a transmit queue of an Ethernet device.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The rte_eth_tx_burst() function is invoked to transmit output packets</span></span><br><span class="line"><span class="comment">* on the output queue *queue_id* of the Ethernet device designated by its</span></span><br><span class="line"><span class="comment">* *port_id*.</span></span><br><span class="line"><span class="comment">* The *nb_pkts* parameter is the number of packets to send which are</span></span><br><span class="line"><span class="comment">* supplied in the *tx_pkts* array of *rte_mbuf* structures, each of them</span></span><br><span class="line"><span class="comment">* allocated from a pool created with rte_pktmbuf_pool_create().</span></span><br><span class="line"><span class="comment">* The rte_eth_tx_burst() function loops, sending *nb_pkts* packets,</span></span><br><span class="line"><span class="comment">* up to the number of transmit descriptors available in the TX ring of the</span></span><br><span class="line"><span class="comment">* transmit queue.</span></span><br><span class="line"><span class="comment">* For each packet to send, the rte_eth_tx_burst() function performs</span></span><br><span class="line"><span class="comment">* the following operations:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - Pick up the next available descriptor in the transmit ring.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - Free the network buffer previously sent with that descriptor, if any.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - Initialize the transmit descriptor with the information provided</span></span><br><span class="line"><span class="comment">*   in the *rte_mbuf data structure.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* In the case of a segmented packet composed of a list of *rte_mbuf* buffers,</span></span><br><span class="line"><span class="comment">* the rte_eth_tx_burst() function uses several transmit descriptors</span></span><br><span class="line"><span class="comment">* of the ring.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The rte_eth_tx_burst() function returns the number of packets it</span></span><br><span class="line"><span class="comment">* actually sent. A return value equal to *nb_pkts* means that all packets</span></span><br><span class="line"><span class="comment">* have been sent, and this is likely to signify that other output packets</span></span><br><span class="line"><span class="comment">* could be immediately transmitted again. Applications that implement a</span></span><br><span class="line"><span class="comment">* &quot;send as many packets to transmit as possible&quot; policy can check this</span></span><br><span class="line"><span class="comment">* specific case and keep invoking the rte_eth_tx_burst() function until</span></span><br><span class="line"><span class="comment">* a value less than *nb_pkts* is returned.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* It is the responsibility of the rte_eth_tx_burst() function to</span></span><br><span class="line"><span class="comment">* transparently free the memory buffers of packets previously sent.</span></span><br><span class="line"><span class="comment">* This feature is driven by the *tx_free_thresh* value supplied to the</span></span><br><span class="line"><span class="comment">* rte_eth_dev_configure() function at device configuration time.</span></span><br><span class="line"><span class="comment">* When the number of free TX descriptors drops below this threshold, the</span></span><br><span class="line"><span class="comment">* rte_eth_tx_burst() function must [attempt to] free the *rte_mbuf*  buffers</span></span><br><span class="line"><span class="comment">* of those packets whose transmission was effectively completed.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* If the PMD is DEV_TX_OFFLOAD_MT_LOCKFREE capable, multiple threads can</span></span><br><span class="line"><span class="comment">* invoke this function concurrently on the same tx queue without SW lock.</span></span><br><span class="line"><span class="comment">* @see rte_eth_dev_info_get, struct rte_eth_txconf::offloads</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @see rte_eth_tx_prepare to perform some prior checks or adjustments</span></span><br><span class="line"><span class="comment">* for offloads.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param port_id</span></span><br><span class="line"><span class="comment">*   The port identifier of the Ethernet device.</span></span><br><span class="line"><span class="comment">* @param queue_id</span></span><br><span class="line"><span class="comment">*   The index of the transmit queue through which output packets must be</span></span><br><span class="line"><span class="comment">*   sent.</span></span><br><span class="line"><span class="comment">*   The value must be in the range [0, nb_tx_queue - 1] previously supplied</span></span><br><span class="line"><span class="comment">*   to rte_eth_dev_configure().</span></span><br><span class="line"><span class="comment">* @param tx_pkts</span></span><br><span class="line"><span class="comment">*   The address of an array of *nb_pkts* pointers to *rte_mbuf* structures</span></span><br><span class="line"><span class="comment">*   which contain the output packets.</span></span><br><span class="line"><span class="comment">* @param nb_pkts</span></span><br><span class="line"><span class="comment">*   The maximum number of packets to transmit.</span></span><br><span class="line"><span class="comment">* @return</span></span><br><span class="line"><span class="comment">*   The number of output packets actually stored in transmit descriptors of</span></span><br><span class="line"><span class="comment">*   the transmit ring. The return value can be less than the value of the</span></span><br><span class="line"><span class="comment">*   *tx_pkts* parameter when the transmit ring is full or has been filled up.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_mbuf **tx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev</span> *<span class="title">dev</span> =</span> &amp;rte_eth_devices[port_id];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_ETHDEV_DEBUG</span></span><br><span class="line"> RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, <span class="number">0</span>);</span><br><span class="line"> RTE_FUNC_PTR_OR_ERR_RET(*dev-&gt;tx_pkt_burst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (queue_id &gt;= dev-&gt;data-&gt;nb_tx_queues) &#123;</span><br><span class="line">	 RTE_ETHDEV_LOG(ERR, <span class="string">&quot;Invalid TX queue_id=%u\n&quot;</span>, queue_id);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_ETHDEV_RXTX_CALLBACKS</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxtx_callback</span> *<span class="title">cb</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* __ATOMIC_RELEASE memory order was used when the</span></span><br><span class="line"><span class="comment">	* call back was inserted into the list.</span></span><br><span class="line"><span class="comment">	* Since there is a clear dependency between loading</span></span><br><span class="line"><span class="comment">	* cb and cb-&gt;fn/cb-&gt;next, __ATOMIC_ACQUIRE memory order is</span></span><br><span class="line"><span class="comment">	* not required.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> cb = __atomic_load_n(&amp;dev-&gt;pre_tx_burst_cbs[queue_id],</span><br><span class="line">			 __ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (unlikely(cb != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">	 <span class="keyword">do</span> &#123;</span><br><span class="line">		 nb_pkts = cb-&gt;fn.tx(port_id, queue_id, tx_pkts, nb_pkts,</span><br><span class="line">				 cb-&gt;param);</span><br><span class="line">		 cb = cb-&gt;next;</span><br><span class="line">	 &#125; <span class="keyword">while</span> (cb != <span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (*dev-&gt;tx_pkt_burst)(dev-&gt;data-&gt;tx_queues[queue_id], tx_pkts, nb_pkts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两块具体的数据收发流程会在后面详细分析。</p>
<p>通过上面的代码分析可以发现，整个 DPDK 中对数据的收发需要进行下面基本的流程：<br>1、环境初始化，即 rte_eal_init 函数对一系列的参数和环境进行处理，比如内存的管理等<br>2、网络设备的配置，特别是相关收发队列的内存配置，即 rte_eth_dev_configure 调用<br>3、具体的收发队列的分配和管理，即 rte_eth_rx_queue_setup 和 rte_eth_tx_queue_setup 函数的调用<br>4、在一系列的准备和配备及相关安全检测通过后，启动网卡设备，将相关数据结构和内存等与网卡关联，即 rte_eth_dev_start 函数<br>5、在循环中处理收发数据，即 rte_eth_rx_burst 和 rte_eth_tx_burst 函数，当然这个程序里处理报文相当简单<br>6、处理程序结束后的环境资源回收即 rte_eal_cleanup 函数</p>
<h1 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h1><p>DPDK 中对数据的处理简化一下就如现在分析的这个程序，其实就是一个收发的过程，只要把基础的收发搞明白，再加上其它逻辑其实就是一个丰富的应用。在这里首先看一下此程序中 DPDK 如何接收数据。<br>接收数据包括下面的发送数据，其实都包含了非常多的知识点，除了前面已经分析过的相关知识外，还有：<br>1、DMA的具体知识<br>这个需要注意的是，现在 IO 设备自身也增加了 DMA 控制系统即现在 DMA 系统分两类，一类是内部 DMA，一类是系统 DMA（IO 系统）。其它具体的 DMA 相关技术需要自己去学习相关的知识，包括软件方面的当然也有关联到的硬件方面的。</p>
<p>2、网卡与内存通信的协议<br>这个就包括相关一些说明文件和格式，特别是后者，包括一些描述符的性质等，应该是实际用到的需要认真的弄明白。<br>从宏观上讲，数据包会先通过物理途径到达网卡，然后网卡 DMA 将数据包写入到系统 Ring 收包队列（进入内存），上层应用 mmap 内存映射拿到数据。具体的流程如下：  </p>
<ul>
<li>1、CPU 与 DMA 通信配置相关队列的信息（含头地址和大小等，物理地址），DMA 会通过队列中描述符得到上层应用的虚拟地址，并将把收到数据包保存到 buf 地址内存（虚拟地址）即 DMA 会从接收方的描述符中得到数据缓冲地址指向上层应用的 mbuf 中的指定内存。  </li>
<li>2、网卡读取接收 Ring 接收端的描述符同时获取上层应用的缓冲 buf 地址。  </li>
<li>3、网卡接收网络数据到网卡本地 FIFO 缓冲区。  </li>
<li>4、网卡的 DMA 控制器将数据写到指定的上层应用内存缓冲区 mbuf。  </li>
<li>5、网卡更新描述符队列（物理地址）中相关 DD 标志为 1，即数据接收完成。  </li>
<li>6、CPU 读取 DD 标志，为 1 则表示可以读取网卡数据。  </li>
<li>7、CPU 读取相关系统队列（虚拟地址）中数据并申请新的 mbuf 替换该描述符（同 1），转换相关地址并更新 DMA 物理地址和描述符中 ring 的 DD 标志为 0，表示可以继续接收数据。  </li>
<li>8、处理 DMA 寄存器的接收队列 ring，此处是更新 tail 寄存器而不是将新的 mbuf 填充到 tail 寄存器。<br>此处的重点其实就是在于两个队列，即上层应用的系统内存队列（虚拟地址）与描述符接收队列（物理地址）一个动态的转换操作。有点类似于 map 映射，而不是强硬的进行增加和删除操作。</li>
</ul>
<h3 id="二、发送数据"><a href="#二、发送数据" class="headerlink" title="二、发送数据"></a>二、发送数据</h3><p>发送数据也是如此，上层应用写入到内存然后 mmap 到 DMA 访问的内存拷贝到网卡，然后网卡将数据发送即可。其具体的流程如下：  </p>
<ul>
<li>1、mmap 的内存地址写入数据。  </li>
<li>2、CPU 读取发送端的 Ring 队列（物理）中的 DD 标志是否为 1，1 表示发送完成。  </li>
<li>3、将发送完成的描述符对应的缓冲区 mbuf 释放（虚拟）。  </li>
<li>4、CPU 将 mbuf 发送缓冲区（虚拟）填充到描述符的系统队列（虚拟）。  </li>
<li>5、CPU 将 mbuf 中的 data 物理地址转换到到后填充到发送端队列（物理）并置 DD 标志为 0.  </li>
<li>6、DMA 控制器读取 base 寄存器得到发送端描述符并获取发送队列地址（物理），根据 DD 标志为 0 则读取 mbuf 数据（虚拟）到网卡缓存并发送。  </li>
<li>7、DMA 控制器置 DD 标志位为 1 并触发 CPU 数据发送成功消息。</li>
</ul>
<p>其实从上面的分析可以看到很多细节其实需要对硬件和 DMA 及相关网卡中的控制器等需要有一个相对了解的过程，这也是前面提示大家需要对一些基础准备知识要有一个心理准备一样。</p>
<h3 id="三、源码分析-2"><a href="#三、源码分析-2" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>对数据的收发进行分析后，结合源码来看一下:<br>1、接收数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在DPDK中有很多类似下面网卡的相关定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_dev_ops</span> <span class="title">ixgbe_eth_dev_ops</span> =</span> &#123;</span><br><span class="line">	.dev_configure        = ixgbe_dev_configure,</span><br><span class="line">	.dev_start            = ixgbe_dev_start,</span><br><span class="line">	.dev_stop             = ixgbe_dev_stop,</span><br><span class="line">	.dev_set_link_up    = ixgbe_dev_set_link_up,</span><br><span class="line">	.dev_set_link_down  = ixgbe_dev_set_link_down,</span><br><span class="line">	.dev_close            = ixgbe_dev_close,</span><br><span class="line">......</span><br><span class="line">  <span class="comment">//注意下面的函数注册</span></span><br><span class="line">	.rx_queue_start	      = ixgbe_dev_rx_queue_start,</span><br><span class="line">	.rx_queue_stop        = ixgbe_dev_rx_queue_stop,</span><br><span class="line">	.tx_queue_start	      = ixgbe_dev_tx_queue_start,</span><br><span class="line">	.tx_queue_stop        = ixgbe_dev_tx_queue_stop,</span><br><span class="line">	.rx_queue_setup       = ixgbe_dev_rx_queue_setup,</span><br><span class="line">	.rx_queue_intr_enable = ixgbe_dev_rx_queue_intr_enable,</span><br><span class="line">	.rx_queue_intr_disable = ixgbe_dev_rx_queue_intr_disable,</span><br><span class="line">	.rx_queue_release     = ixgbe_dev_rx_queue_release,</span><br><span class="line">	.rx_queue_count       = ixgbe_dev_rx_queue_count,</span><br><span class="line">	.rx_descriptor_done   = ixgbe_dev_rx_descriptor_done,</span><br><span class="line">	.rx_descriptor_status = ixgbe_dev_rx_descriptor_status,</span><br><span class="line">	.tx_descriptor_status = ixgbe_dev_tx_descriptor_status,</span><br><span class="line">	.tx_queue_setup       = ixgbe_dev_tx_queue_setup,</span><br><span class="line">	.tx_queue_release     = ixgbe_dev_tx_queue_release,</span><br><span class="line">......</span><br><span class="line">	.tm_ops_get           = ixgbe_tm_ops_get,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_rx_queue_setup</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> rx_queue_id,</span></span><br><span class="line"><span class="params">		       <span class="type">uint16_t</span> nb_rx_desc, <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="keyword">struct</span> rte_eth_rxconf *rx_conf,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> rte_mempool *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">//dev_ops-&gt;rx_queue_setup和上面的数据结构体的函数指针注册结合起来</span></span><br><span class="line">	ret = (*dev-&gt;dev_ops-&gt;rx_queue_setup)(dev, rx_queue_id, nb_rx_desc,</span><br><span class="line">					      socket_id, &amp;local_conf, mp);</span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;data-&gt;min_rx_buf_size ||</span><br><span class="line">		    dev-&gt;data-&gt;min_rx_buf_size &gt; mbp_buf_size)</span><br><span class="line">			dev-&gt;data-&gt;min_rx_buf_size = mbp_buf_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> eth_err(port_id, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册函数调用下面的函数,注意每个设备的注册可能都有不同</span></span><br><span class="line"><span class="type">int</span> __attribute__((cold))</span><br><span class="line">ixgbe_dev_rx_queue_setup(<span class="keyword">struct</span> rte_eth_dev *dev,</span><br><span class="line">			 <span class="type">uint16_t</span> queue_idx,</span><br><span class="line">			 <span class="type">uint16_t</span> nb_desc,</span><br><span class="line">			 <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span><br><span class="line">			 <span class="type">const</span> <span class="keyword">struct</span> rte_eth_rxconf *rx_conf,</span><br><span class="line">			 <span class="keyword">struct</span> rte_mempool *mp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">rz</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span>     *<span class="title">hw</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_adapter</span> *<span class="title">adapter</span> =</span> dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="type">uint64_t</span> offloads;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_FUNC_TRACE();</span><br><span class="line">	hw = IXGBE_DEV_PRIVATE_TO_HW(dev-&gt;data-&gt;dev_private);</span><br><span class="line"></span><br><span class="line">	offloads = rx_conf-&gt;offloads | dev-&gt;data-&gt;dev_conf.rxmode.offloads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Validate number of receive descriptors.</span></span><br><span class="line"><span class="comment">	 * It must not exceed hardware maximum, and must be multiple</span></span><br><span class="line"><span class="comment">	 * of IXGBE_ALIGN.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nb_desc % IXGBE_RXD_ALIGN != <span class="number">0</span> ||</span><br><span class="line">			(nb_desc &gt; IXGBE_MAX_RING_DESC) ||</span><br><span class="line">			(nb_desc &lt; IXGBE_MIN_RING_DESC)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free memory prior to re-allocation if needed... */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;rx_queues[queue_idx] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ixgbe_rx_queue_release(dev-&gt;data-&gt;rx_queues[queue_idx]);</span><br><span class="line">		dev-&gt;data-&gt;rx_queues[queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First allocate the rx queue data structure */</span></span><br><span class="line">	rxq = rte_zmalloc_socket(<span class="string">&quot;ethdev RX queue&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ixgbe_rx_queue),</span><br><span class="line">				 RTE_CACHE_LINE_SIZE, socket_id);</span><br><span class="line">	<span class="keyword">if</span> (rxq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	rxq-&gt;mb_pool = mp;</span><br><span class="line">	rxq-&gt;nb_rx_desc = nb_desc;</span><br><span class="line">	rxq-&gt;rx_free_thresh = rx_conf-&gt;rx_free_thresh;</span><br><span class="line">	rxq-&gt;queue_id = queue_idx;</span><br><span class="line">	rxq-&gt;reg_idx = (<span class="type">uint16_t</span>)((RTE_ETH_DEV_SRIOV(dev).active == <span class="number">0</span>) ?</span><br><span class="line">		queue_idx : RTE_ETH_DEV_SRIOV(dev).def_pool_q_idx + queue_idx);</span><br><span class="line">	rxq-&gt;port_id = dev-&gt;data-&gt;port_id;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.rxmode.offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">		rxq-&gt;crc_len = RTE_ETHER_CRC_LEN;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rxq-&gt;crc_len = <span class="number">0</span>;</span><br><span class="line">	rxq-&gt;drop_en = rx_conf-&gt;rx_drop_en;</span><br><span class="line">	rxq-&gt;rx_deferred_start = rx_conf-&gt;rx_deferred_start;</span><br><span class="line">	rxq-&gt;offloads = offloads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet type in RX descriptor is different for different NICs.</span></span><br><span class="line"><span class="comment">	 * Some bits are used for x550 but reserved for other NICS.</span></span><br><span class="line"><span class="comment">	 * So set different masks for different NICs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac.type == ixgbe_mac_X550 ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_x ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_a ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_x_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_a_vf)</span><br><span class="line">		rxq-&gt;pkt_type_mask = IXGBE_PACKET_TYPE_MASK_X550;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rxq-&gt;pkt_type_mask = IXGBE_PACKET_TYPE_MASK_82599;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 82599 errata, UDP frames with a 0 checksum can be marked as checksum</span></span><br><span class="line"><span class="comment">	 * errors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB)</span><br><span class="line">		rxq-&gt;rx_udp_csum_zero_err = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Allocate RX ring hardware descriptors. A memzone large enough to</span></span><br><span class="line"><span class="comment">	 * handle the maximum ring size is allocated in order to allow for</span></span><br><span class="line"><span class="comment">	 * resizing in later calls to the queue setup function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rz = rte_eth_dma_zone_reserve(dev, <span class="string">&quot;rx_ring&quot;</span>, queue_idx,</span><br><span class="line">				      RX_RING_SZ, IXGBE_ALIGN, socket_id);</span><br><span class="line">	<span class="keyword">if</span> (rz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ixgbe_rx_queue_release(rxq);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Zero init all the descriptors in the ring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(rz-&gt;addr, <span class="number">0</span>, RX_RING_SZ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Modified to setup VFRDT for Virtual Function</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac.type == ixgbe_mac_82599_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X540_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_x_vf ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X550EM_a_vf) &#123;</span><br><span class="line">		rxq-&gt;rdt_reg_addr =</span><br><span class="line">			IXGBE_PCI_REG_ADDR(hw, IXGBE_VFRDT(queue_idx));</span><br><span class="line">		rxq-&gt;rdh_reg_addr =</span><br><span class="line">			IXGBE_PCI_REG_ADDR(hw, IXGBE_VFRDH(queue_idx));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rxq-&gt;rdt_reg_addr =</span><br><span class="line">			IXGBE_PCI_REG_ADDR(hw, IXGBE_RDT(rxq-&gt;reg_idx));</span><br><span class="line">		rxq-&gt;rdh_reg_addr =</span><br><span class="line">			IXGBE_PCI_REG_ADDR(hw, IXGBE_RDH(rxq-&gt;reg_idx));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rxq-&gt;rx_ring_phys_addr = rz-&gt;iova;</span><br><span class="line">	rxq-&gt;rx_ring = (<span class="keyword">union</span> ixgbe_adv_rx_desc *) rz-&gt;addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Certain constraints must be met in order to use the bulk buffer</span></span><br><span class="line"><span class="comment">	 * allocation Rx burst function. If any of Rx queues doesn&#x27;t meet them</span></span><br><span class="line"><span class="comment">	 * the feature should be disabled for the whole port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_rx_burst_bulk_alloc_preconditions(rxq)) &#123;</span><br><span class="line">		PMD_INIT_LOG(DEBUG, <span class="string">&quot;queue[%d] doesn&#x27;t meet Rx Bulk Alloc &quot;</span></span><br><span class="line">				    <span class="string">&quot;preconditions - canceling the feature for &quot;</span></span><br><span class="line">				    <span class="string">&quot;the whole port[%d]&quot;</span>,</span><br><span class="line">			     rxq-&gt;queue_id, rxq-&gt;port_id);</span><br><span class="line">		adapter-&gt;rx_bulk_alloc_allowed = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Allocate software ring. Allow for space at the end of the</span></span><br><span class="line"><span class="comment">	 * S/W ring to make sure look-ahead logic in bulk alloc Rx burst</span></span><br><span class="line"><span class="comment">	 * function does not access an invalid memory region.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	len = nb_desc;</span><br><span class="line">	<span class="keyword">if</span> (adapter-&gt;rx_bulk_alloc_allowed)</span><br><span class="line">		len += RTE_PMD_IXGBE_RX_MAX_BURST;</span><br><span class="line"></span><br><span class="line">	rxq-&gt;sw_ring = rte_zmalloc_socket(<span class="string">&quot;rxq-&gt;sw_ring&quot;</span>,</span><br><span class="line">					  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ixgbe_rx_entry) * len,</span><br><span class="line">					  RTE_CACHE_LINE_SIZE, socket_id);</span><br><span class="line">	<span class="keyword">if</span> (!rxq-&gt;sw_ring) &#123;</span><br><span class="line">		ixgbe_rx_queue_release(rxq);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Always allocate even if it&#x27;s not going to be needed in order to</span></span><br><span class="line"><span class="comment">	 * simplify the code.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This ring is used in LRO and Scattered Rx cases and Scattered Rx may</span></span><br><span class="line"><span class="comment">	 * be requested in ixgbe_dev_rx_init(), which is called later from</span></span><br><span class="line"><span class="comment">	 * dev_start() flow.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rxq-&gt;sw_sc_ring =</span><br><span class="line">		rte_zmalloc_socket(<span class="string">&quot;rxq-&gt;sw_sc_ring&quot;</span>,</span><br><span class="line">				   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ixgbe_scattered_rx_entry) * len,</span><br><span class="line">				   RTE_CACHE_LINE_SIZE, socket_id);</span><br><span class="line">	<span class="keyword">if</span> (!rxq-&gt;sw_sc_ring) &#123;</span><br><span class="line">		ixgbe_rx_queue_release(rxq);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_LOG(DEBUG, <span class="string">&quot;sw_ring=%p sw_sc_ring=%p hw_ring=%p &quot;</span></span><br><span class="line">			    <span class="string">&quot;dma_addr=0x%&quot;</span>PRIx64,</span><br><span class="line">		     rxq-&gt;sw_ring, rxq-&gt;sw_sc_ring, rxq-&gt;rx_ring,</span><br><span class="line">		     rxq-&gt;rx_ring_phys_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_is_power_of_2(nb_desc)) &#123;</span><br><span class="line">		PMD_INIT_LOG(DEBUG, <span class="string">&quot;queue[%d] doesn&#x27;t meet Vector Rx &quot;</span></span><br><span class="line">				    <span class="string">&quot;preconditions - canceling the feature for &quot;</span></span><br><span class="line">				    <span class="string">&quot;the whole port[%d]&quot;</span>,</span><br><span class="line">			     rxq-&gt;queue_id, rxq-&gt;port_id);</span><br><span class="line">		adapter-&gt;rx_vec_allowed = <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ixgbe_rxq_vec_setup(rxq);</span><br><span class="line"></span><br><span class="line">	dev-&gt;data-&gt;rx_queues[queue_idx] = rxq;</span><br><span class="line"></span><br><span class="line">	ixgbe_reset_rx_queue(adapter, rxq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的注册函数中还有很多的函数，需要注意的是不同的设备可能注册的函数都有所不同，不要盲目的僵化套路这些功能。在数据结构体中注册的 ixgbe_dev_start 函数中，调用了 ixgbe_dev_rx_init：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __attribute__((cold)) ixgbe_dev_rx_init(<span class="keyword">struct</span> rte_eth_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span>     *<span class="title">hw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> bus_addr;</span><br><span class="line">	<span class="type">uint32_t</span> rxctrl;</span><br><span class="line">	<span class="type">uint32_t</span> fctrl;</span><br><span class="line">	<span class="type">uint32_t</span> hlreg0;</span><br><span class="line">	<span class="type">uint32_t</span> maxfrs;</span><br><span class="line">	<span class="type">uint32_t</span> srrctl;</span><br><span class="line">	<span class="type">uint32_t</span> rdrxctl;</span><br><span class="line">	<span class="type">uint32_t</span> rxcsum;</span><br><span class="line">	<span class="type">uint16_t</span> buf_size;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> *<span class="title">rx_conf</span> =</span> &amp;dev-&gt;data-&gt;dev_conf.rxmode;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_FUNC_TRACE();</span><br><span class="line">	hw = IXGBE_DEV_PRIVATE_TO_HW(dev-&gt;data-&gt;dev_private);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure receives are disabled while setting</span></span><br><span class="line"><span class="comment">	 * up the RX context (registers, descriptor rings, etc.).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable receipt of broadcasted frames */</span></span><br><span class="line">	fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);</span><br><span class="line">	fctrl |= IXGBE_FCTRL_BAM;</span><br><span class="line">	fctrl |= IXGBE_FCTRL_DPF;</span><br><span class="line">	fctrl |= IXGBE_FCTRL_PMCF;</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Configure CRC stripping, if any.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);</span><br><span class="line">	<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">		hlreg0 &amp;= ~IXGBE_HLREG0_RXCRCSTRP;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		hlreg0 |= IXGBE_HLREG0_RXCRCSTRP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Configure jumbo frame support, if any.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_JUMBO_FRAME) &#123;</span><br><span class="line">		hlreg0 |= IXGBE_HLREG0_JUMBOEN;</span><br><span class="line">		maxfrs = IXGBE_READ_REG(hw, IXGBE_MAXFRS);</span><br><span class="line">		maxfrs &amp;= <span class="number">0x0000FFFF</span>;</span><br><span class="line">		maxfrs |= (rx_conf-&gt;max_rx_pkt_len &lt;&lt; <span class="number">16</span>);</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_MAXFRS, maxfrs);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		hlreg0 &amp;= ~IXGBE_HLREG0_JUMBOEN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If loopback mode is configured, set LPBK bit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.lpbk_mode != <span class="number">0</span>) &#123;</span><br><span class="line">		rc = ixgbe_check_supported_loopback_mode(dev);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			PMD_INIT_LOG(ERR, <span class="string">&quot;Unsupported loopback mode&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line">		&#125;</span><br><span class="line">		hlreg0 |= IXGBE_HLREG0_LPBK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		hlreg0 &amp;= ~IXGBE_HLREG0_LPBK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Assume no header split and no VLAN strip support</span></span><br><span class="line"><span class="comment">	 * on any Rx queue first .</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rx_conf-&gt;offloads &amp;= ~DEV_RX_OFFLOAD_VLAN_STRIP;</span><br><span class="line">	<span class="comment">/* Setup RX queues */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;data-&gt;nb_rx_queues; i++) &#123;</span><br><span class="line">		rxq = dev-&gt;data-&gt;rx_queues[i];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Reset crc_len in case it was changed after queue setup by a</span></span><br><span class="line"><span class="comment">		 * call to configure.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">			rxq-&gt;crc_len = RTE_ETHER_CRC_LEN;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rxq-&gt;crc_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Setup the Base and Length of the Rx Descriptor Rings */</span></span><br><span class="line">		bus_addr = rxq-&gt;rx_ring_phys_addr;</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDBAL(rxq-&gt;reg_idx),</span><br><span class="line">				(<span class="type">uint32_t</span>)(bus_addr &amp; <span class="number">0x00000000ffffffff</span>ULL));</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDBAH(rxq-&gt;reg_idx),</span><br><span class="line">				(<span class="type">uint32_t</span>)(bus_addr &gt;&gt; <span class="number">32</span>));</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDLEN(rxq-&gt;reg_idx),</span><br><span class="line">				rxq-&gt;nb_rx_desc * <span class="keyword">sizeof</span>(<span class="keyword">union</span> ixgbe_adv_rx_desc));</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDH(rxq-&gt;reg_idx), <span class="number">0</span>);</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDT(rxq-&gt;reg_idx), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Configure the SRRCTL register */</span></span><br><span class="line">		srrctl = IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Set if packets are dropped when no descriptors available */</span></span><br><span class="line">		<span class="keyword">if</span> (rxq-&gt;drop_en)</span><br><span class="line">			srrctl |= IXGBE_SRRCTL_DROP_EN;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Configure the RX buffer size in the BSIZEPACKET field of</span></span><br><span class="line"><span class="comment">		 * the SRRCTL register of the queue.</span></span><br><span class="line"><span class="comment">		 * The value is in 1 KB resolution. Valid values can be from</span></span><br><span class="line"><span class="comment">		 * 1 KB to 16 KB.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		buf_size = (<span class="type">uint16_t</span>)(rte_pktmbuf_data_room_size(rxq-&gt;mb_pool) -</span><br><span class="line">			RTE_PKTMBUF_HEADROOM);</span><br><span class="line">		srrctl |= ((buf_size &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT) &amp;</span><br><span class="line">			   IXGBE_SRRCTL_BSIZEPKT_MASK);</span><br><span class="line"></span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(rxq-&gt;reg_idx), srrctl);</span><br><span class="line"></span><br><span class="line">		buf_size = (<span class="type">uint16_t</span>) ((srrctl &amp; IXGBE_SRRCTL_BSIZEPKT_MASK) &lt;&lt;</span><br><span class="line">				       IXGBE_SRRCTL_BSIZEPKT_SHIFT);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* It adds dual VLAN length for supporting dual VLAN */</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;data-&gt;dev_conf.rxmode.max_rx_pkt_len +</span><br><span class="line">					    <span class="number">2</span> * IXGBE_VLAN_TAG_SIZE &gt; buf_size)</span><br><span class="line">			dev-&gt;data-&gt;scattered_rx = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (rxq-&gt;offloads &amp; DEV_RX_OFFLOAD_VLAN_STRIP)</span><br><span class="line">			rx_conf-&gt;offloads |= DEV_RX_OFFLOAD_VLAN_STRIP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_SCATTER)</span><br><span class="line">		dev-&gt;data-&gt;scattered_rx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Device configured with multiple RX queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ixgbe_dev_mq_rx_configure(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setup the Checksum Register.</span></span><br><span class="line"><span class="comment">	 * Disable Full-Packet Checksum which is mutually exclusive with RSS.</span></span><br><span class="line"><span class="comment">	 * Enable IP/L4 checkum computation by hardware if requested to do so.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rxcsum = IXGBE_READ_REG(hw, IXGBE_RXCSUM);</span><br><span class="line">	rxcsum |= IXGBE_RXCSUM_PCSD;</span><br><span class="line">	<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_CHECKSUM)</span><br><span class="line">		rxcsum |= IXGBE_RXCSUM_IPPCSE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rxcsum &amp;= ~IXGBE_RXCSUM_IPPCSE;</span><br><span class="line"></span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RXCSUM, rxcsum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB ||</span><br><span class="line">	    hw-&gt;mac.type == ixgbe_mac_X540) &#123;</span><br><span class="line">		rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);</span><br><span class="line">		<span class="keyword">if</span> (rx_conf-&gt;offloads &amp; DEV_RX_OFFLOAD_KEEP_CRC)</span><br><span class="line">			rdrxctl &amp;= ~IXGBE_RDRXCTL_CRCSTRIP;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rdrxctl |= IXGBE_RDRXCTL_CRCSTRIP;</span><br><span class="line">		rdrxctl &amp;= ~IXGBE_RDRXCTL_RSCFRSTSIZE;</span><br><span class="line">		IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rdrxctl);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rc = ixgbe_set_rsc(dev);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">	ixgbe_set_rx_function(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start Receive Units for specified queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __attribute__((cold))</span><br><span class="line">ixgbe_dev_rx_queue_start(<span class="keyword">struct</span> rte_eth_dev *dev, <span class="type">uint16_t</span> rx_queue_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span>     *<span class="title">hw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> rxdctl;</span><br><span class="line">	<span class="type">int</span> poll_ms;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_FUNC_TRACE();</span><br><span class="line">	hw = IXGBE_DEV_PRIVATE_TO_HW(dev-&gt;data-&gt;dev_private);</span><br><span class="line"></span><br><span class="line">	rxq = dev-&gt;data-&gt;rx_queues[rx_queue_id];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate buffers for descriptor rings */</span></span><br><span class="line">	<span class="keyword">if</span> (ixgbe_alloc_rx_queue_mbufs(rxq) != <span class="number">0</span>) &#123;</span><br><span class="line">		PMD_INIT_LOG(ERR, <span class="string">&quot;Could not alloc mbuf for queue:%d&quot;</span>,</span><br><span class="line">			     rx_queue_id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(rxq-&gt;reg_idx));</span><br><span class="line">	rxdctl |= IXGBE_RXDCTL_ENABLE;</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(rxq-&gt;reg_idx), rxdctl);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait until RX Enable ready */</span></span><br><span class="line">	poll_ms = RTE_IXGBE_REGISTER_POLL_WAIT_10_MS;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		rte_delay_ms(<span class="number">1</span>);</span><br><span class="line">		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(rxq-&gt;reg_idx));</span><br><span class="line">	&#125; <span class="keyword">while</span> (--poll_ms &amp;&amp; !(rxdctl &amp; IXGBE_RXDCTL_ENABLE));</span><br><span class="line">	<span class="keyword">if</span> (!poll_ms)</span><br><span class="line">		PMD_INIT_LOG(ERR, <span class="string">&quot;Could not enable Rx Queue %d&quot;</span>, rx_queue_id);</span><br><span class="line">	rte_wmb();</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RDH(rxq-&gt;reg_idx), <span class="number">0</span>);</span><br><span class="line">	IXGBE_WRITE_REG(hw, IXGBE_RDT(rxq-&gt;reg_idx), rxq-&gt;nb_rx_desc - <span class="number">1</span>);</span><br><span class="line">	dev-&gt;data-&gt;rx_queue_state[rx_queue_id] = RTE_ETH_QUEUE_STATE_STARTED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以真正接收数据了，在接收数据前得看看如何将函数指针挂接到相关的设备函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eth_ixgbevf_dev_init</span><span class="params">(<span class="keyword">struct</span> rte_eth_dev *eth_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> diag;</span><br><span class="line">	<span class="type">uint32_t</span> tc, tcs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_adapter</span> *<span class="title">ad</span> =</span> eth_dev-&gt;data-&gt;dev_private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_pci_device</span> *<span class="title">pci_dev</span> =</span> RTE_ETH_DEV_TO_PCI(eth_dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_intr_handle</span> *<span class="title">intr_handle</span> =</span> &amp;pci_dev-&gt;intr_handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span> *<span class="title">hw</span> =</span></span><br><span class="line">		IXGBE_DEV_PRIVATE_TO_HW(eth_dev-&gt;data-&gt;dev_private);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_vfta</span> *<span class="title">shadow_vfta</span> =</span></span><br><span class="line">		IXGBE_DEV_PRIVATE_TO_VFTA(eth_dev-&gt;data-&gt;dev_private);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hwstrip</span> *<span class="title">hwstrip</span> =</span></span><br><span class="line">		IXGBE_DEV_PRIVATE_TO_HWSTRIP_BITMAP(eth_dev-&gt;data-&gt;dev_private);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> *<span class="title">perm_addr</span> =</span></span><br><span class="line">		(<span class="keyword">struct</span> rte_ether_addr *)hw-&gt;mac.perm_addr;</span><br><span class="line"></span><br><span class="line">	PMD_INIT_FUNC_TRACE();</span><br><span class="line"></span><br><span class="line">	eth_dev-&gt;dev_ops = &amp;ixgbevf_eth_dev_ops;</span><br><span class="line">	eth_dev-&gt;rx_pkt_burst = &amp;ixgbe_recv_pkts;</span><br><span class="line">	eth_dev-&gt;tx_pkt_burst = &amp;ixgbe_xmit_pkts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ixgbe_recv_pkts</span><span class="params">(<span class="type">void</span> *rx_queue, <span class="keyword">struct</span> rte_mbuf **rx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_queue</span> *<span class="title">rxq</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_rx_desc</span> *<span class="title">rx_ring</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_rx_desc</span> *<span class="title">rxdp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_entry</span> *<span class="title">sw_ring</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_entry</span> *<span class="title">rxe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">rxm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">nmb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_rx_desc</span> <span class="title">rxd</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> dma_addr;</span><br><span class="line">	<span class="type">uint32_t</span> staterr;</span><br><span class="line">	<span class="type">uint32_t</span> pkt_info;</span><br><span class="line">	<span class="type">uint16_t</span> pkt_len;</span><br><span class="line">	<span class="type">uint16_t</span> rx_id;</span><br><span class="line">	<span class="type">uint16_t</span> nb_rx;</span><br><span class="line">	<span class="type">uint16_t</span> nb_hold;</span><br><span class="line">	<span class="type">uint64_t</span> pkt_flags;</span><br><span class="line">	<span class="type">uint64_t</span> vlan_flags;</span><br><span class="line"></span><br><span class="line">	nb_rx = <span class="number">0</span>;</span><br><span class="line">	nb_hold = <span class="number">0</span>;</span><br><span class="line">	rxq = rx_queue;</span><br><span class="line">	rx_id = rxq-&gt;rx_tail;</span><br><span class="line">	rx_ring = rxq-&gt;rx_ring;</span><br><span class="line">	sw_ring = rxq-&gt;sw_ring;</span><br><span class="line">	vlan_flags = rxq-&gt;vlan_flags;</span><br><span class="line">	<span class="keyword">while</span> (nb_rx &lt; nb_pkts) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The order of operations here is important as the DD status</span></span><br><span class="line"><span class="comment">		 * bit must not be read after any other descriptor fields.</span></span><br><span class="line"><span class="comment">		 * rx_ring and rxdp are pointing to volatile data so the order</span></span><br><span class="line"><span class="comment">		 * of accesses cannot be reordered by the compiler. If they were</span></span><br><span class="line"><span class="comment">		 * not volatile, they could be reordered which could lead to</span></span><br><span class="line"><span class="comment">		 * using invalid descriptor fields when read from rxd.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rxdp = &amp;rx_ring[rx_id];</span><br><span class="line">		staterr = rxdp-&gt;wb.upper.status_error;</span><br><span class="line">		<span class="keyword">if</span> (!(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rxd = *rxdp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * End of packet.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If the IXGBE_RXDADV_STAT_EOP flag is not set, the RX packet</span></span><br><span class="line"><span class="comment">		 * is likely to be invalid and to be dropped by the various</span></span><br><span class="line"><span class="comment">		 * validation checks performed by the network stack.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Allocate a new mbuf to replenish the RX ring descriptor.</span></span><br><span class="line"><span class="comment">		 * If the allocation fails:</span></span><br><span class="line"><span class="comment">		 *    - arrange for that RX descriptor to be the first one</span></span><br><span class="line"><span class="comment">		 *      being parsed the next time the receive function is</span></span><br><span class="line"><span class="comment">		 *      invoked [on the same queue].</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *    - Stop parsing the RX ring and return immediately.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This policy do not drop the packet received in the RX</span></span><br><span class="line"><span class="comment">		 * descriptor for which the allocation of a new mbuf failed.</span></span><br><span class="line"><span class="comment">		 * Thus, it allows that packet to be later retrieved if</span></span><br><span class="line"><span class="comment">		 * mbuf have been freed in the mean time.</span></span><br><span class="line"><span class="comment">		 * As a side effect, holding RX descriptors instead of</span></span><br><span class="line"><span class="comment">		 * systematically giving them back to the NIC may lead to</span></span><br><span class="line"><span class="comment">		 * RX ring exhaustion situations.</span></span><br><span class="line"><span class="comment">		 * However, the NIC can gracefully prevent such situations</span></span><br><span class="line"><span class="comment">		 * to happen by sending specific &quot;back-pressure&quot; flow control</span></span><br><span class="line"><span class="comment">		 * frames to its peer(s).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_id=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;ext_err_stat=0x%08x pkt_len=%u&quot;</span>,</span><br><span class="line">			   (<span class="type">unsigned</span>) rxq-&gt;port_id, (<span class="type">unsigned</span>) rxq-&gt;queue_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) rx_id, (<span class="type">unsigned</span>) staterr,</span><br><span class="line">			   (<span class="type">unsigned</span>) rte_le_to_cpu_16(rxd.wb.upper.length));</span><br><span class="line"></span><br><span class="line">		nmb = rte_mbuf_raw_alloc(rxq-&gt;mb_pool);</span><br><span class="line">		<span class="keyword">if</span> (nmb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			PMD_RX_LOG(DEBUG, <span class="string">&quot;RX mbuf alloc failed port_id=%u &quot;</span></span><br><span class="line">				   <span class="string">&quot;queue_id=%u&quot;</span>, (<span class="type">unsigned</span>) rxq-&gt;port_id,</span><br><span class="line">				   (<span class="type">unsigned</span>) rxq-&gt;queue_id);</span><br><span class="line">			rte_eth_devices[rxq-&gt;port_id].data-&gt;rx_mbuf_alloc_failed++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nb_hold++;</span><br><span class="line">		rxe = &amp;sw_ring[rx_id];</span><br><span class="line">		rx_id++;</span><br><span class="line">		<span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc)</span><br><span class="line">			rx_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Prefetch next mbuf while processing current one. */</span></span><br><span class="line">		rte_ixgbe_prefetch(sw_ring[rx_id].mbuf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When next RX descriptor is on a cache-line boundary,</span></span><br><span class="line"><span class="comment">		 * prefetch the next 4 RX descriptors and the next 8 pointers</span></span><br><span class="line"><span class="comment">		 * to mbufs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			rte_ixgbe_prefetch(&amp;rx_ring[rx_id]);</span><br><span class="line">			rte_ixgbe_prefetch(&amp;sw_ring[rx_id]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rxm = rxe-&gt;mbuf;</span><br><span class="line">		rxe-&gt;mbuf = nmb;</span><br><span class="line">		dma_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(nmb));</span><br><span class="line">		rxdp-&gt;read.hdr_addr = <span class="number">0</span>;</span><br><span class="line">		rxdp-&gt;read.pkt_addr = dma_addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Initialize the returned mbuf.</span></span><br><span class="line"><span class="comment">		 * 1) setup generic mbuf fields:</span></span><br><span class="line"><span class="comment">		 *    - number of segments,</span></span><br><span class="line"><span class="comment">		 *    - next segment,</span></span><br><span class="line"><span class="comment">		 *    - packet length,</span></span><br><span class="line"><span class="comment">		 *    - RX port identifier.</span></span><br><span class="line"><span class="comment">		 * 2) integrate hardware offload data, if any:</span></span><br><span class="line"><span class="comment">		 *    - RSS flag &amp; hash,</span></span><br><span class="line"><span class="comment">		 *    - IP checksum flag,</span></span><br><span class="line"><span class="comment">		 *    - VLAN TCI, if any,</span></span><br><span class="line"><span class="comment">		 *    - error flags.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pkt_len = (<span class="type">uint16_t</span>) (rte_le_to_cpu_16(rxd.wb.upper.length) - rxq-&gt;crc_len);</span><br><span class="line">		rxm-&gt;data_off = RTE_PKTMBUF_HEADROOM;</span><br><span class="line">		rte_packet_prefetch((<span class="type">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off);</span><br><span class="line">		rxm-&gt;nb_segs = <span class="number">1</span>;</span><br><span class="line">		rxm-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		rxm-&gt;pkt_len = pkt_len;</span><br><span class="line">		rxm-&gt;data_len = pkt_len;</span><br><span class="line">		rxm-&gt;port = rxq-&gt;port_id;</span><br><span class="line"></span><br><span class="line">		pkt_info = rte_le_to_cpu_32(rxd.wb.lower.lo_dword.data);</span><br><span class="line">		<span class="comment">/* Only valid if PKT_RX_VLAN set in pkt_flags */</span></span><br><span class="line">		rxm-&gt;vlan_tci = rte_le_to_cpu_16(rxd.wb.upper.vlan);</span><br><span class="line"></span><br><span class="line">		pkt_flags = rx_desc_status_to_pkt_flags(staterr, vlan_flags);</span><br><span class="line">		pkt_flags = pkt_flags | rx_desc_error_to_pkt_flags(staterr, (<span class="type">uint16_t</span>)pkt_info, rxq-&gt;rx_udp_csum_zero_err);</span><br><span class="line">		pkt_flags = pkt_flags | ixgbe_rxd_pkt_info_to_pkt_flags((<span class="type">uint16_t</span>)pkt_info);</span><br><span class="line">		rxm-&gt;ol_flags = pkt_flags;</span><br><span class="line">		rxm-&gt;packet_type = ixgbe_rxd_pkt_info_to_pkt_type(pkt_info, rxq-&gt;pkt_type_mask);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(pkt_flags &amp; PKT_RX_RSS_HASH))</span><br><span class="line">			rxm-&gt;hash.rss = rte_le_to_cpu_32(rxd.wb.lower.hi_dword.rss);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pkt_flags &amp; PKT_RX_FDIR) &#123;</span><br><span class="line">			rxm-&gt;hash.fdir.hash = rte_le_to_cpu_16(rxd.wb.lower.hi_dword.csum_ip.csum) &amp; IXGBE_ATR_HASH_MASK;</span><br><span class="line">			rxm-&gt;hash.fdir.id = rte_le_to_cpu_16(rxd.wb.lower.hi_dword.csum_ip.ip_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Store the mbuf address into the next entry of the array</span></span><br><span class="line"><span class="comment">		 * of returned packets.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rx_pkts[nb_rx++] = rxm;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;rx_tail = rx_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the number of free RX descriptors is greater than the RX free</span></span><br><span class="line"><span class="comment">	 * threshold of the queue, advance the Receive Descriptor Tail (RDT)</span></span><br><span class="line"><span class="comment">	 * register.</span></span><br><span class="line"><span class="comment">	 * Update the RDT with the value of the last processed RX descriptor</span></span><br><span class="line"><span class="comment">	 * minus 1, to guarantee that the RDT register is never equal to the</span></span><br><span class="line"><span class="comment">	 * RDH register, which creates a &quot;full&quot; ring situtation from the</span></span><br><span class="line"><span class="comment">	 * hardware point of view...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nb_hold = (<span class="type">uint16_t</span>) (nb_hold + rxq-&gt;nb_rx_hold);</span><br><span class="line">	<span class="keyword">if</span> (nb_hold &gt; rxq-&gt;rx_free_thresh) &#123;</span><br><span class="line">		PMD_RX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u rx_tail=%u &quot;</span></span><br><span class="line">			   <span class="string">&quot;nb_hold=%u nb_rx=%u&quot;</span>,</span><br><span class="line">			   (<span class="type">unsigned</span>) rxq-&gt;port_id, (<span class="type">unsigned</span>) rxq-&gt;queue_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) rx_id, (<span class="type">unsigned</span>) nb_hold,</span><br><span class="line">			   (<span class="type">unsigned</span>) nb_rx);</span><br><span class="line">		rx_id = (<span class="type">uint16_t</span>) ((rx_id == <span class="number">0</span>) ?</span><br><span class="line">				     (rxq-&gt;nb_rx_desc - <span class="number">1</span>) : (rx_id - <span class="number">1</span>));</span><br><span class="line">		IXGBE_PCI_REG_WRITE(rxq-&gt;rdt_reg_addr, rx_id);</span><br><span class="line">		nb_hold = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rxq-&gt;nb_rx_hold = nb_hold;</span><br><span class="line">	<span class="keyword">return</span> nb_rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IXGBE_RXDADV_STAT_DD 就是那个总提到的 DD 标志位，大家对应着相关的上面的说明并结合注释就基本弄明白了整个细节。</p>
<p>2、发送数据<br>发送的前的准备和接收前的准备有些类似，在上面的注册函数中都有，这里就不再拷贝进来，可以直接下载源码观看，重点看一下发送的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ixgbe_xmit_pkts</span><span class="params">(<span class="type">void</span> *tx_queue, <span class="keyword">struct</span> rte_mbuf **tx_pkts, <span class="type">uint16_t</span> nb_pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_tx_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_tx_entry</span> *<span class="title">sw_ring</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_tx_entry</span> *<span class="title">txe</span>, *<span class="title">txn</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_tx_desc</span> *<span class="title">txr</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_tx_desc</span> *<span class="title">txd</span>, *<span class="title">txp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>     *<span class="title">tx_pkt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>     *<span class="title">m_seg</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> buf_dma_addr;</span><br><span class="line">	<span class="type">uint32_t</span> olinfo_status;</span><br><span class="line">	<span class="type">uint32_t</span> cmd_type_len;</span><br><span class="line">	<span class="type">uint32_t</span> pkt_len;</span><br><span class="line">	<span class="type">uint16_t</span> slen;</span><br><span class="line">	<span class="type">uint64_t</span> ol_flags;</span><br><span class="line">	<span class="type">uint16_t</span> tx_id;</span><br><span class="line">	<span class="type">uint16_t</span> tx_last;</span><br><span class="line">	<span class="type">uint16_t</span> nb_tx;</span><br><span class="line">	<span class="type">uint16_t</span> nb_used;</span><br><span class="line">	<span class="type">uint64_t</span> tx_ol_req;</span><br><span class="line">	<span class="type">uint32_t</span> ctx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> new_ctx;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">ixgbe_tx_offload</span> <span class="title">tx_offload</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_SECURITY</span></span><br><span class="line">	<span class="type">uint8_t</span> use_ipsec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	tx_offload.data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	tx_offload.data[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	txq = tx_queue;</span><br><span class="line">	sw_ring = txq-&gt;sw_ring;</span><br><span class="line">	txr     = txq-&gt;tx_ring;</span><br><span class="line">	tx_id   = txq-&gt;tx_tail;</span><br><span class="line">	txe = &amp;sw_ring[tx_id];</span><br><span class="line">	txp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Determine if the descriptor ring needs to be cleaned. */</span></span><br><span class="line">	<span class="keyword">if</span> (txq-&gt;nb_tx_free &lt; txq-&gt;tx_free_thresh)</span><br><span class="line">		ixgbe_xmit_cleanup(txq);</span><br><span class="line"></span><br><span class="line">	rte_prefetch0(&amp;txe-&gt;mbuf-&gt;pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TX loop */</span></span><br><span class="line">	<span class="keyword">for</span> (nb_tx = <span class="number">0</span>; nb_tx &lt; nb_pkts; nb_tx++) &#123;</span><br><span class="line">		new_ctx = <span class="number">0</span>;</span><br><span class="line">		tx_pkt = *tx_pkts++;</span><br><span class="line">		pkt_len = tx_pkt-&gt;pkt_len;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Determine how many (if any) context descriptors</span></span><br><span class="line"><span class="comment">		 * are needed for offload functionality.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ol_flags = tx_pkt-&gt;ol_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_SECURITY</span></span><br><span class="line">		use_ipsec = txq-&gt;using_ipsec &amp;&amp; (ol_flags &amp; PKT_TX_SEC_OFFLOAD);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If hardware offload required */</span></span><br><span class="line">		tx_ol_req = ol_flags &amp; IXGBE_TX_OFFLOAD_MASK;</span><br><span class="line">		<span class="keyword">if</span> (tx_ol_req) &#123;</span><br><span class="line">			tx_offload.l2_len = tx_pkt-&gt;l2_len;</span><br><span class="line">			tx_offload.l3_len = tx_pkt-&gt;l3_len;</span><br><span class="line">			tx_offload.l4_len = tx_pkt-&gt;l4_len;</span><br><span class="line">			tx_offload.vlan_tci = tx_pkt-&gt;vlan_tci;</span><br><span class="line">			tx_offload.tso_segsz = tx_pkt-&gt;tso_segsz;</span><br><span class="line">			tx_offload.outer_l2_len = tx_pkt-&gt;outer_l2_len;</span><br><span class="line">			tx_offload.outer_l3_len = tx_pkt-&gt;outer_l3_len;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_SECURITY</span></span><br><span class="line">			<span class="keyword">if</span> (use_ipsec) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">union</span> <span class="title">ixgbe_crypto_tx_desc_md</span> *<span class="title">ipsec_mdata</span> =</span> (<span class="keyword">union</span> ixgbe_crypto_tx_desc_md *) &amp;tx_pkt-&gt;udata64;</span><br><span class="line">				tx_offload.sa_idx = ipsec_mdata-&gt;sa_idx;</span><br><span class="line">				tx_offload.sec_pad_len = ipsec_mdata-&gt;pad_len;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* If new context need be built or reuse the exist ctx. */</span></span><br><span class="line">			ctx = what_advctx_update(txq, tx_ol_req, tx_offload);</span><br><span class="line">			<span class="comment">/* Only allocate context descriptor if required*/</span></span><br><span class="line">			new_ctx = (ctx == IXGBE_CTX_NUM);</span><br><span class="line">			ctx = txq-&gt;ctx_curr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Keep track of how many descriptors are used this loop</span></span><br><span class="line"><span class="comment">		 * This will always be the number of segments + the number of</span></span><br><span class="line"><span class="comment">		 * Context descriptors required to transmit the packet</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		nb_used = (<span class="type">uint16_t</span>)(tx_pkt-&gt;nb_segs + new_ctx);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (txp != <span class="literal">NULL</span> &amp;&amp; nb_used + txq-&gt;nb_tx_used &gt;= txq-&gt;tx_rs_thresh)</span><br><span class="line">			<span class="comment">/* set RS on the previous packet in the burst */</span></span><br><span class="line">			txp-&gt;read.cmd_type_len |= rte_cpu_to_le_32(IXGBE_TXD_CMD_RS);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The number of descriptors that must be allocated for a</span></span><br><span class="line"><span class="comment">		 * packet is the number of segments of that packet, plus 1</span></span><br><span class="line"><span class="comment">		 * Context Descriptor for the hardware offload, if any.</span></span><br><span class="line"><span class="comment">		 * Determine the last TX descriptor to allocate in the TX ring</span></span><br><span class="line"><span class="comment">		 * for the packet, starting from the current position (tx_id)</span></span><br><span class="line"><span class="comment">		 * in the ring.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tx_last = (<span class="type">uint16_t</span>) (tx_id + nb_used - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Circular ring */</span></span><br><span class="line">		<span class="keyword">if</span> (tx_last &gt;= txq-&gt;nb_tx_desc)</span><br><span class="line">			tx_last = (<span class="type">uint16_t</span>) (tx_last - txq-&gt;nb_tx_desc);</span><br><span class="line"></span><br><span class="line">		PMD_TX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u pktlen=%u&quot;</span></span><br><span class="line">			   <span class="string">&quot; tx_first=%u tx_last=%u&quot;</span>,</span><br><span class="line">			   (<span class="type">unsigned</span>) txq-&gt;port_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) txq-&gt;queue_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) pkt_len,</span><br><span class="line">			   (<span class="type">unsigned</span>) tx_id,</span><br><span class="line">			   (<span class="type">unsigned</span>) tx_last);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make sure there are enough TX descriptors available to</span></span><br><span class="line"><span class="comment">		 * transmit the entire packet.</span></span><br><span class="line"><span class="comment">		 * nb_used better be less than or equal to txq-&gt;tx_rs_thresh</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (nb_used &gt; txq-&gt;nb_tx_free) &#123;</span><br><span class="line">			PMD_TX_FREE_LOG(DEBUG,</span><br><span class="line">					<span class="string">&quot;Not enough free TX descriptors &quot;</span></span><br><span class="line">					<span class="string">&quot;nb_used=%4u nb_free=%4u &quot;</span></span><br><span class="line">					<span class="string">&quot;(port=%d queue=%d)&quot;</span>,</span><br><span class="line">					nb_used, txq-&gt;nb_tx_free,</span><br><span class="line">					txq-&gt;port_id, txq-&gt;queue_id);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ixgbe_xmit_cleanup(txq) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">/* Could not clean any descriptors */</span></span><br><span class="line">				<span class="keyword">if</span> (nb_tx == <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">goto</span> end_of_tx;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* nb_used better be &lt;= txq-&gt;tx_rs_thresh */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(nb_used &gt; txq-&gt;tx_rs_thresh)) &#123;</span><br><span class="line">				PMD_TX_FREE_LOG(DEBUG,</span><br><span class="line">					<span class="string">&quot;The number of descriptors needed to &quot;</span></span><br><span class="line">					<span class="string">&quot;transmit the packet exceeds the &quot;</span></span><br><span class="line">					<span class="string">&quot;RS bit threshold. This will impact &quot;</span></span><br><span class="line">					<span class="string">&quot;performance.&quot;</span></span><br><span class="line">					<span class="string">&quot;nb_used=%4u nb_free=%4u &quot;</span></span><br><span class="line">					<span class="string">&quot;tx_rs_thresh=%4u. &quot;</span></span><br><span class="line">					<span class="string">&quot;(port=%d queue=%d)&quot;</span>,</span><br><span class="line">					nb_used, txq-&gt;nb_tx_free,</span><br><span class="line">					txq-&gt;tx_rs_thresh,</span><br><span class="line">					txq-&gt;port_id, txq-&gt;queue_id);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Loop here until there are enough TX</span></span><br><span class="line"><span class="comment">				 * descriptors or until the ring cannot be</span></span><br><span class="line"><span class="comment">				 * cleaned.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">while</span> (nb_used &gt; txq-&gt;nb_tx_free) &#123;</span><br><span class="line">					<span class="keyword">if</span> (ixgbe_xmit_cleanup(txq) != <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 * Could not clean any</span></span><br><span class="line"><span class="comment">						 * descriptors</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						<span class="keyword">if</span> (nb_tx == <span class="number">0</span>)</span><br><span class="line">							<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">goto</span> end_of_tx;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * By now there are enough free TX descriptors to transmit</span></span><br><span class="line"><span class="comment">		 * the packet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Set common flags of all TX Data Descriptors.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The following bits must be set in all Data Descriptors:</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_ADVTXD_DTYP_DATA</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_ADVTXD_DCMD_DEXT</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The following bits must be set in the first Data Descriptor</span></span><br><span class="line"><span class="comment">		 * and are ignored in the other ones:</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_ADVTXD_DCMD_IFCS</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_ADVTXD_MAC_1588</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_ADVTXD_DCMD_VLE</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The following bits must only be set in the last Data</span></span><br><span class="line"><span class="comment">		 * Descriptor:</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_TXD_CMD_EOP</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The following bits can be set in any Data Descriptor, but</span></span><br><span class="line"><span class="comment">		 * are only set in the last Data Descriptor:</span></span><br><span class="line"><span class="comment">		 *   - IXGBE_TXD_CMD_RS</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cmd_type_len = IXGBE_ADVTXD_DTYP_DATA |</span><br><span class="line">			IXGBE_ADVTXD_DCMD_IFCS | IXGBE_ADVTXD_DCMD_DEXT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_IEEE1588</span></span><br><span class="line">		<span class="keyword">if</span> (ol_flags &amp; PKT_TX_IEEE1588_TMST)</span><br><span class="line">			cmd_type_len |= IXGBE_ADVTXD_MAC_1588;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		olinfo_status = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (tx_ol_req) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ol_flags &amp; PKT_TX_TCP_SEG) &#123;</span><br><span class="line">				<span class="comment">/* when TSO is on, paylen in descriptor is the</span></span><br><span class="line"><span class="comment">				 * not the packet len but the tcp payload len */</span></span><br><span class="line">				pkt_len -= (tx_offload.l2_len +</span><br><span class="line">					tx_offload.l3_len + tx_offload.l4_len);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Setup the TX Advanced Context Descriptor if required</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (new_ctx) &#123;</span><br><span class="line">				<span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_adv_tx_context_desc</span> *</span></span><br><span class="line"><span class="class">				    <span class="title">ctx_txd</span>;</span></span><br><span class="line"></span><br><span class="line">				ctx_txd = (<span class="keyword">volatile</span> <span class="keyword">struct</span></span><br><span class="line">				    ixgbe_adv_tx_context_desc *)</span><br><span class="line">				    &amp;txr[tx_id];</span><br><span class="line"></span><br><span class="line">				txn = &amp;sw_ring[txe-&gt;next_id];</span><br><span class="line">				rte_prefetch0(&amp;txn-&gt;mbuf-&gt;pool);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (txe-&gt;mbuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">					rte_pktmbuf_free_seg(txe-&gt;mbuf);</span><br><span class="line">					txe-&gt;mbuf = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ixgbe_set_xmit_ctx(txq, ctx_txd, tx_ol_req,</span><br><span class="line">					tx_offload, &amp;tx_pkt-&gt;udata64);</span><br><span class="line"></span><br><span class="line">				txe-&gt;last_id = tx_last;</span><br><span class="line">				tx_id = txe-&gt;next_id;</span><br><span class="line">				txe = txn;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Setup the TX Advanced Data Descriptor,</span></span><br><span class="line"><span class="comment">			 * This path will go through</span></span><br><span class="line"><span class="comment">			 * whatever new/reuse the context descriptor</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			cmd_type_len  |= tx_desc_ol_flags_to_cmdtype(ol_flags);</span><br><span class="line">			olinfo_status |= tx_desc_cksum_flags_to_olinfo(ol_flags);</span><br><span class="line">			olinfo_status |= ctx &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		olinfo_status |= (pkt_len &lt;&lt; IXGBE_ADVTXD_PAYLEN_SHIFT);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_SECURITY</span></span><br><span class="line">		<span class="keyword">if</span> (use_ipsec)</span><br><span class="line">			olinfo_status |= IXGBE_ADVTXD_POPTS_IPSEC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		m_seg = tx_pkt;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			txd = &amp;txr[tx_id];</span><br><span class="line">			txn = &amp;sw_ring[txe-&gt;next_id];</span><br><span class="line">			rte_prefetch0(&amp;txn-&gt;mbuf-&gt;pool);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (txe-&gt;mbuf != <span class="literal">NULL</span>)</span><br><span class="line">				rte_pktmbuf_free_seg(txe-&gt;mbuf);</span><br><span class="line">			txe-&gt;mbuf = m_seg;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Set up Transmit Data Descriptor.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			slen = m_seg-&gt;data_len;</span><br><span class="line">			buf_dma_addr = rte_mbuf_data_iova(m_seg);</span><br><span class="line">			txd-&gt;read.buffer_addr = rte_cpu_to_le_64(buf_dma_addr);</span><br><span class="line">			txd-&gt;read.cmd_type_len = rte_cpu_to_le_32(cmd_type_len | slen);</span><br><span class="line">			txd-&gt;read.olinfo_status = rte_cpu_to_le_32(olinfo_status);</span><br><span class="line">			txe-&gt;last_id = tx_last;</span><br><span class="line">			tx_id = txe-&gt;next_id;</span><br><span class="line">			txe = txn;</span><br><span class="line">			m_seg = m_seg-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (m_seg != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The last packet data descriptor needs End Of Packet (EOP)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cmd_type_len |= IXGBE_TXD_CMD_EOP;</span><br><span class="line">		txq-&gt;nb_tx_used = (<span class="type">uint16_t</span>)(txq-&gt;nb_tx_used + nb_used);</span><br><span class="line">		txq-&gt;nb_tx_free = (<span class="type">uint16_t</span>)(txq-&gt;nb_tx_free - nb_used);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Set RS bit only on threshold packets&#x27; last descriptor */</span></span><br><span class="line">		<span class="keyword">if</span> (txq-&gt;nb_tx_used &gt;= txq-&gt;tx_rs_thresh) &#123;</span><br><span class="line">			PMD_TX_FREE_LOG(DEBUG,</span><br><span class="line">					<span class="string">&quot;Setting RS bit on TXD id=&quot;</span></span><br><span class="line">					<span class="string">&quot;%4u (port=%d queue=%d)&quot;</span>,</span><br><span class="line">					tx_last, txq-&gt;port_id, txq-&gt;queue_id);</span><br><span class="line"></span><br><span class="line">			cmd_type_len |= IXGBE_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Update txq RS bit counters */</span></span><br><span class="line">			txq-&gt;nb_tx_used = <span class="number">0</span>;</span><br><span class="line">			txp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			txp = txd;</span><br><span class="line"></span><br><span class="line">		txd-&gt;read.cmd_type_len |= rte_cpu_to_le_32(cmd_type_len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">end_of_tx:</span><br><span class="line">	<span class="comment">/* set RS on last packet in the burst */</span></span><br><span class="line">	<span class="keyword">if</span> (txp != <span class="literal">NULL</span>)</span><br><span class="line">		txp-&gt;read.cmd_type_len |= rte_cpu_to_le_32(IXGBE_TXD_CMD_RS);</span><br><span class="line"></span><br><span class="line">	rte_wmb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set the Transmit Descriptor Tail (TDT)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PMD_TX_LOG(DEBUG, <span class="string">&quot;port_id=%u queue_id=%u tx_tail=%u nb_tx=%u&quot;</span>,</span><br><span class="line">		   (<span class="type">unsigned</span>) txq-&gt;port_id, (<span class="type">unsigned</span>) txq-&gt;queue_id,</span><br><span class="line">		   (<span class="type">unsigned</span>) tx_id, (<span class="type">unsigned</span>) nb_tx);</span><br><span class="line">	IXGBE_PCI_REG_WRITE_RELAXED(txq-&gt;tdt_reg_addr, tx_id);</span><br><span class="line">	txq-&gt;tx_tail = tx_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nb_tx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3、系统 ring 和描述符 ring 映射代码<br>上文分析过这两个队列挺重要，并做了一个转换的动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __attribute__((cold)) ixgbe_alloc_rx_queue_mbufs(<span class="keyword">struct</span> ixgbe_rx_queue *rxq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_rx_entry</span> *<span class="title">rxe</span> =</span> rxq-&gt;sw_ring;</span><br><span class="line">	<span class="type">uint64_t</span> dma_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize software ring entries */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rxq-&gt;nb_rx_desc; i++) &#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">ixgbe_adv_rx_desc</span> *<span class="title">rxd</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">mbuf</span> =</span> rte_mbuf_raw_alloc(rxq-&gt;mb_pool);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			PMD_INIT_LOG(ERR, <span class="string">&quot;RX mbuf alloc failed queue_id=%u&quot;</span>,</span><br><span class="line">				     (<span class="type">unsigned</span>) rxq-&gt;queue_id);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mbuf-&gt;data_off = RTE_PKTMBUF_HEADROOM;</span><br><span class="line">		mbuf-&gt;port = rxq-&gt;port_id;</span><br><span class="line"></span><br><span class="line">		dma_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(mbuf));</span><br><span class="line">		rxd = &amp;rxq-&gt;rx_ring[i];</span><br><span class="line">		rxd-&gt;read.hdr_addr = <span class="number">0</span>;</span><br><span class="line">		rxd-&gt;read.pkt_addr = dma_addr;</span><br><span class="line">		rxe[i].mbuf = mbuf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ixgbe_dev_rx_queue_setup 可以看到 rx_ring 和 sw_ring 的创建，但其真正的关联是在上面的函数中完成的，当然，不同的设备可能还是有所不同请大家注意。</p>
<p>通过上面的源码分析和流程说明，其实发现，DPDK 的应用可以分成两个层次，一个层次是偏向于上层应用的，可以用软件的编译思维去解决；另外一个是硬件层次的，毕竟 DPDK 是一种数据平台框架，它一定最终落实到某个型号的网卡上。那么这其实就是类似于驱动层次了，需要对硬件的各种情况非常了解，这就需要对 Datasheet 进行详细的掌握。当然可能对于常见的几种网卡和常见的应用形式，其实第二个层次基本已经成熟，仍然是聚集到第一个层次。  </p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>DPDK 的源码分析的很多了，也应该让他发挥一些作用了。前面的分析可以知道，DPDK 的优势在于网络通信，那么它可不可以替代传统的 Socket 网络通信的底层协议栈呢？答案是肯定的。<br>一个框架最重要的意义就在能为上层所应用并且达到一个新的性能上的高度，DPDK 正是如此。网络编程中常用的是 TCP 编程和 UDP 编程，本篇就用 DPDK 模拟实现网络通信的一个简单框架流程的分析说明。为下一步的 TCP&#x2F;UDP 等网络编程进行一个基础的准备。</p>
<p>利用 DPDK 实现网络编程，主要需要实现通过 DPDK 的相关接口来模拟实现与网卡的网络通信 Socket 编程。包括相关的设备初始化、通过 DPDK 与网卡进行数据交互、应用层的模拟通信接口和上层应用的数据收发处理。</p>
<p>下面看一下主体框架的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = rte_eal_init(argc,argv);</span><br><span class="line">  <span class="comment">// create devices</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;port_conf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_eth_conf));</span><br><span class="line">  <span class="comment">//set config</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// get port</span></span><br><span class="line">  <span class="type">uint16_t</span> port;</span><br><span class="line">  port = rte_eth_find_next_owned_by(<span class="number">0</span>, RTE_ETH_DEV_NO_OWNER);</span><br><span class="line">  <span class="comment">//init port</span></span><br><span class="line">  ret = rte_eth_dev_configure(port, <span class="number">1</span>, <span class="number">1</span>, &amp;port_conf);</span><br><span class="line">  <span class="comment">//start port</span></span><br><span class="line">  rte_eth_macaddr_get(port,&amp;server_port-&gt;mac_addr);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createSocket</span><span class="params">()</span> &#123;</span><br><span class="line">......</span><br><span class="line">  listenFd_ = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set pars</span></span><br><span class="line">  ......</span><br><span class="line">  bind(listenFd_, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">  listen(listenFd_, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">accept</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!bStop) &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="type">int</span> connfd = accept(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">      <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          rte_eth_rx_burst(portid, <span class="number">0</span>, pkts_burst, BURST_SIZE); <span class="comment">// recv package</span></span><br><span class="line">          pthread_create(&amp;tid,<span class="literal">NULL</span>,&amp;recv,connfd);</span><br><span class="line">          pthread_detach(tid);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recv</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!bStop)&#123;</span><br><span class="line">        ......</span><br><span class="line">        rx = rte_eth_rx_burst(portid, <span class="number">0</span>, mbuf, BURST_SIZE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rx;i++)&#123;</span><br><span class="line">            <span class="type">char</span> * pdata = rte_pktmbuf_mtod(mbuf[i], <span class="type">char</span> * );</span><br><span class="line">            <span class="type">int</span> len = rte_pktmbuf_data_len(mbuf[i]);</span><br><span class="line">            cb(pdata,len);<span class="comment">//callback data</span></span><br><span class="line">            rte_pktmbuf_free(mbuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是一个基本的使用 DPDK 的网络通信框架，具体的实现都没有完成，但基本上整体的流程都清晰了。细一看，和前面分析的 fwd 的代码基本没有什么大差别。但真正的差别就在实现的细节里，这些放到下一篇再分析。</p>
<p>首先需要说明一点，开发者需要对基本 TCP 编程和相关协议至少有基础的了解，否则可能会有理解上的偏差。这里不对这些协议等进行介绍，主要是资料太多了，从教科书到网上到各种培训机构视频多得很。有不太清楚的可以回头稍微补充一下。<br>下面代码来自开源网站 github(<a target="_blank" rel="noopener" href="https://github.com/hjlogzw/DPDK-TCP-UDP_Protocol_Stack">https://github.com/hjlogzw/DPDK-TCP-UDP_Protocol_Stack</a>)<br>TCP 编程的要点在上一篇分析过，下面看一个开源的例程:<br>1、数据结构和协议实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TCP_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TCP_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_process</span><span class="params">(<span class="keyword">struct</span> rte_mbuf* pstTcpMbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_out</span><span class="params">(<span class="keyword">struct</span> rte_mempool* pstMbufPool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11种tcp连接状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">ENUM_TCP_STATUS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TCP_STATUS_CLOSED = <span class="number">0</span>,</span><br><span class="line">	TCP_STATUS_LISTEN,</span><br><span class="line">	TCP_STATUS_SYN_RCVD,</span><br><span class="line">	TCP_STATUS_SYN_SENT,</span><br><span class="line">	TCP_STATUS_ESTABLISHED,</span><br><span class="line"></span><br><span class="line">	TCP_STATUS_FIN_WAIT_1,</span><br><span class="line">	TCP_STATUS_FIN_WAIT_2,</span><br><span class="line">	TCP_STATUS_CLOSING,</span><br><span class="line">	TCP_STATUS_TIME_WAIT,</span><br><span class="line"></span><br><span class="line">	TCP_STATUS_CLOSE_WAIT,</span><br><span class="line">	TCP_STATUS_LAST_ACK</span><br><span class="line"></span><br><span class="line">&#125; TCP_STATUS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcb control block</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> dip;</span><br><span class="line">	<span class="type">uint8_t</span> localmac[RTE_ETHER_ADDR_LEN];</span><br><span class="line">	<span class="type">uint16_t</span> dport;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> protocol;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> sport;</span><br><span class="line">	<span class="type">uint32_t</span> sip;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> snd_nxt; <span class="comment">// seqnum</span></span><br><span class="line">	<span class="type">uint32_t</span> rcv_nxt; <span class="comment">// acknum</span></span><br><span class="line"></span><br><span class="line">	TCP_STATUS status;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span>* <span class="title">sndbuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span>* <span class="title">rcvbuf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span>* <span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="comment">//struct tcp_stream *listener_set;	//</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SINGLE_EPOLL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span>;</span> <span class="comment">// single epoll</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span>* <span class="title">tcb_set</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_fragment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> sport;</span><br><span class="line">	<span class="type">uint16_t</span> dport;</span><br><span class="line">	<span class="type">uint32_t</span> seqnum;</span><br><span class="line">	<span class="type">uint32_t</span> acknum;</span><br><span class="line">	<span class="type">uint8_t</span>  hdrlen_off;</span><br><span class="line">	<span class="type">uint8_t</span>  tcp_flags;</span><br><span class="line">	<span class="type">uint16_t</span> windows;</span><br><span class="line">	<span class="type">uint16_t</span> cksum;</span><br><span class="line">	<span class="type">uint16_t</span> tcp_urp;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> optlen;</span><br><span class="line">	<span class="type">uint32_t</span> option[D_TCP_OPTION_LENGTH];</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line">	<span class="type">uint32_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>2、接口实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tcp_stream * <span class="title function_">tcp_stream_create</span><span class="params">(<span class="type">uint32_t</span> sip, <span class="type">uint32_t</span> dip, <span class="type">uint16_t</span> sport, <span class="type">uint16_t</span> dport)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> acBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiSeed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span> *<span class="title">pstStream</span> =</span> rte_malloc(<span class="string">&quot;tcp_stream&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_stream), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pstStream == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pstStream-&gt;sip = sip;</span><br><span class="line">    pstStream-&gt;dip = dip;</span><br><span class="line">    pstStream-&gt;sport = sport;</span><br><span class="line">    pstStream-&gt;dport = dport;</span><br><span class="line">    pstStream-&gt;protocol = IPPROTO_TCP;</span><br><span class="line">    pstStream-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    pstStream-&gt;status = TCP_STATUS_LISTEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(acBuf, <span class="string">&quot;sndbuf%x%d&quot;</span>, sip, sport);</span><br><span class="line">	pstStream-&gt;sndbuf = rte_ring_create(acBuf, D_RING_SIZE, rte_socket_id(), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(acBuf, <span class="string">&quot;rcvbuf%x%d&quot;</span>, sip, sport);</span><br><span class="line">	pstStream-&gt;rcvbuf = rte_ring_create(acBuf, D_RING_SIZE, rte_socket_id(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seq num</span></span><br><span class="line">	uiSeed = time(<span class="literal">NULL</span>);</span><br><span class="line">	pstStream-&gt;snd_nxt = rand_r(&amp;uiSeed) % D_TCP_MAX_SEQ;</span><br><span class="line">	rte_memcpy(pstStream-&gt;localmac, &amp;g_stCpuMac, RTE_ETHER_ADDR_LEN);</span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_cond_t</span> blank_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">	rte_memcpy(&amp;pstStream-&gt;cond, &amp;blank_cond, <span class="keyword">sizeof</span>(<span class="type">pthread_cond_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_mutex_t</span> blank_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">	rte_memcpy(&amp;pstStream-&gt;mutex, &amp;blank_mutex, <span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pstStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_handle_listen</span><span class="params">(<span class="keyword">struct</span> tcp_stream *pstStream, <span class="keyword">struct</span> rte_tcp_hdr *pstTcphdr,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> rte_ipv4_hdr *pstIphdr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pstTcphdr-&gt;tcp_flags &amp; RTE_TCP_SYN_FLAG) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pstStream-&gt;status == TCP_STATUS_LISTEN) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span> *<span class="title">pstSyn</span> =</span> tcp_stream_create(pstIphdr-&gt;src_addr, pstIphdr-&gt;dst_addr,</span><br><span class="line">                                                            pstTcphdr-&gt;src_port, pstTcphdr-&gt;dst_port);</span><br><span class="line">			LL_ADD(pstSyn, g_pstTcpTbl-&gt;tcb_set);</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tcp_fragment</span> *<span class="title">pstFragment</span> =</span> rte_malloc(<span class="string">&quot;tcp_fragment&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_fragment), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (pstFragment == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="built_in">memset</span>(pstFragment, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_fragment));</span><br><span class="line"></span><br><span class="line">            pstFragment-&gt;sport = pstTcphdr-&gt;dst_port;</span><br><span class="line">			pstFragment-&gt;dport = pstTcphdr-&gt;src_port;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">			addr.s_addr = pstSyn-&gt;sip;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;tcp ---&gt; src: %s:%d &quot;</span>, inet_ntoa(addr), ntohs(pstTcphdr-&gt;src_port));</span><br><span class="line"></span><br><span class="line">			addr.s_addr = pstSyn-&gt;dip;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  ---&gt; dst: %s:%d \n&quot;</span>, inet_ntoa(addr), ntohs(pstTcphdr-&gt;dst_port));</span><br><span class="line"></span><br><span class="line">            pstFragment-&gt;seqnum = pstSyn-&gt;snd_nxt;</span><br><span class="line">			pstFragment-&gt;acknum = ntohl(pstTcphdr-&gt;sent_seq) + <span class="number">1</span>;</span><br><span class="line">			pstSyn-&gt;rcv_nxt = pstFragment-&gt;acknum;</span><br><span class="line"></span><br><span class="line">			pstFragment-&gt;tcp_flags = (RTE_TCP_SYN_FLAG | RTE_TCP_ACK_FLAG);</span><br><span class="line">			pstFragment-&gt;windows = D_TCP_INITIAL_WINDOW;</span><br><span class="line">			pstFragment-&gt;hdrlen_off = <span class="number">0x50</span>;</span><br><span class="line"></span><br><span class="line">			pstFragment-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">			pstFragment-&gt;length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue(pstSyn-&gt;sndbuf, pstFragment);</span><br><span class="line"></span><br><span class="line">			pstSyn-&gt;status = TCP_STATUS_SYN_RCVD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_handle_syn_rcvd</span><span class="params">(<span class="keyword">struct</span> tcp_stream *pstStream, <span class="keyword">struct</span> rte_tcp_hdr *pstTcphdr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pstTcphdr-&gt;tcp_flags &amp; RTE_TCP_ACK_FLAG) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pstStream-&gt;status == TCP_STATUS_SYN_RCVD) &#123;</span><br><span class="line">			<span class="type">uint32_t</span> acknum = ntohl(pstTcphdr-&gt;recv_ack);</span><br><span class="line">			<span class="keyword">if</span> (acknum == pstStream-&gt;snd_nxt + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;ack response success!\n&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;ack response error! \n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pstStream-&gt;status = TCP_STATUS_ESTABLISHED;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// accept</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span> *<span class="title">pstListener</span> =</span> tcp_stream_search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pstStream-&gt;dport);</span><br><span class="line">			<span class="keyword">if</span> (pstListener == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				rte_exit(EXIT_FAILURE, <span class="string">&quot;tcp_stream_search failed\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pthread_mutex_lock(&amp;pstListener-&gt;mutex);</span><br><span class="line">			pthread_cond_signal(&amp;pstListener-&gt;cond);   <span class="comment">// 唤醒accept中的等待</span></span><br><span class="line">			pthread_mutex_unlock(&amp;pstListener-&gt;mutex);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SINGLE_EPOLL</span></span><br><span class="line"></span><br><span class="line">   		    epoll_event_callback(g_pstTcpTbl-&gt;ep, pstListener-&gt;fd, EPOLLIN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_process</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *pstTcpMbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">pstIpHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tcp_hdr</span> *<span class="title">pstTcpHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span> *<span class="title">pstTcpStream</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> usOldTcpCkSum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> usNewTcpCkSum;</span><br><span class="line"></span><br><span class="line">    pstIpHdr = rte_pktmbuf_mtod_offset(pstTcpMbuf, <span class="keyword">struct</span> rte_ipv4_hdr *, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line">    pstTcpHdr = (<span class="keyword">struct</span> rte_tcp_hdr *)(pstIpHdr + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验和</span></span><br><span class="line">    usOldTcpCkSum = pstTcpHdr-&gt;cksum;</span><br><span class="line">    pstTcpHdr-&gt;cksum = <span class="number">0</span>;</span><br><span class="line">    usNewTcpCkSum = rte_ipv4_udptcp_cksum(pstIpHdr, pstTcpHdr);</span><br><span class="line">    <span class="keyword">if</span> (usOldTcpCkSum != usNewTcpCkSum) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cksum: %x, tcp cksum: %x\n&quot;</span>, usOldTcpCkSum, usNewTcpCkSum);</span><br><span class="line">		rte_pktmbuf_free(pstTcpMbuf);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 搜索涵盖了半连接队列和全连接队列</span></span><br><span class="line">	<span class="comment">// 搜索的stream，根据status状态调用对应处理函数</span></span><br><span class="line">    pstTcpStream = tcp_stream_search(pstIpHdr-&gt;src_addr, pstIpHdr-&gt;dst_addr,</span><br><span class="line">        pstTcpHdr-&gt;src_port, pstTcpHdr-&gt;dst_port);</span><br><span class="line">    <span class="keyword">if</span> (pstTcpStream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_pktmbuf_free(pstTcpMbuf);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(pstTcpStream-&gt;status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> TCP_STATUS_CLOSED: <span class="comment">//client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_LISTEN: <span class="comment">// server</span></span><br><span class="line">			tcp_handle_listen(pstTcpStream, pstTcpHdr, pstIpHdr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_SYN_RCVD: <span class="comment">// server</span></span><br><span class="line">			tcp_handle_syn_rcvd(pstTcpStream, pstTcpHdr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_SYN_SENT: <span class="comment">// client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_ESTABLISHED:  <span class="comment">// server | client</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tcplen = ntohs(pstIpHdr-&gt;total_length) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ipv4_hdr);</span><br><span class="line">			tcp_handle_established(pstTcpStream, pstTcpHdr, tcplen);</span><br><span class="line">			<span class="comment">// printf(&quot;tcplen = %d\n&quot;, tcplen);</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_FIN_WAIT_1: <span class="comment">//  ~client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_FIN_WAIT_2: <span class="comment">// ~client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_CLOSING: <span class="comment">// ~client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_TIME_WAIT: <span class="comment">// ~client</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_CLOSE_WAIT: <span class="comment">// ~server</span></span><br><span class="line">			tcp_handle_close_wait(pstTcpStream, pstTcpHdr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCP_STATUS_LAST_ACK:  <span class="comment">// ~server</span></span><br><span class="line">			tcp_handle_last_ack(pstTcpStream, pstTcpHdr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_out</span><span class="params">(<span class="keyword">struct</span> rte_mempool *pstMbufPool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_table</span> *<span class="title">pstTable</span> =</span> tcpInstance();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_stream</span> *<span class="title">pstStream</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(pstStream = pstTable-&gt;tcb_set; pstStream != <span class="literal">NULL</span>; pstStream = pstStream-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span>(pstStream-&gt;sndbuf == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_fragment</span> *<span class="title">pstFragment</span> =</span> <span class="literal">NULL</span>;		</span><br><span class="line">		<span class="type">int</span> iSendCnt = rte_ring_mc_dequeue(pstStream-&gt;sndbuf, (<span class="type">void</span>**)&amp;pstFragment);</span><br><span class="line">		<span class="keyword">if</span> (iSendCnt &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// struct in_addr addr;</span></span><br><span class="line">		<span class="comment">// addr.s_addr = pstStream-&gt;sip;</span></span><br><span class="line">		<span class="comment">// printf(&quot;tcp_out ---&gt; src: %s:%d \n&quot;, inet_ntoa(addr), ntohs(pstFragment-&gt;dport));</span></span><br><span class="line"></span><br><span class="line">		<span class="type">uint8_t</span> *dstmac = ng_get_dst_macaddr(pstStream-&gt;sip); <span class="comment">// 这里的源ip指的是对端ip</span></span><br><span class="line">		<span class="keyword">if</span> (dstmac == <span class="literal">NULL</span>) &#123; <span class="comment">// 先广播发个arp包确定对端mac地址</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ng_send_arp\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstArpbuf</span> =</span> ng_send_arp(pstMbufPool, RTE_ARP_OP_REQUEST, g_aucDefaultArpMac,</span><br><span class="line">				pstStream-&gt;dip, pstStream-&gt;sip);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue_burst(g_pstRingIns-&gt;pstOutRing, (<span class="type">void</span> **)&amp;pstArpbuf, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue(pstStream-&gt;sndbuf, pstFragment);  <span class="comment">// 将取出的数据再次放入队列</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ng_send_data\n&quot;</span>);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstTcpBuf</span> =</span> ng_tcp_pkt(pstMbufPool, pstStream-&gt;dip, pstStream-&gt;sip,</span><br><span class="line">												pstStream-&gt;localmac, dstmac, pstFragment);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue_burst(g_pstRingIns-&gt;pstOutRing, (<span class="type">void</span> **)&amp;pstTcpBuf, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pstFragment-&gt;data != <span class="literal">NULL</span>)</span><br><span class="line">				rte_free(pstFragment-&gt;data);</span><br><span class="line"></span><br><span class="line">			rte_free(pstFragment);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、应用例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> <span class="title">g_stCpuMac</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_kni</span> *<span class="title">g_pstKni</span>;</span>                    <span class="comment">// todo：后续将全局变量统一初始化，不再使用getInstance()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">St_InOut_Ring</span> *<span class="title">g_pstRingIns</span> =</span> <span class="literal">NULL</span>;   <span class="comment">// todo：后续将全局变量统一初始化，不再使用getInstance()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">g_pstHost</span> =</span> <span class="literal">NULL</span>;          <span class="comment">// todo：后续将全局变量统一初始化，不再使用getInstance()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_table</span> *<span class="title">g_pstArpTbl</span> =</span> <span class="literal">NULL</span>;        <span class="comment">// todo：后续将全局变量统一初始化，不再使用getInstance()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_table</span> *<span class="title">g_pstTcpTbl</span> =</span> <span class="literal">NULL</span>;		 <span class="comment">// todo：后续将全局变量统一初始化，不再使用getInstance()</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> g_aucDefaultArpMac[RTE_ETHER_ADDR_LEN] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> g_ucFdTable[D_MAX_FD_COUNT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> St_InOut_Ring *<span class="title function_">ringInstance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_pstRingIns == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		g_pstRingIns = rte_malloc(<span class="string">&quot;in/out ring&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> St_InOut_Ring), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memset</span>(g_pstRingIns, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> St_InOut_Ring));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g_pstRingIns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ng_init_port</span><span class="params">(<span class="keyword">struct</span> rte_mempool *pstMbufPoolPub)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiPortsNum;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iRxQueueNum = <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> iTxQueueNum = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">stDevInfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">stTxConf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">stPortConf</span> =</span>    <span class="comment">// 端口配置信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        .rxmode = &#123;.max_rx_pkt_len = <span class="number">1518</span> &#125;   <span class="comment">// RTE_ETHER_MAX_LEN = 1518</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    uiPortsNum = rte_eth_dev_count_avail();</span><br><span class="line">	<span class="keyword">if</span> (uiPortsNum == <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;No Supported eth found\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rte_eth_dev_info_get(D_PORT_ID, &amp;stDevInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置以太网设备</span></span><br><span class="line">	rte_eth_dev_configure(D_PORT_ID, iRxQueueNum, iTxQueueNum, &amp;stPortConf);</span><br><span class="line"></span><br><span class="line">    iRet = rte_eth_rx_queue_setup(D_PORT_ID, <span class="number">0</span> , <span class="number">1024</span>, rte_eth_dev_socket_id(D_PORT_ID), <span class="literal">NULL</span>, pstMbufPoolPub);</span><br><span class="line">	<span class="keyword">if</span>(iRet &lt; <span class="number">0</span>)</span><br><span class="line">	    rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup RX queue!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	stTxConf = stDevInfo.default_txconf;</span><br><span class="line">	stTxConf.offloads = stPortConf.txmode.offloads;</span><br><span class="line">    iRet = rte_eth_tx_queue_setup(D_PORT_ID, <span class="number">0</span> , <span class="number">1024</span>, rte_eth_dev_socket_id(D_PORT_ID), &amp;stTxConf);</span><br><span class="line">	<span class="keyword">if</span> (iRet &lt; <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup TX queue\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eth_dev_start(D_PORT_ID) &lt; <span class="number">0</span> )</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rte_eth_promiscuous_enable(D_PORT_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ng_config_network_if</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">unsigned</span> <span class="type">char</span> if_up)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rte_eth_dev_is_valid_port(port_id)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (if_up) &#123;</span><br><span class="line"></span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line">		ret = rte_eth_dev_start(port_id);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to start port : %d\n&quot;</span>, port_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rte_kni *<span class="title function_">ng_alloc_kni</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mbuf_pool)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni</span> *<span class="title">kni_hanlder</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni_conf</span> <span class="title">conf</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;conf, <span class="number">0</span>, <span class="keyword">sizeof</span>(conf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(conf.name, RTE_KNI_NAMESIZE, <span class="string">&quot;vEth%u&quot;</span>, D_PORT_ID);</span><br><span class="line">	conf.group_id = D_PORT_ID;</span><br><span class="line">	conf.mbuf_size = D_MAX_PACKET_SIZE;</span><br><span class="line">	rte_eth_macaddr_get(D_PORT_ID, (<span class="keyword">struct</span> rte_ether_addr *)conf.mac_addr);</span><br><span class="line">	rte_eth_dev_get_mtu(D_PORT_ID, &amp;conf.mtu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print_ethaddr(&quot;ng_alloc_kni: &quot;, (struct ether_addr *)conf.mac_addr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct rte_eth_dev_info dev_info;</span></span><br><span class="line"><span class="comment">	memset(&amp;dev_info, 0, sizeof(dev_info));</span></span><br><span class="line"><span class="comment">	rte_eth_dev_info_get(D_PORT_ID, &amp;dev_info);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni_ops</span> <span class="title">ops</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ops, <span class="number">0</span>, <span class="keyword">sizeof</span>(ops));</span><br><span class="line"></span><br><span class="line">	ops.port_id = D_PORT_ID;</span><br><span class="line">	ops.config_network_if = ng_config_network_if;</span><br><span class="line"></span><br><span class="line">	kni_hanlder = rte_kni_alloc(mbuf_pool, &amp;conf, &amp;ops);</span><br><span class="line">	<span class="keyword">if</span> (!kni_hanlder) &#123;</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Failed to create kni for port : %d\n&quot;</span>, D_PORT_ID);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kni_hanlder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pkt_process</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pstMbufPool</span>;</span></span><br><span class="line">    <span class="type">int</span> iRxNum;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_hdr</span> *<span class="title">pstEthHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">pstIpHdr</span>;</span></span><br><span class="line"></span><br><span class="line">    pstMbufPool = (<span class="keyword">struct</span> rte_mempool *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstMbuf</span>[32];</span></span><br><span class="line">        iRxNum = rte_ring_mc_dequeue_burst(g_pstRingIns-&gt;pstInRing, (<span class="type">void</span>**)pstMbuf, D_BURST_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRxNum &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; iRxNum; ++i) &#123;</span><br><span class="line">            pstEthHdr = rte_pktmbuf_mtod_offset(pstMbuf[i], <span class="keyword">struct</span> rte_ether_hdr *, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (pstEthHdr-&gt;ether_type == rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4)) &#123; <span class="comment">//IPv4: 0800</span></span><br><span class="line">                pstIpHdr = rte_pktmbuf_mtod_offset(pstMbuf[i], <span class="keyword">struct</span> rte_ipv4_hdr *, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 维护一个arp表</span></span><br><span class="line">				ng_arp_entry_insert(pstIpHdr-&gt;src_addr, pstEthHdr-&gt;s_addr.addr_bytes);</span><br><span class="line">                <span class="keyword">if</span>(pstIpHdr-&gt;next_proto_id == IPPROTO_UDP) &#123; <span class="comment">// udp</span></span><br><span class="line">                    <span class="comment">// udp process</span></span><br><span class="line">                    <span class="comment">//udp_process(pstMbuf[i]);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstIpHdr-&gt;next_proto_id == IPPROTO_TCP) &#123; <span class="comment">// tcp</span></span><br><span class="line">                    <span class="comment">// printf(&quot;tcp_process ---\n&quot;);</span></span><br><span class="line">					tcp_process(pstMbuf[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					rte_kni_tx_burst(g_pstKni, pstMbuf, iRxNum);</span><br><span class="line">					<span class="comment">// printf(&quot;tcp/udp --&gt; rte_kni_handle_request\n&quot;);</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// ifconfig vEth0 192.168.181.169 up</span></span><br><span class="line">				rte_kni_tx_burst(g_pstKni, pstMbuf, iRxNum);</span><br><span class="line">				<span class="comment">// printf(&quot;ip --&gt; rte_kni_handle_request\n&quot;);</span></span><br><span class="line">			&#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		rte_kni_handle_request(g_pstKni);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to send</span></span><br><span class="line">        udp_out(pstMbufPool);</span><br><span class="line">        tcp_out(pstMbufPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_SINGLE_EPOLL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_server_entry</span><span class="params">(__attribute__((unused))  <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> listenfd = nsocket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">	nbind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	nlisten(listenfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> epfd = nepoll_create(<span class="number">1</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[1024];</span></span><br><span class="line">	ev.data.fd = listenfd;</span><br><span class="line">	ev.events |= EPOLLIN;</span><br><span class="line">	nepoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buff[BUFFER_SIZE] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> nready = nepoll_wait(epfd, events, <span class="number">1024</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span>(listenfd == fd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">				<span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">				<span class="type">int</span> connfd = naccept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">				ev.events = EPOLLIN;</span><br><span class="line">				ev.data.fd = connfd;</span><br><span class="line">				nepoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> n = nrecv(fd, buff, BUFFER_SIZE, <span class="number">0</span>); <span class="comment">//block</span></span><br><span class="line">				<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; arno --&gt; recv: %s\n&quot;</span>, buff);</span><br><span class="line">					nsend(fd, buff, n, <span class="number">0</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">					nepoll_ctl(epfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">					nclose(fd);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_server_entry</span><span class="params">(__attribute__((unused))  <span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> listenfd;</span><br><span class="line">	<span class="type">int</span> iRet = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	listenfd = nsocket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%s][%d] nsocket error!\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">	iRet = nbind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="keyword">if</span>(iRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;nbind error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nlisten(listenfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">		<span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">		<span class="type">int</span> connfd = naccept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> buff[D_TCP_BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> n = nrecv(connfd, buff, D_TCP_BUFFER_SIZE, <span class="number">0</span>); <span class="comment">//block</span></span><br><span class="line">			<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, buff);</span><br><span class="line">				nsend(connfd, buff, n, <span class="number">0</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;nclose()\n&quot;</span>);</span><br><span class="line">				nclose(connfd);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//nonblock</span></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	nclose(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pstMbufPoolPub</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">St_InOut_Ring</span> *<span class="title">pstRing</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstRecvMbuf</span>[32] =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstSendMbuf</span>[32] =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iRxNum;</span><br><span class="line">    <span class="type">int</span> iTotalNum;</span><br><span class="line">    <span class="type">int</span> iOffset;</span><br><span class="line">    <span class="type">int</span> iTxNum;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiCoreId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rte_eal_init(argc, argv) &lt; <span class="number">0</span>)</span><br><span class="line">	    rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pstMbufPoolPub = rte_pktmbuf_pool_create(<span class="string">&quot;MBUF_POOL_PUB&quot;</span>, D_NUM_MBUFS, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line">	<span class="keyword">if</span>(pstMbufPoolPub == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;rte_errno = %x, errmsg = %s\n&quot;</span>, rte_errno, rte_strerror(rte_errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rte_kni_init(D_PORT_ID))</span><br><span class="line">        rte_exit(EXIT_FAILURE, <span class="string">&quot;kni init failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ng_init_port(pstMbufPoolPub);</span><br><span class="line">	g_pstKni = ng_alloc_kni(pstMbufPoolPub);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ng_init_port(pstMbufPoolPub);</span></span><br><span class="line"></span><br><span class="line">    rte_eth_macaddr_get(D_PORT_ID, &amp;g_stCpuMac);</span><br><span class="line"></span><br><span class="line">    pstRing = ringInstance();</span><br><span class="line">	<span class="keyword">if</span>(pstRing == <span class="literal">NULL</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;ring buffer init failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pstRing-&gt;pstInRing = rte_ring_create(<span class="string">&quot;in ring&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">    pstRing-&gt;pstOutRing = rte_ring_create(<span class="string">&quot;out ring&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_lcore_id();</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	rte_eal_remote_launch(pkt_process, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	rte_eal_remote_launch(udp_server_entry, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rte_eal_remote_launch(tcp_server_entry, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// rx</span></span><br><span class="line">        iRxNum = rte_eth_rx_burst(D_PORT_ID, <span class="number">0</span>, pstRecvMbuf, D_BURST_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(iRxNum &gt; <span class="number">0</span>)</span><br><span class="line">            rte_ring_sp_enqueue_burst(pstRing-&gt;pstInRing, (<span class="type">void</span>**)pstRecvMbuf, iRxNum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tx</span></span><br><span class="line">        iTotalNum = rte_ring_sc_dequeue_burst(pstRing-&gt;pstOutRing, (<span class="type">void</span>**)pstSendMbuf, D_BURST_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (iTotalNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			iOffset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (iOffset &lt; iTotalNum) &#123;</span><br><span class="line">				iTxNum = rte_eth_tx_burst(D_PORT_ID, <span class="number">0</span>, &amp;pstSendMbuf[iOffset], iTotalNum - iOffset);</span><br><span class="line">				<span class="keyword">if</span>(iTxNum &gt; <span class="number">0</span>)</span><br><span class="line">					iOffset += iTxNum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的优点在于实现的比较简单（简单才是王道，特别是对于学习），没有太多复杂的相关协议的处理（只实现主干）。而且代码实现的手段也相对容易看明白，这样更有助于学习。源码的 Readme 中有相关测试启动的方法，此处不再赘述。<br>另外，此开源的代码基本实现了相关的功能，如果有什么需要可以继续在这个基础上进行完善或者重构，非常感谢作者。不过需要注意的是，代码的管理有点零乱，需要自己处理一下。</p>
<h1 id="UDP-编程"><a href="#UDP-编程" class="headerlink" title="UDP 编程"></a>UDP 编程</h1><p>UDP 编程的应用和 TCP 编程的应用同样非常广泛，如果说真得想使用 UDP 编程，一般情况下还真得不至于运用 DPDK 这种重量级的框架。但一个框架的优秀与否，不仅仅在于自身的整体设计优秀，更重要的在于其对应用的支持更完善。<br>正如 DPDK 对 TCP 的支持一样，其实对于 DPDK 这种更侧重于底层的应用来说，实现 UDP 和 TCP 没有本质的区别，只是套的一层解析的协议不同罢了。同样，UDP 与 TCP 的不同及其协议的内容如有不明白可自行查看相关资料，此处不再赘述。</p>
<p>下面看一下例程（代码来源与 TCP 相同）:<br>1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>和协议</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arp表的单个条目</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> ip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> hwaddr[RTE_ETHER_ADDR_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> type;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arp表结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span> *<span class="title">entries</span>;</span></span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// udp control block</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">localhost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//unsigned int status; //</span></span><br><span class="line">	<span class="type">uint32_t</span> localip; <span class="comment">// ip --&gt; mac</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> localmac[RTE_ETHER_ADDR_LEN];</span><br><span class="line">	<span class="type">uint16_t</span> localport;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> protocol;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">sndbuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">rcvbuf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//UDP的数据包</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">offload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> sip;</span><br><span class="line">	<span class="type">uint32_t</span> dip;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> sport;</span><br><span class="line">	<span class="type">uint16_t</span> dport;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> protocol;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data;</span><br><span class="line">	<span class="type">uint16_t</span> length;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//common.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ng_arp_entry_insert</span><span class="params">(<span class="type">uint32_t</span> ip, <span class="type">unsigned</span> <span class="type">char</span> *mac)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arp_table</span> *<span class="title">pstTbl</span> =</span> arp_table_instance();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span> *<span class="title">pstEntry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pstHwaddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pstHwaddr = ng_get_dst_macaddr(ip);</span><br><span class="line">    <span class="keyword">if</span>(pstHwaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pstEntry = rte_malloc(<span class="string">&quot;arp_entry&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> arp_entry), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (pstEntry)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">memset</span>(pstEntry, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> arp_entry));</span><br><span class="line"></span><br><span class="line">			pstEntry-&gt;ip = ip;</span><br><span class="line">			rte_memcpy(pstEntry-&gt;hwaddr, mac, RTE_ETHER_ADDR_LEN);</span><br><span class="line">			pstEntry-&gt;type = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			pthread_spin_lock(&amp;pstTbl-&gt;spinlock);</span><br><span class="line">			LL_ADD(pstEntry, pstTbl-&gt;entries);</span><br><span class="line">			pstTbl-&gt;count ++;</span><br><span class="line">			pthread_spin_unlock(&amp;pstTbl-&gt;spinlock);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> arp_table *<span class="title function_">arp_table_instance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_pstArpTbl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		g_pstArpTbl = rte_malloc(<span class="string">&quot;arp table&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span>  arp_table), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (g_pstArpTbl == <span class="literal">NULL</span>)</span><br><span class="line">			rte_exit(EXIT_FAILURE, <span class="string">&quot;rte_malloc arp table failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(g_pstArpTbl, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> arp_table));</span><br><span class="line"></span><br><span class="line">		pthread_spin_init(&amp;g_pstArpTbl-&gt;spinlock, PTHREAD_PROCESS_SHARED);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g_pstArpTbl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">ng_get_dst_macaddr</span><span class="params">(<span class="type">uint32_t</span> dip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arp_entry</span> *<span class="title">pstIter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arp_table</span> *<span class="title">pstTbl</span> =</span> arp_table_instance();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count = pstTbl-&gt;count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pstIter = pstTbl-&gt;entries; count-- != <span class="number">0</span> &amp;&amp; pstIter != <span class="literal">NULL</span>; pstIter = pstIter-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (dip == pstIter-&gt;ip)</span><br><span class="line">			<span class="keyword">return</span> pstIter-&gt;hwaddr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">数据处理</a>分为两类一类是控制包，一类是负载包也就是数据包。arp 表的作用类似于快递小哥的作用，查找 IP 与 MAC 的映射并实现数据包的准确传输，即其有两个出口，一个是数据发送时的出口，保存发送时的 IP 和 MAC（没有则先广播）；一个是接收时的出口，用来保存收到的数据包对应的 IP 和 MAC。代码没有什么难度，大家对照着相关的协议实现就明白了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nsocket</span><span class="params">(__attribute__((unused)) <span class="type">int</span> domain, <span class="type">int</span> type, __attribute__((unused))  <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHost</span>;</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> pctCond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> pmtMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">    iFd = get_fd_frombitmap();</span><br><span class="line">    <span class="keyword">if</span>(type == SOCK_DGRAM) <span class="comment">// udp</span></span><br><span class="line">    &#123;</span><br><span class="line">        pstHost = rte_malloc(<span class="string">&quot;localhost&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> localhost), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pstHost == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s][%d]: rte_malloc fail!\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(pstHost, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> localhost));</span><br><span class="line">        pstHost-&gt;fd = iFd;</span><br><span class="line">        pstHost-&gt;protocol = IPPROTO_UDP;</span><br><span class="line">        pstHost-&gt;rcvbuf = rte_ring_create(<span class="string">&quot;recv buffer&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">        <span class="keyword">if</span> (pstHost-&gt;rcvbuf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s][%d]: rte_ring_create fail!\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">			rte_free(pstHost);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        pstHost-&gt;sndbuf = rte_ring_create(<span class="string">&quot;send buffer&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">        <span class="keyword">if</span> (pstHost-&gt;sndbuf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s][%d]: rte_ring_create fail!\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">            rte_ring_free(pstHost-&gt;rcvbuf);</span><br><span class="line">			rte_free(pstHost);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rte_memcpy(&amp;pstHost-&gt;cond, &amp;pctCond, <span class="keyword">sizeof</span>(<span class="type">pthread_cond_t</span>));</span><br><span class="line"></span><br><span class="line">		rte_memcpy(&amp;pstHost-&gt;mutex, &amp;pmtMutex, <span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line"></span><br><span class="line">		LL_ADD(pstHost, g_pstHost);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == SOCK_STREAM) &#123; <span class="comment">// tcp</span></span><br><span class="line">        <span class="keyword">struct</span> tcp_stream *pstStream = rte_malloc(<span class="string">&quot;tcp_stream&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_stream), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (pstStream == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(pstStream, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_stream));</span><br><span class="line">        pstStream-&gt;fd = iFd;</span><br><span class="line">        pstStream-&gt;protocol = IPPROTO_TCP;</span><br><span class="line">		pstStream-&gt;next = pstStream-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pstStream-&gt;rcvbuf = rte_ring_create(<span class="string">&quot;tcp recv buffer&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">		<span class="keyword">if</span> (pstStream-&gt;rcvbuf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			rte_free(pstStream);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pstStream-&gt;sndbuf = rte_ring_create(<span class="string">&quot;tcp send buffer&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">		<span class="keyword">if</span> (pstStream-&gt;sndbuf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			rte_ring_free(pstStream-&gt;rcvbuf);</span><br><span class="line">			rte_free(pstStream);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_cond_t</span> blank_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">		rte_memcpy(&amp;pstStream-&gt;cond, &amp;blank_cond, <span class="keyword">sizeof</span>(<span class="type">pthread_cond_t</span>));</span><br><span class="line"></span><br><span class="line">		<span class="type">pthread_mutex_t</span> blank_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">		rte_memcpy(&amp;pstStream-&gt;mutex, &amp;blank_mutex, <span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line"></span><br><span class="line">        g_pstTcpTbl = tcpInstance();</span><br><span class="line">		LL_ADD(pstStream, g_pstTcpTbl-&gt;tcb_set);           <span class="comment">// todo :hash</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iFd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nbind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, __attribute__((unused))  <span class="type">socklen_t</span> addrlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = get_hostinfo_fromfd(sockfd);</span><br><span class="line">    <span class="keyword">if</span>(info == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHostInfo</span> =</span> (<span class="keyword">struct</span> localhost *)info;</span><br><span class="line">    <span class="keyword">if</span>(pstHostInfo-&gt;protocol == IPPROTO_UDP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">pstAddr</span> =</span> (<span class="type">const</span> <span class="keyword">struct</span> sockaddr_in *)addr;</span><br><span class="line">		pstHostInfo-&gt;localport = pstAddr-&gt;sin_port;</span><br><span class="line">		rte_memcpy(&amp;pstHostInfo-&gt;localip, &amp;pstAddr-&gt;sin_addr.s_addr, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">		rte_memcpy(pstHostInfo-&gt;localmac, &amp;g_stCpuMac, RTE_ETHER_ADDR_LEN);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstHostInfo-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">struct</span> tcp_stream* pstStream = (<span class="keyword">struct</span> tcp_stream*)pstHostInfo;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">pstAddr</span> =</span> (<span class="type">const</span> <span class="keyword">struct</span> sockaddr_in *)addr;</span><br><span class="line">		pstStream-&gt;dport = pstAddr-&gt;sin_port;</span><br><span class="line">		rte_memcpy(&amp;pstStream-&gt;dip, &amp;pstAddr-&gt;sin_addr.s_addr, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">		rte_memcpy(pstStream-&gt;localmac, &amp;g_stCpuMac, RTE_ETHER_ADDR_LEN);</span><br><span class="line"></span><br><span class="line">		pstStream-&gt;status = TCP_STATUS_CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">nrecvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, __attribute__((unused))  <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> sockaddr *src_addr, __attribute__((unused))  <span class="type">socklen_t</span> *addrlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHostInfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">offload</span> *<span class="title">pstOffLoad</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">pstAddr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *pucPtr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> iLen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> iRet = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pstHostInfo = (<span class="keyword">struct</span> localhost *)get_hostinfo_fromfd(sockfd);</span><br><span class="line">    <span class="keyword">if</span>(pstHostInfo == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstHostInfo-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span>((iRet = rte_ring_mc_dequeue(pstHostInfo-&gt;rcvbuf, (<span class="type">void</span>**)&amp;pstOffLoad)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;pstHostInfo-&gt;cond, &amp;pstHostInfo-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;pstHostInfo-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    pstAddr = (<span class="keyword">struct</span> sockaddr_in *)src_addr;</span><br><span class="line">    pstAddr-&gt;sin_port = pstOffLoad-&gt;sport;</span><br><span class="line">    rte_memcpy(&amp;pstAddr-&gt;sin_addr.s_addr, &amp;pstOffLoad-&gt;sip, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &lt; pstOffLoad-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        rte_memcpy(buf, pstOffLoad-&gt;data, len);</span><br><span class="line"></span><br><span class="line">        pucPtr = rte_malloc(<span class="string">&quot;unsigned char *&quot;</span>, pstOffLoad-&gt;length - len, <span class="number">0</span>);</span><br><span class="line">		rte_memcpy(pucPtr, pstOffLoad-&gt;data + len, pstOffLoad-&gt;length - len);</span><br><span class="line"></span><br><span class="line">		pstOffLoad-&gt;length -= len;</span><br><span class="line">		rte_free(pstOffLoad-&gt;data);</span><br><span class="line">		pstOffLoad-&gt;data = pucPtr;</span><br><span class="line"></span><br><span class="line">		rte_ring_mp_enqueue(pstHostInfo-&gt;rcvbuf, pstOffLoad);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iLen = pstOffLoad-&gt;length;</span><br><span class="line">    rte_memcpy(buf, pstOffLoad-&gt;data, pstOffLoad-&gt;length);</span><br><span class="line"></span><br><span class="line">    rte_free(pstOffLoad-&gt;data);</span><br><span class="line">    rte_free(pstOffLoad);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iLen;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">nsendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, __attribute__((unused))  <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, __attribute__((unused))  <span class="type">socklen_t</span> addrlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHostInfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">offload</span> *<span class="title">pstOffLoad</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">pstAddr</span> =</span> (<span class="type">const</span> <span class="keyword">struct</span> sockaddr_in *)dest_addr;</span><br><span class="line"></span><br><span class="line">    pstHostInfo = (<span class="keyword">struct</span> localhost *)get_hostinfo_fromfd(sockfd);</span><br><span class="line">    <span class="keyword">if</span>(pstHostInfo == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pstOffLoad = rte_malloc(<span class="string">&quot;offload&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> offload), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pstOffLoad == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pstOffLoad-&gt;dip = pstAddr-&gt;sin_addr.s_addr;</span><br><span class="line">	pstOffLoad-&gt;dport = pstAddr-&gt;sin_port;</span><br><span class="line">	pstOffLoad-&gt;sip = pstHostInfo-&gt;localip;</span><br><span class="line">	pstOffLoad-&gt;sport = pstHostInfo-&gt;localport;</span><br><span class="line">	pstOffLoad-&gt;length = len;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.s_addr = pstOffLoad-&gt;dip;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nsendto ---&gt; src: %s:%d \n&quot;</span>, inet_ntoa(addr), ntohs(pstOffLoad-&gt;dport));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pstOffLoad-&gt;data = rte_malloc(<span class="string">&quot;unsigned char *&quot;</span>, len, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pstOffLoad-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rte_free(pstOffLoad);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rte_memcpy(pstOffLoad-&gt;data, buf, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;rte_ring_mp_enqueue before !&quot;</span>);</span><br><span class="line">	rte_ring_mp_enqueue(pstHostInfo-&gt;sndbuf, pstOffLoad);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;rte_ring_mp_enqueue after !&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nclose</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = (<span class="keyword">struct</span> localhost *)get_hostinfo_fromfd(fd);</span><br><span class="line">    <span class="keyword">if</span>(info == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHostInfo</span> =</span> (<span class="keyword">struct</span> localhost *)info;</span><br><span class="line">    <span class="keyword">if</span>(pstHostInfo-&gt;protocol == IPPROTO_UDP)</span><br><span class="line">    &#123;</span><br><span class="line">        LL_REMOVE(pstHostInfo, g_pstHost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pstHostInfo-&gt;rcvbuf)</span><br><span class="line">			rte_ring_free(pstHostInfo-&gt;rcvbuf);</span><br><span class="line">		<span class="keyword">if</span> (pstHostInfo-&gt;sndbuf)</span><br><span class="line">			rte_ring_free(pstHostInfo-&gt;sndbuf);</span><br><span class="line"></span><br><span class="line">		rte_free(pstHostInfo);</span><br><span class="line"></span><br><span class="line">		set_fd_frombitmap(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pstHostInfo-&gt;protocol == IPPROTO_TCP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> tcp_stream *pstStream = (<span class="keyword">struct</span> tcp_stream*)info;</span><br><span class="line">        <span class="keyword">if</span> (pstStream-&gt;status != TCP_STATUS_LISTEN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tcp_fragment</span> *<span class="title">pstFragment</span> =</span> rte_malloc(<span class="string">&quot;tcp_fragment&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_fragment), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (pstFragment == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(pstFragment, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_fragment));</span><br><span class="line">            pstFragment-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">			pstFragment-&gt;length = <span class="number">0</span>;</span><br><span class="line">			pstFragment-&gt;sport = pstStream-&gt;dport;</span><br><span class="line">			pstFragment-&gt;dport = pstStream-&gt;sport;</span><br><span class="line"></span><br><span class="line">			pstFragment-&gt;seqnum = pstStream-&gt;snd_nxt;</span><br><span class="line">			pstFragment-&gt;acknum = pstStream-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">			pstFragment-&gt;tcp_flags = RTE_TCP_FIN_FLAG | RTE_TCP_ACK_FLAG;  <span class="comment">// 发送FIN</span></span><br><span class="line">			pstFragment-&gt;windows = D_TCP_INITIAL_WINDOW;</span><br><span class="line">			pstFragment-&gt;hdrlen_off = <span class="number">0x50</span>;</span><br><span class="line"></span><br><span class="line">            rte_ring_mp_enqueue(pstStream-&gt;sndbuf, pstFragment);</span><br><span class="line">			pstStream-&gt;status = TCP_STATUS_LAST_ACK;</span><br><span class="line"></span><br><span class="line">            set_fd_frombitmap(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LL_REMOVE(pstStream, g_pstTcpTbl-&gt;tcb_set);</span><br><span class="line">			rte_free(pstStream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、接口实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_process</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *pstUdpMbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">pstIpHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_udp_hdr</span> *<span class="title">pstUdpHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHost</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">offload</span> *<span class="title">pstOffLoad</span>;</span></span><br><span class="line"></span><br><span class="line">    pstIpHdr = rte_pktmbuf_mtod_offset(pstUdpMbuf, <span class="keyword">struct</span> rte_ipv4_hdr *, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line">	pstUdpHdr = (<span class="keyword">struct</span> rte_udp_hdr *)(pstIpHdr + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pstHost = get_hostinfo_fromip_port(pstIpHdr-&gt;dst_addr, pstUdpHdr-&gt;dst_port, pstIpHdr-&gt;next_proto_id);</span><br><span class="line">    <span class="keyword">if</span> (pstHost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		rte_pktmbuf_free(pstUdpMbuf);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.s_addr = pstIpHdr-&gt;src_addr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;udp_process ---&gt; src: %s:%d \n&quot;</span>, inet_ntoa(addr), ntohs(pstUdpHdr-&gt;src_port));</span><br><span class="line"></span><br><span class="line">    pstOffLoad = rte_malloc(<span class="string">&quot;offload&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> offload), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pstOffLoad == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		rte_pktmbuf_free(pstUdpMbuf);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    pstOffLoad-&gt;dip = pstIpHdr-&gt;dst_addr;</span><br><span class="line">	pstOffLoad-&gt;sip = pstIpHdr-&gt;src_addr;</span><br><span class="line">	pstOffLoad-&gt;sport = pstUdpHdr-&gt;src_port;</span><br><span class="line">	pstOffLoad-&gt;dport = pstUdpHdr-&gt;dst_port;</span><br><span class="line">    pstOffLoad-&gt;protocol = IPPROTO_UDP;</span><br><span class="line">	pstOffLoad-&gt;length = ntohs(pstUdpHdr-&gt;dgram_len);</span><br><span class="line">    pstOffLoad-&gt;data = rte_malloc(<span class="string">&quot;unsigned char*&quot;</span>, pstOffLoad-&gt;length - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_udp_hdr), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pstOffLoad-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		rte_pktmbuf_free(pstUdpMbuf);</span><br><span class="line">		rte_free(pstOffLoad);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    rte_memcpy(pstOffLoad-&gt;data, (<span class="type">unsigned</span> <span class="type">char</span> *)(pstUdpHdr+<span class="number">1</span>), pstOffLoad-&gt;length - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_udp_hdr));</span><br><span class="line"></span><br><span class="line">	rte_ring_mp_enqueue(pstHost-&gt;rcvbuf, pstOffLoad);  <span class="comment">// recv buffer</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;pstHost-&gt;mutex);</span><br><span class="line">	pthread_cond_signal(&amp;pstHost-&gt;cond);</span><br><span class="line">	pthread_mutex_unlock(&amp;pstHost-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	rte_pktmbuf_free(pstUdpMbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ng_encode_udp_apppkt</span><span class="params">(<span class="type">uint8_t</span> *msg, <span class="type">uint32_t</span> sip, <span class="type">uint32_t</span> dip,</span></span><br><span class="line"><span class="params">	<span class="type">uint16_t</span> sport, <span class="type">uint16_t</span> dport, <span class="type">uint8_t</span> *srcmac, <span class="type">uint8_t</span> *dstmac,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">uint16_t</span> total_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_hdr</span> *<span class="title">pstEth</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">pstIp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_udp_hdr</span> *<span class="title">pstUdp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 ethhdr</span></span><br><span class="line">	pstEth = (<span class="keyword">struct</span> rte_ether_hdr *)msg;</span><br><span class="line">	rte_memcpy(pstEth-&gt;s_addr.addr_bytes, srcmac, RTE_ETHER_ADDR_LEN);</span><br><span class="line">	rte_memcpy(pstEth-&gt;d_addr.addr_bytes, dstmac, RTE_ETHER_ADDR_LEN);</span><br><span class="line">	pstEth-&gt;ether_type = htons(RTE_ETHER_TYPE_IPV4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2 iphdr</span></span><br><span class="line">	pstIp = (<span class="keyword">struct</span> rte_ipv4_hdr *)(pstEth + <span class="number">1</span>);</span><br><span class="line">	pstIp-&gt;version_ihl = <span class="number">0x45</span>;</span><br><span class="line">	pstIp-&gt;type_of_service = <span class="number">0</span>;</span><br><span class="line">	pstIp-&gt;total_length = htons(total_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line">	pstIp-&gt;packet_id = <span class="number">0</span>;</span><br><span class="line">	pstIp-&gt;fragment_offset = <span class="number">0</span>;</span><br><span class="line">	pstIp-&gt;time_to_live = <span class="number">64</span>; <span class="comment">// ttl = 64</span></span><br><span class="line">	pstIp-&gt;next_proto_id = IPPROTO_UDP;</span><br><span class="line">	pstIp-&gt;src_addr = sip;</span><br><span class="line">	pstIp-&gt;dst_addr = dip;</span><br><span class="line">	pstIp-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line">	pstIp-&gt;hdr_checksum = rte_ipv4_cksum(pstIp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3 udphdr</span></span><br><span class="line">	pstUdp = (<span class="keyword">struct</span> rte_udp_hdr *)(pstIp + <span class="number">1</span>);</span><br><span class="line">	pstUdp-&gt;src_port = sport;</span><br><span class="line">	pstUdp-&gt;dst_port = dport;</span><br><span class="line">	<span class="type">uint16_t</span> udplen = total_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ipv4_hdr);</span><br><span class="line">	pstUdp-&gt;dgram_len = htons(udplen);</span><br><span class="line">	rte_memcpy((<span class="type">uint8_t</span>*)(pstUdp + <span class="number">1</span>), data, udplen);</span><br><span class="line">	pstUdp-&gt;dgram_cksum = <span class="number">0</span>;</span><br><span class="line">	pstUdp-&gt;dgram_cksum = rte_ipv4_udptcp_cksum(pstIp, pstUdp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rte_mbuf * <span class="title function_">ng_udp_pkt</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mbuf_pool, <span class="type">uint32_t</span> sip, <span class="type">uint32_t</span> dip,</span></span><br><span class="line"><span class="params">	<span class="type">uint16_t</span> sport, <span class="type">uint16_t</span> dport, <span class="type">unsigned</span> <span class="type">char</span> *srcmac, <span class="type">unsigned</span> <span class="type">char</span> *dstmac,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiTotalLen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstMbuf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pucPktData;</span><br><span class="line"></span><br><span class="line">    uiTotalLen = length + <span class="number">42</span>;   <span class="comment">// 42 = eth + ip</span></span><br><span class="line">    pstMbuf = rte_pktmbuf_alloc(mbuf_pool);</span><br><span class="line">    <span class="keyword">if</span> (!pstMbuf)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;rte_pktmbuf_alloc\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pstMbuf-&gt;pkt_len = uiTotalLen;</span><br><span class="line">    pstMbuf-&gt;data_len = uiTotalLen;</span><br><span class="line">    pucPktData = rte_pktmbuf_mtod(pstMbuf, <span class="type">unsigned</span> <span class="type">char</span>*);</span><br><span class="line"></span><br><span class="line">	ng_encode_udp_apppkt(pucPktData, sip, dip, sport, dport, srcmac, dstmac,</span><br><span class="line">		data, uiTotalLen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pstMbuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_out</span><span class="params">(<span class="keyword">struct</span> rte_mempool *pstMbufPool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">localhost</span> *<span class="title">pstHost</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pstHost = g_pstHost; pstHost != <span class="literal">NULL</span>; pstHost = pstHost-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">offload</span> *<span class="title">pstOffLoad</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> iSendCnt = rte_ring_mc_dequeue(pstHost-&gt;sndbuf, (<span class="type">void</span> **)&amp;pstOffLoad);</span><br><span class="line">        <span class="keyword">if</span>(iSendCnt &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">		addr.s_addr = pstOffLoad-&gt;dip;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;udp_out ---&gt; src: %s:%d \n&quot;</span>, inet_ntoa(addr), ntohs(pstOffLoad-&gt;dport));</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *dstmac = ng_get_dst_macaddr(pstOffLoad-&gt;dip); <span class="comment">// 查询对端mac地址</span></span><br><span class="line">		<span class="keyword">if</span> (dstmac == <span class="literal">NULL</span>)  <span class="comment">// 先广播发个arp包确定对端mac地址</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstArpbuf</span> =</span> ng_send_arp(pstMbufPool, RTE_ARP_OP_REQUEST, g_aucDefaultArpMac,</span><br><span class="line">				pstOffLoad-&gt;sip, pstOffLoad-&gt;dip);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue_burst(g_pstRingIns-&gt;pstOutRing, (<span class="type">void</span> **)&amp;pstArpbuf, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue(pstHost-&gt;sndbuf, pstOffLoad); <span class="comment">// 将取出的udp数据再次写入队列</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">struct</span> rte_mbuf *pstUdpbuf = ng_udp_pkt(pstMbufPool, pstOffLoad-&gt;sip, pstOffLoad-&gt;dip,</span><br><span class="line">                    pstOffLoad-&gt;sport, pstOffLoad-&gt;dport, pstHost-&gt;localmac,</span><br><span class="line">                    dstmac, pstOffLoad-&gt;data, pstOffLoad-&gt;length);</span><br><span class="line"></span><br><span class="line">			rte_ring_mp_enqueue_burst(g_pstRingIns-&gt;pstOutRing, (<span class="type">void</span> **)&amp;pstUdpbuf, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pstOffLoad-&gt;data != <span class="literal">NULL</span>)</span><br><span class="line">				rte_free(pstOffLoad-&gt;data);</span><br><span class="line"></span><br><span class="line">			rte_free(pstOffLoad);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>机制和 TCP 类似。</p>
<p>3、上层应用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//netfamily.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> g_aucDefaultArpMac[RTE_ETHER_ADDR_LEN] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> g_ucFdTable[D_MAX_FD_COUNT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> St_InOut_Ring *<span class="title function_">ringInstance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_pstRingIns == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		g_pstRingIns = rte_malloc(<span class="string">&quot;in/out ring&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> St_InOut_Ring), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memset</span>(g_pstRingIns, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> St_InOut_Ring));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g_pstRingIns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ng_init_port</span><span class="params">(<span class="keyword">struct</span> rte_mempool *pstMbufPoolPub)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiPortsNum;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iRxQueueNum = <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> iTxQueueNum = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">stDevInfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">stTxConf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">stPortConf</span> =</span>    <span class="comment">// 端口配置信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        .rxmode = &#123;.max_rx_pkt_len = <span class="number">1518</span> &#125;   <span class="comment">// RTE_ETHER_MAX_LEN = 1518</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    uiPortsNum = rte_eth_dev_count_avail();</span><br><span class="line">	<span class="keyword">if</span> (uiPortsNum == <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;No Supported eth found\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	rte_eth_dev_info_get(D_PORT_ID, &amp;stDevInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置以太网设备</span></span><br><span class="line">	rte_eth_dev_configure(D_PORT_ID, iRxQueueNum, iTxQueueNum, &amp;stPortConf);</span><br><span class="line"></span><br><span class="line">    iRet = rte_eth_rx_queue_setup(D_PORT_ID, <span class="number">0</span> , <span class="number">1024</span>, rte_eth_dev_socket_id(D_PORT_ID), <span class="literal">NULL</span>, pstMbufPoolPub);</span><br><span class="line">	<span class="keyword">if</span>(iRet &lt; <span class="number">0</span>)</span><br><span class="line">	    rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup RX queue!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	stTxConf = stDevInfo.default_txconf;</span><br><span class="line">	stTxConf.offloads = stPortConf.txmode.offloads;</span><br><span class="line">    iRet = rte_eth_tx_queue_setup(D_PORT_ID, <span class="number">0</span> , <span class="number">1024</span>, rte_eth_dev_socket_id(D_PORT_ID), &amp;stTxConf);</span><br><span class="line">	<span class="keyword">if</span> (iRet &lt; <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup TX queue\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_eth_dev_start(D_PORT_ID) &lt; <span class="number">0</span> )</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rte_eth_promiscuous_enable(D_PORT_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ng_config_network_if</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">unsigned</span> <span class="type">char</span> if_up)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!rte_eth_dev_is_valid_port(port_id)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (if_up) &#123;</span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line">		ret = rte_eth_dev_start(port_id);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rte_eth_dev_stop(port_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to start port : %d\n&quot;</span>, port_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rte_kni *<span class="title function_">ng_alloc_kni</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mbuf_pool)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni</span> *<span class="title">kni_hanlder</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni_conf</span> <span class="title">conf</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;conf, <span class="number">0</span>, <span class="keyword">sizeof</span>(conf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(conf.name, RTE_KNI_NAMESIZE, <span class="string">&quot;vEth%u&quot;</span>, D_PORT_ID);</span><br><span class="line">	conf.group_id = D_PORT_ID;</span><br><span class="line">	conf.mbuf_size = D_MAX_PACKET_SIZE;</span><br><span class="line">	rte_eth_macaddr_get(D_PORT_ID, (<span class="keyword">struct</span> rte_ether_addr *)conf.mac_addr);</span><br><span class="line">	rte_eth_dev_get_mtu(D_PORT_ID, &amp;conf.mtu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print_ethaddr(&quot;ng_alloc_kni: &quot;, (struct ether_addr *)conf.mac_addr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct rte_eth_dev_info dev_info;</span></span><br><span class="line"><span class="comment">	memset(&amp;dev_info, 0, sizeof(dev_info));</span></span><br><span class="line"><span class="comment">	rte_eth_dev_info_get(D_PORT_ID, &amp;dev_info);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_kni_ops</span> <span class="title">ops</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ops, <span class="number">0</span>, <span class="keyword">sizeof</span>(ops));</span><br><span class="line"></span><br><span class="line">	ops.port_id = D_PORT_ID;</span><br><span class="line">	ops.config_network_if = ng_config_network_if;</span><br><span class="line"></span><br><span class="line">	kni_hanlder = rte_kni_alloc(mbuf_pool, &amp;conf, &amp;ops);</span><br><span class="line">	<span class="keyword">if</span> (!kni_hanlder) &#123;</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Failed to create kni for port : %d\n&quot;</span>, D_PORT_ID);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kni_hanlder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pkt_process</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pstMbufPool</span>;</span></span><br><span class="line">    <span class="type">int</span> iRxNum;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_hdr</span> *<span class="title">pstEthHdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span> *<span class="title">pstIpHdr</span>;</span></span><br><span class="line"></span><br><span class="line">    pstMbufPool = (<span class="keyword">struct</span> rte_mempool *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstMbuf</span>[32];</span></span><br><span class="line">        iRxNum = rte_ring_mc_dequeue_burst(g_pstRingIns-&gt;pstInRing, (<span class="type">void</span>**)pstMbuf, D_BURST_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRxNum &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; iRxNum; ++i) &#123;</span><br><span class="line">            pstEthHdr = rte_pktmbuf_mtod_offset(pstMbuf[i], <span class="keyword">struct</span> rte_ether_hdr *, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (pstEthHdr-&gt;ether_type == rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4)) &#123;  <span class="comment">//IPv4: 0800</span></span><br><span class="line">                pstIpHdr = rte_pktmbuf_mtod_offset(pstMbuf[i], <span class="keyword">struct</span> rte_ipv4_hdr *, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 维护一个arp表</span></span><br><span class="line">				ng_arp_entry_insert(pstIpHdr-&gt;src_addr, pstEthHdr-&gt;s_addr.addr_bytes);</span><br><span class="line">                <span class="keyword">if</span>(pstIpHdr-&gt;next_proto_id == IPPROTO_UDP) &#123; <span class="comment">// udp</span></span><br><span class="line">                    <span class="comment">// udp process</span></span><br><span class="line">                    udp_process(pstMbuf[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstIpHdr-&gt;next_proto_id == IPPROTO_TCP) &#123; <span class="comment">// tcp</span></span><br><span class="line">                    <span class="comment">// printf(&quot;tcp_process ---\n&quot;);</span></span><br><span class="line">					tcp_process(pstMbuf[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					rte_kni_tx_burst(g_pstKni, pstMbuf, iRxNum);</span><br><span class="line">					<span class="comment">// printf(&quot;tcp/udp --&gt; rte_kni_handle_request\n&quot;);</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// ifconfig vEth0 192.168.181.169 up</span></span><br><span class="line">				rte_kni_tx_burst(g_pstKni, pstMbuf, iRxNum);</span><br><span class="line">				<span class="comment">// printf(&quot;ip --&gt; rte_kni_handle_request\n&quot;);</span></span><br><span class="line">			&#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		rte_kni_handle_request(g_pstKni);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to send</span></span><br><span class="line">        udp_out(pstMbufPool);</span><br><span class="line">        tcp_out(pstMbufPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_server_entry</span><span class="params">(__attribute__((unused))  <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;           </span><br><span class="line">    <span class="type">int</span> iConnfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">stLocalAddr</span>, <span class="title">stClientAddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> uiAddrLen = <span class="keyword">sizeof</span>(stClientAddr);;</span><br><span class="line">	<span class="type">char</span> acBuf[D_UDP_BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	iConnfd = nsocket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (iConnfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;nsocket failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;stLocalAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line"></span><br><span class="line">	stLocalAddr.sin_port = htons(<span class="number">8889</span>);</span><br><span class="line">	stLocalAddr.sin_family = AF_INET;</span><br><span class="line">	stLocalAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.181.169&quot;</span>);</span><br><span class="line"></span><br><span class="line">	nbind(iConnfd, (<span class="keyword">struct</span> sockaddr*)&amp;stLocalAddr, <span class="keyword">sizeof</span>(stLocalAddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nrecvfrom(iConnfd, acBuf, D_UDP_BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">			(<span class="keyword">struct</span> sockaddr*)&amp;stClientAddr, &amp;uiAddrLen) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;recv from %s:%d, data:%s\n&quot;</span>, inet_ntoa(stClientAddr.sin_addr),</span><br><span class="line">				ntohs(stClientAddr.sin_port), acBuf);</span><br><span class="line">			nsendto(iConnfd, acBuf, <span class="built_in">strlen</span>(acBuf), <span class="number">0</span>,</span><br><span class="line">				(<span class="keyword">struct</span> sockaddr*)&amp;stClientAddr, <span class="keyword">sizeof</span>(stClientAddr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nclose(iConnfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pstMbufPoolPub</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">St_InOut_Ring</span> *<span class="title">pstRing</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstRecvMbuf</span>[32] =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pstSendMbuf</span>[32] =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iRxNum;</span><br><span class="line">    <span class="type">int</span> iTotalNum;</span><br><span class="line">    <span class="type">int</span> iOffset;</span><br><span class="line">    <span class="type">int</span> iTxNum;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiCoreId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rte_eal_init(argc, argv) &lt; <span class="number">0</span>)</span><br><span class="line">	    rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pstMbufPoolPub = rte_pktmbuf_pool_create(<span class="string">&quot;MBUF_POOL_PUB&quot;</span>, D_NUM_MBUFS, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line">	<span class="keyword">if</span>(pstMbufPoolPub == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;rte_errno = %x, errmsg = %s\n&quot;</span>, rte_errno, rte_strerror(rte_errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rte_kni_init(D_PORT_ID))</span><br><span class="line">        rte_exit(EXIT_FAILURE, <span class="string">&quot;kni init failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ng_init_port(pstMbufPoolPub);</span><br><span class="line">	g_pstKni = ng_alloc_kni(pstMbufPoolPub);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ng_init_port(pstMbufPoolPub);</span></span><br><span class="line">    rte_eth_macaddr_get(D_PORT_ID, &amp;g_stCpuMac);</span><br><span class="line"></span><br><span class="line">    pstRing = ringInstance();</span><br><span class="line">	<span class="keyword">if</span>(pstRing == <span class="literal">NULL</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;ring buffer init failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pstRing-&gt;pstInRing = rte_ring_create(<span class="string">&quot;in ring&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line">    pstRing-&gt;pstOutRing = rte_ring_create(<span class="string">&quot;out ring&quot;</span>, D_RING_SIZE, rte_socket_id(), RING_F_SP_ENQ | RING_F_SC_DEQ);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_lcore_id();</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	rte_eal_remote_launch(pkt_process, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	rte_eal_remote_launch(udp_server_entry, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    uiCoreId = rte_get_next_lcore(uiCoreId, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rte_eal_remote_launch(tcp_server_entry, pstMbufPoolPub, uiCoreId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// rx</span></span><br><span class="line">        iRxNum = rte_eth_rx_burst(D_PORT_ID, <span class="number">0</span>, pstRecvMbuf, D_BURST_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(iRxNum &gt; <span class="number">0</span>)</span><br><span class="line">            rte_ring_sp_enqueue_burst(pstRing-&gt;pstInRing, (<span class="type">void</span>**)pstRecvMbuf, iRxNum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tx</span></span><br><span class="line">        iTotalNum = rte_ring_sc_dequeue_burst(pstRing-&gt;pstOutRing, (<span class="type">void</span>**)pstSendMbuf, D_BURST_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(iTotalNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			iOffset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(iOffset &lt; iTotalNum) &#123;</span><br><span class="line">				iTxNum = rte_eth_tx_burst(D_PORT_ID, <span class="number">0</span>, &amp;pstSendMbuf[iOffset], iTotalNum - iOffset);</span><br><span class="line">				<span class="keyword">if</span>(iTxNum &gt; <span class="number">0</span>)</span><br><span class="line">					iOffset += iTxNum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2024/07/31/sdn/dpdk/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2024/07/31/sdn/dpdk/')">远辰</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2024/07/31/sdn/dpdk/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=远辰&amp;url=https://shippomx.github.io/2024/07/31/sdn/dpdk/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-number">1.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">框架主要结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">源码目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hello-world%E4%BE%8B%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">hello world例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95%E5%92%8C-DPDK"><span class="toc-number">2.4.</span> <span class="toc-text">网络发展和 DPDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">技术分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIO-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">UIO 机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">DPDK 的并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">多线程模型及源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">例程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">虚拟化的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91"><span class="toc-number">4.1.1.</span> <span class="toc-text">虚拟化的应用方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DPDK-%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">DPDK 和虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#virtio"><span class="toc-number">4.2.1.</span> <span class="toc-text">virtio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vhost"><span class="toc-number">4.2.2.</span> <span class="toc-text">vhost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtio-%E7%9A%84%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">virtio 的框架流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DPDK-%E7%9A%84-virtio-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">DPDK 的 virtio 的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#virio-net"><span class="toc-number">5.</span> <span class="toc-text">virio-net</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1"><span class="toc-number">5.0.1.</span> <span class="toc-text">前后端的数据通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtio%E5%92%8C-vhost-%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">5.0.2.</span> <span class="toc-text">virtio和 vhost 的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.3.</span> <span class="toc-text">基础数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCI-%E8%AE%BE%E5%A4%87%E7%AE%80%E4%BB%8B"><span class="toc-number">5.0.4.</span> <span class="toc-text">PCI 设备简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCI-%E8%AE%BE%E5%A4%87%E5%8F%91%E7%8E%B0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.0.5.</span> <span class="toc-text">PCI 设备发现基本流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vring%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">vring基础数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vring%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">6.0.1.</span> <span class="toc-text">vring主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.0.2.</span> <span class="toc-text">基本流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E7%BD%91%E5%8D%A1%E6%8A%BD%E8%B1%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">DPDK 网卡抽象实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.0.1.</span> <span class="toc-text">基本数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B-1"><span class="toc-number">7.0.2.</span> <span class="toc-text">基本流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vhost-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">vhost 的基础数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.0.1.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vhost-user"><span class="toc-number">9.</span> <span class="toc-text">vhost-user</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.0.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">9.0.2.</span> <span class="toc-text">通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#virtio-1"><span class="toc-number">10.</span> <span class="toc-text">virtio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E9%A9%B1%E5%8A%A8"><span class="toc-number">10.0.1.</span> <span class="toc-text">用户态驱动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DPDK-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.</span> <span class="toc-text">DPDK 中实现机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NFV"><span class="toc-number">11.</span> <span class="toc-text">NFV</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">12.</span> <span class="toc-text">DPDK 中的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DPDK-%E7%9A%84%E6%95%B4%E4%BD%93%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">12.0.1.</span> <span class="toc-text">DPDK 的整体内存层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C-API"><span class="toc-number">12.0.2.</span> <span class="toc-text">相关的数据结构和 API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOVA"><span class="toc-number">13.</span> <span class="toc-text">IOVA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81"><span class="toc-number">13.0.1.</span> <span class="toc-text">数据结构和源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%85"><span class="toc-number">14.</span> <span class="toc-text">网络传输中的分包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">14.0.1.</span> <span class="toc-text">内存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">14.0.2.</span> <span class="toc-text">网络中的控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">15.</span> <span class="toc-text">DPDK 中的内存池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E4%B8%AD%E7%9A%84-Cache-%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">DPDK 中的 Cache 处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DIDO"><span class="toc-number">17.</span> <span class="toc-text">DIDO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DIDO-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">17.0.1.</span> <span class="toc-text">DIDO 的流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="toc-number">18.</span> <span class="toc-text">DPDK 启动分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">18.0.1.</span> <span class="toc-text">分配初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E4%B8%AD%E7%9A%84%E5%A4%A7%E9%A1%B5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">DPDK 中的大页内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">20.</span> <span class="toc-text">环形队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK%E5%B9%B6%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">21.</span> <span class="toc-text">DPDK并行机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BC%B9%E6%80%A7%E6%89%A9%E5%B1%95"><span class="toc-number">22.</span> <span class="toc-text">DPDK 中并行机制及弹性扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SIMD"><span class="toc-number">23.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">24.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">24.0.1.</span> <span class="toc-text">并行和并发中的同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPDK-%E5%AF%B9%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">25.</span> <span class="toc-text">DPDK 对网络数据的处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86"><span class="toc-number">26.</span> <span class="toc-text">网络报文处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">26.1.</span> <span class="toc-text">转发应用框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipleline-%E6%A8%A1%E5%9E%8B%EF%BC%88Packet-Framework%EF%BC%89"><span class="toc-number">26.1.1.</span> <span class="toc-text">Pipleline 模型（Packet Framework）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-to-completion-%E6%A8%A1%E5%9E%8B%EF%BC%88RTC%EF%BC%89"><span class="toc-number">26.1.2.</span> <span class="toc-text">run to completion 模型（RTC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">26.1.3.</span> <span class="toc-text">相关算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E5%88%86%E5%8F%91"><span class="toc-number">26.1.4.</span> <span class="toc-text">报文分发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PCIe-%E6%80%BB%E7%BA%BF%E5%92%8C-DMA-%E5%8F%8A%E7%BC%93%E5%AD%98"><span class="toc-number">27.</span> <span class="toc-text">PCIe 总线和 DMA 及缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">27.0.1.</span> <span class="toc-text">数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91"><span class="toc-number">27.0.2.</span> <span class="toc-text">数据转发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">28.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%8D%A1%E4%BC%98%E5%8C%96"><span class="toc-number">28.0.1.</span> <span class="toc-text">网卡优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B1%82%E9%9D%A2"><span class="toc-number">28.0.2.</span> <span class="toc-text">软件层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E4%BC%98%E5%8C%96"><span class="toc-number">28.0.3.</span> <span class="toc-text">IO 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="toc-number">28.0.4.</span> <span class="toc-text">平台及配置优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E9%80%82%E9%85%8D"><span class="toc-number">28.0.5.</span> <span class="toc-text">相关设置适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">28.0.6.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF"><span class="toc-number">29.</span> <span class="toc-text">多队列技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">29.1.</span> <span class="toc-text">流分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="toc-number">30.</span> <span class="toc-text">硬件加速</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">30.0.1.</span> <span class="toc-text">三、源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">31.</span> <span class="toc-text">数据包流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">31.0.1.</span> <span class="toc-text">三、源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">32.</span> <span class="toc-text">接收数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">32.0.1.</span> <span class="toc-text">二、发送数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="toc-number">32.0.2.</span> <span class="toc-text">三、源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">33.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP-%E7%BC%96%E7%A8%8B"><span class="toc-number">34.</span> <span class="toc-text">UDP 编程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E4%BB%8E%E7%A1%AC%E4%BB%B6%E7%9C%8B%E4%B8%AD%E6%96%AD%E4%B9%8B%20APIC%EF%BC%88%E4%B8%89%E4%B8%87%EF%BC%89-CSDN%20%E5%8D%9A%E5%AE%A2/" title="无题">无题</a><time datetime="2024-08-13T07:48:29.025Z" title="发表于 2024-08-13 15:48:29">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/linux/%E5%86%85%E5%AD%98/%E9%A1%B5%E8%A1%A8/" title="无题">无题</a><time datetime="2024-08-13T06:57:36.023Z" title="发表于 2024-08-13 14:57:36">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20%5B%E4%B8%80%5D%20-%20%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/" title="无题">无题</a><time datetime="2024-08-13T06:50:07.571Z" title="发表于 2024-08-13 14:50:07">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="无题">无题</a><time datetime="2024-08-12T03:18:47.311Z" title="发表于 2024-08-12 11:18:47">2024-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/sdn/dpdk/" title="无题">无题</a><time datetime="2024-07-31T11:36:18.019Z" title="发表于 2024-07-31 19:36:18">2024-07-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 0.88rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 0.88rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 0.88rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 0.88rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 0.88rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>