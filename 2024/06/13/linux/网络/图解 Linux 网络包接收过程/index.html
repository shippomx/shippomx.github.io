<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>远辰 | 远辰</title><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="远辰"><meta name="application-name" content="远辰"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="远辰"><meta property="og:url" content="https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="转自：   张彦飞 allen（开发内功修炼）  因为要对百万、千万、甚至是过亿的用户提供各种网络服务，所以在一线互联网企业里面试和晋升后端开发同学的其中一个重点要求就是要能支撑高并发，要理解性能开销，会进行性能优化。而很多时候，如果你对 Linux 底层的理解不深的话，遇到很多线上性能瓶颈你会觉"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="转自：   张彦飞 allen（开发内功修炼）  因为要对百万、千万、甚至是过亿的用户提供各种网络服务，所以在一线互联网企业里面试和晋升后端开发同学的其中一个重点要求就是要能支撑高并发，要理解性能开销，会进行性能优化。而很多时候，如果你对 Linux 底层的理解不深的话，遇到很多线上性能瓶颈你会觉"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: '远辰',
  postAI: '',
  pageFillDescription: '2.1 创建 ksoftirqd 内核线程, 2.2 网络子系统初始化, 2.3 协议栈注册, 2.4 网卡驱动初始化, 2.5 启动网卡, 3.1 硬中断处理, 3.2 ksoftirqd 内核线程处理软中断, 3.3 网络协议栈处理, 3.4 IP 协议层处理, 3.5 UDP 协议层处理转自张彦飞开发内功修炼因为要对百万千万甚至是过亿的用户提供各种网络服务所以在一线互联网企业里面试和晋升后端开发同学的其中一个重点要求就是要能支撑高并发要理解性能开销会进行性能优化而很多时候如果你对底层的理解不深的话遇到很多线上性能瓶颈你会觉得狗拿刺猬无从下手我们今天用图解的方式来深度理解一下在下网络包的接收过程还是按照惯例来借用一段最简单的代码开始思考为了简单起见我们用来举例如下上面代码是一段接收收据的逻辑当在开发视角看的时候只要客户端有对应的数据发送过来服务器端执行后就能收到它并把它打印出来我们现在想知道的是当网络包达到网卡直到我们的收到数据这中间究竟都发生过什么通过本文你将深入理解网络系统内部是如何实现的以及各个部分之间如何交互相信这对你的工作将会有非常大的帮助本文基于源代码参见网卡驱动采用的网卡举例友情提示本文略长可以先后看一网络收包总览在网络分层模型里整个协议栈被分成了物理层链路层网络层传输层和应用层物理层对应的是网卡和网线应用层对应的是我们常见的等等各种应用实现的是链路层网络层和传输层这三层在内核实现中链路层协议靠网卡驱动来实现内核协议栈来实现网络层和传输层内核对更上层的应用层提供接口来供用户进程访问我们用的视角来看到的网络分层模型应该是下面这个样子的图视角的网络协议栈在的源代码中网络设备驱动对应的逻辑位于其中系列网卡的驱动在目录下协议栈模块代码位于和目录内核和网络设备驱动是通过中断的方式来处理的当设备上有数据到达的时候会给的相关引脚上触发一个电压变化以通知来处理数据对于网络模块来说由于处理过程比较复杂和耗时如果在中断函数中完成所有的处理将会导致中断处理函数优先级过高将过度占据将导致无法响应其它设备例如鼠标和键盘的消息因此中断处理函数是分上半部和下半部的上半部是只进行最简单的工作快速处理然后释放接着就可以允许其它中断进来剩下将绝大部分的工作都放到下半部中可以慢慢从容处理以后的内核版本采用的下半部实现方式是软中断由内核线程全权处理和硬中断不同的是硬中断是通过给物理引脚施加电压变化而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序好了大概了解了网卡驱动硬中断软中断和线程之后我们在这几个概念的基础上给出一个内核收包的路径示意图内核网络收包总览当网卡上收到数据以后中第一个工作的模块是网络驱动网络驱动会以的方式把网卡上收到的帧写到内存里再向发起一个中断以通知有数据到达第二当收到中断请求后会去调用网络驱动注册的中断处理函数网卡的中断处理函数并不做过多工作发出软中断请求然后尽快释放检测到有软中断请求到达调用开始轮询收包收到后交由各级协议栈处理对于包来说会被放到用户的接收队列中我们从上面这张图中已经从整体上把握到了对数据包的处理过程但是要想了解更多网络模块工作的细节我们还得往下看二启动驱动内核协议栈等等模块在具备接收网卡数据包之前要做很多的准备工作才行比如要提前创建好内核线程要注册好各个协议对应的处理函数网络设备子系统要提前初始化好网卡要启动好只有这些都之后我们才能真正开始接收数据包那么我们现在来看看这些准备工作都是怎么做的创建内核线程的软中断都是在专门的内核线程中进行的因此我们非常有必要看一下这些进程是怎么初始化的这样我们才能在后面更准确地了解收包过程该进程数量不是个而是个其中等于你的机器的核数系统初始化的时候在中调用了该函数进一步会执行到位于来创建出进程图创建内核线程相关代码如下当被创建出来以后它就会进入自己的线程循环函数和了不停地判断有没有软中断需要被处理这里需要注意的一点是软中断不仅仅只有网络软中断还有其它类型网络子系统初始化图网络子系统初始化内核通过调用来初始化各个子系统在源代码目录里你可以出许多对这个函数的调用这里我们要说的是网络子系统的初始化会执行到函数在这个函数里会为每个都申请一个数据结构在这个数据结构里的是等待驱动程序将其函数注册进来稍后网卡驱动初始化的时候我们可以看到这一过程另外注册了每一种软中断都注册一个处理函数的处理函数为的为继续跟踪后发现这个注册的方式是记录在变量里的后面线程收到软中断的时候也会使用这个变量来找到每一种软中断对应的处理函数协议栈注册内核实现了网络层的协议也实现了传输层的协议和协议这些协议对应的实现函数分别是和和我们平时写代码的方式不一样的是内核是通过注册的方式来实现的内核中的和类似也是初始化模块的入口调用后开始网络协议栈注册通过将这些函数注册到了和数据结构中了如下图图协议栈注册相关代码如下上面的代码中我们可以看到结构体中的是结构体中的是通过被初始化了进来函数将和对应的处理函数都注册到了数组中了再看这一行结构体中的是协议名是函数在中会被注册到哈希表中这里我们需要记住记录着的处理函数地址存储着函数的处理地址后面我们会看到软中断中会通过找到函数地址进而将包正确地送到中执行在中将会通过找到或者的处理函数再而把包转发给或函数扩展一下如果看一下和等函数的代码能看到很多协议的处理过程例如中会处理和过滤如果你有很多或者很复杂的或规则这些规则都是在软中断的上下文中执行的会加大网络延迟再例如中会判断接收队列是否满了对应的相关内核参数是和如果有兴趣建议大家好好读一下这个函数的代码网卡驱动初始化每一个驱动程序不仅仅只是网卡驱动会使用向内核注册一个初始化函数当驱动被加载时内核会调用这个函数比如网卡驱动的代码位于驱动的调用完成后内核就知道了该驱动的相关信息比如网卡驱动的和函数地址等等当网卡设备被识别以后内核会调用其驱动的方法的方法是驱动方法执行的目的就是让设备对于网卡其位于下主要执行的操作如下图网卡驱动初始化第步中我们看到网卡驱动实现了所需要的接口也在这里注册完成函数地址的注册当发起一个系统调用之后内核会找到对应操作的回调函数对于网卡来说其实现函数都在下相信你这次能彻底理解的工作原理了吧这个命令之所以能查看网卡收发包统计能修改网卡自适应模式能调整队列的数量和大小是因为命令最终调用到了网卡驱动的相应方法而不是本身有这个超能力第步注册的中包含的是等函数该函数在网卡被启动的时候会被调用第步中在初始化过程中还调用到了他注册了一个机制所必须的函数对于网卡驱动来说这个函数就是如下代码所示启动网卡当上面的初始化都完成以后就可以启动网卡了回忆前面网卡驱动初始化时我们提到了驱动向内核注册了变量它包含着网卡启用发包设置地址等回调函数函数指针当启用一个网卡时例如通过中的方法会被调用它通常会做以下事情图启动网卡注册中断处理函数启用在上面函数调用了和在这一步操作中分配了并建立内存和队列的映射关系队列的数量和大小可以通过进行配置我们再接着看中断函数注册在上面的代码中跟踪函数调用在中我们看到了对于多队列的网卡为每一个队列都注册了中断其对应的中断处理函数是该函数也在下我们也可以看到方式下每个队列有独立的中断从网卡硬件中断的层面就可以设置让收到的包被不同的处理可以通过或者修改能够修改和的绑定行为当做好以上准备工作以后就可以开门迎客数据包了三迎接数据的到来硬中断处理首先当数据帧从网线到达网卡上的时候第一站是网卡的接收队列网卡在分配给自己的中寻找可用的内存位置找到后引擎会把数据到网卡之前关联的内存里这个时候都是无感的当操作完成以后网卡会像发起一个硬中断通知有数据到达图网卡数据硬中断处理过程注意当满的时候新来的数据包将给丢弃查看网卡的时候可以里面有个表示因为环形队列满被丢弃的包如果发现有丢包可能需要通过命令来加大环形队列的长度在启动网卡一节我们说到了网卡的硬中断注册的处理函数是只是记录一下硬件中断频率据说目的是在减少对的中断频率时用到顺着调用一路跟踪下去这里我们看到修改了变量里的将驱动传过来的添加了进来其中中的是一个双向列表其中的设备都带有输入帧等着被处理紧接着触发了一个软中断这个所谓的触发过程只是对一个变量进行了一次或运算而已我们说过在硬中断里只完成简单必要的工作剩下的大部分的处理都是转交给软中断的通过上面代码可以看到硬中断处理过程真的是非常短只是记录了一个寄存器修改了一下下的然后发出个软中断就这么简单硬中断工作就算是完成了内核线程处理软中断图内核线程内核线程初始化的时候我们介绍了中两个线程函数和其中代码如下这里看到和硬中断中调用了同一个函数使用方式不同的是硬中断位置是为了写入标记这里仅仅只是读取如果硬中断中设置了这里自然能读取的到接下来会真正进入线程函数中处理在中判断根据当前的软中断类型调用其注册的方法在网络子系统初始化小节我们看到我们为注册了处理函数所以函数就会被执行到了这里需要注意一个细节硬中断中设置软中断标记和的判断是否有软中断到达都是基于的这意味着只要硬中断在哪个上被响应那么软中断也是在这个上处理的所以说如果你发现你的软中断消耗都集中在一个核上的话做法是要把调整硬中断的亲和性来将硬中断打散到不同的核上去我们再来把精力集中到这个核心函数上来函数开头的和是用来控制函数主动退出的目的是保证网络包的接收不霸占不放等下次网卡再有硬中断过来的时候再处理剩下的接收数据包其中可以通过内核参数调整这个函数中剩下的核心逻辑是获取到当前变量对其进行遍历然后执行到网卡驱动注册到的函数对于网卡来说就是驱动力的函数了在读取操作中的重点工作是对的调用和的作用就是把数据帧从上取下来为什么需要两个函数呢因为有可能帧要占多多个所以是在一个循环中获取的直到帧尾部获取下来的一个数据帧用一个来表示收取完数据以后对其进行一些校验然后开始设置变量的等字段接下来进入到中这个函数代表的是网卡特性可以简单理解成把相关的小包合并成一个大包就行目的是减少传送给网络栈的包数这有助于减少的使用量我们暂且忽略直接看这个函数主要就是调用了在中数据包将被送到协议栈中声明以下的也都属于软中断的处理过程只不过由于篇幅太长单独拿出来成小节网络协议栈处理函数会根据包的协议假如是包会将包依次送到协议处理函数中进行处理图网络协议栈处理处理逻辑先忽略逻辑这里会将数据送入抓包点就是从这个入口获取包的在中我看着原来经常使用的的抓包点很是激动看来读一遍源代码时间真的没白浪费接着取出它会从数据包中取出协议信息然后遍历注册在这个协议上的回调函数列表是一个在协议注册小节我们提到过函数地址就是存在这个中的这一行就调用到了协议层注册的处理函数了对于包来讲就会进入到如果是包的话会进入到协议层处理我们再来大致看一下在协议层都做了什么包又是怎么样进一步被送到或协议处理函数中的这里是一个钩子函数当执行完注册的钩子后就会执行到最后一个参数指向的函数跟踪后看到它又调用了在中函数被赋值给了如下所以回到中的调用的方法就是路由子系统赋的如协议注册小节看到中保存着和的函数地址这里将会根据包中的协议类型选择进行分发在这里包将会进一步被派送到更上层的协议中和协议层处理在协议注册小节的时候我们说过协议的处理函数是是根据来寻找对应的当找到以后将数据包放到的缓存队列里如果没有找到则发送一个目标不可达的包判断的是用户是不是正在这个上进行系统调用被占用如果没有那就可以直接放到的接收队列中如果有那就通过把数据包添加到队列当用户释放的的时候内核会检查队列如果有数据再移动到接收队列中接收队列如果满了的话将直接把包丢弃接收队列大小受内核参数和影响四系统调用花开两朵各表一枝上面我们说完了整个内核对数据包的接收和处理过程最后把数据包放到的接收队列中了那么我们再回头看用户进程调用后是发生了什么我们在代码里调用的是一个的库函数该函数在执行后会将用户进行陷入到内核态进入到实现的系统调用在理解对之前我们先来简单看一下这个核心数据结构这个数据结构太大了我们只把对和我们今天主题相关的内容画出来如下图内核数据机构数据结构中的对应的是协议的方法集合每个协议都会实现不同的方法集对于协议族来说每种协议都有对应的处理方法如下对于来说是通过来定义的其中注册了方法数据结构中的另一个数据结构是一个非常大非常重要的子结构体其中的又定义了二级处理函数对于协议来说会被设置成协议实现的方法集看完了变量之后我们再来看的实现过程图函数内部实现过程在调用了上面我们说过这个对于协议的来说这个就是下的由此我们找到了方法终于我们找到了我们想要看的重点在上面我们看到了所谓的读取过程就是访问如果没有数据且用户也允许等待则将调用执行等待操作它加入会让用户进程进入睡眠状态五总结网络模块是内核中最复杂的模块了看起来一个简简单单的收包过程就涉及到许多内核组件之间的交互如网卡驱动协议栈内核线程等看起来很复杂本文想通过图示的方式尽量以容易理解的方式来将内核收包过程讲清楚现在让我们再串一串整个收包过程当用户执行完调用后用户进程就通过系统调用进行到内核态工作了如果接收队列没有数据进程就进入睡眠状态被操作系统挂起这块相对比较简单剩下大部分的戏份都是由内核其它模块来表演了首先在开始收包之前要做许多的准备工作创建线程为它设置好它自己的线程函数后面指望着它来处理软中断协议栈注册要实现许多协议比如每一个协议都会将自己的处理函数注册一下方便包来了迅速找到对应的处理函数网卡驱动初始化每个驱动都有一个初始化函数内核会让驱动也初始化一下在这个初始化过程中把自己的准备好把的函数地址告诉内核启动网卡分配队列注册中断对应的处理函数以上是内核准备收包之前的重要工作当上面都之后就可以打开硬中断等待数据包的到来了当数据到来了以后第一个迎接它的是网卡我去这不是废话么网卡将数据帧到内存的中然后向发起中断通知响应中断请求调用网卡启动时注册的中断处理函数中断处理函数几乎没干啥就发起了软中断请求内核线程线程发现有软中断请求到来先关闭硬中断线程开始调用驱动的函数收包函数将收到的包送到协议栈注册的函数中函数再讲包送到函数中对于包就送到现在我们可以回到开篇的问题了我们在用户层看到的简单一行内核要替我们做如此之多的工作才能让我们顺利收到数据这还是简简单单的如果是内核要做的工作更多不由得感叹内核的开发者们真的是用心良苦理解了整个收包过程以后我们就能明确知道收一个包的开销了首先第一块是用户进程调用系统调用陷入内核态的开销第二块是响应包的硬中断的开销第三块是内核线程的软中断上下文花费的后面我们再专门发一篇文章实际观察一下这些开销另外网络收发中有很多末支细节咱们并没有展开了说比如说等因为我觉得说的太对了反而会影响大家对整个流程的把握所以尽量只保留主框架了少即是多',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-14 16:29:16',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 1.05rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 1.05rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 1.05rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 1.05rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 1.05rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-06-13T09:36:26.460Z" title="发表于 2024-06-13 17:36:26">2024-06-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-06-14T08:29:16.634Z" title="更新于 2024-06-14 16:29:16">2024-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2024-06-13T09:36:26.460Z" title="发表于 2024-06-13 17:36:26">2024-06-13</time><time itemprop="dateCreated datePublished" datetime="2024-06-14T08:29:16.634Z" title="更新于 2024-06-14 16:29:16">2024-06-14</time></header><blockquote>
<p>转自：   张彦飞 allen（开发内功修炼）</p>
</blockquote>
<p>因为要对百万、千万、甚至是过亿的用户提供各种网络服务，所以在一线互联网企业里面试和晋升后端开发同学的其中一个重点要求就是要能支撑高并发，要理解性能开销，会进行性能优化。而很多时候，如果你对 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a> 底层的理解不深的话，遇到很多线上性能瓶颈你会觉得狗拿刺猬，无从下手。</p>
<p>我们今天用图解的方式，来深度理解一下在 Linux 下网络包的接收过程。还是按照惯例来借用一段最简单的代码开始思考。为了简单起见，我们用 udp 来举例，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> serverSocketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    bind(serverSocketFd, ...);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buff[BUFFSIZE];</span><br><span class="line">    <span class="type">int</span> readCount = recvfrom(serverSocketFd, buff, BUFFSIZE, <span class="number">0</span>, ...);</span><br><span class="line">    buff[readCount] = <span class="string">&#x27;\0&#x27;</span>;    <span class="built_in">printf</span>(<span class="string">&quot;Receive from client:%s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是一段 udp server 接收收据的逻辑。当在开发视角看的时候，只要客户端有对应的数据发送过来，服务器端执行<code>recv_from</code>后就能收到它，并把它打印出来。我们现在想知道的是，当网络包达到网卡，直到我们的<code>recvfrom</code>收到数据，这中间，究竟都发生过什么？</p>
<p>通过本文，你将深入理解 Linux 网络系统内部是如何实现的，以及各个部分之间如何交互。相信这对你的工作将会有非常大的帮助。本文基于 Linux 3.10，源代码参见 <a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/v3.x/%EF%BC%8C%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%87%87%E7%94%A8">https://mirrors.edge.kernel.org/pub/linux/kernel/v3.x/，网卡驱动采用</a> Intel 的 igb 网卡举例。</p>
<p>友情提示，本文略长，可以先 Mark 后看！</p>
<p>一</p>
<p>Linux 网络收包总览</p>
<p>在 TCP&#x2F;IP 网络分层模型里，整个协议栈被分成了物理层、链路层、网络层，传输层和应用层。物理层对应的是网卡和网线，应用层对应的是我们常见的 Nginx，FTP 等等各种应用。Linux 实现的是链路层、网络层和传输层这三层。  </p>
<p>在 Linux 内核实现中，链路层协议靠网卡驱动来实现，内核协议栈来实现网络层和传输层。内核对更上层的应用层提供 socket 接口来供用户进程访问。我们用 Linux 的视角来看到的 TCP&#x2F;IP 网络分层模型应该是下面这个样子的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlE4c2pMN09ndlB1cG9tRmZpYWRCVGI3UGliRlhqTjQ0YkJrSVYzRmppYjNEbEZwNVVXYTJmZWRGQS82NDA?x-oss-process=image/format,png"></p>
<p>图 1 Linux 视角的网络协议栈</p>
<p>在 Linux 的源代码中，网络设备驱动对应的逻辑位于<code>driver/net/ethernet</code>, 其中 intel 系列网卡的驱动在<code>driver/net/ethernet/intel</code>目录下。协议栈模块代码位于<code>kernel</code>和<code>net</code>目录。</p>
<p>内核和网络设备驱动是通过中断的方式来处理的。当设备上有数据到达的时候，会给 CPU 的相关引脚上触发一个电压变化，以通知 CPU 来处理数据。对于网络模块来说，由于处理过程比较复杂和耗时，如果在中断函数中完成所有的处理，将会导致中断处理函数（优先级过高）将过度占据 CPU，将导致 CPU 无法响应其它设备，例如鼠标和键盘的消息。因此 Linux 中断处理函数是分上半部和下半部的。上半部是只进行最简单的工作，快速处理然后释放 CPU，接着 CPU 就可以允许其它中断进来。剩下将绝大部分的工作都放到下半部中，可以慢慢从容处理。2.4 以后的内核版本采用的下半部实现方式是软中断，由 ksoftirqd 内核线程全权处理。和硬中断不同的是，硬中断是通过给 CPU 物理引脚施加电压变化，而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序。</p>
<p>好了，大概了解了网卡驱动、硬中断、软中断和 ksoftirqd 线程之后，我们在这几个概念的基础上给出一个内核收包的路径示意:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWkNGSEwzcUZpY3dKaWJEdmV2VUNDaWJDdUVUelJCaWN5S1NkemdMcjZPOG5pYXEwZGRiTDhWc3V0eWlidy82NDA?x-oss-process=image/format,png"></p>
<p>图 2 Linux 内核网络收包总览</p>
<p>当网卡上收到数据以后，Linux 中第一个工作的模块是网络驱动。网络驱动会以 DMA 的方式把网卡上收到的帧写到内存里。再向 CPU 发起一个中断，以通知 CPU 有数据到达。第二，当 CPU 收到中断请求后，会去调用网络驱动注册的中断处理函数。网卡的中断处理函数并不做过多工作，发出软中断请求，然后尽快释放 CPU。ksoftirqd 检测到有软中断请求到达，调用 poll 开始轮询收包，收到后交由各级协议栈处理。对于 UDP 包来说，会被放到用户 socket 的接收队列中。</p>
<p>我们从上面这张图中已经从整体上把握到了 Linux 对数据包的处理过程。但是要想了解更多网络模块工作的细节，我们还得往下看。</p>
<p>二</p>
<p>Linux 启动</p>
<p>Linux 驱动，内核协议栈等等模块在具备接收网卡数据包之前，要做很多的准备工作才行。比如要提前创建好 ksoftirqd 内核线程，要注册好各个协议对应的处理函数，网络设备子系统要提前初始化好，网卡要启动好。只有这些都 Ready 之后，我们才能真正开始接收数据包。那么我们现在来看看这些准备工作都是怎么做的。  </p>
<h3 id="2-1-创建-ksoftirqd-内核线程"><a href="#2-1-创建-ksoftirqd-内核线程" class="headerlink" title="2.1 创建 ksoftirqd 内核线程"></a>2.1 创建 ksoftirqd 内核线程</h3><p>Linux 的软中断都是在专门的内核线程（ksoftirqd）中进行的，因此我们非常有必要看一下这些进程是怎么初始化的，这样我们才能在后面更准确地了解收包过程。该进程数量不是 1 个，而是 N 个，其中 N 等于你的机器的核数。</p>
<p>系统初始化的时候在 kernel&#x2F;smpboot.c 中调用了 smpboot_register_percpu_thread， 该函数进一步会执行到 spawn_ksoftirqd（位于 kernel&#x2F;softirq.c）来创建出 softirqd 进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWmlhd0pCNEV4VGlibWljcUJzSFdJNjZJaGJkQ0Z1bzBCVVFBbEM0UXFuWm1GdkxvY2J2TXJlMXhLUS82NDA?x-oss-process=image/format,png"></p>
<p>图 3 创建 ksoftirqd 内核线程</p>
<p>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> =</span> &#123;</span><br><span class="line">    .store          = &amp;ksoftirqd,</span><br><span class="line">    .thread_should_run  = ksoftirqd_should_run,</span><br><span class="line">    .thread_fn      = run_ksoftirqd,</span><br><span class="line">    .thread_comm        = <span class="string">&quot;ksoftirqd/%u&quot;</span>,&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">spawn_ksoftirqd</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_cpu_notifier(&amp;cpu_nfb);</span><br><span class="line"> </span><br><span class="line">    BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br></pre></td></tr></table></figure>

<p>当 ksoftirqd 被创建出来以后，它就会进入自己的线程循环函数 ksoftirqd_should_run 和 run_ksoftirqd 了。不停地判断有没有软中断需要被处理。这里需要注意的一点是，软中断不仅仅只有网络软中断，还有其它类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//file: include/linux/interrupt.h</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-网络子系统初始化"><a href="#2-2-网络子系统初始化" class="headerlink" title="2.2 网络子系统初始化"></a>2.2 网络子系统初始化</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlBmTTE1UGpQSUFDWk5XREVjdWVBR1g0VFRDUDAyNjBsY2VuZkxOY04zQ2R6YWhvVGRsVzBhQS82NDA?x-oss-process=image/format,png"></p>
<p>图 4 网络子系统初始化</p>
<p>linux 内核通过调用<code>subsys_initcall</code>来初始化各个子系统，在源代码目录里你可以 grep 出许多对这个函数的调用。这里我们要说的是网络子系统的初始化，会执行到<code>net_dev_init</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">net_dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;per_cpu(softnet_data, i);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(sd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sd));</span><br><span class="line">        skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">        skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">        sd-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">        INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    open_softirq(NET_TX_SOFTIRQ, net_tx_action);    open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line">&#125;</span><br><span class="line">subsys_initcall(net_dev_init);</span><br></pre></td></tr></table></figure>

<p>在这个函数里，会为每个 CPU 都申请一个<code>softnet_data</code>数据结构，在这个数据结构里的<code>poll_list</code>是等待驱动程序将其 poll 函数注册进来，稍后网卡驱动初始化的时候我们可以看到这一过程。</p>
<p>另外 open_softirq 注册了每一种软中断都注册一个处理函数。NET_TX_SOFTIRQ 的处理函数为 net_tx_action，NET_RX_SOFTIRQ 的为 net_rx_action。继续跟踪<code>open_softirq</code>后发现这个注册的方式是记录在<code>softirq_vec</code>变量里的。后面 ksoftirqd 线程收到软中断的时候，也会使用这个变量来找到每一种软中断对应的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: kernel/softirq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>&#123;</span><br><span class="line">    softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-协议栈注册"><a href="#2-3-协议栈注册" class="headerlink" title="2.3 协议栈注册"></a>2.3 协议栈注册</h3><p>内核实现了网络层的 ip 协议，也实现了传输层的 tcp 协议和 udp 协议。这些协议对应的实现函数分别是 ip_rcv(),tcp_v4_rcv() 和 udp_rcv()。和我们平时写代码的方式不一样的是，内核是通过注册的方式来实现的。Linux 内核中的<code>fs_initcall</code>和<code>subsys_initcall</code>类似，也是初始化模块的入口。<code>fs_initcall</code>调用<code>inet_init</code>后开始网络协议栈注册。通过<code>inet_init</code>，将这些函数注册到了 inet_protos 和 ptype_base 数据结构中了。如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlY5SlNlekp2eGxSNDYwV2o5aWNpYTJiNnRFOWlibk1Fd0x1TXppYTVqalFtcHJYbVdLaWFkUUd0aWJOdy82NDA?x-oss-process=image/format,png"></p>
<p>图 5 AF_INET 协议栈注册</p>
<p>相关代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">    .type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">    .func = ip_rcv,&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> =</span> &#123;</span><br><span class="line">    .handler        =  udp_rcv,</span><br><span class="line">    .err_handler    =  udp_err,</span><br><span class="line">    .no_policy      =  <span class="number">1</span>,</span><br><span class="line">    .netns_ok       =  <span class="number">1</span>,&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">tcp_protocol</span> =</span> &#123;</span><br><span class="line">    .early_demux    =   tcp_v4_early_demux,</span><br><span class="line">    .handler        =   tcp_v4_rcv,</span><br><span class="line">    .err_handler    =   tcp_v4_err,</span><br><span class="line">    .no_policy      =   <span class="number">1</span>,</span><br><span class="line">    .netns_ok       =   <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">staticint __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add ICMP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add UDP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add TCP protocol\n&quot;</span>, __func__);</span><br><span class="line">    ......    dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们可以看到，udp_protocol 结构体中的 handler 是 udp_rcv，tcp_protocol 结构体中的 handler 是 tcp_v4_rcv，通过 inet_add_protocol 被初始化了进来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_add_protocol</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net_protocol *prot, <span class="type">unsigned</span> <span class="type">char</span> protocol)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prot-&gt;netns_ok) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Protocol %u is not namespace aware, cannot register.\n&quot;</span>, protocol);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> !cmpxchg((<span class="type">const</span> <span class="keyword">struct</span> net_protocol **)&amp;inet_protos[protocol], <span class="literal">NULL</span>, prot) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inet_add_protocol</code>函数将 tcp 和 udp 对应的处理函数都注册到了 inet_protos 数组中了。再看<code>dev_add_pack(&amp;ip_packet_type);</code>这一行，ip_packet_type 结构体中的 type 是协议名，func 是 ip_rcv 函数，在 dev_add_pack 中会被注册到 ptype_base 哈希表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_add_pack</span><span class="params">(<span class="keyword">struct</span> packet_type *pt)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span> =</span> ptype_head(pt);    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> list_head *<span class="title function_">ptype_head</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> packet_type *pt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt-&gt;type == htons(ETH_P_ALL))</span><br><span class="line">        <span class="keyword">return</span> &amp;ptype_all;</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> &amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要记住 inet_protos 记录着 udp，tcp 的处理函数地址，ptype_base 存储着 ip_rcv() 函数的处理地址。后面我们会看到软中断中会通过 ptype_base 找到 ip_rcv 函数地址，进而将 ip 包正确地送到 ip_rcv() 中执行。在 ip_rcv 中将会通过 inet_protos 找到 tcp 或者 udp 的处理函数，再而把包转发给 udp_rcv() 或 tcp_v4_rcv() 函数。</p>
<p>扩展一下，如果看一下 ip_rcv 和 udp_rcv 等函数的代码能看到很多协议的处理过程。例如，ip_rcv 中会处理 netfilter 和 iptable 过滤，如果你有很多或者很复杂的 netfilter 或 iptables 规则，这些规则都是在软中断的上下文中执行的，会加大网络延迟。再例如，udp_rcv 中会判断 socket 接收队列是否满了。对应的相关内核参数是 net.core.rmem_max 和 net.core.rmem_default。如果有兴趣，建议大家好好读一下<code>inet_init</code>这个函数的代码。</p>
<h3 id="2-4-网卡驱动初始化"><a href="#2-4-网卡驱动初始化" class="headerlink" title="2.4 网卡驱动初始化"></a>2.4 网卡驱动初始化</h3><p>每一个驱动程序（不仅仅只是网卡驱动）会使用 module_init 向内核注册一个初始化函数，当驱动被加载时，内核会调用这个函数。比如 igb 网卡驱动的代码位于<code>drivers/net/ethernet/intel/igb/igb_main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">igb_driver</span> =</span> &#123;</span><br><span class="line">    .name     = igb_driver_name,</span><br><span class="line">    .id_table = igb_pci_tbl,</span><br><span class="line">    .probe    = igb_probe,</span><br><span class="line">    .remove   = igb_remove,    ......</span><br><span class="line">&#125;;</span><br><span class="line">staticint __init <span class="title function_">igb_init_module</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ret = pci_register_driver(&amp;igb_driver);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>驱动的<code>pci_register_driver</code>调用完成后，Linux 内核就知道了该驱动的相关信息，比如 igb 网卡驱动的<code>igb_driver_name</code>和<code>igb_probe</code>函数地址等等。当网卡设备被识别以后，内核会调用其驱动的 probe 方法（igb_driver 的 probe 方法是 igb_probe）。驱动 probe 方法执行的目的就是让设备 ready，对于 igb 网卡，其<code>igb_probe</code>位于 drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;igb&#x2F;igb_main.c 下。主要执行的操作如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlpZQmpKaWFZWUJnR0hTb3A4VW9XWncwTW9JRXZTNm9EaWFpY1JPcWVyTHlCVkhwQ1RnYmRBcGNydy82NDA?x-oss-process=image/format,png"></p>
<p>图 6 网卡驱动初始化</p>
<p>第 5 步中我们看到，网卡驱动实现了 ethtool 所需要的接口，也在这里注册完成函数地址的注册。当 ethtool 发起一个系统调用之后，内核会找到对应操作的回调函数。对于 igb 网卡来说，其实现函数都在 drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;igb&#x2F;igb_ethtool.c 下。相信你这次能彻底理解 ethtool 的工作原理了吧？这个命令之所以能查看网卡收发包统计、能修改网卡自适应模式、能调整 RX 队列的数量和大小，是因为 ethtool 命令最终调用到了网卡驱动的相应方法，而不是 ethtool 本身有这个超能力。</p>
<p>第 6 步注册的 igb_netdev_ops 中包含的是 igb_open 等函数，该函数在网卡被启动的时候会被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line">staticconststruct net_device_ops igb_netdev_ops = &#123;</span><br><span class="line">  .ndo_open               = igb_open,</span><br><span class="line">  .ndo_stop               = igb_close,</span><br><span class="line">  .ndo_start_xmit         = igb_xmit_frame,</span><br><span class="line">  .ndo_get_stats64        = igb_get_stats64,</span><br><span class="line">  .ndo_set_rx_mode        = igb_set_rx_mode,</span><br><span class="line">  .ndo_set_mac_address    = igb_set_mac,</span><br><span class="line">  .ndo_change_mtu         = igb_change_mtu,</span><br><span class="line">  .ndo_do_ioctl           = igb_ioctl,</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>

<p>第 7 步中，在 igb_probe 初始化过程中，还调用到了<code>igb_alloc_q_vector</code>。他注册了一个 NAPI 机制所必须的 poll 函数，对于 igb 网卡驱动来说，这个函数就是 igb_poll, 如下代码所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_alloc_q_vector</span><span class="params">(<span class="keyword">struct</span> igb_adapter *adapter,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> v_count, <span class="type">int</span> v_idx,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> txr_count, <span class="type">int</span> txr_idx,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> rxr_count, <span class="type">int</span> rxr_idx)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* initialize NAPI */</span></span><br><span class="line">    netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, <span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-启动网卡"><a href="#2-5-启动网卡" class="headerlink" title="2.5 启动网卡"></a>2.5 启动网卡</h3><p>当上面的初始化都完成以后，就可以启动网卡了。回忆前面网卡驱动初始化时，我们提到了驱动向内核注册了 structure net_device_ops 变量，它包含着网卡启用、发包、设置 mac 地址等回调函数（函数指针）。当启用一个网卡时（例如，通过 ifconfig eth0 up），net_device_ops 中的 igb_open 方法会被调用。它通常会做以下事情：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlJWY0tPV2t2clBzZjRQZUNDU2JpYkZ4aWJ1b1hGbnRoT0l4YU0wSkxNTmlhOE1GYzlZeUFvUWd0dy82NDA?x-oss-process=image/format,png"></p>
<p>图 7 启动网卡</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __igb_open(<span class="keyword">struct</span> net_device *netdev, <span class="type">bool</span> resuming)&#123;</span><br><span class="line">    <span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">    err = igb_setup_all_tx_resources(adapter);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">    err = igb_setup_all_rx_resources(adapter);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    err = igb_request_irq(adapter);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_req_irq;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 启用NAPI */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_q_vectors; i++)</span><br><span class="line">        napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面<code>__igb_open</code>函数调用了 igb_setup_all_tx_resources, 和 igb_setup_all_rx_resources。在<code>igb_setup_all_rx_resources</code>这一步操作中，分配了 RingBuffer，并建立内存和 Rx 队列的映射关系。（Rx Tx 队列的数量和大小可以通过 ethtool 进行配置）。我们再接着看中断函数注册<code>igb_request_irq</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_request_irq</span><span class="params">(<span class="keyword">struct</span> igb_adapter *adapter)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adapter-&gt;msix_entries) &#123;</span><br><span class="line">        err = igb_request_msix(adapter);</span><br><span class="line">        <span class="keyword">if</span> (!err)</span><br><span class="line">            <span class="keyword">goto</span> request_done;</span><br><span class="line">        ......    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">staticintigb_request_msix(<span class="keyword">struct</span> igb_adapter *adapter)&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_q_vectors; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        err = request_irq(adapter-&gt;msix_entries[<span class="built_in">vector</span>].<span class="built_in">vector</span>,</span><br><span class="line">                  igb_msix_ring, <span class="number">0</span>, q_vector-&gt;name,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中跟踪函数调用， <code>__igb_open</code> &#x3D;&gt; <code>igb_request_irq</code> &#x3D;&gt; <code>igb_request_msix</code>, 在<code>igb_request_msix</code>中我们看到了，对于多队列的网卡，为每一个队列都注册了中断，其对应的中断处理函数是 igb_msix_ring（该函数也在 drivers&#x2F;net&#x2F;ethernet&#x2F;intel&#x2F;igb&#x2F;igb_main.c 下）。我们也可以看到，msix 方式下，每个 RX 队列有独立的 MSI-X 中断，从网卡硬件中断的层面就可以设置让收到的包被不同的 CPU 处理。（可以通过 irqbalance ，或者修改 &#x2F;proc&#x2F;irq&#x2F;IRQ_NUMBER&#x2F;smp_affinity 能够修改和 CPU 的绑定行为）。</p>
<p>当做好以上准备工作以后，就可以开门迎客（数据包）了！</p>
<p>三</p>
<p>迎接数据的到来</p>
<h3 id="3-1-硬中断处理"><a href="#3-1-硬中断处理" class="headerlink" title="3.1 硬中断处理"></a>3.1 硬中断处理</h3><p>首先当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的 RingBuffer 中寻找可用的内存位置，找到后 DMA 引擎会把数据 DMA 到网卡之前关联的内存里，这个时候 CPU 都是无感的。当 DMA 操作完成以后，网卡会像 CPU 发起一个硬中断，通知 CPU 有数据到达。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWjNKSGdLajhHcFRaV0s2dkM0dWUySjh6Szh6RzNLMEZzaHBxaWJZMlozNjdoaWJ1RlFpYndZUXVFdy82NDA?x-oss-process=image/format,png"></p>
<p>图 8 网卡数据硬中断处理过程</p>
<blockquote>
<p>注意：当 RingBuffer 满的时候，新来的数据包将给丢弃。ifconfig 查看网卡的时候，可以里面有个 overruns，表示因为环形队列满被丢弃的包。如果发现有丢包，可能需要通过 ethtool 命令来加大环形队列的长度。</p>
</blockquote>
<p>在启动网卡一节，我们说到了网卡的硬中断注册的处理函数是 igb_msix_ring。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">igb_msix_ring</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_q_vector</span> *<span class="title">q_vector</span> =</span> data;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Write the ITR value calculated from the previous interrupt. */</span></span><br><span class="line">    igb_write_itr(q_vector);</span><br><span class="line"> </span><br><span class="line">    napi_schedule(&amp;q_vector-&gt;napi);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>igb_write_itr</code>只是记录一下硬件中断频率（据说目的是在减少对 CPU 的中断频率时用到）。顺着 napi_schedule 调用一路跟踪下去，<code>__napi_schedule</code>&#x3D;&gt;<code>____napi_schedule</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called with irq disabled */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> ____napi_schedule(<span class="keyword">struct</span> softnet_data *sd, <span class="keyword">struct</span> napi_struct *napi)&#123;</span><br><span class="line">    list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">    __raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到，<code>list_add_tail</code>修改了 CPU 变量 softnet_data 里的 poll_list，将驱动 napi_struct 传过来的 poll_list 添加了进来。其中 softnet_data 中的 poll_list 是一个双向列表，其中的设备都带有输入帧等着被处理。紧接着<code>__raise_softirq_irqoff</code>触发了一个软中断 NET_RX_SOFTIRQ， 这个所谓的触发过程只是对一个变量进行了一次或运算而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __raise_softirq_irqoff(<span class="type">unsigned</span> <span class="type">int</span> nr)&#123;</span><br><span class="line">    trace_softirq_raise(nr);</span><br><span class="line">    or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file: include/linux/irq_cpustat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> or_softirq_pending(x)  (local_softirq_pending() |= (x))</span></span><br></pre></td></tr></table></figure>

<p>我们说过，Linux 在硬中断里只完成简单必要的工作，剩下的大部分的处理都是转交给软中断的。通过上面代码可以看到，硬中断处理过程真的是非常短。只是记录了一个寄存器，修改了一下下 CPU 的 poll_list，然后发出个软中断。就这么简单，硬中断工作就算是完成了。</p>
<h3 id="3-2-ksoftirqd-内核线程处理软中断"><a href="#3-2-ksoftirqd-内核线程处理软中断" class="headerlink" title="3.2 ksoftirqd 内核线程处理软中断"></a>3.2 ksoftirqd 内核线程处理软中断</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlhhblNUdGdQWWVpYzZOVkZBUUhwTmZiVWlhRTg0ckwwVHF4ZlRDUmVVcmlhNlZkdmlhc2tOSllDbkEvNjQw?x-oss-process=image/format,png"></p>
<p>图 9 ksoftirqd 内核线程</p>
<p>内核线程初始化的时候，我们介绍了 ksoftirqd 中两个线程函数<code>ksoftirqd_should_run</code>和<code>run_ksoftirqd</code>。其中<code>ksoftirqd_should_run</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksoftirqd_should_run</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> local_softirq_pending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_softirq_pending() \    __IRQ_STAT(smp_processor_id(), __softirq_pending)</span></span><br></pre></td></tr></table></figure>

<p>这里看到和硬中断中调用了同一个函数<code>local_softirq_pending</code>。使用方式不同的是硬中断位置是为了写入标记，这里仅仅只是读取。如果硬中断中设置了<code>NET_RX_SOFTIRQ</code>, 这里自然能读取的到。接下来会真正进入线程函数中<code>run_ksoftirqd</code>处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_ksoftirqd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span>&#123;</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">        __do_softirq();</span><br><span class="line">        rcu_note_context_switch(cpu);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">        cond_resched();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>__do_softirq</code>中，判断根据当前 CPU 的软中断类型，调用其注册的 action 方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> vec_nr = h - softirq_vec;</span><br><span class="line">            <span class="type">int</span> prev_count = preempt_count();</span><br><span class="line">            ...</span><br><span class="line">            trace_softirq_entry(vec_nr);</span><br><span class="line">            h-&gt;action(h);</span><br><span class="line">            trace_softirq_exit(vec_nr);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在网络子系统初始化小节， 我们看到我们为 NET_RX_SOFTIRQ 注册了处理函数 net_rx_action。所以<code>net_rx_action</code>函数就会被执行到了。</p>
<p>这里需要注意一个细节，硬中断中设置软中断标记，和 ksoftirq 的判断是否有软中断到达，都是基于 smp_processor_id() 的。这意味着只要硬中断在哪个 CPU 上被响应，那么软中断也是在这个 CPU 上处理的。所以说，如果你发现你的 Linux 软中断 CPU 消耗都集中在一个核上的话，做法是要把调整硬中断的 CPU 亲和性，来将硬中断打散到不同的 CPU 核上去。</p>
<p>我们再来把精力集中到这个核心函数<code>net_rx_action</code>上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;__get_cpu_var(softnet_data);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> time_limit = jiffies + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> budget = netdev_budget;</span><br><span class="line">    <span class="type">void</span> *have;</span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        n = list_first_entry(&amp;sd-&gt;poll_list, <span class="keyword">struct</span> napi_struct, poll_list);</span><br><span class="line"> </span><br><span class="line">        work = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">            work = n-&gt;poll(n, weight);</span><br><span class="line">            trace_napi_poll(n);</span><br><span class="line">        &#125;</span><br><span class="line">        budget -= work;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数开头的 time_limit 和 budget 是用来控制 net_rx_action 函数主动退出的，目的是保证网络包的接收不霸占 CPU 不放。等下次网卡再有硬中断过来的时候再处理剩下的接收数据包。其中 budget 可以通过内核参数调整。这个函数中剩下的核心逻辑是获取到当前 CPU 变量 softnet_data，对其 poll_list 进行遍历, 然后执行到网卡驱动注册到的 poll 函数。对于 igb 网卡来说，就是 igb 驱动力的<code>igb_poll</code>函数了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_poll</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="type">int</span> budget)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;tx.ring)</span><br><span class="line">        clean_complete = igb_clean_tx_irq(q_vector);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;rx.ring)</span><br><span class="line">        clean_complete &amp;= igb_clean_rx_irq(q_vector, budget);    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读取操作中，<code>igb_poll</code>的重点工作是对<code>igb_clean_rx_irq</code>的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">igb_clean_rx_irq</span><span class="params">(<span class="keyword">struct</span> igb_q_vector *q_vector, <span class="type">const</span> <span class="type">int</span> budget)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* retrieve a buffer from the ring */</span></span><br><span class="line">        skb = igb_fetch_rx_buffer(rx_ring, rx_desc, skb);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* fetch next buffer in frame if non-eop */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_is_non_eop(rx_ring, rx_desc))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* verify the packet layout is correct */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_cleanup_headers(rx_ring, rx_desc, skb)) &#123;</span><br><span class="line">            skb = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* populate checksum, timestamp, VLAN, and protocol */</span></span><br><span class="line">        igb_process_skb_fields(rx_ring, rx_desc, skb);</span><br><span class="line"> </span><br><span class="line">        napi_gro_receive(&amp;q_vector-&gt;napi, skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>igb_fetch_rx_buffer</code>和<code>igb_is_non_eop</code>的作用就是把数据帧从 RingBuffer 上取下来。为什么需要两个函数呢？因为有可能帧要占多多个 RingBuffer，所以是在一个循环中获取的，直到帧尾部。获取下来的一个数据帧用一个 sk_buff 来表示。收取完数据以后，对其进行一些校验，然后开始设置 sbk 变量的 timestamp, VLAN id, protocol 等字段。接下来进入到 napi_gro_receive 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">gro_result_t</span> <span class="title function_">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    skb_gro_reset_offset(skb);</span><br><span class="line">    <span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dev_gro_receive</code>这个函数代表的是网卡 GRO 特性，可以简单理解成把相关的小包合并成一个大包就行，目的是减少传送给网络栈的包数，这有助于减少 CPU 的使用量。我们暂且忽略，直接看<code>napi_skb_finish</code>, 这个函数主要就是调用了<code>netif_receive_skb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">gro_result_t</span> <span class="title function_">napi_skb_finish</span><span class="params">(<span class="type">gro_result_t</span> ret, <span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line">        <span class="keyword">if</span> (netif_receive_skb(skb))</span><br><span class="line">            ret = GRO_DROP;</span><br><span class="line">        <span class="keyword">break</span>;    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>netif_receive_skb</code>中，数据包将被送到协议栈中。声明，以下的 3.3, 3.4, 3.5 也都属于软中断的处理过程，只不过由于篇幅太长，单独拿出来成小节。</p>
<h3 id="3-3-网络协议栈处理"><a href="#3-3-网络协议栈处理" class="headerlink" title="3.3 网络协议栈处理"></a>3.3 网络协议栈处理</h3><p><code>netif_receive_skb</code>函数会根据包的协议，假如是 udp 包，会将包依次送到 ip_rcv(),udp_rcv() 协议处理函数中进行处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWnR5UzVlaWFlbUEyNTJ5OWp4OEJBNmFBQnlDbmJsWTBwYkl4T2JsV2dCUjBxbUFJelRDTWg5YmcvNjQw?x-oss-process=image/format,png"></p>
<p>图 10 网络协议栈处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">netif_receive_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="comment">//RPS处理逻辑，先忽略    ......    return __netif_receive_skb(skb);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb(<span class="keyword">struct</span> sk_buff *skb)&#123;</span><br><span class="line">    ......  </span><br><span class="line">    ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb_core(<span class="keyword">struct</span> sk_buff *skb, <span class="type">bool</span> pfmemalloc)&#123;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//pcap逻辑，这里会将数据送入抓包点。tcpdump就是从这个入口获取包的    </span></span><br><span class="line">    list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">            pt_prev = ptype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    list_for_each_entry_rcu(ptype, &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptype-&gt;type == type &amp;&amp;</span><br><span class="line">            (ptype-&gt;dev == null_or_dev || ptype-&gt;dev == skb-&gt;dev ||</span><br><span class="line">             ptype-&gt;dev == orig_dev)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">            pt_prev = ptype;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>__netif_receive_skb_core</code>中，我看着原来经常使用的 tcpdump 的抓包点，很是激动，看来读一遍源代码时间真的没白浪费。接着<code>__netif_receive_skb_core</code>取出 protocol，它会从数据包中取出协议信息，然后遍历注册在这个协议上的回调函数列表。<code>ptype_base</code> 是一个 hash table，在协议注册小节我们提到过。ip_rcv 函数地址就是存在这个 hash table 中的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">deliver_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> packet_type *pt_prev,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> net_device *orig_dev)</span>&#123;</span><br><span class="line">    ......    <span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pt_prev-&gt;func</code>这一行就调用到了协议层注册的处理函数了。对于 ip 包来讲，就会进入到<code>ip_rcv</code>（如果是 arp 包的话，会进入到 arp_rcv）。</p>
<h3 id="3-4-IP-协议层处理"><a href="#3-4-IP-协议层处理" class="headerlink" title="3.4 IP 协议层处理"></a>3.4 IP 协议层处理</h3><p>我们再来大致看一下 linux 在 ip 协议层都做了什么，包又是怎么样进一步被送到 udp 或 tcp 协议处理函数中的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="literal">NULL</span>, ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>NF_HOOK</code>是一个钩子函数，当执行完注册的钩子后就会执行到最后一个参数指向的函数<code>ip_rcv_finish</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!skb_dst(skb)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">                           iph-&gt;tos, skb-&gt;dev);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ......    <span class="keyword">return</span> dst_input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪<code>ip_route_input_noref</code> 后看到它又调用了 <code>ip_route_input_mc</code>。在<code>ip_route_input_mc</code>中，函数<code>ip_local_deliver</code>被赋值给了<code>dst_input</code>, 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/route.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_route_input_mc</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, __be32 daddr, __be32 saddr,u8 tos, <span class="keyword">struct</span> net_device *dev, <span class="type">int</span> our)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (our) &#123;</span><br><span class="line">        rth-&gt;dst_input= ip_local_deliver;</span><br><span class="line">        rth-&gt;rt_flags |= RTCF_LOCAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以回到<code>ip_rcv_finish</code>中的<code>return dst_input(skb);</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Input packet from network to transport.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_input</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> skb_dst(skb)-&gt;input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>skb_dst(skb)-&gt;input</code>调用的 input 方法就是路由子系统赋的 ip_local_deliver。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="comment">/*     *  Reassemble IP fragments.     */</span></span><br><span class="line">    <span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>,               ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br><span class="line">staticintip_local_deliver_finish(<span class="keyword">struct</span> sk_buff *skb)&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line"> </span><br><span class="line">    ipprot = rcu_dereference(inet_protos[protocol]);</span><br><span class="line">    <span class="keyword">if</span> (ipprot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = ipprot-&gt;handler(skb);    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如协议注册小节看到 inet_protos 中保存着 tcp_rcv() 和 udp_rcv() 的函数地址。这里将会根据包中的协议类型选择进行分发, 在这里 skb 包将会进一步被派送到更上层的协议中，udp 和 tcp。</p>
<h3 id="3-5-UDP-协议层处理"><a href="#3-5-UDP-协议层处理" class="headerlink" title="3.5 UDP 协议层处理"></a>3.5 UDP 协议层处理</h3><p>在协议注册小节的时候我们说过，udp 协议的处理函数是<code>udp_rcv</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __udp4_lib_rcv(skb, &amp;udp_table, IPPROTO_UDP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __udp4_lib_rcv(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> udp_table *udptable, <span class="type">int</span> proto)&#123;</span><br><span class="line">    sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = udp_queue_rcv_skb(sk, skb);</span><br><span class="line">    &#125;    </span><br><span class="line">    icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__udp4_lib_lookup_skb</code>是根据 skb 来寻找对应的 socket，当找到以后将数据包放到 socket 的缓存队列里。如果没有找到，则发送一个目标不可达的 icmp 包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (sk_rcvqueues_full(sk, skb, sk-&gt;sk_rcvbuf))</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">    rc = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    ipv4_pktinfo_prepare(skb);</span><br><span class="line">    bh_lock_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk))</span><br><span class="line">        rc = __udp_queue_rcv_skb(sk, skb);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sk_add_backlog(sk, skb, sk-&gt;sk_rcvbuf)) &#123;</span><br><span class="line">        bh_unlock_sock(sk);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk);    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sock_owned_by_user 判断的是用户是不是正在这个 socker 上进行系统调用（socket 被占用），如果没有，那就可以直接放到 socket 的接收队列中。如果有，那就通过<code>sk_add_backlog</code>把数据包添加到 backlog 队列。当用户释放的 socket 的时候，内核会检查 backlog 队列，如果有数据再移动到接收队列中。</p>
<p><code>sk_rcvqueues_full</code>接收队列如果满了的话，将直接把包丢弃。接收队列大小受内核参数 net.core.rmem_max 和 net.core.rmem_default 影响。</p>
<p>四</p>
<p>recvfrom 系统调用</p>
<p>花开两朵，各表一枝。上面我们说完了整个 Linux 内核对数据包的接收和处理过程，最后把数据包放到 socket 的接收队列中了。那么我们再回头看用户进程调用<code>recvfrom</code>后是发生了什么。我们在代码里调用的<code>recvfrom</code>是一个 glibc 的库函数，该函数在执行后会将用户进行陷入到内核态，进入到 Linux 实现的系统调用<code>sys_recvfrom</code>。在理解 Linux 对<code>sys_revvfrom</code>之前，我们先来简单看一下<code>socket</code>这个核心数据结构。这个数据结构太大了，我们只把对和我们今天主题相关的内容画出来，如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWlhtY3FNYXFta1BZeHpNZmNNZ2ljT2liUnRGM05GZnFPd251bmVpYW15VFhlQ20yejlrWG1qMlNsUS82NDA?x-oss-process=image/format,png"></p>
<p>图 11 socket 内核数据机构</p>
<p><code>socket</code>数据结构中的<code>const struct proto_ops</code>对应的是协议的方法集合。每个协议都会实现不同的方法集，对于 IPv4 Internet 协议族来说, 每种协议都有对应的处理方法，如下。对于 udp 来说，是通过<code>inet_dgram_ops</code>来定义的，其中注册了<code>inet_recvmsg</code>方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> =</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    .recvmsg       = inet_recvmsg,</span><br><span class="line">    .mmap          = sock_no_mmap,    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> proto_ops inet_dgram_ops = &#123;</span><br><span class="line">    ......</span><br><span class="line">    .sendmsg       = inet_sendmsg,</span><br><span class="line">    .recvmsg       = inet_recvmsg,    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>socket</code>数据结构中的另一个数据结构<code>struct sock *sk</code>是一个非常大，非常重要的子结构体。其中的<code>sk_prot</code>又定义了二级处理函数。对于 UDP 协议来说，会被设置成 UDP 协议实现的方法集<code>udp_prot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/udp.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">udp_prot</span> =</span> &#123;</span><br><span class="line">    .name          = <span class="string">&quot;UDP&quot;</span>,</span><br><span class="line">    .owner         = THIS_MODULE,</span><br><span class="line">    .close         = udp_lib_close,</span><br><span class="line">    .connect       = ip4_datagram_connect,</span><br><span class="line">    ......</span><br><span class="line">    .sendmsg       = udp_sendmsg,</span><br><span class="line">    .recvmsg       = udp_recvmsg,</span><br><span class="line">    .sendpage      = udp_sendpage,    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了<code>socket</code>变量之后，我们再来看<code>sys_recvfrom</code>的实现过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CQmpBRkY0aGN3cHVscFZTU09aelYzRGtob0lrMHFrWmdMdlZjZWlheXdUSHhUQmdDaWNvWnlUcUxqY01XdjA2MllCVTZOVlVyN1BmUXdaZFB2NlJhaWJyQS82NDA?x-oss-process=image/format,png"></p>
<p>图 12 recvfrom 函数内部实现过程</p>
<p>在<code>inet_recvmsg</code>调用了<code>sk-&gt;sk_prot-&gt;recvmsg</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_recvmsg</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg,<span class="type">size_t</span> size, <span class="type">int</span> flags)</span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    err = sk-&gt;sk_prot-&gt;recvmsg(iocb, sk, msg, size, flags &amp; MSG_DONTWAIT,</span><br><span class="line">                   flags &amp; ~MSG_DONTWAIT, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">        msg-&gt;msg_namelen = addr_len;    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们说过这个对于 udp 协议的 socket 来说，这个<code>sk_prot</code>就是<code>net/ipv4/udp.c</code>下的<code>struct proto udp_prot</code>。由此我们找到了<code>udp_recvmsg</code>方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/core/datagram.c:EXPORT_SYMBOL(__skb_recv_datagram);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_recv_datagram</span>(<span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,<span class="title">int</span>*<span class="title">peeked</span>, <span class="title">int</span>*<span class="title">off</span>, <span class="title">int</span>*<span class="title">err</span>)&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">queue</span> =</span> &amp;sk-&gt;sk_receive_queue;</span><br><span class="line">        skb_queue_walk(<span class="built_in">queue</span>, skb) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* User doesn&#x27;t want to wait */</span></span><br><span class="line">        error = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">goto</span> no_packet;    &#125; <span class="keyword">while</span> (!wait_for_more_packets(sk, err, &amp;timeo, last));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于我们找到了我们想要看的重点，在上面我们看到了所谓的读取过程，就是访问<code>sk-&gt;sk_receive_queue</code>。如果没有数据，且用户也允许等待，则将调用 wait_for_more_packets() 执行等待操作，它加入会让用户进程进入睡眠状态。</p>
<p>五</p>
<p>总结</p>
<p>网络模块是 Linux 内核中最复杂的模块了，看起来一个简简单单的收包过程就涉及到许多内核组件之间的交互，如网卡驱动、协议栈，内核 ksoftirqd 线程等。看起来很复杂，本文想通过图示的方式，尽量以容易理解的方式来将内核收包过程讲清楚。现在让我们再串一串整个收包过程。</p>
<p>当用户执行完<code>recvfrom</code>调用后，用户进程就通过系统调用进行到内核态工作了。如果接收队列没有数据，进程就进入睡眠状态被操作系统挂起。这块相对比较简单，剩下大部分的戏份都是由 Linux 内核其它模块来表演了。</p>
<p>首先在开始收包之前，Linux 要做许多的准备工作：</p>
<ul>
<li><ol>
<li>创建 ksoftirqd 线程，为它设置好它自己的线程函数，后面指望着它来处理软中断</li>
</ol>
</li>
<li><ol start="2">
<li>协议栈注册，linux 要实现许多协议，比如 arp，icmp，ip，udp，tcp，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数</li>
</ol>
</li>
<li><ol start="3">
<li>网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下。在这个初始化过程中，把自己的 DMA 准备好，把 NAPI 的 poll 函数地址告诉内核</li>
</ol>
</li>
<li><ol start="4">
<li>启动网卡，分配 RX，TX 队列，注册中断对应的处理函数</li>
</ol>
</li>
</ul>
<p>以上是内核准备收包之前的重要工作，当上面都 ready 之后，就可以打开硬中断，等待数据包的到来了。</p>
<p>当数据到来了以后，第一个迎接它的是网卡（我去，这不是废话么）：</p>
<ul>
<li><ol>
<li>网卡将数据帧 DMA 到内存的 RingBuffer 中，然后向 CPU 发起中断通知</li>
</ol>
</li>
<li><ol start="2">
<li>CPU 响应中断请求，调用网卡启动时注册的中断处理函数</li>
</ol>
</li>
<li><ol start="3">
<li>中断处理函数几乎没干啥，就发起了软中断请求</li>
</ol>
</li>
<li><ol start="4">
<li>内核线程 ksoftirqd 线程发现有软中断请求到来，先关闭硬中断</li>
</ol>
</li>
<li><ol start="5">
<li>ksoftirqd 线程开始调用驱动的 poll 函数收包</li>
</ol>
</li>
<li><ol start="6">
<li>poll 函数将收到的包送到协议栈注册的 ip_rcv 函数中</li>
</ol>
</li>
<li><ol start="7">
<li>ip_rcv 函数再讲包送到 udp_rcv 函数中（对于 tcp 包就送到 tcp_rcv）</li>
</ol>
</li>
</ul>
<p>现在我们可以回到开篇的问题了，我们在用户层看到的简单一行<code>recvfrom</code>,Linux 内核要替我们做如此之多的工作，才能让我们顺利收到数据。这还是简简单单的 UDP，如果是 TCP，内核要做的工作更多，不由得感叹内核的开发者们真的是用心良苦。</p>
<p>理解了整个收包过程以后，我们就能明确知道 Linux 收一个包的 CPU 开销了。首先第一块是用户进程调用系统调用陷入内核态的开销。第二块是 CPU 响应包的硬中断的 CPU 开销。第三块是 ksoftirqd 内核线程的软中断上下文花费的。后面我们再专门发一篇文章实际观察一下这些开销。</p>
<p>另外网络收发中有很多末支细节咱们并没有展开了说，比如说 no NAPI， GRO，RPS 等。因为我觉得说的太对了反而会影响大家对整个流程的把握，所以尽量只保留主框架了，少即是多！</p>
<ul>
<li>EOF -</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/')">远辰</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=远辰&amp;url=https://shippomx.github.io/2024/06/13/linux/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%20Linux%20%E7%BD%91%E7%BB%9C%E5%8C%85%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/10/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">加权轮询算法</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/31/sdn/dpdk/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA-ksoftirqd-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">2.1 创建 ksoftirqd 内核线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BD%91%E7%BB%9C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">2.2 网络子系统初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%B3%A8%E5%86%8C"><span class="toc-number">3.</span> <span class="toc-text">2.3 协议栈注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">2.4 网卡驱动初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%90%AF%E5%8A%A8%E7%BD%91%E5%8D%A1"><span class="toc-number">5.</span> <span class="toc-text">2.5 启动网卡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">3.1 硬中断处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ksoftirqd-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">7.</span> <span class="toc-text">3.2 ksoftirqd 内核线程处理软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">3.3 网络协议栈处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-IP-%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">3.4 IP 协议层处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-UDP-%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">3.5 UDP 协议层处理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E4%BB%8E%E7%A1%AC%E4%BB%B6%E7%9C%8B%E4%B8%AD%E6%96%AD%E4%B9%8B%20APIC%EF%BC%88%E4%B8%89%E4%B8%87%EF%BC%89-CSDN%20%E5%8D%9A%E5%AE%A2/" title="无题">无题</a><time datetime="2024-08-13T07:48:29.025Z" title="发表于 2024-08-13 15:48:29">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/linux/%E5%86%85%E5%AD%98/%E9%A1%B5%E8%A1%A8/" title="无题">无题</a><time datetime="2024-08-13T06:57:36.023Z" title="发表于 2024-08-13 14:57:36">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/13/containers/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20%5B%E4%B8%80%5D%20-%20%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/" title="无题">无题</a><time datetime="2024-08-13T06:50:07.571Z" title="发表于 2024-08-13 14:50:07">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/linux/%E5%86%85%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="无题">无题</a><time datetime="2024-08-12T03:18:47.311Z" title="发表于 2024-08-12 11:18:47">2024-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/sdn/dpdk/" title="无题">无题</a><time datetime="2024-07-31T11:36:18.019Z" title="发表于 2024-07-31 19:36:18">2024-07-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 0.88rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 0.88rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 0.88rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>25</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>40</sup></a><a href="/tags/network/" style="font-size: 0.88rem;">network<sup>8</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 0.88rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>