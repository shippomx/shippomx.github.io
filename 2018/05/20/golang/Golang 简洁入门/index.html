<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Golang简洁入门 | 远辰</title><meta name="keywords" content="go"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Golang简洁入门"><meta name="application-name" content="Golang简洁入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Golang简洁入门"><meta property="og:url" content="https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="为什么选择golang?从一个程序说起为什么我不从基础说起​		在这里，假定的是你已经有了一定的程序基础，能够明白字符串，结构体等是什么，为了避免大几百页码的书本讲述，如果认认真真读下去，需要耗费比较长的时间，而其中的很多特性在看了新的章节又会忘了之前的。所以，我决定还是从编程实际的例子出发，尽量在"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="为什么选择golang?从一个程序说起为什么我不从基础说起​		在这里，假定的是你已经有了一定的程序基础，能够明白字符串，结构体等是什么，为了避免大几百页码的书本讲述，如果认认真真读下去，需要耗费比较长的时间，而其中的很多特性在看了新的章节又会忘了之前的。所以，我决定还是从编程实际的例子出发，尽量在"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: 'Golang简洁入门',
  postAI: '',
  pageFillDescription: '为什么选择golang?, 从一个程序说起, 为什么我不从基础说起, Golang开发环境搭建, 实现cd命令, 知识点解析, 包, 包的导入, 包的初始化, 命名, 声明, 赋值, 类型, 数组、字符串与切片, 结构体, 函数、方法和接口, 函数, 方法, Panic异常, recover 捕获异常, 接口, 反射, 为什么使用反射？, 总结, go routine和channel, go routine, Go 线程实现模型 MPG, 调度器的三个基本对象：, G-M-P三者的关系与特点：, 局部G队列与全局G队列的关系, Gorutine从入队到执行, 解答问题-①, 中断后的恢复, GOMAXPROCS–性能调优, P(Processor), 均衡的分配工作, channel, Go 的 Context 上下文, 问题引入, 协程泄露, 输出：, 解决方式, 管道通知退出, 输出：, 上下文管理, 官方概念, 程序输出：, 截止超时退出, 请求超时, 程序示例：, Context 值读写, 示例：, Context 的作用域, 参考链接为什么选择从一个程序说起为什么我不从基础说起在这里假定的是你已经有了一定的程序基础能够明白字符串结构体等是什么为了避免大几百页码的书本讲述如果认认真真读下去需要耗费比较长的时间而其中的很多特性在看了新的章节又会忘了之前的所以我决定还是从编程实际的例子出发尽量在一个程序中把大部分重要特性放进去如果需要纠结里面的底层技术细节或为了准备面试则需要把厚厚的教科书拿出来把自己遗忘或不确定的内容进行翔实地复习那么现在我们开始开发环境搭建环境搭建建议使用或者如果对下的命令或者下的软件包源设置有疑问可以参考我的博客文章安装安装开发工具实现命令我之前遇到一道华为的笔试题要求用实现下的类命令不考虑等字符只含数字字母与也不考虑多个连续出现的情况如输入能够打印出当前路径题目不怎么难但是我觉得这是一个很好的例子可以用来说明语言的绝大部分特性的例子源码链接建议你现在就把源码下来对比我的这个教程看懂源码当然我里面可能有些地方可能实现方法有些繁琐你如果有更好的解决方法不妨提给我无缓冲的接收要出现在发送之前作为无缓冲通道的内容生产者作为无缓冲通道的内容生产者只能为第一个字符不考虑连续多个的代表从根目录进行计算统计上述两个文件引入了的一大特性协程注意主程序本身也是一个协程建议先多熟悉几遍上面的源码文件下面将逐步说明一些涉及到的概念知识点解析包包的导入我们先看的结构首先声明了表明这是一个包紧接着了程序中的另一个最后则是主函数的声明程序中只能有一个包对于其它的包包名以当前源码文件所在的文件夹名命名所以一个文件夹下可以有多个源码文件只要源码文件中声明的包名一致对于声明可以有几种不同的导入方式直接引入调用时使用对包使用别名调用时使用仅执行包中的方法不能调用该包成员使用此包内的成员时不带前缀使用规范不要使用相对路径引入包以作为根目录引入包顺序遵循标准库项目包第三方包第三方包按命名顺序包的初始化注意到中有一个函数函数每个包都可以有多个如果当前包有引入其它包必须等其它包的函数执行完才执行另外执行当前包中的函数的顺序与源码文件的编码顺序有关包的初始化首先是解决包级变量的依赖顺序然后安照包级变量声明出现的顺序依次初始化命名包中的函数和变量如果定义的首字母大写则表明可以导出否则不能导出如中的可以在中使用进行调用但是则不能在包外使用语言中的函数名变量名常量名类型名语句标号和包名等所有的命名都遵循一个简单的命名规则一个名字必须以一个字母字母或下划线开头后面可以跟任意数量的字母数字或下划线大写字母和小写字母是不同的和是两个不同的名字建议使用驼峰式命名规则语言中类似和的关键字有个关键字不能用于自定义名字只能在特定语法结构中使用此外还有大约多个预定义的名字比如和等主要对应内建的常量类型和函数内建常量内建类型内建函数可以从文件中看出命名遵循了上述规范声明声明语句定义了程序的各种实体对象以及部分或全部的属性语言主要有四种类型的声明语句和分别对应变量常量类型和函数实体对象的声明例如在中声明了一个元素为字符串的数组声明可以在函数体或者代码块内也可以在函数外部进行声明如果声明在函数体或代码块内该声明的作用域在函数或代码块内如果在函数体外按可引用范围造成影响声明会对基础类型初始化如果是结构体则默认值为如果是通道切片则需要配合函数对这几种类型进行进行分配声明一个接收发送类型为的对进行初值化对底层数据结构进行准备创建了缓冲为的对函数的声明则可能如以下几种伪码形式常见形式参数列表返回值列表函数体成员形式形参列表返回值列表函数体匿名函数形式一行参列表返回值列表函数体使用方式为实参列表匿名函数形式二行参列表返回值列表函数体实参列表函数参数列表规则示例函数体如以上函数均为指定了类型的参数其中因类型一致可以对的类型说明和合并是可变参数使用该函数时可以不准备其实参若传入则的类型均为一个函数最多有一个可变参数列表标准库中的的最后一个参数就为可变参数简短声明是一个有趣的特性只能在函数内使用例如中的就是简短声明通过一个空字符串对进行了声明及初始化也可以用使用其它字符串进行简短声明这个特性在获取函数返回值比较有用不用填提前声明过多变量使程序显得简洁当我们想要在语言中初始化一个结构时可能会用到两个不同的关键字和因为它们的功能相似所以初学者可能会对这两个关键字的作用感到困惑但是它们两者能够初始化的却有较大的不同的作用是初始化内置的数据结构只能用于切片哈希表和返回的是的引用的作用是根据传入的类型在堆上分配一片内存空间并返回指向这片内存空间的指针返回的是的指针实际工程开发中很少用到赋值使用赋值语句可以更新一个变量的值最简单的赋值语句是将要被赋值的变量放在的左边新值的表达式放在的右边通过该方式对分别进行了赋值类型变量或表达式的类型定义了对应存储值的属性特征例如数值在内存的存储大小或者是元素的个数它们在内部是如何表达的是否支持一些操作符以及它们自己关联的方法集等在任何程序中都会存在一些变量有着相同的内部结构但是却表示完全不同的概念例如一个类型的变量可以用来表示一个循环的迭代索引或者一个时间戳或者一个文件描述符或者一个月份一个字符串可以用来表示一个密码或者一个颜色的名称一个类型声明语句创建了一个新的类型名称和现有类型具有相同的底层结构新命名的类型提供了一个方法用来分隔不同概念的类型这样即使它们底层类型相同也是不兼容的类型名字底层类型类型声明语句一般出现在包一级如果新创建的类型名字的首字符大写则在外部包也可以使用一个命名的类型可以提供书写方便特别是可以避免一遍又一遍地书写复杂类型例如用匿名的结构体定义变量如果是复杂的类型将会简洁很多特别是结构体类型命名类型还可以为该类型的值定义新的行为这些行为表示为一组关联到该类型的函数集合我们称为类型的方法集对方法集的介绍稍后在后面的章节会提到这里先暂时不提自定义类型的自增长常量经常包含一个自定义的类型允许你依靠编译器完成自增设置类型类似于枚举类型的出现会使后面的定义进行递增若后面出现数字仍然计数但计数的值被新设置的值覆盖了再次出现从原来的值恢复递增盖住了原本的计算的盖住了原本的计算的比较和的区别数组字符串与切片切片作为中最灵活的类型我们在最初的示例程序中声明了一个切片用来存储目录文件夹的堆栈然后调用内置的函数用来获取环境的目录并将文件夹存储在中假定当前的路径是而则是通过切片获取字符串的部分因为字符串本身是一个数组语言中数组字符串和切片三者是密切相关的数据结构这三种数据类型在底层原始数据有着相同的内存结构在上层因为语法的限制而有着不同的行为表现首先语言的数组是一种值类型虽然数组的元素可以被修改但是数组本身的赋值和函数传参都是以整体复制的方式处理的语言字符串底层数据也是对应的字节数组但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度而不会导致底层数据的复制切片的行为更为灵活切片的结构和字符串结构类似但是解除了只读限制切片的底层数据虽然也是对应数据类型的数组但是每个切片还有独立的长度和容量信息切片赋值和函数传参数时也是将切片头信息部分按传值方式处理因为切片头含有底层数据的指针所以它的赋值也不会导致底层数据的复制数组数组的赋值比较灵活既可以在初始化的时候不进行赋值使用默认的零值如下方式一初始化给定初值方式二初始化通过下标方式对元素进行赋值方式三也通过方式二和方式三混用的方式进行方式四定义长度为的型数组元素全部为定义长度为的型数组元素为定义长度为的型数组元素为定义长度为的型数组元素为字符串字符串结构由两个信息组成第一个是字符串指向的底层字节数组第二个是字符串的字节的长度字符串其实是一个结构体对字符串的复制操作是对字符串结构进行复制并不会涉及底层字节数组的复制如果一个字符串变量我们可以直接使用对其进行使用但是不能通过使用的方式对字符串的元素进行修改切片对于类型和数组的最大不同是切片的类型和长度信息无关只要是相同类型元素构成的切片均对应相同的切片类型切片是一种简化版的动态数组这是切片类型的灵魂除了构造切片和遍历切片之外添加切片元素删除切片元素都是切片处理中经常遇到的问题使用内置函数添加切片元素添加的元素可以是个如果添加的位置在切片的首位一般都会导致内存的重新分配效率比在尾部添加要低很多删除就可以对已有的切片再进行切片操作获得新的切片比如删除位置为的切片元素删除首尾元素可以看作是删除的特殊操作结构体结构体是多种数据类型的集合比如可以保护指向自身类型的指针来实现链表一个结构体可以匿名包含其它类型如果一个结构中包含多个其它类型这些类型中有多个同名字段访问这些同名结构体成员时不指定所属类型的话从最外层开始到最浅深度为止如果这些具有相同名称的结构体成员位于同级深度的话必须通过指定类型的方式进行访问如果类型中包含小写开头的字段小写字段只能在类型声明所在的包中进行访问函数方法和接口函数对应操作序列是程序的基本组成元素语言中的函数有具名和匿名之分具名函数一般对应于包级的函数是匿名函数的一种特例当匿名函数引用了外部作用域中的变量时就成了闭包函数闭包函数是函数式编程语言的核心方法是绑定到一个具体类型的特殊函数语言中的方法是依托于类型的必须在编译时静态绑定接口定义了方法的集合这些方法依托于运行时的接口对象因此接口对应的方法是在运行时动态绑定的语言通过隐式接口机制实现了鸭子面向对象模型函数对于函数需要注意的是函数名的首字母大小写大写表示是可以引出的小写表示是只能包内或者绑定类型调用在调用普通函数或方法前加上关键字就完成了所需要的语法当语句被执行时跟在后面的函数会被延迟执行直到包含该语句的函数执行完毕时后的函数才会被执行不论包含语句的函数是通过正常结束还是由于导致的异常结束可以在一个函数中执行多条语句它们的执行顺序与声明顺序相反语句经常被用于处理成对的操作如打开关闭连接断开连接加锁释放锁通过机制不论函数逻辑多复杂都能保证在任何执行路径下资源被释放释放资源的应该直接跟在请求资源的语句后在调用函数时使用关键字表示在在退出调用代码块时执行该操作对于需要注意如下几点使用调用函数时其参数就会被实时解析即使用初次定义的值执行顺序为先进后出可以读取有名的返回值输出函数执行的是将最终的值赋值给返回值列表所声明的值因此上述事例可以看作在调用函数前执行了返回值的赋值操作然后退出函数时最终执行语句中的只作为传值不影响原来的值在后执行方法方法一般是面向对象编程的一个特性在语言中方法对应一个类对象的成员函数是关联到具体对象上的虚表中的但是语言的方法却是关联到类型的这样可以在编译阶段完成方法的静态绑定一个面向对象的程序会用方法来表达其属性对应的操作这样使用这个对象的用户就不需要直接去操作对象而是借助方法来做这些事情比如声明如下的代码即类型具有了方法那么在调用时直接可以使用输出当调用一个函数时会对其每一个参数值进行拷贝如果一个函数需要更新一个变量或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝这种情况下我们就需要用到指针了对应到我们这里用来更新接收器的对象的方法当这个接受者变量本身比较大时我们就可以用其指针而不是对象来声明方法调用时仍然可以使用能够自动地将类型转化为的引用调用对应的方法如果一个类型中包含多个类型每个类型有同名的方法访问也是跟类型访问一样维持最浅深度访问否则就需要通过指定类型的方式来达到该目的注意到在中都嵌入了匿名成员类型为什么要嵌入一个没有任何子成员类型的匿名成员类型呢答案是匿名类型的方法集简短的点运算符语法可以用于选择匿名成员嵌套的成员也可以用于访问它们的方法实际上外层的结构体不仅仅是获得了匿名成员类型的所有成员而且也获得了该类型导出的全部的方法这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象组合是语言中面向对象编程的核心异常的类型系统会在编译时捕获很多错误但有些错误只能在运行时检查如数组访问越界空指针引用等这些运行时错误会引起异常一般而言当异常发生时程序会中断运行并立即执行在该可以先理解成线程在第章会详细介绍中被延迟的函数机制随后程序崩溃并输出日志信息日志信息包括和函数调用的堆栈跟踪信息通常是某种错误信息对于每个日志信息中都会有与之相对的发生时的函数调用堆栈跟踪信息直接调用内置的函数也会引发异常函数接受任何值作为参数当某些不应该发生的场景发生时我们就应该调用捕获异常如果在函数中调用了内置函数并且定义该语句的函数发生了异常会使程序从中恢复并返回导致异常的函数不会继续运行但能正常返回在未发生时调用会返回直接触发或者手动触发支持抛出任意类型的异常而不仅仅是类型的错误函数调用的返回值和函数的输入参数类型一致它们的函数签名如下语言函数调用的正常流程是函数执行返回语句返回结果在这个流程中是没有异常的因此在这个流程中执行异常捕获函数始终是返回另一种是异常流程当函数调用抛出异常函数将停止执行后续的普通语句但是之前注册的函数调用仍然保证会被正常执行然后再返回到调用者对于当前函数的调用者因为处理异常状态还没有被捕获和直接调用函数的行为类似在异常发生时如果在中执行调用它可以捕获触发时的参数并且恢复到正常的执行流程函数必然是在正常的非异常执行流程中执行没有注册也没法调用到那棵树看起来生气了正确的捕获方式于谦老师三大爱好抽烟喝酒烫头同作用域后的代码无法调用到郭德纲经常抖包袱上面程序中两个调用都不能捕获任何异常在第一个调用执行时函数必然是在正常的非异常执行流程中这时候调用将返回发生异常时第二个调用将没有机会被执行到因为调用会导致函数马上执行已经注册的函数后返回其实函数调用有着更严格的要求我们必须在函数中直接调用如果中调用的是函数的包装函数的话异常的捕获工作将失败必须要和有异常的栈帧只隔一个栈帧函数才能正常捕获异常换言之函数捕获的是祖父一级调用函数栈帧的异常刚好可以跨越一层函数接口终于到接口了前文说过我们通过接口来实现程序运行过程中的动态绑定这是语言最重要的机制之一接口类型是对其它类型行为的抽象和概括因为接口类型不会和特定的实现细节绑定在一起通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力很多面向对象的语言都有相似的接口概念但语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型所谓鸭子类型说的是只要走起路来像鸭子叫起来也像鸭子那么就可以把它当作鸭子语言中的面向对象就是如此我们可以不管这只鸭子是用几只脚走路还是带着带着扩音器叫甚至它还可以开车即使我们不需要一只鸭子学会开车但是它满足所需的条件只要走起路来像鸭子叫起来也像鸭子如果一个对象只要看起来像是某种接口类型的实现那么它就可以作为该接口类型使用这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不用去破坏这些类型原有的定义当我们使用的类型来自于不受我们控制的包时这种设计尤其灵活有用语言的接口类型是延迟绑定可以实现类似虚函数的多态功能例如我都知道知道绝大数鸟都会叫只不过叫声不一样而已可以做如下定义上面的就实现了这个接口虽然这种类只会叫注意到最后一点代码这里用到了接口的另一个特性用于类型断言如果返回的第一个值为反之则为断言类型的实例如果接口类型中嵌入了其它接口那么该接口默认也实现了内嵌的接口所声明的方法并且也遵循最浅访问原则即按照最浅的栈来访问接口所声明的方法跟方法的顺序没有关系如果两个接口值的动态类型相同但是这个动态类型是不可比较的比如切片将它们进行比较就会失败并且反射反射在很多语言中都有其妙用在计算机科学领域反射是指一类应用它们能够自描述和自控制提供了一种机制在编译时不知道类型的情况下可更新变量运行时查看值调用方法以及直接对他们的布局进行操作的机制称为反射为什么使用反射打个比方有时候我们需要一个函数可以处理各种类型的值在不知道类型的情况下你可能会这么写伪代码一些操作一些操作自定义的结构体一些操作这边存在一个问题类型很多这个函数会写的非常长而且还可能存在自定的类型也就是说这个判断日后可能还要一直改因为无法知道未知值到底属于什么类型无法透视一个未知类型的时候以上代码其实不是很合理这时候就需要有反射来帮忙你处理反射使用和函数从接口中获取目标对象的信息轻松完成目的反射具体能做什么获取变量内部信息提供了两种类型来进行访问接口变量的内容类型作用获取输入参数接口中的数据的值如果为空则返回注意是动态获取输入参数接口中的值的类型如果为空则返回注意是会返回目标数据的类型比如指针等返回目标数据的的值比如上文的输出更深一层在以上操作发生的时候反射将接口类型的变量转为了反射的接口类型的变量比如上文实际上返回的是和的接口对象可以根据跟踪一下相关函数返回类型便知的反射我是一个学生获取目标对象可以获取去这个类型的名称这个类型的名称是获取目标对象的值类型来获取其包含的字段的总数从开始获取所包含的通过方法来获取所对应的值第个字段是通过来获取里头的方法第个方法是输出这个类型的名称是第个字段是第个字段是第个方法是匿名或嵌入字段的反射匿名字段这里需要加一个号可以把的详情都给打印出来会发现有说明是匿名字段取出这个学生的名字的详情打印出来获取匿名字段的值的详情输出判断传入的类型是否是我们想要的类型通过来判断对比的值是否是类型输出通过反射修改内容修改值必须是指针类型否则不可行不是指针类型没法进行修改操作获取指针所指向的元素获取目标的的封装小学生如果是整型的话输出小学生通过反射调用方法我的名字是获取方法控制权官方解释返回的名为的方法的已绑定到的持有值的状态的函数形式的封装拼凑参数调用函数输出我的名字是看看的实现反射主要与的类型相关只有类型才有反射一说如果有兴趣可以看一下和会发现其实传入参数的时候已经被转为接口类型了以下为截取的源代码通过来打印任意值的类型和枚举它的方法总结上述详细说明了的反射的各种功能和用法都附带有相应的示例相信能够在工程应用中进行相应实践总结一下就是反射可以大大提高程序的灵活性使得有更大的发挥余地反射必须结合才玩得转变量的要是的也就是变量才有反射一说反射可以将接口类型变量转换为反射类型对象反射使用和函数从接口中获取目标对象信息反射可以将反射类型对象转换为接口类型变量已知的类型遍历的获取其反射可以修改反射类型对象但是其值必须是想要利用反射修改对象状态前提是是即不然会产生通过反射可以动态调用方法因为本身不支持模板因此在以往需要使用模板的场景下往往就需要使用反射来实现和线程有时被称为轻量级进程是程序执行流的最小单元一个标准的线程由线程当前指令指针寄存器集合和堆栈组成另外线程是进程中的一个实体是被系统独立调度和分派的基本单位线程自己不拥有系统资源只拥有一点儿在运行中必不可少的资源但它可与同属一个进程的其它线程共享进程所拥有的全部资源线程拥有自己独立的栈和共享的堆共享堆不共享栈线程的切换一般也由操作系统调度协程又称微线程与子例程或者称为函数一样协程也是一种程序组件相对子例程而言协程更为一般和灵活但在实践中使用没有子例程那样广泛和线程类似共享堆不共享栈协程的切换一般由程序员在代码中显式控制它避免了上下文切换的额外耗费兼顾了多线程的优点简化了高并发程序的复杂在语言中每一个并发的执行单元叫作一个如同本文开始的示例函数启动了一个只需要通过一个简单的关键字当一个程序启动时其主函数即在一个单独的中运行我们叫它新的会用语句来创建在语法上语句是一个普通的函数或方法调用前加上关键字语句会使其语句中的函数在一个新创建的中运行而语句本身会迅速地完成示例中的用来获取键盘的输出主则用来读取键盘输入实现了两种并发形式多线程共享内存其实就是或者等语言中的多线程开发并发模型是语言特有的也是语言推荐的的并发模型是通过和来实现的是语言中并发的执行单位有点抽象其实就是和传统概念上的线程类似可以理解为线程是语言中各个并发结构体之前的通信机制通俗的讲就是各个之间通信的管道有点类似于中的管道线程实现模型调度器的三个基本对象简称的协程和我们常见的线程一样拥有其调度器代表协程也就是每次代码中使用关键词时候会创建的一个对象工作线程代表一个处理器又称上下文另外还有一个代表着一个调度器它维护有存储空闲的队列和空闲的队列可运行的队列自由的队列以及调度器的一些状态信息等三者的关系与特点每一个运行的都必须绑定一个线程创建后会去检查并执行对象每一个保存着一个协程的队列除了每个自身保存的的队列外调度器还拥有一个全局的队列从队列中提取并执行的个数就是最大启动时固定的一般不修改的个数和的个数不一定一样多会有休眠的或不绑定最大是用一个全局数组来保存的并且维护着一个全局的空闲链表局部队列与全局队列的关系全局任务队列会和各个本地任务队列按照一定的策略互相交换没错就是协程任务交换任务的执行顺序是先从本地队列找本地没有则从全局队列找转移局部与全局全局个数个数局部与局部一次性转移一半从入队到执行当我们创建一个对象就是它会加入到本地队列或者全局队列如果还有空闲的则创建一个绑定该注意这里此前必须还没绑定过的否则不满足空闲的条件细节点先找到一个空闲的如果没有则直接返回个数不会占用超过自己设定的个数在被绑定后就会初始化自己的队列此时是一个空队列注意这里的无论在哪个中创建了一个只要有空闲的就会引起新的创建不需考虑当前所在中所绑的的队列是否已满新创建的所绑的的初始化队列会从其他队列中取任务过来这里留下第一个问题如果一个任务执行时间太长它就会一直占用线程由于队列的任务是顺序执行的其它任务就会阻塞如何避免该情况发生会启动一个底层线程循环执行能找到的任务这里的寻找的从下面几方面找当前所绑的队列中找去别的的队列中找去全局队列中找任务的执行顺序是先从本地队列找本地没有则从全局队列找程序启动的时候首先跑的是主线程然后这个主线程会绑定第一个入口函数其实是作为一个来执行解答问题协程的切换时间片是也就是说最多执行就会被切换到下一个这个过程又被称为中断挂起原理程序启动时会首先创建一个特殊的内核线程用来监控和管理其内部是一个循环记录所有的任务的计数会在每执行一个任务后递增如果检查到一直没有递增说明这个一直在执行同一个任务如果超过就在这个任务的栈信息里面加一个标记然后这个任务在执行的时候如果遇到非内联函数调用就会检查一次这个标记然后中断自己把自己加到队列末尾执行下一个如果没有遇到非内联函数调用有时候正常的小函数会被优化成内联函数的话那就会一直执行这个任务直到它自己结束如果是个死循环并且的话那么一直只会只有一个与一个且队列中的其他不会被执行例子下面的这段代码不会被输出强制观察输出非内联函数这行注释打开将导致的输出复制代码中断后的恢复中断的时候将寄存器里的栈信息保存到自己的对象里面当再次轮到自己执行时将自己保存的栈信息复制到寄存器里面这样就接着上次之后运性能调优看完上面的内容相信你已经知道就是中包的一个函数它设置了的最多的个数这也就直接导致了最多的个数是多少而的个数就决定了各个队列能同时被多少个线程来进行调取执行故我们一般将的个数设置为的核数且需要注意的是版本之前的默认是版本之后的默认是的数量由环境变量中的决定通常来说它是和核心数对应例如在的服务器上回启动个线程会有很多个每个会将从一个就绪的队列中做操作为了减小锁的竞争通常情况下每个会负责一个队列三者关系如下图所示以上这个图讲的是两个线程内核线程的情况一个会对应一个内核线程一个也会连接一个上下文一个上下文相当于一个处理器一个上下文连接一个或者多个为了运行线程必须保存上下文上下文的数量在启动时设置为环境变量的值或通过运行时函数通常情况下在程序执行期间不会更改上下文数量固定意味着只有固定数量的线程在任何时候运行代码我们可以使用它来调整进程到个人计算机的调用例如核在个线程上运行代码图中正在执行的为蓝色的处于待执行状态的为灰色的灰色的形成了一个队列语言里启动一个很容易就行所以每有一个语句被执行队列就在其末尾加入一个一旦上下文运行直到调度点它会从其中弹出设置堆栈和指令指针并开始运行你可能会想为什么一定需要一个上下文我们能不能直接除去上下文让的挂到上呢答案是不行需要上下文的目的是让我们可以直接放开其他线程当遇到内核线程阻塞的时候一个很简单的例子就是系统调用一个线程肯定不能同时执行代码和系统调用被阻塞这个时候此线程需要放弃当前的上下文环境以便可以让其他的被调度执行如上图左图所示中的执行了然后就创建了一个也有可能来自线程缓存转向右图然后丢弃了等待的返回值接受了将继续执行队列中的其他当系统调用结束后会偷一个上下文如果不成功就把它的放到一个全局的中将自己置于线程缓存中并进入休眠状态全局是各个在运行完自己的本地的后用来拉取新的地方也会周期性的检查这个全局上的否则全局上的可能得不到执行而饿死均衡的分配工作按照以上的说法上下文会定期的检查全局的队列中的以便自己在消费掉自身队列的时候有事可做假如全局队列中的也没了呢就从其他运行的中的的里偷每个中的不同导致他们运行的效率和时间也不同在一个有很多和的环境中不能让一个跑完自身的就没事可做了因为或许其他的有很长的队列要跑得需要均衡该如何解决呢算法每个新的都会维护这自己的栈当程序启动的时候调度器会创建第一个首先按照图片上的描述管理员找来土拨鼠并分配给土拨鼠一个小车土拨鼠开始推车小车拿走一批砖我们称这些砖被放在本地可运行的队列这个土拨鼠就这么认真努力的开始完成自己的工作有一天你在程序中提高一下程序的并发处理能力创造了很多的砖这时候这么多的砖块已经不够这些土拨鼠去处理了于是调度器就是去仓库里面找到空闲的土拨鼠如果没有就创造一个土拨鼠当工厂管理员发现有个土拨鼠处理的很慢这个时候就会让他去处理但需要让出小车调度器会找到一个新的土拨鼠去处理这个推车上的当土拨鼠处理完这些的时候就需要调度器可运行的队列总去找当土拨鼠实在找不到就去别人的小车中枪走一半如果多次都抢不到那么土拨鼠就丢弃小车回到仓库里面睡觉去了如果土拨鼠赶上了系统调用或者网络的那么土拨鼠就等待他这时候也不能让这个土拨鼠来阻碍其他的砖的运行这时候调度器就会找来新的土拨鼠去完成剩余的工作这时候新的土拨鼠就会抢走车去工作了当这个土拨鼠的任务完成了时候发现自己的小车已经被别人抢跑了这个土拨鼠没有什么事情就回到仓库里面睡觉去了优点开销小的虽然能够提供丰富的例如配置自己的亲和性申请资源等等线程在得到了很多与进程相同的控制权的同时开销也非常的大在中则不需这些额外的开销所以一个的程序中可以支持级别的每个协程默认占用内存远比的线程少线程调度性能好在的程序中操作系统级别的线程调度通常不会做出合适的调度决策例如在时内存必须要达到一个一致的状态在机制里可以控制的调度从而在一个合适的时间进行在应用层模拟的线程它避免了上下文切换的额外耗费兼顾了多线程的优点简化了高并发程序的复杂度缺点协程调度机制无法实现公平调度如果说是语音程序的并发体的话那么它们之间的通信机制一个是一个通信机制它可以让一个通过它给另一个发送值信息每个都有一个特殊的类型也就是可发送数据的类型和类似也一个对应创建的底层数据结构的引用当我们复制一个或用于函数参数传递时我们只是拷贝了一个引用因此调用者何被调用者将引用同一个对象和其它的引用类型一样的零值也是一个有发送和接受两个主要操作都是通信行为一个发送语句将一个值从一个通过发送到另一个执行接收操作的发送和接收两个操作都是用运算符在发送语句中运算符分割和要发送的值在接收语句中运算符写在对象之前一个不使用接收结果的接收操作也是合法的还支持操作用于关闭随后对基于该的任何发送操作都将导致异常对一个已经被过的之行接收操作依然可以接受到之前已经成功发送的数据收到就没有了如果中已经没有数据的话讲产生一个零值的数据使用内置的函数就可以关闭一个输出上面得例子说明向一个通道发送数据并通过关闭通道的实际关闭时间在通道内即使有缓存队列数据完全读完之后才会关闭后注意重复关闭会导致向关闭的发送数据会从关闭的读数据不会但是读出的数据是类似的默认值比如类型的关闭之后读取到的值为通过的方式确定通道是否关闭无缓存的一个基于无缓存的发送操作将导致发送者阻塞直到另一个在相同的上执行接收操作当发送的值通过成功传输之后两个可以继续执行后面的语句反之如果接收操作先发生那么接收者也将阻塞直到有另一个在相同的上执行发送操作基于无缓存的发送和接收操作将导致两个做一次同步操作因为这个原因无缓存有时候也被称为同步当通过一个无缓存发送数据时接收者收到数据发生在唤醒发送者之前在讨论并发编程时当我们说事件在事件之前发生我们并不是说事件在时间上比时间更早我们要表达的意思是要保证在此之前的事件都已经完成了例如在此之前的更新某些变量的操作已经完成你可以放心依赖这些已完成的事件了有缓存的带缓存的内部持有一个元素队列队列的最大容量是在调用函数创建时通过第二个参数指定的关于无缓存或带缓存之间的选择或者是带缓存的容量大小的选择都可能影响程序的正确性无缓存更强地保证了每个发送操作与相应的同步接收操作但是对于带缓存这些操作是解耦的同样即使我们知道将要发送到一个的信息的数量上限创建一个对应容量大小带缓存也是不现实的因为这要求在执行任何接收操作之前缓存所有已经发送的值如果未能分配足够的缓冲将导致程序死锁的缓存也可能影响程序的性能如何使用直接的通信通信基于的多路复用一定程度上可以类比于中的多路复用中的后者相当于提供了对多个事件的统一管理而中的相当于提供了对多个的统一管理当然这只是在上的一种使用方法值得注意的是中的只能跳到这一层使用的时候一般配合循环使用像下面这样因为正常里面的流程也就执行一遍这么来看中的就稍显鸡肋了所以使用的时候一般配置使用定义在循环这一层基于的多路复用可以直接取到中的值当我们使用来操作的时候一旦关闭循环自动结束超时控制在很多操作情况下都需要超时控制利用实现超时控制下面是一个简单的示例类似的上面的可以换成其他的任何异常控制流生产者消费者模型利用缓冲可以很轻松的实现生产者消费者模型上面的示例其实就是一个简单的生产者消费者模型实现无缓冲信道是消息来一个接收一个依次进入流出缓冲信道则是一个一个存储然后一起流出去的上下文前面在聊一聊框架的时候提到了上下文的概念上一个用来列举框架中全局变量的传值和设置还类比了框架中的这一次我们就来聊一聊中的标准库的梳理上下文概念在中的常用情景问题引入在列举上下文的用法之前我们来看一个简单的示例协程泄露打印已有协程数量新起子协程输出复制代码我们在主协程创建一个子协程利用打印当前协程数量可以知道在协程被唤醒之后退出前的那一刻程序中仍然存在两个协程可能我们已经习惯了这种现象杀掉主协程的时候退出会附带把子协程干掉这种让子协程自生自灭的做法其实是不太优雅的解决方式管道通知退出关于控制子协程的退出可能有人会想到另一个做法我们再来看另一个例子主动通知协程退出利用管道通知协程退出监听通知正常执行输出复制代码上面这个例子可以说相对优雅一些在协程里面主动通知子协程退出不过两者之间的仍然存在依赖假如子协程又创建了新的协程这个时候通知只能到达子新协程是无法感知的因此同样可能会存在协程泄露的现象上下文管理下面我们会引进一个利用标准库包的处理方式通过上下文管理子协程的生命周期官方概念在此之前先来复习下标准库的概念上下文带着截止时间信号还有在之间提供值读写返回该上下文的截止时间如果没有设置截至时间第二个值返回返回一个管道上下文结束时该方法会执行经常结合块监听当执行时会返回一个解释退出原因上下文值存储字典其中较为常用的是函数它会返回一个包装了函数的子上下文当我们认为协程需要结束的时候调用其返回值函数子上下文会关闭内部封装的管道来通知相应协程返回新的子上下文将原上下文我们继续引入一个协程泄漏的来看下具体使用例子使用示例阻塞两个子协程预期只有一个协程会正常退出起个协程抢着输入到一有输入立刻返回每一层循环泄漏两个协程程序输出复制代码可以看到随着循环次数增加除去协程每一轮都泄漏两个协程所以程序退出之前最终有个协程接下来我们引入上下文的概念来管理子协程创建上下文用于管理子协程结束前清理未结束协程随机触发某个子协程退出每一层循环泄漏两个协程给它点时间异步清理协程程序分析可以看到函数对管道进行轮询程序只有两个分支方可上下文通知结束收到管道传入的值我们在函数结束前了函数因此会在程序退出前把相应的子协程掉所以可以看到如下输出每一轮都只剩下一个协程程序输出复制代码截止超时退出除了我们手动调用函数退出之外标准库还提供了两个限时退出的操作以及函数可以传入一个时间点或者时间段表示经过该时间之后自动调用该上下文的函数使用示例我们摘取官网一个由于传入时间为微妙因此在选择块中分支会先执行输出请求超时关于上下文函数的用法还可以判断一个请求是否超时程序示例初始化请求使用生成子上下文并且设置截止时间为毫秒绑定超时上下文到这个请求发起请求如果请求没问题打印到控制台我们给请求限时毫秒执行可以看到程序打印上下文已经过期了输出示例复制代码值读写如前面所示还提供了一个读写的函数签名上下文值存储字典复制代码关于它的用法之前在聊一聊的文章中列举过可以这样子使用示例获取顶级上下文在上下文写入值注意需要返回新的上下文复制代码是一个非空的顶级上下文只要程序还在它就不会取消也没有嵌入值经常被函数所使用关于的值读取在规范中有一个约定不应使用它来封装寿命长期的参数一般仅用于传输一个请求作用域的值关于程序的业务参数应该暴露出来放在函数参数列表中以提高可读性的作用域上面列举的几个用法可以说比较常见前面曾经拿中的来类比中的全局上下文但是严格来说其实这个是带有争议的因为的上下文是贯穿整个程序的生命周期往往会附带一些全局设置项在中比较倾向于用于控制一个子程序块和的全局上下文比较的是比较短暂的里面的常用情景用于贯穿一个子协程的任务片段如上面用于把控子协程的退出或者是在网络框架中表示一个请求管理其开始至结束如在框架中的从到并不是全局的另外在参考链接处有一篇比较有意思的争论有个作者吐槽了关于上下文的泛滥关于上下文的辩论在该文章的评论可谓见仁见智总的来说上下文应该着重用于管理子协程或者是有目地嵌入函数链的生命周期中而不是约定俗成在每个方法都传播上下文参考链接关于上下文泛滥的吐槽图片',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 16:22:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/go/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>go</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Golang简洁入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2018-05-20T05:14:56.000Z" title="发表于 2018-05-20 13:14:56">2018-05-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.103Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/"><header><a href="/tags/go/" tabindex="-1" itemprop="url">go</a><h1 id="CrawlerTitle" itemprop="name headline">Golang简洁入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2018-05-20T05:14:56.000Z" title="发表于 2018-05-20 13:14:56">2018-05-20</time><time itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.103Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></header><h1 id="为什么选择golang"><a href="#为什么选择golang" class="headerlink" title="为什么选择golang?"></a>为什么选择golang?</h1><h1 id="从一个程序说起"><a href="#从一个程序说起" class="headerlink" title="从一个程序说起"></a>从一个程序说起</h1><h2 id="为什么我不从基础说起"><a href="#为什么我不从基础说起" class="headerlink" title="为什么我不从基础说起"></a>为什么我不从基础说起</h2><p>​		在这里，假定的是你已经有了一定的程序基础，能够明白字符串，结构体等是什么，为了避免大几百页码的书本讲述，如果认认真真读下去，需要耗费比较长的时间，而其中的很多特性在看了新的章节又会忘了之前的。所以，我决定还是从编程实际的例子出发，尽量在一个程序中把大部分重要特性放进去，如果需要纠结里面的底层技术细节，或为了准备面试，则需要把厚厚的教科书拿出来，把自己遗忘或不确定的内容进行翔实地复习。</p>
<p>​		那么，现在我们开始。</p>
<h2 id="Golang开发环境搭建"><a href="#Golang开发环境搭建" class="headerlink" title="Golang开发环境搭建"></a>Golang开发环境搭建</h2><ul>
<li><p>Linux环境搭建</p>
<p>建议使用Manjaro，或者MacOS，如果对MacOS下的brew命令或者Manjaro下的软件包源设置有疑问，可以参考我的博客文章。</p>
</li>
<li><p>安装go</p>
<ul>
<li>Manjaro: <code>sudo pacman -S go</code></li>
<li>MacOS: <code> brew install go</code></li>
</ul>
</li>
<li><p>安装开发工具Goland</p>
<ul>
<li>Manjaro: <code>sudo pacman -s goland</code></li>
<li>MacOS: <code>brew cask install goland</code></li>
</ul>
</li>
</ul>
<h2 id="实现cd命令"><a href="#实现cd命令" class="headerlink" title="实现cd命令"></a>实现cd命令</h2><p>​		我之前遇到一道华为的笔试题，要求用Golang实现linux下的类cd命令，不考虑”?&amp;,$”等字符，只含数字字母与”&#x2F;~.”， 也不考虑多个”&#x2F;“连续出现的情况 。如输入<code>cd ~/a/b1/c/</code>, 能够打印出当前路径: <code> ~/a/b1/c</code>。题目不怎么难，但是我觉得这是一个很好的例子可以用来说明Go语言的绝大部分特性的例子。源码链接: <code>https://github.com/shippomx/gocd.git</code>. 建议你现在就把源码clone下来，对比我的这个教程，看懂源码，当然我里面可能有些地方可能实现方法有些繁琐，你如果有更好的解决方法，不妨提issue给我。</p>
<p>&#x2F;&#x2F; main.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gocd/keyboard&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Ready to receive keyborad input.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> keyboard.PrintLine() <span class="comment">// 无缓冲的chan 接收要出现在发送之前</span></span><br><span class="line">	keyboard.Readline()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x2F;&#x2F; key.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> keyboard</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> END <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inDirs []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> ChanInput <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> ChanClose <span class="keyword">chan</span> END</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ChanInput = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	ChanClose = <span class="built_in">make</span>(<span class="keyword">chan</span> END, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	homeDir, _ := os.UserHomeDir()</span><br><span class="line">	inDirs = strings.Split(homeDir[<span class="number">1</span>:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为无缓冲channel通道的内容生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Readline</span><span class="params">()</span></span> &#123;</span><br><span class="line">	readLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	curPath	:= <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 作为无缓冲channel通道的内容生产者</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;$ &quot;</span>)</span><br><span class="line">		scanner.Scan()</span><br><span class="line">		cmd := scanner.Text()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> cmd == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">			ChanClose &lt;- <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.HasPrefix(cmd, <span class="string">&quot;cd &quot;</span>) &#123;</span><br><span class="line">			args := strings.Split(cmd, <span class="string">&quot; &quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			curPath, err = assemblePath(args[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cmd == <span class="string">&quot;pwd&quot;</span> &#123;</span><br><span class="line">			curPath, err = assemblePath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">			ChanInput &lt;- curPath</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintLine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> curPath := &lt;- ChanInput:</span><br><span class="line">			fmt.Println(curPath)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ChanClose:</span><br><span class="line">			<span class="built_in">close</span>(ChanInput)</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assemblePath</span><span class="params">(cmd <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> cmd == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cmd = <span class="string">&quot;.&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	idx := strings.IndexAny(cmd, <span class="string">&quot;~&quot;</span>) <span class="comment">// homeDir 只能为第一个字符</span></span><br><span class="line">	<span class="keyword">if</span> idx &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;cd: no such file or directory: &quot;</span> + cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(cmd, <span class="string">&quot;...&quot;</span>) &#123; <span class="comment">// 不考虑连续多个的...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;cd: no such file or directory: &quot;</span> + cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(cmd[<span class="number">0</span>]) == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">		inDirs = []<span class="type">string</span>&#123;&#125; <span class="comment">//代表从根目录进行计算统计</span></span><br><span class="line">	&#125;</span><br><span class="line">	dirs := strings.Split(cmd, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">		<span class="keyword">switch</span> dir &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;&quot;</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;.&quot;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;..&quot;</span>:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(inDirs) &lt; <span class="number">1</span> &#123;</span><br><span class="line">				inDirs = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				inDirs = inDirs[:<span class="built_in">len</span>(inDirs)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			inDirs = <span class="built_in">append</span>(inDirs, dir)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	curPath := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, dir := <span class="keyword">range</span> inDirs &#123;</span><br><span class="line">		curPath += <span class="string">&quot;/&quot;</span> + dir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> curPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		curPath = <span class="string">&quot;/&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curPath, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上述两个文件引入了Golang的一大特性，协程，go routine。注意主程序本身也是一个协程。建议先多熟悉几遍上面的源码文件，下面将逐步说明一些涉及到的概念。</p>
<h1 id="知识点解析"><a href="#知识点解析" class="headerlink" title="知识点解析"></a>知识点解析</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>​		我们先看main.go的结构。 首先声明了package main，表明这是一个main包，紧接着import了程序中的另一个package，最后则是主函数的声明。程序中只能有一个main包。对于其它的包，包名以当前源码文件所在的文件夹名命名，所以，一个文件夹下可以有多个源码文件，只要源码文件中声明的包名一致。</p>
<p>​		对于import声明，可以有几种不同的导入方式:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;a/b/c&quot;</span> <span class="comment">// 直接引入, 调用时使用c.FuncA</span></span><br><span class="line"><span class="keyword">import</span> myC <span class="string">&quot;a/b/c&quot;</span> <span class="comment">// 对包使用别名, 调用时使用myC.FuncA</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;a/b/c&quot;</span> <span class="comment">// 仅执行包中的init方法，不能调用该包成员</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;a/b/c&quot;</span> <span class="comment">// 使用此包内的成员时不带c前缀</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>使用规范</strong></p>
<ul>
<li>不要使用相对路径引入包(以GOPATH&#x2F;src作为根目录)</li>
<li>引入包顺序遵循 标准库，项目包，第三方包</li>
<li>第三方包按命名顺序</li>
</ul>
<h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><p>​		注意到main.go中有一个init函数，init函数每个包都可以有多个，如果当前包有引入其它包，必须等其它包的init函数执行完才执行，另外，执行当前包中的init函数的顺序与源码文件的asiic编码顺序有关。包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始化。</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>包中的函数和变量，如果定义的首字母大写，则表明可以导出，否则不能导出。如key.go中的Readline可以在main.go中使用keyboard.Readline进行调用，但是keyboard.readline则不能在包外使用。</p>
<p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字，建议使用<strong>驼峰式</strong>命名规则。</p>
<p>Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break      default       func     interface   select</span><br><span class="line">case       defer         go       map         struct</span><br><span class="line">chan       else          goto     package     switch</span><br><span class="line">const      fallthrough   if       range       type</span><br><span class="line">continue   for           import   return      var</span><br></pre></td></tr></table></figure>

<p>此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内建常量: true false iota nil</span><br><span class="line"></span><br><span class="line">内建类型: int int8 int16 int32 int64</span><br><span class="line">          uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">          float32 float64 complex128 complex64</span><br><span class="line">          bool byte rune string error</span><br><span class="line"></span><br><span class="line">内建函数: make len cap new append copy close delete</span><br><span class="line">          complex real imag</span><br><span class="line">          panic recover</span><br></pre></td></tr></table></figure>

<p>​		可以从key.go文件中看出命名遵循了上述规范。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。例如在key.go中<code>var inDirs []string</code>声明了一个元素为字符串的数组。声明可以在函数体，或者代码块内，也可以在函数外部进行声明。如果声明在函数体或代码块内，该声明的作用域在函数或代码块内。如果在函数体外，按可引用范围造成影响。</p>
<p>声明会对基础类型初始化，如果是结构体，则默认值为nil。如果是通道Channel, map, slice切片则需要配合make函数对这几种类型进行len, cap, data进行分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ChanInput <span class="keyword">chan</span> <span class="type">string</span> <span class="comment">// 声明一个接收发送类型为string的channel</span></span><br><span class="line">ChanInput = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">0</span>) <span class="comment">// 对channel进行初值化，对底层数据结构进行准备。创建了缓冲为0的channel</span></span><br></pre></td></tr></table></figure>

<p>对函数的声明则可能如以下几种伪码形式:</p>
<ul>
<li><p>常见形式 func fly(参数列表) (返回值列表) {函数体}</p>
</li>
<li><p>成员形式 func (b *Bird) fly(形参列表) (返回值列表) {函数体}</p>
</li>
<li><p>匿名函数形式一 var fly &#x3D; func(行参列表) (返回值列表) {函数体} </p>
<p>使用方式为 fly(实参列表)</p>
</li>
<li><p>匿名函数形式二 func(行参列表) (返回值列表) {函数体} (实参列表)</p>
</li>
</ul>
<p>函数参数列表规则示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">(a, b <span class="type">string</span>, c <span class="type">int</span>, names ...<span class="type">int</span>)</span></span> &#123;<span class="comment">//函数体&#125;</span></span><br></pre></td></tr></table></figure>

<p>如以上函数, a, b, c 均为指定了类型的参数，其中a, b因类型一致，可以对a的类型说明和b合并。names 是可变参数， 使用该函数时，可以不准备其实参。若传入，则names的类型均为int。一个函数最多有一个可变参数列表。标准库中的fmt.Println的最后一个参数就为可变参数。</p>
<p><strong>简短声明</strong>是Golang一个有趣的特性，只能在函数内使用，例如key.go中的<code>curPath := &quot;&quot;</code>就是简短声明，通过一个空字符串对curPath进行了声明及初始化，也可以用使用其它字符串进行简短声明。这个特性在获取函数返回值比较有用， 不用填提前声明过多变量，使程序显得简洁。</p>
<p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code>。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑，但是它们两者能够初始化的却有较大的不同。</p>
<ul>
<li><code>make</code> 的作用是<strong>初始化内置的数据结构</strong>，只能用于切片slice、哈希表map和 Channel，make(T, args) 返回的是 T 的引用；</li>
<li><code>new</code> 的作用是根据传入的类型在堆上分配一片内存空间并返回指向这片内存空间的指针，new(T) 返回的是 T 的指针，实际工程开发中，很少用到；</li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p> 使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在&#x3D;的左边，新值的表达式放在&#x3D;的右边。<code>a, _, c := 1, 2, &quot;3&quot;</code>通过该方式对a, c分别进行了赋值。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p> 变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。</p>
<p>在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个字符串可以用来表示一个密码或者一个颜色的名称。</p>
<p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型 <span class="comment">// 类型声明语句一般出现在包一级，如果新创建的类型名字的首字符大写，则在外部包也可以使用。</span></span><br></pre></td></tr></table></figure>

<p>一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型（例如用匿名的结构体定义变量）。如果是复杂的类型将会简洁很多，特别是结构体类型。</p>
<p>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。对方法集的介绍稍后在后面的章节会提到，这里先暂时不提。</p>
<p>自定义类型的自增长常量经常包含一个自定义的iota类型，允许你依靠编译器完成自增设置，iota类型类似于枚举类型。iota的出现会使后面的定义进行递增，若后面出现数字，仍然计数，但计数的值被新设置的值覆盖了，再次出现，从原来的iota值恢复递增。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RankLevel <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	RankBest    RankLevel = <span class="literal">iota</span> <span class="comment">// 0,</span></span><br><span class="line">	RankNoramal           = <span class="number">5</span>    <span class="comment">// 5 盖住了原本的iota计算的1</span></span><br><span class="line">	RankBad                      <span class="comment">// 5 盖住了原本的iota计算的2</span></span><br><span class="line">	RankBottom  = <span class="literal">iota</span>           <span class="comment">// 3</span></span><br><span class="line">	RankBelow                    <span class="comment">// 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(RankBad, RankBelow) <span class="comment">// 5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较 iota &lt;&lt; 1 和 1 &lt;&lt; iota的区别。</p>
<h3 id="数组、字符串与切片"><a href="#数组、字符串与切片" class="headerlink" title="数组、字符串与切片"></a>数组、字符串与切片</h3><p>切片作为Golang中最灵活的类型，我们在最初的示例程序中声明了一个 <code>var inDirs []string</code>切片用来存储目录文件夹的堆栈，然后调用golang内置的函数<code>	inDirs = strings.Split(homeDir[1:], &quot;/&quot;)</code>用来获取环境的home目录并将文件夹存储在<code>inDirs</code>中，假定当前的home路径是<code>/Users/admin</code>而<code>homeDir[1:]</code>则是通过slice切片，获取homeDir字符串的<code>Users/admin</code>部分，因为字符串本身是一个数组。</p>
<p>Go语言中数组、字符串和切片三者是密切相关的数据结构。这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是<strong>数组本身的赋值和函数传参都是以整体复制的方式</strong>处理的。Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。 切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信 息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。</p>
<p><strong>数组</strong></p>
<p>数组的赋值比较灵活，既可以在初始化的时候，不进行赋值，使用默认的零值(如下方式一)、初始化给定初值(方式二)、初始化通过下标方式对元素进行赋值(方式三)、也通过方式二和方式三混用的方式进行(方式四)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span>										<span class="comment">// 定义长度为3的int型数组, 元素全部为0</span></span><br><span class="line"><span class="keyword">var</span> b = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;				<span class="comment">// 定义长度为3的int型数组, 元素为 1, 2, 3</span></span><br><span class="line"><span class="keyword">var</span> c = [...]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">3</span>, <span class="number">1</span>: <span class="number">2</span>&#125;		<span class="comment">// 定义长度为3的int型数组, 元素为 0, 2, 3</span></span><br><span class="line"><span class="keyword">var</span> d = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>: <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串</strong></p>
<p>字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符 串的字节的长度。字符串其实是一个结构体，对字符串的复制操作是对字符串结构进行复制，并不会涉及底层字节数组的复制。</p>
<p>如果一个字符串变量<code>var str = &quot;one ok rock&quot;</code>，我们可以直接使用<code>str</code>对其进行使用，但是不能通过使用<code>str[2] = d</code>的方式对字符串的元素进行修改。</p>
<p><strong>切片</strong></p>
<p>对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。切片是一种简化版的动态数组，这是切片类型的灵魂。除了构造切片和遍历切片之外，添加切片元素、删除切片元素都是切片处理中经常遇到的问题。</p>
<p>使用内置函数<code>append</code>添加切片元素，添加的元素可以是N个，如果添加的位置在切片的首位，一般都会导致内存的重新分配，效率比在尾部添加要低很多。</p>
<p>删除就可以对已有的切片再进行切片操作，获得新的切片。比如删除位置为i的切片元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>删除首尾元素可以看作是删除的特殊操作。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是多种数据类型的集合，比如可以保护指向自身类型的指针来实现链表。一个结构体可以匿名包含其它类型。如果一个结构中包含多个其它类型，这些类型中有多个同名字段，访问这些同名结构体成员时不指定所属类型的话，从最外层开始，到最浅深度为止; 如果这些具有相同名称的结构体成员位于同级深度的话，必须通过指定类型的方式进行访问。</p>
<p>如果类型中包含小写开头的字段，小写字段只能在类型声明所在的包中进行访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TA <span class="keyword">struct</span> &#123;T <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TB <span class="keyword">struct</span> &#123;</span><br><span class="line">	TA </span><br><span class="line">	T <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TC <span class="keyword">struct</span> &#123;TB&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c TC</span><br><span class="line">	c.T = <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;c.T&quot;</span>, c.T)</span><br><span class="line">	fmt.Println(<span class="string">&quot;c.TA.T&quot;</span>, c.TA.T)</span><br><span class="line">	fmt.Println(<span class="string">&quot;c.TB.T&quot;</span>, c.TB.T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数、方法和接口"><a href="#函数、方法和接口" class="headerlink" title="函数、方法和接口"></a>函数、方法和接口</h2><p> 函数对应操作序列，是程序的基本组成元素。Go语言中的函数有具名和匿名之分： 具名函数一般对应于包级的函数，是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了闭包函数，闭包函数是函数式编程语言的核心。方法是绑定到一个具体类型的特殊函数，Go语言中的方法是依托于类型的，必须在编译时静态绑定。接口定义了方法的集合，这些方法依托于运行时的接口对象，因此接口对应的方法是在运行时动态绑定的。Go语言通过隐式接口机制实现了鸭子面向对象模型。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>对于函数，需要注意的是，函数名的首字母大小写， 大写表示是可以引出的；小写表示是只能包内，或者绑定类型调用。</p>
<p>在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p>
<p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后</p>
<p>在调用函数时使用<code>defer</code>关键字表示在在退出调用代码块时，执行该操作。对于<code>defer</code>需要注意如下几点:</p>
<ul>
<li>使用<code>defer</code>调用函数时，其参数就会被实时解析, 即使用初次定义的值</li>
<li><code>defer</code>执行顺序为先进后出</li>
<li><code>defer</code>可以读取有名的返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result++ &#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">	t := <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t = t+<span class="number">5</span> &#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (t <span class="type">int</span>) &#123;</span><br><span class="line">	t = <span class="number">3</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t = t+<span class="number">5</span> &#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">int</span>)</span></span> &#123; r = r + <span class="number">5</span>&#125;(r)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;f1&quot;</span>, f1())</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;f2&quot;</span>, f2())</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;f3&quot;</span>, f3())</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;f4&quot;</span>, f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f4 3</span><br><span class="line">f3 8</span><br><span class="line">f2 5</span><br><span class="line">f1 4</span><br></pre></td></tr></table></figure>

<p><code>return</code>函数执行的是将最终的值赋值给返回值列表所声明的值，因此上述事例可以看作在<code>defer</code>调用函数前执行了返回值的赋值操作，然后退出函数时，最终执行<code>defer</code>语句。f4中的r只作为传值copy，不影响原来的值。<code>defer</code>在<code>return</code>后执行。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法一般是面向对象编程(OOP)的一个特性，在C++语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是Go语言的方法却是关联到类型的，这样可以在编译阶段完成方法的静态绑定。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p>
<p>比如声明如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Temprature <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="type">int</span></span><br><span class="line"> 	temp <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Temprature)</span></span> checkNow() &#123;</span><br><span class="line">  fmt.Println(a.temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = Temprature&#123;now:<span class="number">2020</span>, temp: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure>

<p>即<code>Temprature</code>类型具有了<code>checkNow()</code>方法，那么在调用时直接可以使用<code>me.checkNow()</code>输出。</p>
<p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Temprature)</span></span> checkNow() &#123;</span><br><span class="line">  fmt.Println(a.temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时仍然可以使用<code>me.checkNow()</code>，golang能够自动地将类型转化为me的引用，调用对应的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TA <span class="keyword">struct</span> &#123;T <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TB <span class="keyword">struct</span> &#123;</span><br><span class="line">	TA</span><br><span class="line">	T <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TC <span class="keyword">struct</span> &#123;</span><br><span class="line">	TB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TA)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TA&quot;</span>, t.T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TB)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TB&quot;</span>, t.T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TC)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TC&quot;</span>, t.T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c TC</span><br><span class="line">	c.T = <span class="number">10</span></span><br><span class="line">	c.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类型中包含多个类型，每个类型有同名的方法，访问也是跟类型访问一样，维持最浅深度访问，否则就需要通过指定类型的方式来达到该目的。</p>
<p>注意到，在TC, TB中都嵌入了匿名成员类型，为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p>
<p>答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心。</p>
<h3 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h3><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p>
<p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。</p>
<p>直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;Invalid information...&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="recover-捕获异常"><a href="#recover-捕获异常" class="headerlink" title="recover 捕获异常"></a>recover 捕获异常</h3><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="type">string</span>)</span></span> (s *Syntax, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...直接触发panic, 或者手动触发panic</span></span><br><span class="line">  	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>panic</code>支持抛出任意类型的异常（而不仅仅是<code>error</code>类型的错误），<code>recover</code>函数调用的返回值和<code>panic</code>函数的输入参数类型一致，它们的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言函数调用的正常流程是函数执行返回语句返回结果，在这个流程中是没有异常的，因此在这个流程中执行<code>recover</code>异常捕获函数始终是返回<code>nil</code>。另一种是异常流程: 当函数调用<code>panic</code>抛出异常，函数将停止执行后续的普通语句，但是之前注册的<code>defer</code>函数调用仍然保证会被正常执行，然后再返回到调用者。对于当前函数的调用者，因为处理异常状态还没有被捕获，和直接调用<code>panic</code>函数的行为类似。在异常发生时，如果在<code>defer</code>中执行<code>recover</code>调用，它可以捕获触发<code>panic</code>时的参数，并且恢复到正常的执行流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123; <span class="comment">// 函数必然是在正常的非异常执行流程中，执行</span></span><br><span class="line">        log.Fatal(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123; <span class="comment">// 没有注册也没法调用到</span></span><br><span class="line">        log.Fatal(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;那棵树看起来生气了: &quot;</span>, msg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;== 正确的捕获方式 ==&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;于谦老师三大爱好: &quot;</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;we used a anonymous function to hide the recover function.&quot;</span>)</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Hakula Matata: &quot;</span>, msg)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;抽烟喝酒烫头&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;== 同作用域panic后的代码无法调用到 ==&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;郭德纲经常抖包袱: &quot;</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面程序中两个<code>recover</code>调用都不能捕获任何异常。在第一个<code>recover</code>调用执行时，函数必然是在正常的非异常执行流程中，这时候<code>recover</code>调用将返回<code>nil</code>。发生异常时，第二个<code>recover</code>调用将没有机会被执行到，因为<code>panic</code>调用会导致函数马上执行已经注册<code>defer</code>的函数后返回。</p>
<p>其实<code>recover</code>函数调用有着更严格的要求：我们必须在<code>defer</code>函数中直接调用<code>recover</code>。如果<code>defer</code>中调用的是<code>recover</code>函数的包装函数的话，异常的捕获工作将失败！</p>
<p>必须要和有异常的栈帧只隔一个栈帧，<code>recover</code>函数才能正常捕获异常。换言之，<code>recover</code>函数捕获的是祖父一级调用函数栈帧的异常（刚好可以跨越一层<code>defer</code><strong>函数</strong>）！</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>终于到接口了，前文说过，我们通过接口来实现程序运行过程中的动态绑定，这是Go语言最重要的机制之一。</p>
<p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型。所谓鸭子类型说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。Go语言中的面向对象就是如此，我们可以不管这只鸭子是用几只脚走路，还是带着带着扩音器叫，甚至它还可以开车(即使我们不需要一只鸭子学会开车)，但是它满足所需的条件: 只要走起路来像鸭子、叫起来也像鸭子。如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。这种 设计可以让你创建一个新的接口类型满足已经存在的具体类型却不用去破坏这些类型原有的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其灵活有 用。Go语言的接口类型是延迟绑定，可以实现类似虚函数的多态功能。</p>
<p>例如我都知道知道绝大数鸟都会叫，只不过叫声不一样而已。可以做如下定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bird <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Alaudidae <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alaudidae)</span></span> Sing() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;diu diu biu&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Corvus <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Corvus)</span></span> Sing() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;yah yah wah&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> bird Bird</span><br><span class="line">	bird = &amp;Alaudidae&#123;&#125;</span><br><span class="line">	bird.Sing()</span><br><span class="line">	bird = &amp;Corvus&#123;&#125;</span><br><span class="line">	bird.Sing()</span><br><span class="line"></span><br><span class="line">	_, ok := bird.(*Alaudidae)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	_, ok = bird.(*Corvus)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的Alaudidae，Corvus就实现了Bird这个接口，虽然这种Bird类只会叫^-^。注意到最后一点代码，这里用到了接口的另一个特性，用于类型断言。如果<code>ok = false</code>，返回的第一个值为nil, 反之则为断言类型的实例。</p>
<p>如果接口类型中嵌入了其它接口，那么该接口默认也实现了内嵌的接口所声明的方法，并且也遵循最浅访问原则。即按照最浅的栈来访问接口所声明的方法，跟方法的顺序没有关系。</p>
<p>如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射在很多语言中都有其妙用。在计算机科学领域，反射是指一类应用，它们能够 <strong>自描述</strong> 和 <strong>自控制 <strong>。Golang 提供了一种机制，在编译时</strong>不知道类型的情况下</strong>，可<strong>更新变量</strong>、运行时<strong>查看值</strong>、<strong>调用方法</strong>以及直接对他们的<strong>布局进行操作</strong>的机制，称为反射。</p>
<h3 id="为什么使用反射？"><a href="#为什么使用反射？" class="headerlink" title="为什么使用反射？"></a>为什么使用反射？</h3><p>打个比方，有时候我们需要一个函数可以处理各种类型的值。在不知道类型的情况下，你可能会这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">switch</span> value := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">	<span class="comment">// ...一些操作</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:	</span><br><span class="line">	<span class="comment">// ...一些操作	</span></span><br><span class="line"><span class="keyword">case</span> cbsStruct: <span class="comment">// 自定义的结构体	</span></span><br><span class="line">	<span class="comment">// ...一些操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边存在一个<strong>问题</strong>：类型很多，这个函数会写的非常长，而且还可能存在自定的类型，也就是说这个判断日后可能还要一直改，因为无法知道未知值到底属于什么类型。</p>
<p>无法透视一个未知类型的时候，以上代码其实不是很合理，这时候就需要有<strong>反射</strong>来帮忙你处理，<strong>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象的信息，轻松完成目的</strong>。</p>
<p>3.4.2 反射具体能做什么？</p>
<ul>
<li><ol>
<li>获取变量内部信息</li>
</ol>
</li>
</ul>
<p>reflect 提供了两种类型来进行访问接口变量的内容：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>reflect.ValueOf()</td>
<td>获取输入参数接口中的数据的值，如果为空则返回 <strong>0</strong> &lt;- 注意是 0</td>
</tr>
<tr>
<td>reflect.TypeOf()</td>
<td>动态获取输入参数接口中的值的类型，如果为空则返回 <strong>nil</strong> &lt;- 注意是 nil</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Offer Get&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// TypeOf会返回目标数据的类型，比如int/float/struct/指针等</span></span><br><span class="line">	reflectType := reflect.TypeOf(name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// valueOf返回目标数据的的值，比如上文的&quot;Offer Get&quot;</span></span><br><span class="line">	reflectValue := reflect.ValueOf(name)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;type: &quot;</span>, reflectType)</span><br><span class="line">	fmt.Println(<span class="string">&quot;value: &quot;</span>, reflectValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:  string</span><br><span class="line">value:  Offer Get</span><br></pre></td></tr></table></figure>

<p>更深一层：在以上操作发生的时候，反射将 “接口类型的变量” 转为了“反射的接口类型的变量”，比如上文实际上返回的是 reflect.Value 和 reflect.Type 的接口对象。（可以根据 ide 跟踪一下相关函数返回类型便知）</p>
<ul>
<li>2.struct 的反射</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> Hello()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是一个学生&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := Student&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;Offer Get&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取目标对象</span></span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	<span class="comment">// .Name()可以获取去这个类型的名称</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;这个类型的名称是:&quot;</span>, t.Name())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取目标对象的值类型</span></span><br><span class="line">	v := reflect.ValueOf(s)</span><br><span class="line">	<span class="comment">// .NumField()来获取其包含的字段的总数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		<span class="comment">// 从0开始获取Student所包含的key</span></span><br><span class="line">		key := t.Field(i)</span><br><span class="line">		<span class="comment">// 通过interface方法来获取key所对应的值</span></span><br><span class="line">		value := v.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d个字段是：%s:%v = %v \n&quot;</span>, i+<span class="number">1</span>, key.Name, key.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过.NumMethod()来获取Student里头的方法</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t.NumMethod(); i++ &#123;</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d个方法是：%s:%v\n&quot;</span>, i+<span class="number">1</span>, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个类型的名称是: Student</span><br><span class="line">第1个字段是：Id:int = 1 </span><br><span class="line">第2个字段是：Name:string = Offer Get</span><br><span class="line">第1个方法是：Hello:func(main.Student)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>匿名或嵌入字段的反射</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Student <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := People&#123;Student&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;Offer Get&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(p)</span><br><span class="line">	<span class="comment">// 这里需要加一个#号，可以把struct的详情都给打印出来</span></span><br><span class="line">	<span class="comment">// 会发现有Anonymous:true，说明是匿名字段</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t.Field(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取出这个学生的名字的详情打印出来</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取匿名字段的值的详情</span></span><br><span class="line">	v := reflect.ValueOf(p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, v.Field(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reflect.StructField&#123;Name:<span class="string">&quot;Student&quot;</span>, PkgPath:<span class="string">&quot;&quot;</span>, Type:(*reflect.rtype)(<span class="number">0x10b92e0</span>), Tag:<span class="string">&quot;&quot;</span>, Offset:<span class="number">0x0</span>, Index:[]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, Anonymous:<span class="literal">true</span>&#125;</span><br><span class="line">reflect.StructField&#123;Name:<span class="string">&quot;Name&quot;</span>, PkgPath:<span class="string">&quot;&quot;</span>, Type:(*reflect.rtype)(<span class="number">0x10ad080</span>), Tag:<span class="string">&quot;&quot;</span>, Offset:<span class="number">0x8</span>, Index:[]<span class="type">int</span>&#123;<span class="number">1</span>&#125;, Anonymous:<span class="literal">false</span>&#125;</span><br><span class="line">main.Student&#123;Id:<span class="number">1</span>, Name:<span class="string">&quot;Offer Get&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>判断传入的类型是否是我们想要的类型</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := Student&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;Offer Get&quot;</span>&#125;</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过.Kind()来判断对比的值是否是struct类型</span></span><br><span class="line">	<span class="keyword">if</span> k := t.Kind(); k == reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;bingo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	num := <span class="number">1</span>;</span><br><span class="line">	numType := reflect.TypeOf(num)</span><br><span class="line">	<span class="keyword">if</span> k := numType.Kind(); k == reflect.Int &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;bingo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bingo</span><br><span class="line">bingo</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li>通过反射修改内容</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := &amp;Student&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;Offer Get&quot;</span>&#125;</span><br><span class="line">	v := reflect.ValueOf(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改值必须是指针类型否则不可行</span></span><br><span class="line">	<span class="keyword">if</span> v.Kind() != reflect.Ptr &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;不是指针类型，没法进行修改操作&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指针所指向的元素</span></span><br><span class="line">	v = v.Elem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取目标key的Value的封装</span></span><br><span class="line">	name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name.Kind() == reflect.String &#123;</span><br><span class="line">		name.SetString(<span class="string">&quot;小学生&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, *s)</span><br><span class="line">	<span class="comment">// 如果是整型的话</span></span><br><span class="line">	test := <span class="number">888</span></span><br><span class="line">	testV := reflect.ValueOf(&amp;test)</span><br><span class="line">	testV.Elem().SetInt(<span class="number">666</span>)</span><br><span class="line">	fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.Student&#123;Id:1, Name:&quot;小学生&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="6">
<li>通过反射调用方法</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> EchoName(name <span class="type">string</span>)&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我的名字是：&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := Student&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;Offer Get&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法控制权</span></span><br><span class="line">	<span class="comment">// 官方解释：返回v的名为name的方法的已绑定（到v的持有值的）状态的函数形式的Value封装</span></span><br><span class="line">	mv := v.MethodByName(<span class="string">&quot;EchoName&quot;</span>)</span><br><span class="line">	<span class="comment">// 拼凑参数</span></span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;Offer Get&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用函数</span></span><br><span class="line">	mv.Call(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的名字是： Offer Get</span><br></pre></td></tr></table></figure>

<p><strong>看看TypeOf的实现</strong></p>
<ul>
<li>反射主要与 Golang 的 interface 类型相关，只有 interface 类型才有反射一说。如果有兴趣可以看一下 TypeOf 和 ValueOf，会发现其实传入参数的时候已经被转为接口类型了。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为截取的源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过reflect.Type来打印任意值的类型和枚举它的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print prints the method set of the value x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    t := v.Type()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type %s\n&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;func (%s) %s%s\n&quot;</span>, t, t.Method(i).Name,</span><br><span class="line">            strings.TrimPrefix(methType.String(), <span class="string">&quot;func&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述详细说明了 Golang 的反射 reflect 的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p>
<ul>
<li>反射可以大大提高程序的灵活性，使得 interface{} 有更大的发挥余地<ul>
<li>反射必须结合 interface 才玩得转</li>
<li>变量的 type 要是 concrete type 的（也就是 interface 变量）才有反射一说</li>
</ul>
</li>
<li>反射可以将 “接口类型变量” 转换为“反射类型对象”</li>
<li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li>
<li>反射可以将 “反射类型对象” 转换为“接口类型变量<ul>
<li>reflect.value.Interface().(已知的类型)</li>
<li>遍历 reflect.Type 的 Field 获取其 Field</li>
</ul>
</li>
<li>反射可以修改反射类型对象，但是其值必须是 “addressable”<ul>
<li>想要利用反射修改对象状态，前提是 interface.data 是 settable, 即 pointer-interface，不然会产生panic</li>
</ul>
</li>
<li>通过反射可以 “动态” 调用方法</li>
<li>因为 Golang 本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射 (reflect) 来实现</li>
</ul>
<h2 id="go-routine和channel"><a href="#go-routine和channel" class="headerlink" title="go routine和channel"></a>go routine和channel</h2><p><strong>线程（Thread）</strong>：有时被称为轻量级进程 (Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程 ID，当前指令指针 (PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<p>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度。</p>
<p><strong>协程（coroutine）</strong>：又称微线程与子例程（或者称为函数）一样，协程（coroutine）也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</p>
<p>和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。它避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。</p>
<h3 id="go-routine"><a href="#go-routine" class="headerlink" title="go routine"></a>go routine</h3><p>在Go语言中，每一个并发的执行单元叫作一个goroutine。如同本文开始的示例。main函数启动了一个go routine，只需要通过一个简单的<code>go</code>关键字。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> keyboard.PrintLine()</span><br></pre></td></tr></table></figure>

<p>示例中的go keyboard.PrintLine()用来获取键盘的输出，主routine则用来读取键盘输入。</p>
<p>Go 实现了两种并发形式：</p>
<ul>
<li>多线程共享内存。其实就是 Java 或者 C++ 等语言中的多线程开发。</li>
<li>CSP（communicating sequential processes）并发模型，是 Go 语言特有的，也是 Go 语言推荐的</li>
</ul>
<p>Go 的 CSP 并发模型，是通过<code>goroutine</code>和<code>channel</code>来实现的。</p>
<ul>
<li><code>goroutine</code> 是 Go 语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程 “类似，可以理解为” 线程“。</li>
<li><code>channel</code>是 Go 语言中各个并发结构体 (<code>goroutine</code>) 之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的” 管道 “，有点类似于 Linux 中的管道。</li>
</ul>
<h3 id="Go-线程实现模型-MPG"><a href="#Go-线程实现模型-MPG" class="headerlink" title="Go 线程实现模型 MPG"></a>Go 线程实现模型 MPG</h3><h4 id="调度器的三个基本对象："><a href="#调度器的三个基本对象：" class="headerlink" title="调度器的三个基本对象："></a>调度器的三个基本对象：</h4><p>Golang 简称 Go，Go 的<code>协程(goroutine)</code> 和我们常见的<code>线程(Thread)</code>一样，拥有其调度器。</p>
<ul>
<li>G (Goroutine)，代表协程，也就是每次代码中使用 <code>go 关键词</code>时候会创建的一个对象</li>
<li>M (Work Thread)，工作线程</li>
<li>P (Processor)，代表一个<code>处理器</code>，又称上下文</li>
<li>另外还有一个Sched, Sched 代表着一个调度器 它维护有存储空闲的 M 队列和空闲的 P 队列，可运行的 G 队列，自由的 G 队列以及调度器的一些状态信息等。</li>
</ul>
<h4 id="G-M-P三者的关系与特点："><a href="#G-M-P三者的关系与特点：" class="headerlink" title="G-M-P三者的关系与特点："></a>G-M-P三者的关系与特点：</h4><ul>
<li>每一个运行的 M 都必须绑定一个 P，线程M 创建后会去检查并执行G (goroutine)对象</li>
<li>每一个 P 保存着一个协程G 的<code>队列</code></li>
<li>除了每个 P 自身保存的 G 的队列外，调度器还拥有一个全局的 G 队列</li>
<li>M 从<code>队列中</code>提取 G，并执行</li>
<li>P 的个数就是<code>GOMAXPROCS</code>（最大256），启动时固定的，一般不修改</li>
<li>M 的个数和 P 的个数不一定一样多（会有休眠的M 或 P不绑定M ）（最大10000）</li>
<li>P 是用一个全局数组（255）来保存的，并且维护着一个全局的 P 空闲链表</li>
</ul>
<h4 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h4><ul>
<li>全局G任务队列会和各个本地G任务队列按照一定的策略互相交换。没错，就是<code>协程任务</code>交换</li>
<li>G任务的执行顺序是，先从本地队列找，本地没有则从<code>全局队列</code>找</li>
<li>转移<ul>
<li>局部与全局，全局G个数 &#x2F; P个数</li>
<li>局部与局部，一次性转移一半</li>
</ul>
</li>
</ul>
<h4 id="Gorutine从入队到执行"><a href="#Gorutine从入队到执行" class="headerlink" title="Gorutine从入队到执行"></a>Gorutine从入队到执行</h4><ol>
<li><p>当我们创建一个G对象，就是 <code>gorutine</code>，它会加入到本地队列或者全局队列</p>
</li>
<li><p>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件。细节点：</p>
<ol>
<li><p>先找到一个空闲的P，如果没有则直接返回</p>
</li>
<li><p>P 个数不会占用超过自己设定的cpu个数</p>
</li>
<li><p>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个<code>空队列</code></p>
</li>
<li><p>注意这里的</p>
<ul>
<li>无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建</li>
<li>不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满</li>
<li>新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来</li>
</ul>
</li>
<li><p>这里留下第一个问题：</p>
<blockquote>
<p>如果一个G任务执行时间太长，它就会一直占用 M 线程，由于队列的G任务是顺序执行的，其它G任务就会阻塞，如何避免该情况发生？ –①</p>
</blockquote>
</li>
</ol>
</li>
<li><p>M 会启动一个底层线程循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：</p>
<ul>
<li>当前 M 所绑的 P 队列中找</li>
<li>去别的 P 的队列中找</li>
<li>去全局 G 队列中找</li>
</ul>
</li>
<li><p>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</p>
</li>
<li><p>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</p>
</li>
<li><p>入口 main 函数，其实是作为一个 goroutine 来执行</p>
</li>
</ol>
<h4 id="解答问题-①"><a href="#解答问题-①" class="headerlink" title="解答问题-①"></a>解答问题-①</h4><p>协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 <code>中断，挂起</code></p>
<p>原理：</p>
<p>go程序启动时会首先创建一个特殊的内核线程 <code>sysmon</code>，用来监控和管理，其内部是一个循环：</p>
<ol>
<li>记录所有 P 的 G 任务的<code>计数 schedtick</code>，schedtick会在每执行一个G任务后递增</li>
<li>如果检查到 <code>schedtick</code> 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记</li>
<li>然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G</li>
<li>如果没有遇到<code>非内联函数</code> 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS&#x3D;1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！</li>
</ol>
<p>例子，下面的这段代码，<code>hello world</code> 不会被输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    	<span class="comment">// panic(&quot;hello world&quot;)  // 强制观察输出</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// fmt.Println(&quot;aaa&quot;)  // 非内联函数，这行注释打开，将导致 hello world 的输出</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="中断后的恢复"><a href="#中断后的恢复" class="headerlink" title="中断后的恢复"></a>中断后的恢复</h4><ol>
<li>中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面</li>
<li>当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运</li>
</ol>
<h4 id="GOMAXPROCS–性能调优"><a href="#GOMAXPROCS–性能调优" class="headerlink" title="GOMAXPROCS–性能调优"></a>GOMAXPROCS–性能调优</h4><p>看完上面的内容，相信你已经知道，<code>GOMAXPROCS</code> 就是 go 中 runtime 包的一个函数。它设置了 P 的最多的个数。这也就直接导致了 M 最多的个数是多少，而 M 的个数就决定了各个 G 队列能同时被多少个 M 线程来进行调取执行！</p>
<p>故，我们一般将 GOMAXPROCS 的个数设置为 CPU 的核数，且需要注意的是：</p>
<ul>
<li>go 1.5 版本之前的 GOMAXPROCS 默认是 1</li>
<li>go 1.5 版本之后的 GOMAXPROCS 默认是 Num of cpu</li>
</ul>
<p>P 的数量由环境变量中的<code>GOMAXPROCS</code>决定，通常来说它是和核心数对应，例如在 4Core 的服务器上回启动 4 个线程。G 会有很多个，每个 P 会将 Goroutine 从一个就绪的队列中做 Pop 操作，为了减小锁的竞争，通常情况下每个 P 会负责一个队列。</p>
<p>三者关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/studygolang/gctt-images/master/go-work-stealing-in-go-Scheduler/ws-1.png" alt="Global and local queues"></p>
<p>以上这个图讲的是两个线程 (内核线程) 的情况。一个 <strong>M</strong> 会对应一个内核线程，一个 <strong>M</strong> 也会连接一个上下文 <strong>P</strong>，一个上下文 <strong>P</strong> 相当于一个 “处理器”，一个上下文连接一个或者多个 Goroutine。为了运行 goroutine，线程必须保存上下文。</p>
<p>上下文 P(Processor) 的数量在启动时设置为<code>GOMAXPROCS</code>环境变量的值或通过运行时函数<code>GOMAXPROCS()</code>。通常情况下，在程序执行期间不会更改。上下文数量固定意味着只有固定数量的线程在任何时候运行 Go 代码。我们可以使用它来调整 Go 进程到个人计算机的调用，例如 4 核 PC 在 4 个线程上运行 Go 代码。</p>
<p>图中 P 正在执行的<code>Goroutine</code>为蓝色的；处于待执行状态的<code>Goroutine</code>为灰色的，灰色的<code>Goroutine</code>形成了一个队列<code>runqueues</code>。</p>
<p>Go 语言里，启动一个 goroutine 很容易：go function 就行，所以每有一个 go 语句被执行，runqueue 队列就在其末尾加入一个 goroutine，一旦上下文运行 goroutine 直到调度点，它会从其 runqueue 中弹出 goroutine，设置堆栈和指令指针并开始运行 goroutine。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://segmentfault.com/img/remote/1460000018150994?w=1712&h=824" alt="img"></p>
<h4 id="P-Processor"><a href="#P-Processor" class="headerlink" title="P(Processor)"></a>P(Processor)</h4><p>你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让<code>Goroutine</code>的<code>runqueues</code>挂到 M 上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。</p>
<p>一个很简单的例子就是系统调用<code>sysall</code>，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程 M 需要放弃当前的上下文环境 P，以便可以让其他的<code>Goroutine</code>被调度执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://segmentfault.com/img/remote/1460000018150995" alt="img"></p>
<p>如上图左图所示，M0 中的 G0 执行了 syscall，然后就创建了一个 M1(也有可能来自线程缓存)，（转向右图）然后 M0 丢弃了 P，等待 syscall 的返回值，M1 接受了 P，将 · 继续执行<code>Goroutine</code>队列中的其他<code>Goroutine</code>。</p>
<p>当系统调用 syscall 结束后，M0 会 “偷” 一个上下文，如果不成功，M0 就把它的 Gouroutine G0 放到一个全局的 runqueue 中，将自己置于线程缓存中并进入休眠状态。全局 runqueue 是各个 P 在运行完自己的本地的 Goroutine runqueue 后用来拉取新 goroutine 的地方。P 也会周期性的检查这个全局 runqueue 上的 goroutine，否则，全局 runqueue 上的 goroutines 可能得不到执行而饿死。</p>
<h4 id="均衡的分配工作"><a href="#均衡的分配工作" class="headerlink" title="均衡的分配工作"></a>均衡的分配工作</h4><p>按照以上的说法，上下文 P 会定期的检查全局的 goroutine 队列中的 goroutine，以便自己在消费掉自身 Goroutine 队列的时候有事可做。假如全局 goroutine 队列中的 goroutine 也没了呢？就从其他运行的中的 P 的 runqueue 里偷。</p>
<p>每个 P 中的<code>Goroutine</code>不同导致他们运行的效率和时间也不同，在一个有很多 P 和 M 的环境中，不能让一个 P 跑完自身的<code>Goroutine</code>就没事可做了，因为或许其他的 P 有很长的<code>goroutine</code>队列要跑，得需要均衡。<br>该如何解决呢？</p>
<p>Work Stealing算法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/studygolang/gctt-images/master/go-work-stealing-in-go-Scheduler/ws-4.png" alt="Work-stealing by P0"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/80/b0630a33ceda74e0b0a476a0466a8420_1440w.jpg" alt="img"></p>
<p>每个新的goroutine都会维护这自己的栈，当程序启动的时候，调度器会创建第一个goroutine，首先，按照图片上的描述，管理员(Seched)找来土拨鼠(M) 并分配给土拨鼠(M)一个小车(P),土拨鼠开始推车小车拿走一批砖，（我们称这些砖被放在本地p可运行的G队列），这个土拨鼠就这么认真努力的开始完成自己的工作，有一天你在程序中提高一下程序的并发处理能力，创造了很多的砖(G)，这时候，这么多的砖块(G)已经不够这些土拨鼠去处理了，于是调度器，就是去仓库里面找到空闲的土拨鼠。</p>
<p>如果没有就创造一个土拨鼠，当工厂管理员发现，有个土拨鼠处理的很慢，这个时候就会让他去处理，但需要让出小车，调度器会找到一个新的土拨鼠去处理这个推车上的G，当土拨鼠处理完这些G的时候就需要调度器可运行的G队列总去找，当土拨鼠实在找不到goroutine就去别人的小车中枪走一半，如果多次都抢不到，那么土拨鼠就丢弃小车回到仓库里面睡觉(sleep)去了,如果土拨鼠赶上了系统调用或者网络的IO，那么土拨鼠就等待他，这时候也不能让这个土拨鼠来阻碍其他的砖(G)的运行，这时候调度器就会找来新的土拨鼠去完成剩余的工作，这时候，新的土拨鼠就会抢走车去工作 了，当这个土拨鼠的任务完成了时候发现自己的小车已经被别人抢跑了，这个土拨鼠没有什么事情，就回到仓库里面睡觉(sleep)去了。</p>
<p><strong>优点</strong>：</p>
<p>1、开销小</p>
<p>POSIX 的 thread API 虽然能够提供丰富的 API，例如配置自己的 CPU 亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在 Goroutine 中则不需这些额外的开销，所以一个 Golang 的程序中可以支持 10w 级别的 Goroutine。</p>
<p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（<em>goroutine：</em>2KB ，线程：8MB）</p>
<p>2、调度性能好</p>
<p>在 Golang 的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在 GC 时，内存必须要达到一个一致的状态。在 Goroutine 机制里，Golang 可以控制 Goroutine 的调度，从而在一个合适的时间进行 GC。</p>
<p>在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</p>
<p>缺点：</p>
<p>协程调度机制无法实现公平调度。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>如果说goroutine是Go语音程序的并发体的话，那么channels它们之间的通信机制。一个channels是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChanInput = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>和map类似，channel也一个对应make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者何被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p>
<p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都是用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChanInput &lt;- curPath</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">curPath := &lt;- ChanInput</span><br></pre></td></tr></table></figure>

<p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel之行接收操作依然可以接受到之前已经成功发送的数据(收到就没有了)；如果channel中已经没有数据的话讲产生一个零值的数据。使用内置的close函数就可以关闭一个channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ChanInput)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;channel closed.&quot;</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    j, ok := &lt;- ch</span><br><span class="line">    fmt.Println(j, ok)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel closed.</span><br><span class="line">1 true</span><br><span class="line">2 true</span><br><span class="line">0 false</span><br><span class="line">0 false</span><br><span class="line">0 false</span><br></pre></td></tr></table></figure>

<p>上面得例子说明，向一个通道发送数据并通过close()关闭，通道的实际关闭时间在通道内(即使有缓存队列)数据完全读完之后才会关闭后。</p>
<p>注意:</p>
<ul>
<li><p>重复关闭 channel 会导致 panic。</p>
</li>
<li><p>向关闭的 channel 发送数据会 panic。</p>
</li>
<li><p>从关闭的 channel 读数据不会 panic，但是读出的数据是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="comment">// 通过comma, ok的方式确定通道是否关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>无缓存的Channel</strong></p>
<p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p>
<p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。</p>
<p>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p>
<p><strong>有缓存的Channel</strong></p>
<p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChanInput = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓冲将导致程序死锁。Channel的缓存也可能影响程序的性能。</p>
<p><strong>如何使用Channel</strong></p>
<ul>
<li><ol>
<li>goroutine直接的通信通信</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>基于Select的多路复用</li>
</ol>
</li>
</ul>
<p>select 一定程度上可以类比于 linux 中的 IO 多路复用中的 select。后者相当于提供了对多个 IO 事件的统一管理，而 Golang 中的 select 相当于提供了对多个 channel 的统一管理。当然这只是 select 在 channel 上的一种使用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case e, ok := &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    case e, ok := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    default:  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是 select 中的 break 只能跳到 select 这一层。select 使用的时候一般配合 for 循环使用，像下面这样，因为正常 select 里面的流程也就执行一遍。这么来看 select 中的 break 就稍显鸡肋了。所以使用 break 的时候一般配置 label 使用，label 定义在 for 循环这一层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>基于for range的多路复用</li>
</ol>
</li>
</ul>
<p>range channel 可以直接取到 channel 中的值。当我们使用 range 来操作 channel 的时候，一旦 channel 关闭，循环自动结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func consumer(ch chan int) &#123;</span><br><span class="line">    for x := range ch &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func producer(ch chan int) &#123;</span><br><span class="line">  for _, v := range values &#123;</span><br><span class="line">      ch &lt;- v</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>channel超时控制</li>
</ol>
</li>
</ul>
<p>在很多操作情况下都需要超时控制，利用 select 实现超时控制，下面是一个简单的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">  case &lt;- ch:</span><br><span class="line">    </span><br><span class="line">  case &lt;- time.After(2 * time.Second)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，上面的 time.After 可以换成其他的任何异常控制流。</p>
<ul>
<li><ol start="5">
<li>生产者 - 消费者模型</li>
</ol>
</li>
</ul>
<p>利用缓冲 channel 可以很轻松的实现生产者 - 消费者模型。上面的 range 示例其实就是一个简单的生产者 - 消费者模型实现。</p>
<ul>
<li>无缓冲信道是消息来一个接收一个，依次进入流出</li>
<li>缓冲信道则是一个一个存储，然后一起流出去</li>
</ul>
<h2 id="Go-的-Context-上下文"><a href="#Go-的-Context-上下文" class="headerlink" title="Go 的 Context 上下文"></a>Go 的 Context 上下文</h2><p>前面在 “聊一聊 http 框架 <strong>httprouter</strong> ” 的时候，提到了上下文的概念，上一个 demo 用来列举 web 框架中全局变量的传值和设置，还类比了 <strong>Java Spring 框架中</strong> 的 <code>ApplicationContext</code> 。</p>
<p>这一次我们就来聊一聊 Go 中的标准库的 context，梳理上下文概念在 go 中的常用情景。</p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>在列举上下文的用法之前，我们来看一个简单的示例：</p>
<h4 id="协程泄露"><a href="#协程泄露" class="headerlink" title="协程泄露"></a>协程泄露</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//打印已有协程数量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Start with goroutines num:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    <span class="comment">//新起子协程</span></span><br><span class="line">    <span class="keyword">go</span> Spawn()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before finished, goroutines num:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Main routines exit!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Spawn</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    	time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    	count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start with goroutines num: 1</span><br><span class="line">Before finished, goroutines num: 2</span><br><span class="line">Main routines exit!</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们在主协程创建一个子协程，利用 <code>runtime.NumGoroutine()</code> 打印当前协程数量，可以知道在 <strong>main 协程</strong> 被唤醒之后退出前的那一刻，程序中仍然存在两个协程，可能我们已经习惯了这种现象，杀掉主协程的时候，退出会附带把子协程干掉，这种让子协程 “自生自灭” 的做法，其实是不太优雅的。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="管道通知退出"><a href="#管道通知退出" class="headerlink" title="管道通知退出"></a>管道通知退出</h4><p>关于控制子协程的退出，可能有人会想到另一个做法，我们再来看另一个例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Main routines exit!&quot;</span>)</span><br><span class="line">    ExitBySignal()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start with goroutines num:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    <span class="comment">//主动通知协程退出</span></span><br><span class="line">    sig &lt;- <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Before finished, goroutines num:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用管道通知协程退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenWithSignal</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    	<span class="keyword">select</span> &#123;</span><br><span class="line">    	<span class="comment">//监听通知</span></span><br><span class="line">    	<span class="keyword">case</span> &lt;-sig:</span><br><span class="line">    		<span class="keyword">return</span></span><br><span class="line">    	<span class="keyword">default</span>:</span><br><span class="line">    		<span class="comment">//正常执行</span></span><br><span class="line">    		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    		count++</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start with goroutines num: 2</span><br><span class="line">Before finished, goroutines num: 1</span><br><span class="line">Main routines exit!</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面这个例子可以说相对优雅一些，在 main 协程里面主动通知子协程退出，不过两者之间的仍然存在依赖，假如子协程 A 又创建了新的协程 B，这个时候通知只能到达子 A，新协程 B 是无法感知的，因此同样可能会存在协程泄露的现象。</p>
<h4 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h4><p>下面我们会引进一个利用 <code>Go</code> 标准库 context 包的处理方式，通过上下文管理子协程的生命周期。</p>
<h4 id="官方概念"><a href="#官方概念" class="headerlink" title="官方概念"></a>官方概念</h4><p>在此之前，先来复习下标准库的概念：</p>
<p>A Context carries a deadline, a cancellation signal, and other values across API boundaries. Context’s methods may be called by multiple goroutines simultaneously.</p>
<p>上下文带着截止时间、cancel 信号、还有在 API 之间提供值读写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回该上下文的截止时间，如果没有设置截至时间，第二个值返回false</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个管道，上下文结束(cancel)时该方法会执行，经常结合select块监听</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当Done()执行时，Err()会返回一个error解释退出原因</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上下文值存储字典</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中较为常用的是 <code>context.Withcancel()</code> 函数，它会返回一个包装了 <code>cancel()</code> 函数的子上下文，当我们认为协程需要结束的时候，调用其返回值 <code>cancel()</code> 函数，子上下文会关闭内部封装的管道 <code>Done()</code> 来通知相应协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    <span class="comment">//返回新的cancelCtx子上下文</span></span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    <span class="comment">//将原上下文</span></span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续引入一个协程泄漏的 demo，来看下具体使用例子：</p>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞两个子协程，预期只有一个协程会正常退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LeakSomeRoutine</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">//起3个协程抢着输入到ch</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	ch &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	ch &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	ch &lt;- <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//一有输入立刻返回</span></span><br><span class="line">    <span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//每一层循环泄漏两个协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">    	LeakSomeRoutine()</span><br><span class="line">    	fmt.Printf(<span class="string">&quot;#Goroutines in roop end: %d.\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Goroutines in roop end: 3.</span><br><span class="line">#Goroutines in roop end: 5.</span><br><span class="line">#Goroutines in roop end: 7.</span><br><span class="line">#Goroutines in roop end: 9.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到，随着循环次数增加，除去 main 协程，每一轮都 <strong>泄漏两个协程</strong> ，所以程序退出之前最终有 9 个协程。</p>
<p>接下来我们引入上下文的概念，来管理子协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FixLeakingByContex</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建上下文用于管理子协程</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束前清理未结束协程</span></span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> CancelByContext(ctx, ch)</span><br><span class="line">    <span class="keyword">go</span> CancelByContext(ctx, ch)</span><br><span class="line">    <span class="keyword">go</span> CancelByContext(ctx, ch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机触发某个子协程退出</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CancelByContext</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> (<span class="type">int</span>)</span></span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    	<span class="comment">//fmt.Println(&quot;cancel by ctx.&quot;)</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> n := &lt;-ch :</span><br><span class="line">    	<span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//每一层循环泄漏两个协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">    	FixLeakingByContex()</span><br><span class="line">    	<span class="comment">//给它点时间 异步清理协程</span></span><br><span class="line">    	time.Sleep(<span class="number">100</span>)</span><br><span class="line">    	fmt.Printf(<span class="string">&quot;#Goroutines in roop end: %d.\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序分析：</p>
<p>可以看到 <code>CancelByContext</code> 函数对管道进行轮询，程序只有两个分支方可 return</p>
<ul>
<li>上下文通知结束</li>
<li>收到管道传入的值</li>
</ul>
<p>我们在 <code>FixLeakingByContex()</code> 函数结束前 defer 了 <code>cancel()</code> 函数，因此会在程序退出前把相应的子协程 <strong>clean</strong> 掉，所以可以看到如下输出，每一轮都只剩下一个 <strong>main</strong> 协程。</p>
<h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Goroutines in roop end: 1.</span><br><span class="line">#Goroutines in roop end: 1.</span><br><span class="line">#Goroutines in roop end: 1.</span><br><span class="line">#Goroutines in roop end: 1.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="截止超时退出"><a href="#截止超时退出" class="headerlink" title="截止超时退出"></a>截止超时退出</h4><p>除了我们手动调用 cancel 函数退出之外，标准库还提供了两个限时退出的操作， <code>WithDeadline(parent Context, d time.Time)</code> 以及 <code>WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code> 函数，可以传入一个时间点或者时间段，表示经过该时间之后自动调用该上下文的 <code>Done()</code> 函数。</p>
<p>使用示例：</p>
<p>我们摘取官网一个 demo：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 由于传入时间为50微妙，因此在select选择块中，ctx.Done()分支会先执行</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">    	fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    	fmt.Println(ctx.Err()) <span class="comment">// prints &quot;context deadline exceeded&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出： context deadline exceeded</span></span><br></pre></td></tr></table></figure>

<h4 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h4><p>关于上下文 <code>WithTimeout()</code> 函数的用法，还可以判断一个 <code>http</code> 请求是否超时。</p>
<h4 id="程序示例："><a href="#程序示例：" class="headerlink" title="程序示例："></a>程序示例：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeReqWithContext</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化http请求</span></span><br><span class="line">    request, e := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.pixelpigpigpig.xyz&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">    	log.Println(<span class="string">&quot;Error: &quot;</span>, e)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Request生成子上下文, 并且设置截止时间为10毫秒</span></span><br><span class="line">    ctx, cancelFunc := context.WithTimeout(request.Context(), <span class="number">10</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancelFunc()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定超时上下文到这个请求</span></span><br><span class="line">    request = request.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//time.Sleep(20 * time.Millisecond)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    response, e := http.DefaultClient.Do(request)</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">    	log.Println(<span class="string">&quot;Error: &quot;</span>, e)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">    <span class="comment">//如果请求没问题, 打印body到控制台</span></span><br><span class="line">    io.Copy(os.Stdout, response.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们给请求限时 10 毫秒，执行可以看到程序打印上下文已经过期了。</p>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestTimeReqWithContext</span><br><span class="line">2020/05/16 23:17:14 Error:  Get https://www.pixelpigpigpig.xyz: context deadline exceeded</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Context-值读写"><a href="#Context-值读写" class="headerlink" title="Context 值读写"></a>Context 值读写</h3><p>如前面所示， <code>context</code> 还提供了一个读写的函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 上下文值存储字典</span><br><span class="line">Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>关于它的用法，之前在 “聊一聊 httpRouter” 的文章中列举过，可以这样子使用，</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶级上下文</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="comment">// 在上下文写入string值, 注意需要返回新的value上下文</span></span><br><span class="line">valueCtx := context.WithValue(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;pixel&quot;</span>)</span><br><span class="line">value := valueCtx.Value(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> value != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Params type: %v, value: %v.\n&quot;</span>, reflect.TypeOf(value), value)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>context.Background()</code> 是一个非空的顶级上下文，只要程序还在它就不会取消，也没有嵌入值，经常被 main 函数所使用。</p>
<p>关于 <code>context</code> 的值读取，在 Go 规范中有一个约定，不应使用它来封装寿命长期的参数，一般仅用于传输一个请求作用域的值，关于程序的业务参数应该暴露出来，放在函数参数列表中，以提高可读性。</p>
<h3 id="Context-的作用域"><a href="#Context-的作用域" class="headerlink" title="Context 的作用域"></a>Context 的作用域</h3><p>上面列举的 <code>Context</code> 几个用法，可以说比较常见，前面曾经拿 <code>go</code> 中 <code>context</code> 的来类比 <strong>Java Spring</strong> 中的 <code>applicationContext</code> 全局上下文，但是严格来说，其实这个是带有争议的。因为 <code>Spring</code> 的上下文是贯穿整个程序的生命周期，往往会附带一些全局设置项，在 <code>go</code> 中，比较倾向于用于控制一个子程序块，和 <strong>Spring</strong> 的全局上下文比较， <code>Go</code> 的 <code>context</code> 是比较短暂的。</p>
<p>Go 里面 <code>context.Context</code> 的常用情景：</p>
<ul>
<li>用于贯穿一个子协程的任务片段，如上面用于把控子协程的退出</li>
<li>或者是在网络框架中表示一个请求，管理其开始至结束，如在 <code>Gin</code> 框架中的从 <code>Request</code> 到 <code>Response</code> ，并不是全局的。</li>
</ul>
<p>另外在参考链接处有一篇比较有意思的争论，有个作者 <strong>吐槽了关于 Go 上下文的泛滥</strong> ，关于上下文的辩论在该文章的评论可谓见仁见智。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions</span><br></pre></td></tr></table></figure>

<p>总的来说， Go 上下文应该着重用于管理子协程或者是有目地嵌入函数链的生命周期中，而不是约定俗成在每个方法都传播上下文。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>Goroutine leak</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/golangspec/goroutine-leak-400063aef468">medium.com&#x2F;golangspec&#x2F;…</a></p>
<p>Understanding the context package</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/rungo/understanding-the-context-package-b2e407a9cdae">medium.com&#x2F;rungo&#x2F;under…</a></p>
<p>Context Package Semantics In Go</p>
<p><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html">www.ardanlabs.com/blog/2019/0…</a></p>
<p>Context should go away for Go 2(“关于 Go 上下文泛滥的吐槽”)</p>
<p><a target="_blank" rel="noopener" href="https://faiface.github.io/post/context-should-go-away-go2/">faiface.github.io&#x2F;post&#x2F;contex…</a></p>
<p>Go: Context and Cancellation by Propagation</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c">medium.com&#x2F;a-journey-w…</a></p>
<p>图片 ref：（Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French. ）</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/')">Golang简洁入门</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Golang简洁入门&amp;url=https://shippomx.github.io/2018/05/20/golang/Golang%20%E7%AE%80%E6%B4%81%E5%85%A5%E9%97%A8/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/go/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>go<span class="tagsPageCount">11</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/06/08/Nginx%20%E9%85%8D%E7%BD%AE%20HTTPS%20%E6%9C%8D%E5%8A%A1%E5%99%A8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx 配置 HTTPS 服务器</div></div></a></div><div class="next-post pull-right"><a href="/2018/07/06/golang/Golang%20%E9%A2%98%E7%9B%AE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一些go的笔试题目</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2020/09/01/golang/20%E5%BC%A0%E5%8A%A8%E5%9B%BE%E4%B8%BA%E4%BD%A0%E6%BC%94%E7%A4%BAGo%E5%B9%B6%E5%8F%91/" title="20 张动图演示 Go 并发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-09-01</div><div class="title">20 张动图演示 Go 并发</div></div></a></div><div><a href="/2020/07/11/golang/GO%20delve(dlv)%20%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" title="go dlv使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-07-11</div><div class="title">go dlv使用</div></div></a></div><div><a href="/2020/07/12/golang/Go%20package%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/" title="Go package的组织方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-07-12</div><div class="title">Go package的组织方式</div></div></a></div><div><a href="/2018/07/06/golang/Golang%20%E9%A2%98%E7%9B%AE/" title="一些go的笔试题目"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2018-07-06</div><div class="title">一些go的笔试题目</div></div></a></div><div><a href="/2020/07/18/golang/Golang%20Runtime%E7%B2%BE%E8%AE%B2/" title="go runtime 精讲"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-07-18</div><div class="title">go runtime 精讲</div></div></a></div><div><a href="/2019/05/28/golang/golang-tls-%E5%AE%9E%E7%8E%B0/" title="GolangTLS的实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2019-05-28</div><div class="title">GolangTLS的实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9golang"><span class="toc-number">1.</span> <span class="toc-text">为什么选择golang?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%AF%B4%E8%B5%B7"><span class="toc-number">2.</span> <span class="toc-text">从一个程序说起</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E4%BB%8E%E5%9F%BA%E7%A1%80%E8%AF%B4%E8%B5%B7"><span class="toc-number">2.1.</span> <span class="toc-text">为什么我不从基础说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">Golang开发环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0cd%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">实现cd命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">知识点解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">3.1.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">包的导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">包的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">3.1.3.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.4.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">3.1.5.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">3.1.7.</span> <span class="toc-text">数组、字符串与切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.1.8.</span> <span class="toc-text">结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">函数、方法和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.3.</span> <span class="toc-text">Panic异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recover-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.4.</span> <span class="toc-text">recover 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.5.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">为什么使用反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-routine%E5%92%8Cchannel"><span class="toc-number">3.4.</span> <span class="toc-text">go routine和channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-routine"><span class="toc-number">3.4.1.</span> <span class="toc-text">go routine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B-MPG"><span class="toc-number">3.4.2.</span> <span class="toc-text">Go 线程实现模型 MPG</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">调度器的三个基本对象：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G-M-P%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">G-M-P三者的关系与特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8G%E9%98%9F%E5%88%97%E4%B8%8E%E5%85%A8%E5%B1%80G%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">局部G队列与全局G队列的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gorutine%E4%BB%8E%E5%85%A5%E9%98%9F%E5%88%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">Gorutine从入队到执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E9%97%AE%E9%A2%98-%E2%91%A0"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">解答问题-①</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">中断后的恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GOMAXPROCS%E2%80%93%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">GOMAXPROCS–性能调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P-Processor"><span class="toc-number">3.4.2.8.</span> <span class="toc-text">P(Processor)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%87%E8%A1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.4.2.9.</span> <span class="toc-text">均衡的分配工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">3.4.3.</span> <span class="toc-text">channel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E7%9A%84-Context-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.5.</span> <span class="toc-text">Go 的 Context 上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">问题引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">协程泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">解决方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E7%9F%A5%E9%80%80%E5%87%BA"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">管道通知退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-1"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">上下文管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">官方概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-number">3.5.2.5.</span> <span class="toc-text">程序输出：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%AD%A2%E8%B6%85%E6%97%B6%E9%80%80%E5%87%BA"><span class="toc-number">3.5.2.6.</span> <span class="toc-text">截止超时退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6"><span class="toc-number">3.5.2.7.</span> <span class="toc-text">请求超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.5.2.8.</span> <span class="toc-text">程序示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E5%80%BC%E8%AF%BB%E5%86%99"><span class="toc-number">3.5.3.</span> <span class="toc-text">Context 值读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.5.4.</span> <span class="toc-text">Context 的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/IEEE%20802.1Q%20%E5%B0%81%E8%A3%85%E7%9A%84%20VLAN%20%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F%20/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/Linux%20%E4%B8%8B%20Pcap%20%E5%8C%85%E9%87%8D%E6%94%BE%E5%B7%A5%E5%85%B7%20Tcpreplay%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/OpenFlow%20%E6%B5%81%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F%E3%80%81IP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E3%80%81TCPUDP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/02/sdn/netperf%20%E7%9A%84%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-02T05:58:53.067Z" title="发表于 2023-12-02 13:58:53">2023-12-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>