<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>内核skb_sk_buff详解 | 远辰</title><meta name="keywords" content="linux,sdn,network"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="内核skb_sk_buff详解"><meta name="application-name" content="内核skb_sk_buff详解"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="内核skb_sk_buff详解"><meta property="og:url" content="https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="序言Linux 内核 skb，是 struct sk_buff 数据结构的简称，skb 可以说是内核网络子系统使用最多，也是最重要的数据结构。掌握 skb 对内核协议栈的理解，以及网络设备驱动程序的实现至关重要。本文的目的是帮助你对 skb 结构以及相关辅助函数有深入领会，并尝试解决以下疑问：  s"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="序言Linux 内核 skb，是 struct sk_buff 数据结构的简称，skb 可以说是内核网络子系统使用最多，也是最重要的数据结构。掌握 skb 对内核协议栈的理解，以及网络设备驱动程序的实现至关重要。本文的目的是帮助你对 skb 结构以及相关辅助函数有深入领会，并尝试解决以下疑问：  s"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: '内核skb_sk_buff详解',
  postAI: '',
  pageFillDescription: '序言, skb 在哪里用, TX 方向, RX 方向, skbx2Fsk_buff 结构, alloc_skb or dev_alloc_skb, skb_reserve, skb_put, skb_push, skb_pull, SKB 常用成员, TX 发包示例, 什么是（skb_shared_info）, 结构自身放在哪里, 结构体重要成员, skb 数据空间划分, 干什么（skb_shared_info）, frags 应用场景, frag_list 应用场景, 问题, 参考序言内核是数据结构的简称可以说是内核网络子系统使用最多也是最重要的数据结构掌握对内核协议栈的理解以及网络设备驱动程序的实现至关重要本文的目的是帮助你对结构以及相关辅助函数有深入领会并尝试解决以下疑问在内核的哪些层次会被使用有哪些重要的成员如何借助于一些辅助函数操作这些成员中的和有什么区别各自的用途是什么怎么基于中的实现磁盘文件到网络的零拷贝怎么基于中的实现硬件内核和驱动是如何支持在哪里用如上图流动方向分为两个一个是发送方向另一个是接受方向对于的流动路径我们通常又称为数据路径所以数据路径包括了的和本篇文章只关心在数据路径的使用从上图可以看到和设备驱动之间是用在流动数据对于来说传输层申请设备驱动释放对于来说设备驱动申请网络协议栈负责释放之如果你对底层设备的感兴趣建议阅读作者的另一篇文章一文读懂内存及设备内存控制方向用户态应用程序基于系统调用接口传送需要的应用层数据如产生内核态层读取用户态数据并按照应用层的协议类型将数据发送到对应的传输层如对应传输层申请数据结构并填充数据到然后会向下传送到网络层和链路层链路层在内核对应网络设备层继续添加和到中最后到达网络设备驱动其从中获取到数据的虚拟地址并映射出总线地址给网卡进行读取方向如高速网卡收到从光纤上传入的数据包后基于网卡内控制器和总线将数据包送入设备驱动层设备驱动收到数据包后申请并将数据放入结构指向的数据空间位于结构的和指针之间注驱动放数据到有两种方式一种方式是第二种是实现零拷贝效率更高驱动调用将数据送入到达层则去除指向数据的到达层去除最后在内核基于等路由信息查找到对应的将数据基于送入用户态应用程序结构数据结构的成员很多但是掌握一个结构必须从关键成员着手否则就会迷失在辅助信息的汪洋大海之中当然不是说辅助信息不重要只是其对我们理解和使用一个结构不会起到决定性的作用而我们理解一个结构就是为了更好地运用之所以下面将结合使用函数来解释结构的关键成员当协议栈需要时会调用分配实体而设备驱动程序在时会调用来分配当然这是一种低效的方式因为需要将的数据到指向的中下面以为例说明该函数执行后的内存空间状态只有一个输入参数用于指定需要申请长度首先该函数会申请结构体自身的内存如上图左侧用两种颜色展示了该结构体最重要的个成员指针信息接着会申请的内存如上图右侧的总长度对上图右侧数据以及左侧的各个指针解释如下我们看到右侧分为三块第一块是即的大小为是的输入参数第三块后面会有详细的讲解其用于分散聚合长度的用于存放数据包而只是一个结构的长度该结构的成员会再指向分散聚合的数据包初始时指向的起始位置而指向长度的尾部参考源码分配结构体的内存将和长度对齐加上并与长度对齐申请指向的空间如下图调用之后会将和指向开始的位置即在和之间加入一个保留的头部空间便于协议栈做头部扩展而不需要移动指针后面的数据负责向指向的中添加数据如下图在将数据到指针开始的位置时需要调用移动指针到位置返回原始的指针在指针前面继续添加数据例如在协议栈数据包时需要添加等协议头部信息则会调用将指针向上移动长度从指向的位置向下移动类似于出栈如下图将上一次给掉则回到时的起始位置这主要被协议栈收包时去除协议头时使用常用成员通过串联起来下文会介绍线性区和非线性区数据总长下文会详细介绍非线性区的数据总长包括和网络设备层选择该的发送该通常会作为网络设备驱动发包的如果协议栈没有算其被赋值为指示硬件做的无状态卸载即硬件计算指示该指向的数据包是否为一个隧道包当设备支持卸载时层会没有会填充在该字段和填充在下一个字段协议类型封包为或普通包为协议类型线性区有效数据的结尾位置线性区结束位置从到之间称为线性区开头指针从到之间称为线性区有效数据的起始地址被引用次数当引用计数为零时即可释放发包示例分配设置保留空间将返回原始指针给将用户态的数据到将指针向上移动然后赋值什么是结构自身放在哪里首先我们来看看内核是如何获取到一个已知的的结构信息的如下实现非常简洁就是从指针开始的位置基于结构强制转换即可所以你现在可以体会到为什么在前面的图中将结构画在之后这是一个比较诡异的地方我们通常会以为和都是管理的结构所以应该将放入将所有管理数据结构的内存空间放在一起才比较好但是内核不是这样设计的其将结构放到了的数据区后面结构体重要成员该数据结构的核心灵魂就是成员和数组结构以及重要成员的解释如下数组中有效的成员个数进行分段时每段最大长度即头部的因为硬件可以做分段所以网络设备驱动需要传给硬件按照即进行分段时该将被分为多少段大块数据包需要分为多个为的数据包每个数据包对应一个这些通过该结构进行链表连接驱动和硬件支持对小块数据进行聚合以及硬件分段会用到该数组后面会有详细介绍每个存放数据块基于的地址和长度信息当前块数据对应的虚拟地址当前块数据在中的偏移量所以一个可以给多个共享当前块数据的大小数据空间划分和之间的数据区称为线性区而中和指向的数据区统称为非线性区下图摘自深入理解网络技术内幕完整展示了管理的各个内存数据区但是通过上面的基础铺垫你应该会发现一点不妥的地方那就是对应的结构在内存空间上并不是排在结构的后面而是接在的后面但是这幅图也有其优势即管理的结构放在左边而数据部分位于右边更便于我们的理解线性区线性区的总长度非线性区非线性区的总长度下面内核代码通过返回类型如果大于则返回即存储的数据是非线性化的总长线性区加非线性区的总长度线性区加非线性区总长相加所有的总共有数量的干什么要深入是干什么用的还是需要深入其结构成员前面我们提到中两个最重要的成员就是和很多人可能会存在疑问这两个看起来很像的家伙到底有什么区别呢分别会用在哪些应用场景下呢本章节将尝试来回答这两个作者研究已久但可能会回答不够全面的问题首先给出结论会用在内核功能将分断从内核协议栈的层推迟到或层会用在内核和网络设备配合的功能将分段从协议栈的层推迟到硬件实现会用在内核和网络设备配合的功能是指应用层发送小片数据包然后硬件负责聚合为一笔包另外也是功能用户态实现零拷贝的基础设施目前作者看到的主要是应用程序发送巨大数据时协议栈层的分片功能将其分解为多个小于的然后通过将这些通过指针串联起来在网络设备层会将每个中的每个独立的传输给设备驱动层目前的高速网卡还没有看到支持的硬件卸载如果驱动和硬件支持的卸载则只需要传递包括的第一个给驱动即可应用场景作者所知的应用场景有三个而且这三个场景都需要软硬件一起配合来实现第一个是分散聚合第二个是分段卸载第三个是通过网络发送磁盘文件的零拷贝的字面意思是分散聚合分散聚合功能需要软件驱动和硬件的一起协作配合才可实现主要用在方向如下需要确认网络设备是否开启了表示硬件可以支持分散聚合而该功能是基于来实现关闭开启除了上面的手动开启也可以在驱动初始化时开启软件产生的是一块一块分散内存可能不连续的数据而硬件分别对每个分散的数据块进行读然后硬件再负责将每个数据块合并为一笔完整的数据包并发出这就实现了一种数据发送的加速因为应用层生成多个小片数据包后再做一次最终发送时内核协议栈软件就不需要将每片数据进行复制和拼接毕竟硬件做一般都比软件快如上图为第一个和第二个全部指向同一个的起始地址使用来进行页内的偏移分别为和需要注意的是线性和非线性区的总长度为其通常小于比如为则同一个所有的数据长度相加也通常小于所以也小于默认但只是通常而已下一小节将说明大于的情况基于上图示例驱动程序会针对份数据产生三个地址数据产生地址的方式是数据和产生地址的方式是将这些地址传给硬件即可让硬件来干聚合的脏活啦哈哈太坏了例如驱动访问每个的代码如下通知硬件干活我们知道头部信息中有个字段在进行三次握手时客户端和服务器端会基于路径等信息协商一个最大的分段大小例如则通常和通常都是协商得到之后从客户或服务端用于协商地址发出的数据大小层后面的数据等协议头必须小于值所以对于应用层协议发送的大于的数据包就需要在内核的协议层进行分段当然前提条件是以下两个开关和全部关闭只要有一个开启则协议层就不会做分段的工作开启则分段工作推迟内核网络设备层开启则分段工作推迟到硬件网络设备如网卡前文提到同一个的线性区和非线性区数据总长通常小于但是如果网络设备开启了那就不一定了在硬件支持功能时每个指向数据的大小通常可以到达个所以一个也可以由多个拼接而成下面是关闭和开启网络设备网卡的方法确认功能是否开启关闭开启如下图在开启时内核协议栈需要发送一笔大于的数据包则申请了两个对应个共而对应一个为网络驱动程序在接受到如上图远大于网卡的最大通常为约为的超大数据包之后会指示硬件进行分段处理以下是为做做准备代码的代码是数据包总长减去到总长得到数据部分的总长包括应用层协议头是指示硬件在做分段时每笔包的给硬件生产时即生成和每个的地址如果数据的长度大于硬件一次的最大长度通常为则需要针对超长如切分出多个地址给硬件做首先线性区的做映射得到硬件可以读取操作地址当一个或对应的大小如超过硬件支持的最大一次长度时需要分多个读基于的零拷贝基于不仅可以实现而且可以实现从读取磁盘文件到网络发送的零拷贝在说明零拷贝之前我们首先看一下通过和发送文件的系统资源消耗上下文切换操作共次下图上半部分表示上下文切换红色表示切换的时机和分别需要两次首先系统调用需要从用户态陷入内核态再从内核态回到用户态其次系统调用类似控制器和参与的共次下图下半部分表示内存拷贝蓝色表示拷贝的时机首先控制器从磁盘文件拷贝数据到这不需要参与然后将数据从拷贝到用户态接着通过系统调用将数据从拷贝到内核最后网卡通过控制器将数据从拷贝到网卡硬件进行发送上面次上下文切换次数据拷贝的繁重任务是否有优化办法呢答案是肯定的因为有实现分散聚合的功能通过内核的适当优化调整支持用户态的功能从而去掉了部分上下文切换和数据拷贝的动作上下文切换操作需要共次上图上半部分表示上下文切换红色表示切换的时机系统调用需要从用户态陷入内核态再从内核态回到用户态控制器参与的共次上图下半部分表示内存拷贝蓝色表示拷贝的时机首先控制器从磁盘文件拷贝数据到这不需要参与然后数据并不会真正从拷贝到而只是通过指针赋值的方式因为从磁盘读出的数据放在指向内存而该内存指针直接赋值给即可最后网卡通过控制器直接从拷贝数据到网卡发送你可能想说这能叫零拷贝吗不是还有吗说得没错的确还需要控制器的参与但是相对低效的拷贝已经消除了而且少了两次上下文切换整体的效率提升是相当明显的应用场景据我所知主要用在内核协议栈的分片目前看来还很少有硬件网络设备支持卸载如果硬件支持卸载则设备驱动会对或上即例如当应用层发送一笔字节的为则会分为三个进行发送三个通过第一个的作为链表的头部后面两个通过指针进行串联在协议层调用进行分片代码如下加入头到如果还有则需要在头部加上标志发送中的每个分片问题提两个问题给自己大家有想法也请帮忙解答当多个指向的空间是线性连续的驱动可否合并这些让硬件做一次读在开启时如果一个指向的数据达到而一个是即一个指向个而这个采用一个地址传递给硬件硬件做时需要这个是物理连续的内核的内存页管理是如何保证分配多个连续性的物理页参考深入理解网络技术内幕',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-29 14:14:31',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 1.05rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 1.05rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 1.05rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>41</sup></a><a href="/tags/network/" style="font-size: 1.05rem;">network<sup>9</sup></a><a href="/tags/pppoe/" style="font-size: 1.05rem;">pppoe<sup>1</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 1.05rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/linux/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>linux</span></a><a class="article-meta__tags" href="/tags/sdn/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>sdn</span></a><a class="article-meta__tags" href="/tags/network/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>network</span></a></span></div></div><h1 class="post-title" itemprop="name headline">内核skb_sk_buff详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-12-23T06:44:56.000Z" title="发表于 2022-12-23 14:44:56">2022-12-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-29T06:14:31.933Z" title="更新于 2024-05-29 14:14:31">2024-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/"><header><a href="/tags/linux/" tabindex="-1" itemprop="url">linux</a><a href="/tags/sdn/" tabindex="-1" itemprop="url">sdn</a><a href="/tags/network/" tabindex="-1" itemprop="url">network</a><h1 id="CrawlerTitle" itemprop="name headline">内核skb_sk_buff详解</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2022-12-23T06:44:56.000Z" title="发表于 2022-12-23 14:44:56">2022-12-23</time><time itemprop="dateCreated datePublished" datetime="2024-05-29T06:14:31.933Z" title="更新于 2024-05-29 14:14:31">2024-05-29</time></header><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Linux 内核 skb，是 struct sk_buff 数据结构的简称，skb 可以说是内核网络子系统使用最多，也是最重要的数据结构。掌握 skb 对内核协议栈的理解，以及网络设备驱动程序的实现至关重要。本文的目的是帮助你对 skb 结构以及相关辅助函数有深入领会，并尝试解决以下疑问：</p>
<ol>
<li>skb 在内核的哪些层次会被使用</li>
<li>skb 有哪些重要的成员，如何借助于一些辅助函数操作这些成员</li>
<li>skb_shared_info 中的 frags 和 frag_list 有什么区别，各自的用途是什么</li>
<li>怎么基于 skb_shared_info 中的 frags[] 实现磁盘文件到网络的零拷贝</li>
<li>怎么基于 skb_shared_info 中的 frags[] 实现 TSO （硬件 TCP Segment Offload）</li>
<li>linux 内核和驱动是如何支持 scatter-gather</li>
</ol>
<h2 id="skb-在哪里用"><a href="#skb-在哪里用" class="headerlink" title="skb 在哪里用"></a>skb 在哪里用</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-983934d8b576772d7323033ae3001f48_r.jpg"></p>
<p>如上图，Packet 流动方向 分为两个，一个是发送（TX or Transmit）方向；另一个是接受（RX or Receive）方向。对于 Packet 的流动路径，我们通常又称为数据路径（Data Path），所以数据路径包括了 Packet 的 TX 和 RX。</p>
<p>本篇文章只关心 SKB 在 kernel space 数据路径的使用，从上图可以看到 TCP&#x2F;IP Stack 和设备驱动之间是用 SKB 在流动数据。对于 TX 来说，传输层申请 SKB，设备驱动释放 SKB；对于 RX 来说，设备驱动申请 SKB，网络协议栈 TCP&#x2F;IP Stack 负责释放之。</p>
<p>如果你对底层设备的 DMA 感兴趣，建议阅读作者的另一篇文章 “<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/618143764">一文读懂 内存 DMA 及 设备内存控制</a>”。</p>
<h3 id="TX-方向"><a href="#TX-方向" class="headerlink" title="TX 方向"></a>TX 方向</h3><ol>
<li>用户态应用程序基于 socket 系统调用接口，传送需要 TX 的 HTTP 应用层数据（如 Ngnix 产生）</li>
<li>内核态 socket 层读取用户态数据，并按照应用层的协议类型，将数据发送到对应的传输层（如 HTTP 对应 TCP）</li>
<li><strong>传输层申请 skb 数据结构，并填充数据到 skb，然后 skb 会向下传送到网络层和链路层（链路层在内核对应网络设备层），继续添加 IP 和 MAC header 到 skb 中</strong>**</li>
<li>最后 skb 到达网络设备驱动，其从 skb 中获取到 packet data 数据的虚拟地址（skb-&gt;data)，并映射出 dma 总线地址给 网卡进行 DMA 读取</li>
</ol>
<h3 id="RX-方向"><a href="#RX-方向" class="headerlink" title="RX 方向"></a>RX 方向</h3><ol>
<li>如高速网卡收到从光纤上传入的数据包后，基于网卡内 DMA 控制器 和 PCIe 总线，将数据包送入设备驱动层</li>
<li><strong>设备驱动（Device Driver）收到数据包后，申请 SKB，并将数据放入 SKB 结构指向的数据空间（位于 skb 结构 的 head 和 end 指针之间）注：驱动放数据到 skb 有两种方式，一种方式是 dev_alloc_skb + memcpy；第二种是 page + build_skb 实现零拷贝，效率更高</strong></li>
<li><strong>驱动调用 NAPI Schedule 将 RX 数据送入 TCP&#x2F;IP Stack, 到达 IP 层则去除 SKB 指向数据的 IP Header，到达 TCP 层去除 TCP Head</strong></li>
<li>最后在内核基于 IP 等路由信息，查找到对应的 socket，将数据基于 socket 送入用户态应用程序</li>
</ol>
<h2 id="skb-x2F-sk-buff-结构"><a href="#skb-x2F-sk-buff-结构" class="headerlink" title="skb&#x2F;sk_buff 结构"></a>skb&#x2F;sk_buff 结构</h2><p>数据结构 sk_buff 的成员很多，但是掌握一个结构，必须从关键成员着手，否则就会迷失在辅助信息的汪洋大海之中。当然，不是说辅助信息不重要，只是其对我们理解和使用一个结构，不会起到决定性的作用。而我们理解一个结构，就是为了更好地运用之，所以下面将结合使用函数，来解释 skb 结构的关键成员。</p>
<h3 id="alloc-skb-or-dev-alloc-skb"><a href="#alloc-skb-or-dev-alloc-skb" class="headerlink" title="alloc_skb or dev_alloc_skb"></a>alloc_skb or dev_alloc_skb</h3><p>当协议栈需要 TX Packet 时，会调用 alloc_skb 分配 skb 实体；而设备驱动程序在 RX Packet 时，会调用 dev_alloc_skb 来分配 skb，当然这是一种低效的方式，因为需要将 RX 的数据 memcpy 到 skb 指向的 buffer 中。下面以 dev_alloc_skb 为例，说明该函数执行后的内存空间状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-12526a262c6fee85269a3c50d054c1ac_r.jpg"></p>
<p>dev_alloc_skb 只有一个输入参数 length，用于指定需要申请 buffer 长度：</p>
<ol>
<li>首先，该函数 会申请 sk_buff 结构体自身的内存，如上图左侧，用两种颜色展示了该结构体最重要的 4 个成员指针信息: Head&#x2F;End, Data&#x2F;Tail。</li>
<li>接着，会申请 data buffer 的内存，如上图右侧，Buffer 的总长度 buffer length &#x3D; NET_SKB_PAD + length + sizeof(struct skb_shared_info)</li>
</ol>
<p>对上图右侧数据 buffer 以及 左侧的各个指针解释如下：</p>
<ol>
<li>我们看到右侧 Buffer 分为三块，第一块是 NET_SKB_PAD （#define NET_SKB_PAD max(32, L1_CACHE_BYTES)， 即 L1 CACHE Line 的大小，I7 CPU 为 64 Bytes</li>
<li>Length 是 dev_alloc_skb 的输入参数</li>
<li>第三块 sizeof(struct skb_shared_info)，后面会有详细的讲解，其用于分散聚合（Scatter Gather）</li>
<li>NET_SKB_PAD + length 长度的 buffer 用于存放数据包，而 sizeof(struct skb_shared_info) 只是一个结构的长度，该结构的成员会再指向分散聚合的数据包</li>
<li>head&#x2F;data&#x2F;tail 初始时指向 buffer 的起始位置。而 end 指向 NET_SKB_PAD + length 长度的 buffer 尾部</li>
</ol>
<p>参考源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> sk_buff *<span class="title function_">dev_alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = NET_SKB_PAD + length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配skb 结构体的内存*/</span></span><br><span class="line">    skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 size 和 L1 Cache Line 长度对齐 */</span></span><br><span class="line">    size = SKB_DATA_ALIGN(size);</span><br><span class="line">    <span class="comment">/* size 加上 sizeof(struct skb_shared_info)，并与  L1 Cache Line 长度对齐 */</span></span><br><span class="line">    size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info));</span><br><span class="line">    <span class="comment">/* 申请 skb 指向的 data buffer 空间 */</span></span><br><span class="line">    data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line">    skb-&gt;head = data;</span><br><span class="line">    skb-&gt;data = data;</span><br><span class="line">    skb_reset_tail_pointer(skb);</span><br><span class="line">    skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skb-reserve"><a href="#skb-reserve" class="headerlink" title="skb_reserve"></a>skb_reserve</h3><p>如下图，调用 skb_reserve(skb, len) 之后，会将 data 和 tail 指向 len 开始的位置，即在 skb-&gt;head 和 skb-&gt;data 之间，加入一个保留的头部空间（resv_len），便于协议栈做头部扩展，而不需要移动 data 指针后面的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-1fa64415b60a4dee14f869b9e5019c68_r.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void skb_reserve(struct sk_buff *skb, int len)</span><br><span class="line">&#123;</span><br><span class="line">    skb-&gt;data += len;</span><br><span class="line">    skb-&gt;tail += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skb-put"><a href="#skb-put" class="headerlink" title="skb_put"></a>skb_put</h3><p>skb put 负责向 skb 指向的 buffer 中添加数据。如下图，在将数据 memcpy(skb-&gt;data, put_len) 到 data 指针开始的位置时，需要调用 skb_put 移动 tail 指针到 skb-&gt;data + put_len 位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-59970b5e881768a16154c44050f5f4f9_r.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    skb_put - add data to a buffer</span></span><br><span class="line"><span class="comment"> *    @skb: buffer to use</span></span><br><span class="line"><span class="comment"> *    @len: amount of data to add</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    This function extends the used data area of the buffer. If this would</span></span><br><span class="line"><span class="comment"> *    exceed the total buffer size the kernel will panic. A pointer to the</span></span><br><span class="line"><span class="comment"> *    first byte of the extra data is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *tmp = skb_tail_pointer(skb);</span><br><span class="line">    SKB_LINEAR_ASSERT(skb);</span><br><span class="line">    skb-&gt;tail += len;</span><br><span class="line">    skb-&gt;len  += len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回原始的tail指针 */</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skb-push"><a href="#skb-push" class="headerlink" title="skb_push"></a>skb_push</h3><p>skb push 在 skb-&gt;data 指针前面继续添加数据。例如在协议栈 TX 数据包时，需要添加 IP，UDP 等协议头部信息，则会调用 skb_push 将 skb-&gt;data 指针向上移动 push_len 长度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-c274bd73752bc0b3b8fe9ba18933b8c5_r.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    skb_push - add data to the start of a buffer</span></span><br><span class="line"><span class="comment"> *    @skb: buffer to use</span></span><br><span class="line"><span class="comment"> *    @len: amount of data to add</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    This function extends the used data area of the buffer at the buffer</span></span><br><span class="line"><span class="comment"> *    start. If this would exceed the total buffer headroom the kernel will</span></span><br><span class="line"><span class="comment"> *    panic. A pointer to the first byte of the extra data is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">skb_push</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    skb-&gt;data -= len;</span><br><span class="line">    skb-&gt;len  += len;</span><br><span class="line">    <span class="keyword">return</span> skb-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skb-pull"><a href="#skb-pull" class="headerlink" title="skb_pull"></a>skb_pull</h3><p>skb pull 从 skb-&gt;data 指向的位置向下移动，类似于 pop 出栈。如下图，将上一次 push_len 给 pop 掉，则 skb-&gt;data 回到 skb_put 时的起始位置。这主要被协议栈 RX 收包时，去除协议头时使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-4bb88b66aa1a655516d2ca793ada8302_r.jpg"></p>
<h3 id="SKB-常用成员"><a href="#SKB-常用成员" class="headerlink" title="SKB 常用成员"></a>SKB 常用成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>      *<span class="title">next</span>;</span>     <span class="comment">// frag_list 通过next串联起来（下文会介绍frag_list）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        len;       <span class="comment">// 线性区和非线性区数据总长（下文会详细介绍）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        data_len;  <span class="comment">// 非线性区的数据总长，包括frags和fraglist</span></span><br><span class="line">    __u16               queue_mapping; <span class="comment">//网络设备层（L2）选择该packet的发送Queue ID, 该Queue ID通常会作为网络设备驱动发包的Ring ID</span></span><br><span class="line"></span><br><span class="line">    __u8            ip_summed:<span class="number">2</span>; <span class="comment">/*如果协议栈没有算checksum，其被赋值为CHECKSUM_PARTIAL，指示硬件做checksum的无状态卸载（即硬件计算checksum）*/</span></span><br><span class="line">    __u8            encapsulation:<span class="number">1</span>; <span class="comment">/* 指示该skb指向的数据包是否为一个隧道Tunnel 包*/</span></span><br><span class="line">    __be16          vlan_proto;  <span class="comment">/* 当设备支持VLAN卸载时，packet L2层会没有VLAN，</span></span><br><span class="line"><span class="comment">                                             * VLAN protocol（1Q， 1AD)会填充在该字段，</span></span><br><span class="line"><span class="comment">                                             * cos 和 vlan id 填充在下一个字段</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">    __u16            vlan_tci;</span><br><span class="line">    __be16            protocol; <span class="comment">// 协议类型，VLAN封包为 ETH_P_8021Q 或 ETH_P_8021AD，普通包为L3协议类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">    <span class="type">sk_buff_data_t</span>       tail;   <span class="comment">// skb 线性区有效数据的结尾位置  </span></span><br><span class="line">    <span class="type">sk_buff_data_t</span>       end;    <span class="comment">// skb 线性区结束位置，从tail到end之间称为tailroom</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>        *head;  <span class="comment">// skb 线性区开头指针，从head到data之间称为headroom</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>        *data;  <span class="comment">// skb 线性区有效数据的起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">refcount_t</span>        users;  <span class="comment">// skb 被引用次数，当引用计数为零时，即可释放</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TX-发包示例"><a href="#TX-发包示例" class="headerlink" title="TX 发包示例"></a>TX 发包示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配 skb */</span></span><br><span class="line">skb = alloc_skb(len, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置保留空间 */</span></span><br><span class="line">skb_reserve(skb, header_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* skb put 将tail+user_data_len，返回原始tail指针 给 data*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = skb_put(skb, user_data_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将用户态user_pointer的数据 copy 到 data */</span></span><br><span class="line">skb-&gt;csum = csum_and_copy_from_user(user_pointer, data, user_data_len, <span class="number">0</span>, &amp;err);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">uh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将skb data 指针向上移动 udphdr size，然后赋值 udp head*/</span></span><br><span class="line">skb-&gt;h.raw = skb_push(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr));</span><br><span class="line">uh = skb-&gt;h.uh</span><br><span class="line">uh-&gt;source = fl-&gt;fl_ip_sport;</span><br><span class="line">uh-&gt;dest = fl-&gt;fl_ip_dport;</span><br><span class="line">uh-&gt;len = htons(user_data_len);</span><br><span class="line">uh-&gt;check = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="什么是（skb-shared-info）"><a href="#什么是（skb-shared-info）" class="headerlink" title="什么是（skb_shared_info）"></a>什么是（skb_shared_info）</h2><h3 id="结构自身放在哪里"><a href="#结构自身放在哪里" class="headerlink" title="结构自身放在哪里"></a>结构自身放在哪里</h3><p>首先我们来看看，内核是如何获取到一个已知 SKB 的 shared info 的结构信息的。如下实现非常简洁，就是从 skb-&gt;end 指针开始的位置，基于结构 (struct skb_shared_info *) 强制转换即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> skb_shinfo(SKB)    ((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_end_pointer</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以你现在可以体会到，为什么在前面的图中，将结构 (struct skb_shared_info）画在 skb-&gt;end 之后。</p>
<p>这是一个比较诡异的地方，我们通常会以为，struct sk_buff 和 struct skb_shared_info 都是管理 skb 的结构。所以应该将 struct skb_shared_info 放入 struct sk_buff ，将所有管理数据结构的内存空间放在一起才比较好。但是内核不是这样设计的，其将 shared info 结构放到了 skb-&gt;end 的数据区后面。</p>
<h3 id="结构体重要成员"><a href="#结构体重要成员" class="headerlink" title="结构体重要成员"></a>结构体重要成员</h3><p>该数据结构的核心灵魂就是 frag_list 成员 和 frags 数组。结构 structskb_shared_info 以及 struct skb_frag_struct 重要成员的解释如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This data lives at</span></span><br><span class="line"><span class="comment"> * the end of the header data, ie. at skb-&gt;end.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    __u8        nr_frags; <span class="comment">/* frags 数组中有效的成员个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>    gso_size; <span class="comment">/* 进行 TCP 分段时，每段最大长度，即TCP头部的MSS，因为硬件可以做TSO（TCP 分段），所以网络设备驱动需要传给硬件 */</span></span><br><span class="line">    <span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>    gso_segs; <span class="comment">/* 按照gso_size 即MSS进行 TCP 分段时，该skb将被分为多少段 segments */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>    *<span class="title">frag_list</span>;</span> <span class="comment">/* UDP大块数据包需要分为多个Size为MTU的数据包，每个MTU数据包对应一个SKB，这些SKB通过该结构进行链表连接 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">    <span class="type">skb_frag_t</span>    frags[MAX_SKB_FRAGS];<span class="comment">/* 驱动和硬件支持 Scatter Gatter 对小块数据进行聚合，以及 TSO（硬件TCP分段）会用到该数组（后面会有详细介绍）*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每个 skb_frag_t 存放数据块基于 struct page 的地址和长度信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skb_frag_struct</span> <span class="title">skb_frag_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_frag_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span>;</span></span><br><span class="line">    &#125; page;                             <span class="comment">/* 当前 块数据对应 page 的虚拟地址*/</span></span><br><span class="line">    __u32 page_offset;                  <span class="comment">/* 当前 块数据在 page 中的偏移量，所以一个page可以给多个frags共享 */</span></span><br><span class="line">    __u32 size;                         <span class="comment">/* 当前 块数据的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="skb-数据空间划分"><a href="#skb-数据空间划分" class="headerlink" title="skb 数据空间划分"></a>skb 数据空间划分</h3><p>skb head 和 end 之间的数据区称为线性区，而 skb_shared_info 中 frags 和 frag_list 指向的数据区统称为非线性区。下图摘自《深入理解 LINUX 网络技术内幕》，完整展示了 skb 管理的各个内存数据区。</p>
<p>但是通过上面的基础铺垫，你应该会发现一点不妥的地方。那就是 skb_shinfo(SKB) 对应的 skb_shared_info 结构，在内存空间上，并不是排在 struct sk_buff 结构的后面，而是接在 skb-&gt;end 的后面。但是这幅图也有其优势，即管理的结构放在左边，而数据部分位于右边，更便于我们的理解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-2dcb0c9b0a72891d481170343b1d2bd8_r.jpg"></p>
<ul>
<li><strong>线性区</strong></li>
</ul>
<p>skb 线性区的总长度 &#x3D; skb_headlen(skb) &#x3D; S</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">skb_headlen</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> skb-&gt;len - skb-&gt;data_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非线性区</strong></li>
</ul>
<p>skb 非线性区的总长度 &#x3D; skb-&gt;datalen &#x3D; S1 + S2 + S3</p>
<p>下面内核代码通过 unsigned int data_len 返回 bool 类型，如果 data_len 大于 0，则返回 true，即 skb 存储的数据是非线性化的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">skb_is_nonlinear</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> skb-&gt;data_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>总长</strong></li>
</ul>
<p>skb 线性区 加 非线性区的 总长度 &#x3D; skb-&gt;len &#x3D; S + S1 + S2 +S3</p>
<p>skb 线性区 加 frags 非线性区总长 &#x3D; skb_pagelen(skb) &#x3D; S + S1 + S2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">skb_pagelen</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> skb_headlen(skb) + __skb_pagelen(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loop 相加所有 frags[i] 的size，总共有 nr_frags 数量的 frags[i] */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __skb_pagelen(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = skb_shinfo(skb)-&gt;nr_frags - <span class="number">1</span>; (<span class="type">int</span>)i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        len += skb_frag_size(&amp;skb_shinfo(skb)-&gt;frags[i]);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">skb_frag_size</span><span class="params">(<span class="type">const</span> <span class="type">skb_frag_t</span> *frag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> frag-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="干什么（skb-shared-info）"><a href="#干什么（skb-shared-info）" class="headerlink" title="干什么（skb_shared_info）"></a>干什么（skb_shared_info）</h2><p>要深入 skb_shared_info 是干什么用的，还是需要深入其结构成员。前面我们提到，skb_shared_info 中两个最重要的成员，就是 frags 和 frag_list。很多人可能会存在疑问，这两个看起来很像的家伙，到底有什么区别呢，分别会用在哪些应用场景下呢？本章节将尝试来回答这两个作者研究已久，但可能会回答不够全面的问题。</p>
<p>首先给出结论：</p>
<ol>
<li>frags 会用在 内核 GSO 功能（将 TCP 分断从内核协议栈的 TCP 层推迟到 Netdev 或 L2 层）；</li>
<li>frags 会用在 内核和网络设备配合的 TSO 功能（将 TCP 分段从协议栈的 TCP 层推迟到硬件实现）；</li>
<li>frags 会用在 内核和网络设备配合的 Scatter Gather（SG） 功能，SG 是指应用层发送小片数据包，然后硬件负责聚合为一笔包。另外 SG 也是 TSO 功能、用户态 sendfile 实现零拷贝的基础设施</li>
<li>frag_list，目前作者看到的主要是 应用程序发送巨大 UDP 数据时，协议栈 IP 层的分片功能，将其分解为多个 小于 MTU 的 skb，然后通过 frag_list 将这些 skb 通过 next 指针串联起来。在网络设备层，会将每个 frag_list 中的每个 skb，独立的传输给 设备驱动层，目前的高速网卡，还没有看到支持 frag_list 的硬件卸载（如果驱动和硬件支持 frag_list 的卸载，则只需要传递包括 frag_list 的第一个 skb 给驱动即可）。</li>
</ol>
<h3 id="frags-应用场景"><a href="#frags-应用场景" class="headerlink" title="frags 应用场景"></a>frags 应用场景</h3><p>作者所知的 frags 应用场景有三个，而且这三个场景都需要软硬件一起配合来实现。第一个是 Scatter Gather（分散聚合）；第二个是 TSO - TCP Segment Offload（TCP 分段卸载）；第三个是通过网络发送磁盘文件的零拷贝。</p>
<ul>
<li><strong>Scatter Gather</strong></li>
</ul>
<p>Scatter Gather 的字面意思是分散聚合，分散聚合功能需要软件（OS + 驱动）和硬件的一起协作配合才可实现，Scatter Gather 主要用在 TX 方向。如下需要确认网络设备是否开启了 Scatter Gathter。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* tx-scatter-gather on 表示硬件可以支持分散聚合，而该功能是基于 skb_shinfo(skb)-&gt;frags[i] 来实现*/</span><br><span class="line">$ ethtool -k ens39f0 | grep scatter</span><br><span class="line">scatter-gather: on</span><br><span class="line">        tx-scatter-gather: on</span><br><span class="line">        tx-scatter-gather-fraglist: off [fixed]</span><br><span class="line"></span><br><span class="line">/* 关闭 scatter gather */</span><br><span class="line">$ sudo ethtool -K ens39f0 sg off</span><br><span class="line">Actual changes:</span><br><span class="line">tx-scatter-gather: off</span><br><span class="line">$ ethtool -k ens39f0 | grep scatter</span><br><span class="line">scatter-gather: off</span><br><span class="line">        tx-scatter-gather: off</span><br><span class="line"></span><br><span class="line">/* 开启 scatter gather */</span><br><span class="line">$ sudo ethtool -K ens39f0 sg on</span><br><span class="line">/* 除了上面的手动开启，也可以在驱动 初始化时开启：netdev-&gt;features = NETIF_F_SG */</span><br><span class="line">static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span><br><span class="line">&#123;</span><br><span class="line">    netdev = alloc_etherdev_mq(sizeof(struct ixgbe_adapter), indices);</span><br><span class="line">    netdev-&gt;features = NETIF_F_SG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>软件产生的是一块一块分散（内存可能不连续）的数据，而硬件分别对每个分散的数据块进行 DMA 读，然后硬件再负责将每个数据块合并为一笔完整的数据包并发出。这就实现了一种数据发送的加速，因为应用层生成多个小片数据包后，再做一次最终发送时，内核协议栈软件就不需要将每片数据进行复制和拼接，毕竟硬件做一般都比软件快。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-3b8e2d62797fcfdcc0814fe0b6e83b75_r.jpg"></p>
<p>如上图，“nr_flags” （number flags）为 2，第一个 flags[0] 和第二个 flags[1] 全部指向同一个 Page 的起始地址。使用 page_offset 来进行页内的偏移，size 分别为 S1 和 S2。</p>
<p>需要注意的是，skb 线性和非线性区的总长度为 X+S1+S2，其通常小于 MTU，比如 MTU 为 1500，则同一个 skb 所有 frags 的数据长度相加，也通常小于 MTU，所以也小于默认 page size 4K。但只是通常而已，下一小节 TSO 将说明大于 MTU 的情况。</p>
<p>基于上图示例，驱动程序会针对 3 份 payloay 数据（X，S1，S2），产生三个 dma 地址。数据 X 产生 DMA 地址的方式是 【dma &#x3D; dma_map_single(device, skb-&gt;data, skb_headlen(skb), DMA_TO_DEVICE)】，数据 S1 和 S2 产生 DMA 地址的方式是 【dma &#x3D; skb_frag_dma_map(device, frags[i], 0, frags[i].size, DMA_TO_DEVICE)】，将这些 DMA 地址传给硬件，即可让硬件来干聚合的脏活啦，哈哈太坏了。</p>
<p>例如 ixgbe 驱动访问每个 frags 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ixgbe_tx_map</span><span class="params">(<span class="keyword">struct</span> ixgbe_ring *tx_ring, <span class="keyword">struct</span> ixgbe_tx_buffer *first, <span class="type">const</span> u8 hdr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = skb_headlen(skb);</span><br><span class="line">    data_len = skb-&gt;data_len;</span><br><span class="line">    dma = dma_map_single(tx_ring-&gt;dev, skb-&gt;data, size, DMA_TO_DEVICE);</span><br><span class="line">    <span class="keyword">for</span> (frag = &amp;skb_shinfo(skb)-&gt;frags[<span class="number">0</span>];; frag++) &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (likely(!data_len))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        size = skb_frag_size(frag);</span><br><span class="line">        data_len -= size;</span><br><span class="line">        dma = skb_frag_dma_map(tx_ring-&gt;dev, frag, <span class="number">0</span>, size, DMA_TO_DEVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知硬件干活 */</span> </span><br><span class="line">    writel(i, tx_ring-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>TSO</strong></li>
</ul>
<p>我们知道 TCP 头部信息中，有个 MSS （Max Segment Size）字段。在 TCP 进行三次握手时，客户端和服务器端会基于路径 MTU 等信息协商一个最大的 分段大小 MSS（例如 MTU &#x3D; 1500， 则通常 MSS &#x3D; MTU - IP_head_size - TCP_head_size &#x3D; 1500 - 20 - 20 &#x3D; 1460，IP head 和 TCP head size 通常都是 20）。</p>
<p>协商得到 MSS 之后，从客户或服务端（用于协商 IP 地址）发出 packet 的 TCP 数据大小（TCP 层后面的数据 &#x3D; HTTP 等协议头 + Data），必须小于 MSS 值。所以对于应用层协议 write 发送的大于 MSS 的数据包，就需要在内核的 TCP 协议层进行分段。当然，前提条件是以下两个开关（TSO 和 GSO）全部关闭，只要有一个开启，则 TCP 协议层就不会做分段的工作。GSO 开启，则分段工作推迟内核网络设备层；TSO 开启，则分段工作推迟到硬件网络设备如网卡。</p>
<p>前文提到，同一个 skb 的线性区和非线性区数据总长，通常小于 MTU。但是，如果网络设备开启了 TSO，那就不一定了。在硬件支持 TSO（tcp-segmentation-offload）功能时，每个 frags 指向数据的大小，通常可以到达 32K（8 个 pages），所以一个 frags[] 也可以由多个 pages 拼接而成。下面是关闭和开启网络设备（网卡）TSO 的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 确认 TSO 功能是否开启 */</span><br><span class="line">$ ethtool -k ens39f0 | grep tcp</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">/* 关闭/开启 TSO */</span><br><span class="line">$ ethtool -K ens39f0 tso off</span><br><span class="line">$ ethtool -K ens39f0 tso on</span><br></pre></td></tr></table></figure>

<p>如下图，在 TSO 开启时，内核协议栈需要发送一笔 大于 36KB 的数据包，则申请 了两个 frags，frags[0] 对应 8 个 pages，共 32KB，而 frags[1] 对应一个 Page，为 4KB。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-adc9948d5999d39423536581c85e5261_r.jpg"></p>
<p>网络驱动程序，在接受到 如上图 远大于 MTU（网卡的最大 MTU 通常为 9600，约为 9K） 的超大数据包之后，会指示硬件进行 TSO 分段处理。以下是为做 TSO 做准备代码的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ice_tso</span><span class="params">(<span class="keyword">struct</span> ice_tx_buf *first, <span class="keyword">struct</span> ice_tx_offload_params *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!skb_is_gso(skb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* determine offset of outer transport header */</span></span><br><span class="line">    l4_start = (u8)(l4.hdr - skb-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* compute length of TCP segmentation header */</span></span><br><span class="line">    off-&gt;header_len = (u8)((l4.tcp-&gt;doff * <span class="number">4</span>) + l4_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cd_tso_len 是数据包总长 减去 L2到L4总长，得到 TCP 数据部分的总长（包括应用层协议头） */</span></span><br><span class="line">    cd_tso_len = skb-&gt;len - off-&gt;header_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cd_mss  是指示硬件在做TCP 分段时，每笔 TCP 包的 MSS */</span></span><br><span class="line">    cd_mss = skb_shinfo(skb)-&gt;gso_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给硬件生产 Packet 时，即生成 skb-&gt;data 和 每个 frags 的 dma 地址，如果数据的长度 大于 硬件 一次 DMA 的最大长度（通常为 16K），则需要针对超长 frags（如 32K）切分出多个 dma 地址给硬件做 DMA Read。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ice_tx_map</span><span class="params">(<span class="keyword">struct</span> ice_ring *tx_ring, <span class="keyword">struct</span> ice_tx_buf *first, <span class="keyword">struct</span> ice_tx_offload_params *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data_len, size;</span><br><span class="line"></span><br><span class="line">    skb = first-&gt;skb;</span><br><span class="line">    data_len = skb-&gt;data_len;</span><br><span class="line">    size = skb_headlen(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先，线性区的 skb-&gt;data 做 dma 映射，得到 硬件可以读取操作 dma 地址 */</span></span><br><span class="line">    dma = dma_map_single(tx_ring-&gt;dev, skb-&gt;data, size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (frag = &amp;skb_shinfo(skb)-&gt;frags[<span class="number">0</span>];; frag++) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> max_data = ICE_MAX_DATA_PER_TXD_ALIGNED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* account for data chunks larger than the hardware can handle */</span></span><br><span class="line">        <span class="comment">/* 当一个 frags 或 skb-&gt;data 对应的大小（如32K） 超过硬件支持的最大一次DMA长度时，需要分多个 DMA读 */</span></span><br><span class="line">        <span class="keyword">while</span> (unlikely(size &gt; ICE_MAX_DATA_PER_TXD)) &#123;</span><br><span class="line">            dma += max_data;</span><br><span class="line">            size -= max_data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size = skb_frag_size(frag);</span><br><span class="line">        data_len -= size;</span><br><span class="line"></span><br><span class="line">        dma = skb_frag_dma_map(tx_ring-&gt;dev, frag, <span class="number">0</span>, size, DMA_TO_DEVICE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基于 frags 的零拷贝</strong></li>
</ul>
<p>基于 frags 不仅可以实现 Scatter、TSO，而且可以实现从读取磁盘文件到网络发送的零拷贝。在说明零拷贝之前，我们首先看一下通过 file read 和 socket write 发送 文件的系统资源消耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file_fd, tmp_buf, len);</span><br><span class="line">write(socket_fd, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<ol>
<li>OS 上下文切换操作：共 4 次（下图上半部分表示上下文切换，红色 1，2，3，4 表示切换的时机），read 和 write 分别需要两次。首先，read 系统调用需要从用户态陷入内核态，再从内核态回到用户态；其次 write 系统调用类似。</li>
<li>DMA 控制器和 CPU 参与的 Copy：共 4 次（下图下半部分表示内存拷贝，蓝色 1，2，3，4 表示拷贝的时机）。首先 ，DMA 控制器从磁盘文件 拷贝数据到 Kernel Buffer（这不需要 CPU 参与）；然后，CPU 将数据从 Kernel Buffer 拷贝到 用户态 User buffer；接着，CPU 通过 socket write 系统调用，将数据从 user buffer 拷贝到 内核 socket buffer；最后，网卡（nic）通过 DMA 控制器将 数据从 Socket Buffer 拷贝到网卡硬件进行发送。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-6798411177c14b1a621e8cdb39661643_r.jpg"></p>
<p>上面 4 次上下文切换，4 次数据拷贝的繁重任务，是否有优化办法呢？答案是肯定的，因为 skb 有 frags 实现分散聚合的功能，通过内核的适当优化调整，支持 用户态的 sendfile 功能，从而去掉了部分上下文切换和数据拷贝的动作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-f1562800568627cf06a506ebbbab6c7d_r.jpg"></p>
<ol>
<li>OS 上下文切换操作：sendfile 需要共 2 次（上图上半部分表示上下文切换，红色 1，2 表示切换的时机）。sendfile 系统调用需要从用户态陷入内核态，再从内核态回到用户态。</li>
<li>DMA 控制器参与的 Copy：共 2 次（上图下半部分表示内存拷贝，蓝色 1，2 表示拷贝的时机）。首先 ，DMA 控制器从磁盘文件 拷贝数据到 Kernel Buffer（这不需要 CPU 参与）；然后，数据并不会真正从 kernel Buffer 拷贝到 socket buffer，而只是通过指针赋值的方式，因为从磁盘读出的数据放在 struct page 指向内存，而该内存指针直接赋值给 frags[].page 即可；最后，网卡（nic）通过 DMA 控制器直接从 Kernel Buffer 拷贝数据到网卡发送。</li>
</ol>
<p>你可能想说，这能叫零拷贝吗，不是还有 DMA Copy 吗。说得没错，的确还需要 DMA 控制器的参与，但是相对低效的 CPU 拷贝已经消除了，而且少了两次上下文切换，整体的效率提升是相当明显的。</p>
<h3 id="frag-list-应用场景"><a href="#frag-list-应用场景" class="headerlink" title="frag_list 应用场景"></a>frag_list 应用场景</h3><p>据我所知，frag_list 主要用在内核协议栈的 IP 分片。目前看来，还很少有硬件网络设备支持 frag list 卸载（如果硬件支持卸载，则设备驱动会对 netdevice feature 或上 NETIF_F_FRAGLIST，即 netdev-&gt;hw_features |&#x3D; NETIF_F_FRAGLIST）。</p>
<p>例如，当应用层 write 发送一笔 4432 (S1 + S2 + S3) 字节的 packet，MTU 为 1500， 则会分为三个 skb 进行发送。三个 skb 通过第一个 skb 的 frag_list 作为链表的头部，后面两个 skb 通过 skb-&gt;next 指针进行串联。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-caa9e4a6103681b6a41320659559fa40_r.jpg"></p>
<p>在 IP 协议层，ip_fragment 调用 ip_do_fragment 进行 IP 分片，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    This IP datagram is too large to be sent in one piece.  Break it up into</span></span><br><span class="line"><span class="comment"> *    smaller pieces (each of size equal to IP header plus</span></span><br><span class="line"><span class="comment"> *    a block of the data of the original IP data part) that will yet fit in a</span></span><br><span class="line"><span class="comment"> *    single device frame, and queue such a frame for sending.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_do_fragment</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> (*output)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* When frag_list is given, use it. First, check its validity:</span></span><br><span class="line"><span class="comment">     * some transformers could create wrong frag_list or break existing</span></span><br><span class="line"><span class="comment">     * one, it is not prohibited. In this case fall back to copying.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * LATER: this step can be merged to real generation of fragments,</span></span><br><span class="line"><span class="comment">     * we can switch to copy when see the first bad fragment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skb_has_frag_list(skb)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> first_len = skb_pagelen(skb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/* Prepare header of the next frame, before previous one went down. */</span></span><br><span class="line">            <span class="keyword">if</span> (frag) &#123;</span><br><span class="line">                <span class="comment">/* 加入IP头 iph 到 skb network head，如果frag-&gt;next 还有skb， 则需要在IP 头部加上 more frag 标志 IP_MF */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(skb_network_header(frag), iph, hlen);</span><br><span class="line">                iph = ip_hdr(frag);</span><br><span class="line">                iph-&gt;tot_len = htons(frag-&gt;len);</span><br><span class="line">                ip_copy_metadata(frag, skb);</span><br><span class="line">                <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">                    ip_options_fragment(frag);</span><br><span class="line">                offset += skb-&gt;len - hlen;</span><br><span class="line">                iph-&gt;frag_off = htons(offset&gt;&gt;<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (frag-&gt;next)</span><br><span class="line">                    iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 发送 frag list 中的每个 skb 分片 */</span></span><br><span class="line">            err = output(net, sk, skb);</span><br><span class="line"></span><br><span class="line">            skb = frag;</span><br><span class="line">            frag = skb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>提两个问题给自己，大家有想法也请帮忙解答：</p>
<ol>
<li>当多个 frags[] 指向的空间是线性连续的，驱动可否合并这些 frags，让硬件做一次 DMA 读？</li>
<li>在开启 TSO 时，如果一个 frags[] 指向的数据达到 32K，而一个 page 是 4K，即一个 frags[] 指向 8 个 page。而这 8 个 page 采用 一个 DMA 地址传递给硬件，硬件做 DMA 时需要这 8 个 page 是物理连续的。内核的内存页管理是如何保证分配多个连续性的物理页？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解 Linux 网络技术内幕》</p>
<p>zero copy：<a href="https://link.zhihu.com/?target=https://www.linuxjournal.com/article/6345">Zero Copy I: User-Mode Perspective</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/')">内核skb_sk_buff详解</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=内核skb_sk_buff详解&amp;url=https://shippomx.github.io/2022/12/23/sdn/%E5%86%85%E6%A0%B8%20skb_sk_buff%20%E8%AF%A6%E8%A7%A3/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/linux/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>linux<span class="tagsPageCount">41</span></a><a class="post-meta__box__tags" href="/tags/sdn/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>sdn<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/network/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>network<span class="tagsPageCount">9</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/23/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">如何实现ring buffer</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/23/sdn/netperf%20%E7%9A%84%E4%BD%BF%E7%94%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">netperf的使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/12/23/sdn/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ring%20buffer/" title="如何实现ring buffer"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-23</div><div class="title">如何实现ring buffer</div></div></a></div><div><a href="/2022/12/23/sdn/dpdk%E7%BC%96%E8%AF%91/" title="DPDK编译"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-23</div><div class="title">DPDK编译</div></div></a></div><div><a href="/2020/05/11/tcpdump%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="tcpdump 使用指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-05-11</div><div class="title">tcpdump 使用指南</div></div></a></div><div><a href="/2022/12/23/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%B7%A5%E5%85%B7%20iperf%20%E4%B8%8E%20netperf/" title="网络性能测量工具iperf和netperf"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-23</div><div class="title">网络性能测量工具iperf和netperf</div></div></a></div><div><a href="/2022/12/23/sdn/Tcpreplay%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="TCPReplay的简单使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-23</div><div class="title">TCPReplay的简单使用</div></div></a></div><div><a href="/2022/12/23/sdn/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F/" title="以太网帧格式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-23</div><div class="title">以太网帧格式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">序言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#skb-%E5%9C%A8%E5%93%AA%E9%87%8C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">skb 在哪里用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-%E6%96%B9%E5%90%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">TX 方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RX-%E6%96%B9%E5%90%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">RX 方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skb-x2F-sk-buff-%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">skb&#x2F;sk_buff 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-skb-or-dev-alloc-skb"><span class="toc-number">1.2.1.</span> <span class="toc-text">alloc_skb or dev_alloc_skb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-reserve"><span class="toc-number">1.2.2.</span> <span class="toc-text">skb_reserve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-put"><span class="toc-number">1.2.3.</span> <span class="toc-text">skb_put</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-push"><span class="toc-number">1.2.4.</span> <span class="toc-text">skb_push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-pull"><span class="toc-number">1.2.5.</span> <span class="toc-text">skb_pull</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SKB-%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98"><span class="toc-number">1.2.6.</span> <span class="toc-text">SKB 常用成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-%E5%8F%91%E5%8C%85%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">TX 发包示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%EF%BC%88skb-shared-info%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">什么是（skb_shared_info）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%87%AA%E8%BA%AB%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">结构自身放在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">结构体重要成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skb-%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">skb 数据空间划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%88skb-shared-info%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">干什么（skb_shared_info）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frags-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">frags 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frag-list-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">frag_list 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/" title="加权轮询算法">加权轮询算法</a><time datetime="2023-12-10T05:29:00.000Z" title="发表于 2023-12-10 13:29:00">2023-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/02/sdn/Using%20ONOS%20as%20a%20robust%20SDN%20controller%20with%20Mininet/" title="using onos as a robust sdn controller with mininet">using onos as a robust sdn controller with mininet</a><time datetime="2023-11-02T03:12:32.000Z" title="发表于 2023-11-02 11:12:32">2023-11-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/10/golang/%E8%B0%88%E8%B0%88%20go.mod%E3%80%81go.sum%E3%80%81go.work/" title="go modules">go modules</a><time datetime="2023-10-10T02:13:22.000Z" title="发表于 2023-10-10 10:13:22">2023-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/cmake%20starter/" title="cmake starters">cmake starters</a><time datetime="2023-10-08T03:25:56.000Z" title="发表于 2023-10-08 11:25:56">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/07/containers/Docker%E5%AE%B9%E5%99%A8%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96/" title="Docker与虚拟化">Docker与虚拟化</a><time datetime="2023-10-07T06:44:56.000Z" title="发表于 2023-10-07 14:44:56">2023-10-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DPDK/" style="font-size: 0.88rem;">DPDK<sup>3</sup></a><a href="/tags/ONOS/" style="font-size: 0.88rem;">ONOS<sup>1</sup></a><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/configuration/" style="font-size: 0.88rem;">configuration<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>26</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>14</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>41</sup></a><a href="/tags/network/" style="font-size: 0.88rem;">network<sup>9</sup></a><a href="/tags/pppoe/" style="font-size: 0.88rem;">pppoe<sup>1</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>4</sup></a><a href="/tags/systemtap/" style="font-size: 0.88rem;">systemtap<sup>4</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>