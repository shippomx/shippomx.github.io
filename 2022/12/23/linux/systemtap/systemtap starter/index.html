<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>systemtap starter | 远辰</title><meta name="keywords" content="linux"><meta name="author" content="哪吒藕霸"><meta name="copyright" content="哪吒藕霸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="systemtap starter"><meta name="application-name" content="systemtap starter"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="systemtap starter"><meta property="og:url" content="https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/index.html"><meta property="og:site_name" content="远辰"><meta property="og:description" content="1. 介绍SystemTap是一种允许用户研究和监控操作系统（尤指Linux内核）运行细节的跟踪&amp;#x2F;剖析工具。SystemTap可以像netstat，ps，top和iostat那样统计系统数据；不止于此，为了收集信息，它还提供了更多过滤和分析的途径。 1.1. 编写本文档的目标SystemT"><meta property="og:locale" content="zh"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="哪吒藕霸"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1. 介绍SystemTap是一种允许用户研究和监控操作系统（尤指Linux内核）运行细节的跟踪&amp;#x2F;剖析工具。SystemTap可以像netstat，ps，top和iostat那样统计系统数据；不止于此，为了收集信息，它还提供了更多过滤和分析的途径。 1.1. 编写本文档的目标SystemT"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 哪吒藕霸","link":"链接: ","source":"来源: 远辰","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '远辰',
  title: 'systemtap starter',
  postAI: '',
  pageFillDescription: '1. 介绍, 1.1. 编写本文档的目标, 1.2. SystemTap的能力, 1.3. SystemTap的局限, 2. 安装和配置, 2.1. 安装和配置, 安装SystemTap, 手动安装依赖的内核调试信息包, 检查安装是否成功, 2.2. 为其它计算机生成检测模块, 2.3. 运行SystemTap脚本, 飞行记录仪模式, 内存型飞行记录仪模式, 文件型飞行记录仪模式, 3. 工作细节, 3.1. 结构, 3.2. 脚本, 事件, 同步事件, 异步事件, 处理程序, 3.3. 处理程序的基本结构, 变量, 目标变量（Target Variables）, 整齐打印目标变量（Pretty Printing Target Variables）, 条件语句, 命令行参数, 3.4. 关联数组, 3.5. 数组操作, 设置给定键的值, 获取给定键的值, 自增给定键的值, 遍历数组中的多个元素, 清除数组或数组中某个元素, 使用聚集变量（use aggregates）, 3.6. Tapsets, 3. 工作细节, 4. 用户空间探测, 4.1. 用户空间事件, 4.2. 访问用户空间目标变量, 4.3. 用户空间栈回溯, 5. SystemTap脚本集锦, 5.1. 网络, 剖析网络活动, 跟踪网络连接中的内核函数调用, 监控TCP连接的创建, 监控TCP包, 监控内核中的网络丢包情况, 5.2. 磁盘, 统计磁盘读写状况, 追踪对任意文件的读写, 追踪Ix2FO的累计总量, 监控指定设备的Ix2FO, 监控对指定文件的读写, 监控对指定文件的属性的修改, 定期输出块Ix2FO等待时间, 5.3. 剖析, 统计函数调用次数, 追踪函数调用链, 统计给定线程在内核空间和用户空间上的耗时, 监控应用轮询情况, 监控最常调用的系统调用, 找出每个进程的系统调用量, 5.4. 标识用户空间锁竞争, 6. 解读错误信息, 6.1. 解析和文法错误, 6.2. 运行时错误和警告, Summary介绍是一种允许用户研究和监控操作系统尤指内核运行细节的跟踪剖析工具可以像和那样统计系统数据不止于此为了收集信息它还提供了更多过滤和分析的途径编写本文档的目标允许使用者监控系统当前的运行情况以便进一步分析这将有助于运维或开发人员缉查或性能问题的罪魁祸首在开发出来之前要想监控一个运行中的内核有些时候需要注入检测代码重新编译安装还要重启一下的诞生把程序员从这一串繁琐的步骤中解放出来现在要想完成同样的工作你只需要简单地运行下自己写的脚本不过的目标用户是那些对内核驾轻就熟的老手对于内核菜鸟来说依旧难以上手雪上加霜的是现存的许多文档都假定读者有相当丰富的内核经验这使得学习的路途道阻且长为了降低入门的门槛我们编写了新手指南它包括下面的内容介绍和它的用法并列出各种型号内核下的安装方式提供监控系统各组件的运行详情的脚本作为例子并介绍它们的运行方式和分析其输出的能力灵活性提供了一门领域特定语言使得用户可以编写自定义脚本调查和监控各种内核函数系统调用和其它发生在内核空间的事件就此而言不仅仅是个工具它是一个让你能够自定义内核取证和监控工具的生态系统易于上手正如前面谈到的把用户从在探测内核空间事件时注入检测代码重新编译安装重启这一繁琐过程解放出来我们在第五章脚本集锦列出的大多数脚本所展现出的系统取证和监控能力是其它同类型工具比如所不能及的这些脚本很好地诠释了强大的功能届时将会拓宽诸位读者编写自己的脚本时的眼界的局限当前版本的提供的探测内核空间事件的众多选项可以在不同版本的内核下使用然而对探测用户空间事件的支持依赖于内核的支持需要机制而多数内核缺乏这一支持结果是仅有部分内核上的版本支持用户空间探测当前社区正集中力量改进的用户空间探测能力译注本指南写于年现今的内核普遍已经支持用户空间探测旧的内核用的是新的内核用的是安装和配置本章会教用户怎么安装并介绍脚本的运行方式安装和配置要想使用需要安装跟目标内核版本匹配的和包如果要在不止一个内核上运行需要根据每个内核的版本安装对应的和包接下来的几个小节里我们会详细讲解这一过程译注的里面有针对各发行版的安装步骤本节内容仅适用于且不能保证及时更新建议跳过本节直接参考官方文档如果你正好用的是可以参考的很多用户把记成了要想使用切记安装对应内核的包不是包安装要想使用安装下面的包以权限运行下面的命令注意要想用上还得安装依赖的内核调试信息包在较新的系统上仅需以权限运行下面的命令如果这个命令没起作用你需要按照下面的步骤手动安装手动安装依赖的内核调试信息包需要内核信息这样才能注入指令此外这些信息还能帮助生成合适的检测代码这些必要的内核信息分别包括在特定内核版本所对应的和包中对于标准版内核指按照常规配置编译的内核所需的和等包命名为同样的启用了的内核所需的包分别为和译注即物理地址拓展位可以用它拓展内存访问空间要想确定当前系统的内核版本敲入举个例子如果你想在环境下的内核上使用需要下载安装如下的包你安装的和包的版本一定要匹配目标内核的版本特性架构安装依赖的内核信息包最简单的方法就是用和命令命令包含在版本以上的包里还需要一个能够下载安装和包的源确保系统包管理的源满足要求运行下面的命令就能安装特定内核对应的包把命令中的替换成对应的内核名比如换成目标内核的版本举个例子安装内核所对应的内核信息包需要运行一旦手动下载了所依赖的包之后以权限运行下面的命令来安装它们检查安装是否成功如果你正在用的内核就是你的目标内核你现在就能检查下安装是否成功如果不是重启下系统并载入目标内核运行下面命令开始检查这个命令让在虚拟文件系统的读事件发生之后输出接着退出如果安装成功了应该会输出类似下面的内容从开始的最后三行说明已经成功地注入并运行了内核探测指令捕获了要探测的事件在这个例子里指虚拟文件系统的读事件并执行了有效的处理程序输出并正常退出为其它计算机生成检测模块当用户运行一个脚本时会从中创建一个内核模块然后会把该模块加载到内核里这样一来它就能从内核直接提取出特定的数据详见第节结构中会话部分一般来说脚本只能运行在安装了的系统上见第节安装和配置这意味着如果想在十个系统上运行你需要挨个系统安装在有些情况下这既不如人意也不合实际比如公司内部的规章可能会禁止管理员往机器上安装提供编译器或调试信息的包这么一来就没法安装了为了避开这个问题提供了交叉检测的功能在一台计算机上运行脚本生成在另一台机器上可用的检测模块这一过程就叫做交叉检测这一功能提供了以下便利仅需在单台开发机上安装适合其它机器的多个内核信息包每个目标机器仅需安装单个包来使用生成的检测模块译注所以说还是得安装新的包为简明起见定义下本节用到的几个术语检测模块由脚本创建的内核模块模块由主机系统创建并且将会被分发到目标系统的目标内核上主机系统在这个系统上编译脚本成目标系统上可用的检测模块目标系统需要应用检测模块的系统目标内核目标系统的内核这个内核将加载和运行检测模块为了创建可用的检测模块主机系统使用的硬件架构和分行版需要跟目标系统相同完成下面各步来配置主机系统和目标系统在每个目标系统上安装包通过运行获取每个目标系统的内核版本你将在主机系统上创建适用于目标系统的检测模块关于安装的信息请参考第节安装和配置中的安装译注请查看官方在主机系统上安装跟目标内核版本一样的内核和对应的内核信息包可以参考第节中的手动安装依赖的内核调试信息包如果多个目标系统使用的内核版本不一样每种内核版本都要安装一次完成了这几步后你现在可以在主机系统上给所有的目标系统创建检测模块了要想创建检测模块在主机系统运行下面命令记得把等改成实际的值在这里表示目标系统的版本目标系统上的输出表示需要编译成检测模块的脚本而则是你给检测模块起的名字要想获得当前内核的硬件架构你可以运行下面的命令一旦检测模块编译好了把它分发到目标系统然后加载它举个例子需要从脚本中创建检测模块来应用于版本为的目标系统架构使用下面命令这将创建一个名为的模块把它复制到目标系统并在目标系统上运行下面命令运行脚本包含了许多用于监控系统活动的命令行工具命令从脚本中读取探测指令把它们转化为代码构建一个内核模块并加载到当前的内核中命令会运行检测模块比如通过交叉检测创建的内核模块运行和需要较高的系统权限由于不是每个运行的用户都可以被授予权限对于那些没有权限的用户你可以把他们的帐号加入到下面的用户组中该组内的成员可以使用运行脚本或运行检测模块运行命令包括把脚本编译成内核模块并加载进内核这一操作需要较高的系统访问权限所以用户组下的成员会拥有较高的权限不幸的是这也意味着他们可以做到许多只有用户才能做到的事所以你应该只把那些原可以拥有权限的用户加到这个用户组中该组内的成员仅能使用命令来运行检测模块另外他们也只能在文件夹下运行模块注意这个文件夹必须仅由用户所拥有而且仅对用户可写命令从文件或标准输入中读取脚本要想让从文件中读取脚本需要在命令行中指定文件名要想让从标准输入中读取脚本需要用换掉文件名记得把用到的命令行选项挪到之前举个例子要让输出更多的运行信息输入下面列出常用的命令行选项让会话输出更加详细的信息你可以重复该选项多次来提高执行信息的详尽程度举个例子当你的脚本在运行时发生了错误可以加下这个选项查看更详细的输出信息关于错误信息的更多内容请参考第章解读错误信息将标准输出重定向到将输出文件的最大大小限制成存储文件的最大数目为这个命令实现了的功能每个输出文件会以序列号作为后缀译注会把日志切割成的形式每当一个日志文件达到最大大小时新开一个日志文件当日志文件数达到最大数目时旧的日志文件会被删掉设置处理函数为指定关于的更多信息请参考函数列表运行并在结束时退出该选项同时会把设置成运行时的直接执行给定的译注如进入的飞行记录仪模式并在后台运行该脚本关于的更多信息请参考下面的飞行记录仪模式关于的更多信息请参考关于和交叉检测的更多信息请参考第节为其它计算机生成检测模块或飞行记录仪模式的飞行记录仪模式允许你长时间运行一个脚本并关注最新的输出飞行记录仪模式会限制输出的生成量飞行记录仪模式还可以分成两种内存型和文件型无论是哪一种脚本都是作为后台进程运行内存型飞行记录仪模式当飞行记录仪模式没有跟输出文件选项一起使用时会把脚本输出结果存储在内核内存的缓冲区内一旦检测模块被加载并开始探测检测过程会分离到后台运行当感兴趣的事件发生后你可以重新载入检测过程来查看内存缓冲区中最近的输出和之后的输出要想在内存型飞行记录仪模式下运行带选项运行命令一旦脚本启动了会输出类似于如下的信息告诉你怎么重新连接运行的脚本当感兴趣的事件发生后运行对应的命令来连接当前运行的脚本输出内存缓冲区中的最近的数据并获取之后的输出默认情况下缓冲区大小为你可以使用来调整这个值单位是会向的幂取整举个例子将指定缓冲区大小为文件型飞行记录仪模式在飞行记录仪模式下你也可以把输出存储在文件中你可以通过选项指定文件名还可以通过选项来控制输出文件的大小和数目下面的命令会以文件型飞行记录仪模式启动输出到每个文件不超过保留最新的两个文件这个命令会把输出到标准输出稍候片刻给这个进程发个终止它的运行在这个例子里仅仅有最新的两个文件被保留下来其余的旧文件都被移除了使用验证下要想查看最新数据读取序号最大的输出文件在这里指的是工作细节允许用户仅需编写和重用简单的脚本即可获取繁多的运行数据通过脚本你可以又好又快地提取数据过滤数据汇总数据诊断复杂的性能问题或功能问题再也不是难事整个脚本所做的无非就是声明感兴趣的事件然后添加对应的处理程序当脚本运行时会监控声明的事件一旦事件发生内核会临时切换到对应的处理程序完成后再重拾原先的工作可供监控的事件种类繁多进入退出某个函数定时器到期会话终止等等处理程序由一组语句构成指明事件发生后要做的工作其中包括从事件上下文中提取数据存储到内部变量中输出结果结构脚本运行时会启动一个对应的会话整个会话大致流程如下首先会检查脚本中用到的确保它们都存在于库中通常是然后会把找到的替换成在库中对应的定义译注是听诊器的集合指一些预定义的事件或函数完整的列表见接着会把脚本转化成代码运行系统的编译器编译出一个内核模块完成这一步的工具包含在包中详见第节安装和配置随即加载该模块并启用脚本中所有的探针包括事件和对应的处理程序这一步由包的完成详见第节安装和配置每当被监控的事件发生对应的处理程序就会被执行一旦会话终止探针会被禁用内核模块也会被卸载这一串流程皆始于一个简单的命令行程序这个程序包揽了主要的功能要想了解关于的更多信息请前提是你的机器上已经安装了脚本在大多数情况下脚本是每个会话的基石脚本决定了需要收集的信息类型也决定了对收集到的信息的处理方式在本章的开头曾经提到过脚本由两部分组成事件和处理程序一旦会话准备就绪会监控操作系统中特定的事件并在事件发生的时候触发对应的处理程序一个事件和它对应的处理程序合称探针一个脚本可以有多个探针一个探针的处理程序部分通常称之为探针主体以应用开发的方式类比使用事件和处理程序就像在程序的特定位置插入打日志的语句每当程序运行时这些日志会帮助你查看程序执行的流程脚本允许你在无需重新编译代码即可插入检测指令而且处理程序也不限于单纯地打印数据事件会触发对应的处理程序对应的处理程序记录下感兴趣的数据并以你指定的格式输出脚本的后缀是并以这样的语句表示一个探针译注如果你写过脚本应该会感觉似曾相识支持给一个探针指定多个事件每个事件以逗号隔开如果给某一个探针指定了多个事件只要其中一个事件发生就会执行对应的处理程序每个探针有自己对应的语句块语句块由花括号括住包含事件发生时需要执行的所有语句会顺序执行这些语句语句间通常不需要特殊的分隔符或终止符脚本的语句块使用跟语言一样的语法语句块内允许嵌套允许你编写函数来提取探针间公共的逻辑所以与其在多个探针间复制粘贴重复的语句你不如把它们放入函数中就像当探针被触发时中的语句会被执行是传递给函数的可选的入参本节仅仅是粗略地介绍下脚本的结构要想了解更详细的内容最好坚持读到第章脚本集锦其中的每一节都会详细介绍一个脚本包含它所监控的事件它的处理程序和输出内容事件事件大致分为两类同步事件和异步事件同步事件同步事件会在任意进程执行到内核特定位置时触发你可以用它来作为其它事件的参照点毕竟同步事件有着清晰的上下文信息同步事件包括进入名为的系统调用如果想要监控的是退出某个系统调用的事件在后面添加举个例子要想监控进入和退出系统调用的事件应该使用和进入虚拟文件系统名为的文件操作跟系统调用事件一样在后面添加可以监控对应的退出事件译注取值的范畴取决于当前内核中的定义的操作可能位于中版本不同位置会不一样建议上查找进入名为的内核函数举个例子即内核函数被调用时所触发的事件同样会在函数调用返回时被触发在定义探测事件时可以使用像这样的通配符你也可以用内核源码文件名限定要跟踪的函数看下面的例子在上面的例子中第一个探针会监控中的所有函数的调用第二个会监控所有这些函数的退出注意在这个例子里处理程序是空的所以即使事件被触发了什么也不会发生译注例子中用的是探测内核源码中的函数的语法完整的语法是由函数名文件名行号三部分组成其中函数名在例子中为匹配任意函数行号是可选的在上面的例子里就被忽略掉了如果想指定某个范围内的函数如从行到使用这样格式作为行号到达名为的静态内核探测点较新的内核包含了特定事件的检测代码这些事件一般会被标记成静态内核探测点一个例子是表示内核释放了一个网络缓冲区的事件译注想知道当前内核设置了哪些静态内核探测点吗你需要运行进入指定模块的函数举个例子上面例子的第一个探针会在每个模块中的函数被调用时触发第二个探针会在函数退出时触发一切就跟一样系统内的所有内核模块通常都在其中取当前内核版本号模块的后缀名为译注在该路径下使用可列出所有的内核模块异步事件异步事件跟特定的指令或代码的位置无关这部分事件主要包含计数器定时器和其它类似的东西会话的启动事件会在脚本开始时触发会话的结束事件会在脚本结束时触发用于周期性执行某段处理程序举个例子上面的例子中每隔秒就会输出还可以使用其它规格的定时器定时事件总是跟其它事件搭配使用其它事件负责收集信息而定时事件定期输出当前状况让你看到数据随时间的变化情况限于篇幅还有些事件就不再一一介绍了如果你想了解更多内容请该中的一节包括了通往其它的链接你还可以随之找到某些特定子系统和组件所支持的事件处理程序看一下下面的示例脚本在上面的例子中每当会话开始时事件会触发内的处理程序输出加一个换行符然后退出脚本会一直运行直到执行了函数如果你想中途退出一个脚本可以用中断是最简单的函数之一可以跟许多函数搭配使用用来输出数据通常我们会这样调用指明输出的格式在前面的例子里语句内没有指定格式符在格式字符串中你可以用表示字符串表示数字格式字符串中可以包含多个格式符每个格式符对应一个参数每个参数之间用逗号隔开的语句跟的语句无论在语法还是在格式字符串上都差不多下面让我们再看多一个例子在上面的例子中会在每次被调用时输出调用程序的名字和外加这个词该探针输出的结果看上去会是这样你可以在里使用其他的函数比如上面的例子中就用到获取触发事件的进程名和当前进程下面列出常用的函数当前的当前的当前的号自以来的秒数将上一个函数返回的秒数转化成时间字符串返回描述当前处理的探测点的字符串你可以用这个函数来组织你的输出结果这个函数接受一个表示缩进差额的参数用来更新当前线程的缩进计数器其实就是用于缩进的空格数它返回的是加了足够缩进的标识字符串这个标识字符串包括一个时间戳表示自从该线程首次调用以来所经过的毫秒数一个进程名一个由此可以清晰地看出函数的调用次序和调用层级和每次调用时的间隔如果一个函数调用后随即退出很容易就能看出被触发的两个事件是相关的然而在大多数情况下一个函数调用和退出之间往往会有调用其他别的函数通过缩进可以相对更清晰地看出某个函数调用和退出的时机看一下下面使用的例子它输出的结果大概是这个样子的注意箭头前面的空格数上面的输出包含如下信息自从该线程首次调用以来所经过的毫秒数进程名和用于缩进的若干个空格以上三项均为的输出表示函数调用表示函数退出触发事件的函数名返回系统调用的名字这个变量只能在触发的处理程序中使用当你通过或来执行某个脚本时会返回你指定的或命令名举个例子当上面的例子中的脚本带命令行参数运行时它会监控所有的系统调用并输出其中由指定进程所触发的系统调用你当然可以把上面例子中的替换成你想要指定的不过使用让你的脚本可以重用现在你只需在运行时指定而无需每次都修改掉硬编码的值要想了解更多关于函数的信息请处理程序的基本结构支持在处理程序中使用一些基本的结构它们的语法基本上类似于或了解最常用的一些结构有助于你写出更清晰的脚本变量处理程序里面当然可以使用变量你所需的不过是给它取个好名字把函数或表达式的值赋给它然后就可以使用它了可以自动判定变量的类型举个例子如果你用给变量赋值那么就是数值类型的可以在中通过输出变量默认只能在其所定义的探针内可用这意味着变量的生命周期仅仅是处理程序的某次运行不过你也可以在探针外定义变量并使用修饰它们这样就能在探针间共享变量了在上面的例子中通过累加和来求出内核的配置语句使得和在每个探针中可用在上面的例子中我们用来将变量的值加一如下探针中每隔会自增知道是一个整数那是因为没有被赋予一个初始值所以它的值默认为零目标变量跟内核代码相关的事件如和允许使用目标变量获取这部分代码中可访问到的变量的值你可以使用选项来列出特定探测点下可用的目标变量如果已经安装了内核调试信息你可以通过这个命令获取中可用的目标变量它会有类似如下的输出每个目标变量前面都以开头并以加变量类型结尾上面的输出表示函数入口处有三个变量可用指向描述文件的结构体指向接收读取的数据的用户空间缓冲区读取的字节数和读开始的位置对于那些不属于本地变量的变量像是全局变量或一个在文件中定义的静态变量可以用获取会保留目标变量的类型信息并且允许通过访问其中的成员跟语言不同的是既可以用来访问指针指向的值也可以用来访问子结构体中的成员在获取复杂结构体中的信息时可以链式使用举个例子中的静态目标变量存储着一些当前文件系统中可调节的参数我们为了获取其中的一个域可以这么写会有类似如下的输出有许多函数可以通过指向基本类型的指针获取内核空间对应地址上的数据在此一一列出在第节我们还会谈到获取用户空间数据的类似函数从内核空间地址中获取变量从内核空间地址中获取变量从内核空间地址中获取变量从内核空间地址中获取变量从内核空间地址中获取字符串从内核空间地址中获取长为的字符串整齐打印目标变量某些场景中我们可能需要输出当前可访问的各种变量以便于记录底层的变化提供了一些操作可以生成描述特定目标变量的字符串输出作用域内每个变量的值等价于如果变量的值在运行时找不到输出同只输出本地变量同只输出函数入参仅在带的探针中可用如果被监控的函数有返回值它等价于否则为空字符串下面的例子中我们会输出的入参的入参有四个和会给这些入参生成描述字符串在这个例子里四个变量都是指针下面是之前的命令的输出关输出个地址值没什么用啊要想输出指针指向的值我们可以加上后缀下面的命令使用后缀来输出入参的实际值输出的结果只使用后缀的话是不会展开结构体里面嵌套的结构体的要想展开嵌套的结构体你需要使用后缀下面是一个使用的例子注意的输出会受到字符串最长长度的限制来自上面命令的输出就因此被截断了条件语句有些时候你写的脚本较为复杂可能需要用上条件语句支持风格的条件语句另外还支持形式的遍历命令行参数通过或加个数字的形式可以访问对应位置的命令行参数用会把用户输入当作整数用会把用户输入当作字符串上面的脚本期望用户把要监控的函数作为命令行参数传递进来你可以让脚本接受多个命令行参数分别命名为等等按用户输入的次序逐个对应关联数组支持关联数组关联数组就像其它编程语言中的你可以把它看作由互不相同的键所组成的数组每个键都有一个关联的值关联数组需要定义为全局变量访问关联数组的值的语法跟类似就是这里的指关联数组的名字指数组中某个唯一的键比如在下面的例子中我们需要在数组中存三个人的年龄可以这么写在一个数组语句中你最多可以指定九个表达式每个表达式间以隔开这样做可以给单个键附加多个信息下面一行代码中数组的键包含五个表达式进程可执行程序名用户父进程和字符串值关联到这个键上面所有的关联数组都必须是全局变量不管它们是否使用在多个探针内数组操作本节将列举中若干常用的数组操作设置给定键的值使用来设置给定键所对应的值正如会把的结果作为一个键并把的结果赋给这个键如果这个键已经存在中原先关联的值会被覆盖掉获取给定键的值使用可以获取对应键上的值比如如果数组中没有对应的键默认情况下它会返回在数值计算中或者空字符串在字符串操作中自增给定键的值使用来增加对应键上的值比如在下面的例子里每次都会把当前进程名所关联的值加一你可以用来判断数组是否有指定的键遍历数组中的多个元素一旦已经收集了足够的信息到数组里你往往需要去遍历它正如上面的例子中在收集了各个进程的读次数后你可能需要遍历它输出每个进程的结果那该怎么做呢最好的方法就是使用语句看下这个例子在第二个探针中的语句里引用了的键所以可以通过读取对应键所关联的值在这个语句里面我们依次遍历的每个值假如我们不想遍历整个数组或者想指定遍历的顺序该怎么做呢你可以给数组名加个后缀来表示按升序遍历或按降序遍历另外你可以用加一个数字来限制迭代的次数看下这个类似于上一个探针的例子上面的语句会按关联的值降序遍历数组表示语句只会迭代次也即输出最高的个值清除数组或数组中某个元素有时你需要清除数组值某个值或者清空整个数组以便于在另一个探针值重用在之前统计的例子里每三秒统计一次各个进程的调用读操作的次数如果要想统计三秒内各个进程的数据需要每三秒清空一次数组你可以使用运算符来删除数组中的某个元素或整个数组看下下面的例子在上面的例子中第二个探针仅输出三秒内每个进程的读次数这里的语句清空了整个数组使用聚集变量有时候你需要快速处理新的数值并且数据量较大这时候可以考虑使用聚集变量因为它实现了对数据的流式处理聚集变量可以用作全局变量也可以用作数组中的值使用运算符可以往聚集变量中添加新数据假设在上面的例子中的值是一段时间内当前进程的读次数会把的值存储到数组关联的聚集变量中请注意我们是把值存储在聚集变量里面它们既没有加到原来的值上也没有覆盖掉原来的值可以这么说就像是数组值每个键都有多个关联的值并且探针的每次触发都会添加新的值要想从聚集变量中获取汇总的结果使用这样的语法可以取以下的函数返回中存储的数值的数目以上面为例返回对应进程的聚集变量所存储的数据数返回中存储的数值的和以上面为例返回对应进程的读总数返回中存储的数值的最小值返回中存储的数值的最大值返回中存储的数值的数目你可以使用多重索引表达式在数组里关联一个聚集变量最多使用个索引这么做的好处在于你可以在数组中附加更多的上下文信息举个例子在上面的例子中第一个探针记录每个进程的次数跟之前的例子不同的是这里的数组同时使用进程名和作为索引在第二个探针里我们使用语句遍历并输出每个进程的数据注意这里我们分别使用和来引用进程名和是一些包含常用的探针和函数的内置脚本你可以在脚本中复用它们当用户运行一个脚本时会检测脚本中的事件和处理程序并在翻译脚本成代码之前加载用到的可以回顾下本章开头所讲到的会话的启动过程就像脚本一样的拓展名也是默认情况下位于跟脚本不同的是不能被直接运行它只能作为库使用库让用户能够在更高的抽象层次上定义事件和函数提供了一些常用的内核函数的别名这样用户就不需要记住完整的内核函数名了尤其是有些函数名可能会因内核版本的不同而不同另外也提供了常用的辅助函数比如之前我们见过的工作细节允许用户仅需编写和重用简单的脚本即可获取繁多的运行数据通过脚本你可以又好又快地提取数据过滤数据汇总数据诊断复杂的性能问题或功能问题再也不是难事整个脚本所做的无非就是声明感兴趣的事件然后添加对应的处理程序当脚本运行时会监控声明的事件一旦事件发生内核会临时切换到对应的处理程序完成后再重拾原先的工作可供监控的事件种类繁多进入退出某个函数定时器到期会话终止等等处理程序由一组语句构成指明事件发生后要做的工作其中包括从事件上下文中提取数据存储到内部变量中输出结果用户空间探测诞生的最初使命是探测内核空间由于许多情况下用户空间探测有助于诊断问题从版本开始也支持探测用户空间的进程可以探测用户空间进程内函数的调用和退出可以探测用户代码中预定义的标记可以探测用户进程的事件进行用户空间探测需要模块如果你的内核版本大于等于它已经内置了要想验证当前内核是否原生支持运行下面命令如果当前内核集成了就会输出以下内容如果你的内核版本小于会自动构建模块不过的用户空间事件跟踪功能依然需要你的内核支持拓展可以从这个链接获取更多关于的细节要想验证当前内核是否提供了必要的支持在终端中输入下面的命令如果当前内核支持用户空间探测就会输出以下内容用户空间事件所有的用户空间事件都以开头你可以通过进程指定要检测的进程也可以通过可执行文件名的路径名指定会查看系统的环境变量所以你既可以使用绝对路径也可以使用在命令行中运行可执行文件时所用的名字由于静态分析放置探针的位置时离不开调试信息一些用户空间事件需要给定或可执行文件的路径以下将两者统称为不过大多数事件中和可执行文件路径名都是可选的下面列出的事件都需要进程或可执行文件的路径不在其中的事件不需要和可执行文件路径名进入可执行文件的用户空间函数该事件相当于内核空间中的它允许使用通配符和后缀代码中第一次执行的地方该事件相当于内核空间中的在中定义的静态探测点你可以使用通配符在单个探针中指定多个探测点有些静态探测点中允许使用编了号的参数等等有些用户空间下的可执行程序提供了这些静态探测点比如大多数提供了静态探测点的程序也一并给这些探测点提供了易于使用的别名下面是虚拟机中的一个例子创建了一个用户空间下的进程你可以限定某个进程或可执行文件的路径如果不限定任意进程的创建都会触发该事件创建了一个用户空间下的线程你可以限定某个进程或可执行文件的路径销毁了一个用户空间下的进程你可以限定某个进程或可执行文件的路径销毁了一个用户空间下的线程你可以限定某个进程或可执行文件的路径一个用户空间进程调用了系统调用可以通过上下文变量获取系统调用号还可以通过到分别获取前六个参数添加后缀后会捕获退出系统调用的事件在中可以通过上下文变量获取返回值你可以用某个进程或可执行文件的路径进行限定访问用户空间目标变量你可以访问用户空间目标变量所用的语法与第节第二部分目标变量中访问内核空间的语法相同在中用户代码和内核代码使用的地址空间是隔绝的不过可以在使用运算符时找到恰当的地址空间对于指向基本类型如整数和字符串的指针可以使用下列的函数访问用户空间的数据每个函数的第一个参数都是指向数据的指针从当前用户进程中获取地址对应的字符数据从当前用户进程中获取地址对应的型数据从当前用户进程中获取地址对应的型数据从当前用户进程中获取地址对应的型数据从当前用户进程中获取地址对应的字符串数据从当前用户进程中获取地址对应的字符串数据取前字节译注这些函数都是在事件的处理程序中使用的当前用户进程指的就是如指向地址空间中的某个地址用户空间栈回溯函数可以返回触发当前处理程序的事件名包含展开了的通配符和别名如果该事件与特定的函数相关的输出会包括触发了该事件的函数名然而许多情况下触发同一个事件的函数可能来自于程序中不同的模块特别是在该函数位于某个共享库的情况下还好提供了用户空间栈的回溯功能便于查看事件是怎么被触发的编译器优化代码时会消除栈帧指针这将混淆用户空间栈回溯的结果所以要想查看栈回溯需要有编译器生成的调试信息用户空间栈回溯机制可以利用这些调试信息来重建栈回溯的现场不过该功能当前只实现在位和位处理器上还不支持其他架构的处理器要想使用这些调试信息来重建栈回溯给可执行文件加上选项并给共享库加上选项举个例子你可以使用函数来输出命令中函数的调用情况如果你已经安装了命令的下面的命令会在函数调用时输出栈回溯的结果译注要想成功运行上面的命令你需要安装的具体安装方式请根据自己用的发行版搜索一下如果你跟我一样用的也是可以看下上这个回答运行运行后上面的命令会有类似下面的输出关于在用户空间栈回溯中可用的函数的更多内容请查看和两个上述中的函数的描述信息也可以在找到脚本集锦本章列举了若干可用于监控和调查内核子系统的脚本如果你安装了这个包所有这些示例都能在下找到网络以下各节的脚本展示了如何跟踪网络相关的函数和剖析网络活动剖析网络活动本节展示中剖析网络活动的方式下面的允许我们一窥每个进程的网络流量使用情况注意看的这几个表达式它们也是语句等价于如下的伪代码跟踪用了网络流量的进程并逐个进程输出如下的信息进程的进程所有者的进程使用的端口如发送的包的数量接收的包的数量发送的数接收的数每隔秒就会取样一次你可以修改来调整取样间隔在秒内的输出如下跟踪网络连接中的内核函数调用本节展示如何跟踪内核的中的函数的调用情况这将帮助你从细节上看清各进程是怎么跟内核的网络功能打交道的这个脚本其实在我们之前在第章介绍的时候已经见过了下面是它在秒内的输出监控连接的创建本节展示如何监控连接的创建这可以帮助你第一时间识别出任何未授权的可疑的或其它不请自来的网络连接当运行时它会实时输出新创建的连接的如下信息当前接受连接的程序名接受连接的进程创建连接的远程地址监控包本节展示如何监控收到的包这可以帮助你分析应用的流量使用情况当运行时它会实时输出收到的包的如下信息源地址和目标地址和源端口和目标端口和包标识使用了以下函数来获取包的标识信息上述函数返回或来表示包中是否存在对应的标识监控内核中的网络丢包情况某些情况下网络栈会丢包有些版本的内核包含静态内核探测点它可以帮助你跟踪包丢掉的原因就使用了它来跟踪丢包这个脚本每五秒统计一次丢包的位置跟踪内核中网络包被丢弃的位置它有两个参数一个指向将被释放的缓冲区的指针和释放缓冲区时的内核位置如果可以获取所存储的内核地址上对应的函数名脚本可以把它的值映射成对应的函数这个映射默认不会启用对于及以上的你可以指定选项来启用该映射在低版本的你可以使用下面的命令模拟选项运行秒会输出类似下面的结果输出的结果会按函数名或地址聚合丢包的次数当运行脚本的机器不支持和时只会输出原始的地址你可以通过按地址找出对应的函数下面的片段中地址映射到函数磁盘以下各节的脚本展示了如何监控磁盘和活动统计磁盘读写状况本节展示了如何找出磁盘读写最频繁的进程输出磁盘读写最频繁的十个进程包含各个进程的以下数据进程所有者的进程的进程的父进程的进程的名字读写的设备名进程的操作是写而是读读写的数据量使用和输出当前时间返回当前时间自年月日以来的秒数把它转化成可读的时间戳在这个脚本中是一个存储着虚拟文件系统读写的字节数的本地变量只能在函数返回事件探针中使用比如这里的和以下是本节脚本的输出追踪对任意文件的读写本节展示如何监控各进程读写任意文件所花费的时间这可以帮助你发现系统中加载时间过长的文件跟踪每次和系统调用对于访问到的每个文件都会计算读写操作花费的时间和读写的数据量以字节为单位虽然我们可以在读写事件和中使用本地变量但是存储的是系统调用想要读写的数据量要获取实际读写到的数据量需要使用本节的脚本会输出以下数据时间戳精确到毫秒和进程名或访问的文件如果一个进程读写了数据你会看到和成对出现那一行的时间戳表示进程访问了文件在结尾处会输出读写的数据以字节为单位那一行会输出读写消耗的时间以毫秒为单位如果一行后面没有意味着进程没有读写到数据追踪的累计总量本节展示如何累计总量逐秒输出累计最频繁的前十个进程此外它还会累计每个进程的情况注意该脚本跟开头找出磁盘读写最频繁的进程的脚本一样也通过本地变量获取实际的读写数据量监控指定设备的本节展示如何监控指定设备的活动接受一个参数设备号要想获取名为的文件夹所在设备的设备号使用把设备号转化成内核理解的格式的输出经过和处理分别得到主设备号和次设备号再经过处理得到内核里对应的设备号的输出包括了读写进程的名字和所调用的函数或和内核里对应的设备号下面是的输出其中是的设备号位于正是我们想要监控的设备监控对指定文件的读写本节展示如何实时监控对指定文件的读写从命令行中依次获取如下参数文件的主设备号文件的次设备号文件的号要获取上述信息使用注意取绝对路径比如要监控先运行应该会有如下输出是十六进制的设备号最小的两位是次设备号其余是主设备号是号要监控运行加以表示这是十六进制的数该命令的输出包括进程名和进程以及调用的函数或设备号以十六进制的格式输出和号下面就是的输出当脚本运行时也正在执行中监控对指定文件的属性的修改本节展示如何实时监控对指定文件的属性的修改跟上一节的脚本类似也需要提供目标文件的设备号和号作为参数用上一节的方法可以获取这些数据的输出也类似于上一节的脚本不过还包括文件属性的变化和对应用户的下面就是监控时用户执行和后的输出定期输出块等待时间本节展示如何跟踪每个块的等待时间这可以帮助你发现给定时间内块操作是否排起了长队计算每个设备上块平均等待时间每秒更新一次你可以修改来更改刷新频率有时候在设备上的块操作实在太多以致于超过了默认的值如果你在定义数组时没有指定大小会以作为数组的最大长度它的默认值是不过你可以使用命令的选项来指定该变量的值上面的输出展示了设备名操作类型总等待时间操作数和平均等待时间这里面的时间都是以毫秒为单位剖析以下各节的脚本展示了如何通过监控函数调用来剖析内核活动统计函数调用次数本节展示如何统计秒内某个内核函数调用次数通过使用通配符你可以用这个脚本同时统计多个内核函数接受内核函数名作为参数你可以使用通配符这样就能同时监控多个内核函数它的输出包括调用者的名字和取样时间内调用次数下面是的输出片段追踪函数调用链本节展示如何追踪函数调用链接受两个命令行参数想要跟踪的函数可选的触发函数该函数可以在线程范围内启动停止追踪只要触发函数不退出追踪就不会结束使用了此外它的输出包括了时间戳进程名和所在的线程关于的更多信息请参考译注这个脚本的编码风格小朋友们可不要学前两个探针里的是数组后两个探针里的是函数另外表示参数的个数写过的都明白是一个预处理三元表达式见中的下面是的输出片段统计给定线程在内核空间和用户空间上的耗时本节展示如何统计给定线程花费在内核空间或用户空间上的运行时间列出秒内花费时间最多的个进程和这段时间滴答的总数脚本的输出还包括每个进程占用百分比分别按内核空间和用户空间列出下面就是它的输出监控应用轮询情况本节展示如何监控应用的轮询情况这将允许你跟踪多余的或过度的轮询帮助锁定使用或能源消耗需要改善的地方跟踪下列系统调用并仅当因为超时而退出该调用时记录次数你可以通过修改最后一个探针来增大取样时间的输出包括前个轮询应用的名字和连带每个应用调用每种轮询系统调用的累计次数在上面的输出片段中由于某个插件模块进行了过度的轮询监控最常调用的系统调用上一节的通过监控系统调用的某个子集帮助你找到过度轮询的应用同样如果你怀疑某些系统调用被过度地调用了通过类似的监控你也能把它们找出来下面就通过实现这一点每秒列出调用最多的个系统调用它也列出了这段时间内每个系统调用被调用的次数下面是它的一个输出找出每个进程的系统调用量本节展示如何找出调用系统调用最多的进程在上一节我们谈到了如何找出调用最多的系统调用而在上上节我们也谈到了如何找出轮询最多的进程通过监控每个进程的调用系统调用的次数可以在调查轮询进程和其他滥用资源者时提供更多的数据列出调用系统调用最多的个进程它也列出了这段时间内每个进程调用系统调用的数量下面是它的输出要想输出进程而非进程名改用下面的脚本正如在输出中提到的你需要手动退出程序来显示结果你可以简单地添加一个探针让脚本在给定时间后自动退出举个例子要想让脚本秒后退出往里面添加下面的探针标识用户空间锁竞争本节展示如何显示特定时间内用户空间锁竞争的情况通过展示锁竞争的图景你可以判断当前的性能问题是否由对的竞争所造成的简单地说如果在同一时间内多个进程试图获取同一把锁就会产生对的竞争由于仅有一个进程可以持有锁其他的进程都只能等待锁重新可用锁竞争会导致性能的下降下面的脚本通过探测系统调用来显示锁竞争的情况需要手动退出一旦退出后它会输出下面信息参与锁竞争的进程的名字和被竞争的锁变量的地址锁被竞争的次数竞争锁的平均耗时下面是在运行约秒退出时大致的输出情况解读错误信息本章解释使用过程中常见的错误信息解析和文法错误解析和文法错误发生在解析脚本和编译成代码时举个例子把无效的值赋给变量或数组时会报类型错误脚本存在语法或排版错误会探测到脚本中存在的不正确结构并指出有问题的探针举个例子下面的脚本是有问题的里面的探针缺了处理程序尝试运行这个脚本它会报告以下的错误信息声称第行第列不应该是关键字脚本中嵌入了不安全的代码允许你通过代码块嵌入代码以便于定义适合的然而这样做是不安全的一旦你真的在脚本里这么做了用这个错误来警告你如果你确信你的做法是安全的并且拥有权限或权限可以带上选项以模式运行脚本来消除这个报错脚本中的函数使用了错误的类型比如或在下面的例子中格式标志符应该是而不是因为函数返回一个字符串你使用了一个变量但是没办法推导出它的类型数值或字符串举个例子如果你在一个语句中使用了从未赋过值的变量就会遇到这样的错误不能完成某个赋值操作因为这个操作的接收者不合理下面的示例代码就会发生这个错误脚本中的函数调用或数组索引表达式使用了不合理的参数个数在可以指数组的索引个数也可以指函数的参数个数在脚本中使用了一个数组却没有把它定义成全局变量脚本中全局变量可以定义在使用的位置之后如果一个数组使用的索引个数不一致也会报告相似的错误中数组可以使用一组值作为索引而不仅仅是一个下标用迭代数组的同时修改了该数组赋新的值或使用了如果在迭代的过程中对数组调用了函数也会显示这个错误无法找到事件或函数的定义通常意味着在库中找不到匹配的项表示错误的行号和列号因为一些原因不能解析事件或处理函数比如说脚本包含事件而并不存在在某些时候这个错误也意味着脚本中包含不存在的内核文件名或源代码行号脚本中的一个处理程序用到了某个目标变量但这个目标变量无法解析这个错误意味着该目标变量在处理程序的上下文里不存在也许是编译器把代码优化掉了在处理调试信息的时候遇到一个问题在大多数情况下这个错误的产生源于安装的包没有完全匹配要探测的内核也许是安装的包中存在某些完整性或正确性问题找不到适合的包运行时错误和警告运行时错误和警告发生在安装了检测代码并开始收集数据的时候在运行时出错并或跳过某些探针由于诸如给定时间不足以执行完处理程序的原因某些探针没有得到执行和就是这些探针的数目代码里出现了除零错误在一个空的聚集变量上调用除以外的提取函数这就跟除零差不多关于聚集变量的更多信息参见数组操作中的使用聚集变量部分聚集变量数组中包含太多的键译注前文有提及数组的索引中最多只能使用九个键过多的嵌套函数调用默认函数调用层级是可以使用重编译脚本来修改这个限制处理程序太长了默认一个探针的处理程序里面最多只能执行个语句可以使用或重编译脚本来修改这个限制处理程序试图把一个来自内核或用户空间的字符串拷贝到无效地址指针解引用时发生了一个错误可能发生在诸如计算目标变量的时候介绍编写本文档的目标的能力的局限使用安装和配置为其它计算机生成检测模块运行脚本工作细节结构脚本处理程序的基本结构关联数组数组操作用户空间探测用户空间事件访问用户空间目标变量用户空间栈回溯脚本集锦网络磁盘剖析标识用户空间锁竞争解读错误信息解析和文法错误运行时错误和警告',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 16:22:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">远辰</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 1.05rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 1.05rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 1.05rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 1.05rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 1.05rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 1.05rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 1.05rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 1.05rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">December 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">July 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">June 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">March 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/linux/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>linux</span></a></span></div></div><h1 class="post-title" itemprop="name headline">systemtap starter</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-12-23T06:44:56.000Z" title="发表于 2022-12-23 14:44:56">2022-12-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.107Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/"><header><a href="/tags/linux/" tabindex="-1" itemprop="url">linux</a><h1 id="CrawlerTitle" itemprop="name headline">systemtap starter</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">哪吒藕霸</span><time itemprop="dateCreated datePublished" datetime="2022-12-23T06:44:56.000Z" title="发表于 2022-12-23 14:44:56">2022-12-23</time><time itemprop="dateCreated datePublished" datetime="2023-09-28T08:22:11.107Z" title="更新于 2023-09-28 16:22:11">2023-09-28</time></header><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>SystemTap是一种允许用户研究和监控操作系统（尤指Linux内核）运行细节的跟踪&#x2F;剖析工具。SystemTap可以像<code>netstat</code>，<code>ps</code>，<code>top</code>和<code>iostat</code>那样统计系统数据；不止于此，为了收集信息，它还提供了更多过滤和分析的途径。</p>
<h1 id="1-1-编写本文档的目标"><a href="#1-1-编写本文档的目标" class="headerlink" title="1.1. 编写本文档的目标"></a>1.1. 编写本文档的目标</h1><p>SystemTap允许使用者监控Linux系统当前的运行情况，以便进一步分析。这将有助于运维或开发人员缉查bug或性能问题的罪魁祸首。</p>
<p>在SystemTap开发出来之前，要想监控一个运行中的内核，有些时候需要注入检测代码（instrument），重新编译，安装，还要重启一下。SystemTap的诞生，把程序员从这一串繁琐的步骤中解放出来。现在要想完成同样的工作，你只需要简单地运行下自己写的SystemTap脚本。</p>
<p>不过，SystemTap的目标用户是那些对内核驾轻就熟的老手。对于内核菜鸟来说，SystemTap依旧难以上手。雪上加霜的是，现存的许多SystemTap文档都假定读者有相当丰富的内核经验，这使得学习SystemTap的路途道阻且长。</p>
<p>为了降低入门的门槛，我们编写了《SystemTap新手指南》。它包括下面的内容：</p>
<ol>
<li>介绍SystemTap和它的用法，并列出各种型号内核下的安装方式。</li>
<li>提供监控系统各组件的运行详情的SystemTap脚本作为例子，并介绍它们的运行方式和分析其输出。</li>
</ol>
<h1 id="1-2-SystemTap的能力"><a href="#1-2-SystemTap的能力" class="headerlink" title="1.2. SystemTap的能力"></a>1.2. SystemTap的能力</h1><p><strong>灵活性</strong>：SystemTap提供了一门领域特定语言，使得用户可以编写自定义脚本，调查和监控各种内核函数、系统调用，和其它发生在内核空间的事件。就此而言，SystemTap不仅仅是个工具，它是一个让你能够自定义内核取证和监控工具的生态系统。</p>
<p><strong>易于上手</strong>：正如前面谈到的，SystemTap把用户从在探测内核空间事件时，注入检测代码-重新编译-安装-重启这一繁琐过程解放出来。</p>
<p>我们在第五章——<a href="5_UsefulSystemTapScripts.md">SystemTap脚本集锦</a>——列出的大多数SystemTap脚本所展现出的系统取证和监控能力，是其它同类型工具（比如<code>top</code>，<code>oprofile</code>，<code>ps</code>）所不能及的。这些脚本很好地诠释了SystemTap强大的功能，届时将会拓宽诸位读者编写自己的SystemTap脚本时的眼界。</p>
<h1 id="1-3-SystemTap的局限"><a href="#1-3-SystemTap的局限" class="headerlink" title="1.3. SystemTap的局限"></a>1.3. SystemTap的局限</h1><p>当前版本的SystemTap提供的探测内核空间事件的众多选项，可以在不同版本的内核下使用。然而，SystemTap对探测用户空间事件的支持依赖于内核的支持（需要utrace机制），而多数内核缺乏这一支持。结果是，仅有部分内核上的SystemTap版本支持用户空间探测。<br>当前，SystemTap社区正集中力量改进SystemTap的用户空间探测能力。<br>（译注：本指南写于2013年。现今的内核普遍已经支持用户空间探测，旧的内核用的是utrace，新的内核用的是uprobes）</p>
<h1 id="2-安装和配置"><a href="#2-安装和配置" class="headerlink" title="2. 安装和配置"></a>2. 安装和配置</h1><p>本章会教用户怎么安装SystemTap，并介绍SystemTap脚本的运行方式。</p>
<h1 id="2-1-安装和配置"><a href="#2-1-安装和配置" class="headerlink" title="2.1. 安装和配置"></a>2.1. 安装和配置</h1><p>要想使用<code>SystemTap</code>，需要安装跟目标内核版本匹配的<code>-devel</code>、<code>-debuginfo</code>和<code>-debuginfo-common-arch</code>包。如果要在不止一个内核上运行<code>SystemTap</code>，需要根据每个内核的版本安装对应的<code>-devel</code>和<code>-debuginfo</code>包。</p>
<p>接下来的几个小节里，我们会详细讲解这一过程。（译注：SystemTap的<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/wiki/">wiki</a>里面有针对Linux各发行版的安装步骤。本节内容仅适用于RHEL，且不能保证及时更新，建议跳过本节，直接参考官方文档。如果你正好用的是ubuntu，可以参考ubuntu的<a target="_blank" rel="noopener" href="https://wiki.ubuntu.com/Kernel/Systemtap">wiki</a>）</p>
<blockquote>
<p>很多用户把<code>-debuginfo</code>记成了<code>-debug</code>。要想使用SystemTap，切记安装对应内核的<code>-debuginfo</code>包，不是<code>-debug</code>包。</p>
</blockquote>
<h2 id="安装SystemTap"><a href="#安装SystemTap" class="headerlink" title="安装SystemTap"></a>安装SystemTap</h2><p>要想使用SystemTap，安装下面的RPM包：</p>
<ul>
<li>systemtap</li>
<li>systemtap-runtime</li>
</ul>
<p>以root权限运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install systemtap systemtap-runtime</span><br></pre></td></tr></table></figure>

<p>注意要想用上SystemTap，还得安装依赖的内核调试信息包。在较新的系统上，仅需以root权限运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap-prep</span><br></pre></td></tr></table></figure>

<p>如果这个命令没起作用，你需要按照下面的步骤手动安装。</p>
<h2 id="手动安装依赖的内核调试信息包"><a href="#手动安装依赖的内核调试信息包" class="headerlink" title="手动安装依赖的内核调试信息包"></a>手动安装依赖的内核调试信息包</h2><p>SystemTap需要内核信息，这样才能注入指令。此外，这些信息还能帮助SystemTap生成合适的检测代码。</p>
<p>这些必要的内核信息分别包括在特定内核版本所对应的<code>-devel</code>，<code>-debuginfo</code>和<code>-debuginfo-common</code>包中。对于“标准版”内核（指按照常规配置编译的内核），所需的<code>-devel</code>和<code>-debuginfo</code>等包命名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel-debuginfo</span><br><span class="line">kernel-debuginfo-common</span><br><span class="line">kernel-devel</span><br></pre></td></tr></table></figure>

<p>同样的，启用了PAE的内核所需的包分别为<code>kernel-PAE-debuginfo</code>，<code>kernel-PAE-debuginfo-common</code>，和<code>kernel-PAE-devel</code>。（译注：PAE即Physical Address Extension（物理地址拓展），32位Linux可以用它拓展内存访问空间）</p>
<p>要想确定当前系统的内核版本，敲入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>举个例子，如果你想在i686环境下的2.6.18-53.el5内核上使用SystenTap，需要下载安装如下的RPM包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel-debuginfo-2.6.18-53.1.13.el5.i686.rpm</span><br><span class="line">kernel-debuginfo-common-2.6.18-53.1.13.el5.i686.rpm</span><br><span class="line">kernel-devel-2.6.18-53.1.13.el5.i686.rpm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你安装的<code>-devel</code>、<code>-debuginfo</code>和<code>-debuginfo-common</code>包的版本一定要匹配目标内核的版本&#x2F;特性&#x2F;架构。</p>
</blockquote>
<p>安装依赖的内核信息包最简单的方法，就是用<code>yum install</code>和<code>debuginfo-install</code>命令。<code>debuginfo-install</code>命令包含在版本1.1.10以上的<code>yum-utils</code>包里，还需要一个能够下载安装<code>-debuginfo</code>和<code>-debuginfo-common</code>包的yum源。<br>确保系统包管理的源满足要求，运行下面的命令就能安装特定内核对应的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install kernelname-devel-version</span><br><span class="line">debuginfo-install kernelname-version</span><br></pre></td></tr></table></figure>

<p>把命令中的<code>kernelname</code>替换成对应的内核名（比如，<code>kernel-PAE</code>），<code>version</code>换成目标内核的版本。举个例子，安装<code>kernel-PAE-2.6.18-53.1.13.el5</code>内核所对应的内核信息包，需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install kernel-PAE-devel-2.6.18-53.1.13.el5</span><br><span class="line">debuginfo-install kernel-PAE-2.6.18-53.1.13.el5</span><br></pre></td></tr></table></figure>

<p>一旦手动下载了所依赖的包之后，以root权限运行下面的命令来安装它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --force -ivh package_names</span><br></pre></td></tr></table></figure>

<h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><p>如果你正在用的内核就是你的目标内核，你现在就能检查下安装是否成功。如果不是，重启下系统并载入目标内核。</p>
<p>运行下面命令开始检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -v -e &#x27;probe vfs.read &#123;printf(&quot;read performed\n&quot;); exit()&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>这个命令让SystemTap在虚拟文件系统的读事件发生之后，输出<code>read performed</code>接着退出。如果SystemTap安装成功了，应该会输出类似下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass 1: parsed user script and 45 library script(s) in 340usr/0sys/358real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe(s), 1 function(s), 0 embed(s), 0 global(s) in 290usr/260sys/568real ms.</span><br><span class="line">Pass 3: translated to C into &quot;/tmp/stapiArgLX/stap_e5886fa50499994e6a87aacdc43cd392_399.c&quot; in 490usr/430sys/938real ms.</span><br><span class="line">Pass 4: compiled C into &quot;stap_e5886fa50499994e6a87aacdc43cd392_399.ko&quot; in 3310usr/430sys/3714real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">read performed</span><br><span class="line">Pass 5: run completed in 10usr/40sys/73real ms.</span><br></pre></td></tr></table></figure>

<p>从<code>Pass 5</code>开始的最后三行说明SystemTap已经成功地注入并运行了内核探测指令，捕获了要探测的事件（在这个例子里，指虚拟文件系统的读事件），并执行了有效的处理程序（输出“read performed”并正常退出）。</p>
<h1 id="2-2-为其它计算机生成检测模块"><a href="#2-2-为其它计算机生成检测模块" class="headerlink" title="2.2. 为其它计算机生成检测模块"></a>2.2. 为其它计算机生成检测模块</h1><p>当用户运行一个SystemTap脚本时，SystemTap会从中创建一个内核模块。然后SystemTap会把该模块加载到内核里，这样一来它就能从内核直接提取出特定的数据。（详见第3.1节“结构”中“SystemTap会话”部分）</p>
<p>一般来说，SystemTap脚本只能运行在安装了SystemTap的系统上（见第2.1节，“安装和配置”）。这意味着，如果想在十个系统上运行SystemTap，你需要挨个系统安装SystemTap。在有些情况下，这既不如人意也不合实际。比如，公司内部的规章可能会禁止管理员往机器上安装提供编译器或调试信息的RPM包，这么一来SystemTap就没法安装了。为了避开这个问题，SystemTap提供了交叉检测（cross-instrumentaion）的功能。</p>
<p>在一台计算机上运行SystemTap脚本，生成在另一台机器上可用的SystemTap检测模块，这一过程就叫做交叉检测。这一功能提供了以下便利：</p>
<ul>
<li>仅需在单台开发机上安装适合其它机器的多个内核信息包。</li>
<li>每个目标机器仅需安装单个RPM包来使用生成的SystemTap检测模块：<code>systemtap-runtime</code>（译注：所以说还是得安装新的包）</li>
</ul>
<p>为简明起见，定义下本节用到的几个术语：</p>
<ul>
<li>检测模块 - 由SystemTap脚本创建的内核模块。SystemTap模块由主机系统创建，并且将会被分发到目标系统的目标内核上。</li>
<li>主机系统 - 在这个系统上编译SystemTap脚本成目标系统上可用的检测模块。</li>
<li>目标系统 - 需要应用检测模块的系统。</li>
<li>目标内核 - 目标系统的内核。这个内核将加载和运行检测模块。</li>
</ul>
<blockquote>
<p><strong>为了创建可用的检测模块，主机系统使用的硬件架构和分行版需要跟目标系统相同。</strong></p>
</blockquote>
<p>完成下面各步来配置主机系统和目标系统：</p>
<ol>
<li>在每个目标系统上安装<code>systemtap-runtime</code>包。</li>
<li>通过运行<code>uname -r</code>，获取每个目标系统的内核版本。</li>
<li>你将在主机系统上创建适用于目标系统的检测模块。关于安装SystemTap的信息，请参考第2.1节“安装和配置”中的“安装SystemTap”。（译注：请查看官方<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/wiki">Wiki</a>）</li>
<li>在主机系统上，安装跟目标内核版本一样的内核和对应的内核信息包，可以参考第2.1节中的“手动安装依赖的内核调试信息包”。如果多个目标系统使用的内核版本不一样，每种内核版本都要安装一次。</li>
</ol>
<p>完成了这几步后，你现在可以在主机系统上给所有的目标系统创建检测模块了。</p>
<p>要想创建检测模块，在主机系统运行下面命令（<strong>记得把<code>kernel_version</code>等改成实际的值</strong>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -r kernel_version script -m module_name</span><br></pre></td></tr></table></figure>

<p>在这里，<code>kernel_version</code>表示目标系统的版本（目标系统上<code>uname -r</code>的输出），<code>script</code>表示需要编译成检测模块的脚本，而<code>module_name</code>则是你给检测模块起的名字。</p>
<blockquote>
<p>要想获得当前内核的硬件架构，你可以运行下面的命令：<br><code>uname -m</code></p>
</blockquote>
<p>一旦检测模块编译好了，把它分发到目标系统，然后加载它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staprun module_name.ko</span><br></pre></td></tr></table></figure>

<p>举个例子，需要从SystemTap脚本<code>simple.stp</code>中创建检测模块<code>simple.ko</code>，来应用于版本为<code>2.6.18-92.1.10.el5</code>的目标系统（x86_64架构），使用下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -r 2.6.18-92.1.10.el5 -e &#x27;probe vfs.read &#123;exit()&#125;&#x27; -m simple</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为<code>simple.ko</code>的模块。把它复制到目标系统并在目标系统上运行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staprun simple.ko</span><br></pre></td></tr></table></figure>

<h1 id="2-3-运行SystemTap脚本"><a href="#2-3-运行SystemTap脚本" class="headerlink" title="2.3. 运行SystemTap脚本"></a>2.3. 运行SystemTap脚本</h1><p>SystemTap包含了许多用于监控系统活动的命令行工具。<code>stap</code>命令从SystemTap脚本中读取探测指令，把它们转化为C代码，构建一个内核模块，并加载到当前的Linux内核中。<code>staprun</code>命令会运行SystemTap检测模块，比如SystemTap通过交叉检测创建的内核模块。</p>
<p>运行<code>stap</code>和<code>staprun</code>需要较高的系统权限。由于不是每个运行SystemTap的用户都可以被授予root权限，对于那些没有权限的用户，你可以把他们的帐号加入到下面的用户组中：</p>
<ol>
<li><p><strong>stapdev</strong><br>该组内的成员可以使用<code>stap</code>运行SystemTap脚本，或<code>staprun</code>运行SystemTap检测模块。<br>运行<code>stap</code>命令包括把SystemTap脚本编译成内核模块并加载进内核。这一操作需要较高的系统访问权限。所以<code>stapdev</code>用户组下的成员会拥有较高的权限。不幸的是，这也意味着他们可以做到许多只有root用户才能做到的事。所以，你应该只把那些原可以拥有root权限的用户加到这个用户组中。</p>
</li>
<li><p><strong>stapusr</strong><br>该组内的成员仅能使用<code>staprun</code>命令来运行SystemTap检测模块。另外，他们也只能在<code>/lib/modules/kernel_version/systemtap/</code>文件夹下运行模块。注意这个文件夹必须仅由root用户所拥有，而且仅对root用户可写。</p>
</li>
</ol>
<p><code>stap</code>命令从文件或标准输入中读取SystemTap脚本。要想让<code>stap</code>从文件中读取SystemTap脚本，需要在命令行中指定文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap file_name</span><br></pre></td></tr></table></figure>

<p>要想让<code>stap</code>从标准输入中读取SystemTap脚本，需要用<code>-</code>换掉文件名。记得把用到的命令行选项挪到<code>-</code>之前。举个例子，要让<code>stap</code>输出更多的运行信息，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;probe timer.s(1) &#123;exit()&#125;&quot; | stap -v -</span><br></pre></td></tr></table></figure>

<p>下面列出常用的<code>stap</code>命令行选项：</p>
<p><strong>-v</strong><br>让SystemTap会话输出更加详细的信息。你可以重复该选项多次来提高执行信息的详尽程度，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -vvv script.stp</span><br></pre></td></tr></table></figure>

<p>当你的脚本在运行时发生了错误，可以加下这个选项查看更详细的输出信息。关于SystemTap错误信息的更多内容，请参考第6章，“解读错误信息”</p>
<p><strong>-o file_name</strong><br>将标准输出重定向到<code>file_name</code></p>
<p><strong>-S size[,count]</strong><br>将输出文件的最大大小限制成<code>size</code>MB，存储文件的最大数目为<code>count</code>。这个命令实现了logrotate的功能，每个输出文件会以序列号作为后缀。（译注：logrotate会把日志切割成xxx.1, xxx.2, xxx.3的形式。每当一个日志文件达到最大大小时，新开一个日志文件。当日志文件数达到最大数目时，旧的日志文件会被删掉。）</p>
<p><strong>-x process_id</strong><br>设置SystemTap处理函数<code>target()</code>为指定PID。关于<code>target()</code>的更多信息，请参考<a target="_blank" rel="noopener" href="http://linux.die.net/man/5/stapfuncs">SystemTap函数列表</a>。</p>
<p><strong>-c ‘command’</strong><br>运行<code>command</code>，并在<code>command</code>结束时退出。该选项同时会把<code>target()</code>设置成<code>command</code>运行时的PID</p>
<p><strong>-e ‘code’</strong><br>直接执行给定的<code>code</code>。（译注：如<code>stap -v -e &#39;probe vfs.read &#123;printf(&quot;read performed\n&quot;); exit()&#125;&#39;</code>）</p>
<p><strong>-F</strong><br>进入SystemTap的飞行记录仪模式（flight recorder mode），并在后台运行该脚本。关于的更多信息，请参考下面的“飞行记录仪模式”。</p>
<p>关于<code>stap</code>的更多信息，请参考<code>stap(1)</code> man page。关于<code>staprun</code>和交叉检测的更多信息，请参考第2.2节“为其它计算机生成检测模块”，或<code>staprun(8)</code> man page。</p>
<h2 id="飞行记录仪模式"><a href="#飞行记录仪模式" class="headerlink" title="飞行记录仪模式"></a>飞行记录仪模式</h2><p>SystemTap的飞行记录仪模式允许你长时间运行一个SystemTap脚本，并关注最新的输出。飞行记录仪模式会限制输出的生成量。</p>
<p>飞行记录仪模式还可以分成两种：内存型（in-memory）和文件型（file）。无论是哪一种，SystemTap脚本都是作为后台进程运行。</p>
<h3 id="内存型飞行记录仪模式"><a href="#内存型飞行记录仪模式" class="headerlink" title="内存型飞行记录仪模式"></a>内存型飞行记录仪模式</h3><p>当飞行记录仪模式（<code>-F</code>）没有跟输出文件选项（<code>-o</code>）一起使用时，SystemTap会把脚本输出结果存储在内核内存的缓冲区内。一旦SystemTap检测模块被加载并开始探测，检测过程会分离到后台运行。当感兴趣的事件发生后，你可以重新载入检测过程来查看内存缓冲区中最近的输出和之后的输出。</p>
<p>要想在内存型飞行记录仪模式下运行SystemTap，带<code>-F</code>选项运行<code>stap</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -F iotime.stp</span><br></pre></td></tr></table></figure>

<p>一旦脚本启动了，<code>stap</code>会输出类似于如下的信息，告诉你怎么重新连接运行的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disconnecting from systemtap module.</span><br><span class="line">To reconnect, type &quot;staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556&quot;</span><br></pre></td></tr></table></figure>

<p>当感兴趣的事件发生后，运行对应的命令来连接当前运行的脚本，输出内存缓冲区中的最近的数据，并获取之后的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556</span><br></pre></td></tr></table></figure>

<p>默认情况下，缓冲区大小为1MB.你可以使用<code>-s</code>来调整这个值（单位是MB，会向2的幂取整）。举个例子，<code>-s2</code>将指定缓冲区大小为2MB.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./flight_record_mode_in_memory.gif" alt="flight_record_mode_in_memory"></p>
<h3 id="文件型飞行记录仪模式"><a href="#文件型飞行记录仪模式" class="headerlink" title="文件型飞行记录仪模式"></a>文件型飞行记录仪模式</h3><p>在飞行记录仪模式下，你也可以把输出存储在文件中。你可以通过<code>-o</code>选项指定文件名，还可以通过<code>-S</code>选项来控制输出文件的大小和数目。</p>
<p>下面的命令会以文件型飞行记录仪模式启动SystemTap，输出到<code>/tmp/iotime.log.[0-9]+</code>，每个文件不超过1MB，保留最新的两个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -F -o /tmp/pfaults.log -S 1,2  pfaults.stp</span><br></pre></td></tr></table></figure>

<p>这个命令会把PID输出到标准输出。稍候片刻，给这个进程发个<code>SIGTERM</code>终止它的运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s SIGTERM 7590</span><br></pre></td></tr></table></figure>

<p>在这个例子里，仅仅有最新的两个文件被保留下来：其余的旧文件都被SystemTap移除了。使用<code>ls -sh /tmp/pfaults.log.*</code>验证下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1020K /tmp/pfaults.log.5    44K /tmp/pfaults.log.6</span><br></pre></td></tr></table></figure>

<p>要想查看最新数据，读取序号最大的输出文件，在这里指的是<code>/tmp/pfaults.log.6</code>。</p>
<h1 id="3-工作细节"><a href="#3-工作细节" class="headerlink" title="3. 工作细节"></a>3. 工作细节</h1><p>SystemTap允许用户仅需编写和重用简单的脚本即可获取Linux繁多的运行数据。通过SystemTap脚本，你可以又好又快地提取数据、过滤数据、汇总数据。诊断复杂的性能问题（或功能问题）再也不是难事。</p>
<p>整个SystemTap脚本所做的，无非就是声明感兴趣的事件，然后添加对应的处理程序。当SystemTap脚本运行时，SystemTap会监控声明的事件；一旦事件发生，Linux内核会临时切换到对应的处理程序，完成后再重拾原先的工作。</p>
<p>可供监控的事件种类繁多：进入&#x2F;退出某个函数，定时器到期，会话终止，等等。处理程序由一组SystemTap语句构成，指明事件发生后要做的工作。其中包括从事件上下文中提取数据，存储到内部变量中，输出结果。</p>
<h1 id="3-1-结构"><a href="#3-1-结构" class="headerlink" title="3.1. 结构"></a>3.1. 结构</h1><p>SystemTap脚本运行时，会启动一个对应的SystemTap会话。整个会话大致流程如下：</p>
<p>首先，SystemTap会检查脚本中用到的<code>tapset</code>，确保它们都存在于tapset库中（通常是<code>/usr/share/systemtap/tapset/</code>）。然后SystemTap会把找到的<code>tapset</code>替换成在tapset库中对应的定义。（译注：tapset是tap（听诊器）的集合，指一些预定义的SystemTap事件或函数。完整的tapset列表见 <a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/tapsets/">https://sourceware.org/systemtap/tapsets/</a> ）</p>
<p>SystemTap接着会把脚本转化成C代码，运行系统的C编译器编译出一个内核模块。完成这一步的工具包含在systemtap包中（详见第2.1节，“安装和配置”）</p>
<p>SystemTap随即加载该模块，并启用脚本中所有的探针（包括事件和对应的处理程序）。这一步由system-runtime包的<code>staprun</code>完成。（详见第2.1节，“安装和配置”）</p>
<p>每当被监控的事件发生，对应的处理程序就会被执行。</p>
<p>一旦SystemTap会话终止，探针会被禁用，内核模块也会被卸载。</p>
<p>这一串流程皆始于一个简单的命令行程序：<code>stap</code>。这个程序包揽了SystemTap主要的功能。要想了解关于<code>stap</code>的更多信息，请<code>man stap</code>（前提是你的机器上已经安装了SystemTap）</p>
<h1 id="3-2-脚本"><a href="#3-2-脚本" class="headerlink" title="3.2. 脚本"></a>3.2. 脚本</h1><p>在大多数情况下，SystemTap脚本是每个SystemTap会话的基石。SystemTap脚本决定了需要收集的信息类型，也决定了对收集到的信息的处理方式。</p>
<p>在本章的开头曾经提到过，SystemTap脚本由两部分组成：事件和处理程序。一旦SystemTap会话准备就绪，SystemTap会监控操作系统中特定的事件，并在事件发生的时候触发对应的处理程序。</p>
<blockquote>
<p>一个事件和它对应的处理程序合称探针。一个SystemTap脚本可以有多个探针。<br>一个探针的处理程序部分通常称之为探针主体（probe body）</p>
</blockquote>
<p>以应用开发的方式类比，使用事件和处理程序就像在程序的特定位置插入打日志的语句。每当程序运行时，这些日志会帮助你查看程序执行的流程。</p>
<p>SystemTasp脚本允许你在无需重新编译代码，即可插入检测指令，而且处理程序也不限于单纯地打印数据。事件会触发对应的处理程序；对应的处理程序记录下感兴趣的数据，并以你指定的格式输出。</p>
<p>SystemTap脚本的后缀是<code>.stp</code>，并以这样的语句表示一个探针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe   event &#123;statements&#125;</span><br></pre></td></tr></table></figure>

<p>译注：如果你写过awk脚本，应该会感觉似曾相识。</p>
<p>SystemTap支持给一个探针指定多个事件；每个事件以逗号隔开。如果给某一个探针指定了多个事件，只要其中一个事件发生，SystemTap就会执行对应的处理程序。</p>
<p>每个探针有自己对应的语句块。语句块由花括号（<code>&#123;&#125;</code>）括住，包含事件发生时需要执行的所有语句。SystemTap会顺序执行这些语句；语句间通常不需要特殊的分隔符或终止符。</p>
<blockquote>
<p>SystemTap脚本的语句块使用跟C语言一样的语法。语句块内允许嵌套。</p>
</blockquote>
<p>SystemTap允许你编写函数来提取探针间公共的逻辑。所以，与其在多个探针间复制粘贴重复的语句，你不如把它们放入函数中，就像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function_name(arguments) &#123;statements&#125;</span><br><span class="line"></span><br><span class="line">probe event &#123;function_name(arguments)&#125;</span><br></pre></td></tr></table></figure>

<p>当探针被触发时，<code>function_name</code>中的语句会被执行。<code>arguments</code>是传递给函数的可选的入参。</p>
<blockquote>
<p>本节仅仅是粗略地介绍下SystemTap脚本的结构。要想了解更详细的内容，最好坚持读到第5章，SystemTap脚本集锦；其中的每一节都会详细介绍一个脚本，包含它所监控的事件、它的处理程序和输出内容。</p>
</blockquote>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>SystemTap事件大致分为两类：同步事件和异步事件。</p>
<h3 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h3><p>同步事件会在任意进程执行到内核特定位置时触发。你可以用它来作为其它事件的参照点，毕竟同步事件有着清晰的上下文信息。</p>
<p>同步事件包括：</p>
<p><strong>syscall.system_call</strong></p>
<p>进入名为<code>system_call</code>的系统调用。如果想要监控的是退出某个系统调用的事件，在后面添加<code>.return</code>。举个例子，要想监控进入和退出系统调用<code>close</code>的事件，应该使用<code>syscall.close</code>和<code>syscall.close.return</code>。</p>
<p><strong>vfs.file_operation</strong></p>
<p>进入虚拟文件系统（VFS）名为<code>file_operation</code>的文件操作。跟系统调用事件一样，在后面添加<code>.return</code>可以监控对应的退出事件。<br>译注：<code>file_operation</code>取值的范畴，取决于当前内核中<code>struct file_operations</code>的定义的操作（可能位于<code>include/linux/fs.h</code>中，版本不同位置会不一样，建议上<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident">http://lxr.free-electrons.com/ident</a> 查找<code>file_operations</code>）。</p>
<p><strong>kernel.function(“function”)</strong></p>
<p>进入名为<code>function</code>的内核函数。举个例子，<code>kernel.function(&quot;sys_open&quot;)</code>即内核函数<code>sys_open</code>被调用时所触发的事件。同样，<code>kernel.function(&quot;sys_open&quot;).return</code>会在<code>sys_open</code>函数调用返回时被触发。</p>
<p>在定义探测事件时，可以使用像<code>*</code>这样的通配符。你也可以用内核源码文件名限定要跟踪的函数。看下面的例子：</p>
<blockquote>
<pre><code>probe kernel.function(&quot;*@net/socket.c&quot;) &#123; &#125;
probe kernel.function(&quot;*@net/socket.c&quot;).return &#123; &#125;
</code></pre>
</blockquote>
<p>在上面的例子中，第一个探针会监控<code>net/socket.c</code>中的所有函数的调用。第二个会监控所有这些函数的退出。注意在这个例子里，处理程序是空的；所以，即使事件被触发了，什么也不会发生。<br>译注：例子中用的是探测内核源码中的函数的语法。完整的语法是<code>func_name@file_name[:line_num]</code>，由函数名、文件名、行号三部分组成。其中函数名在例子中为<code>*</code>，匹配任意函数。行号是可选的，在上面的例子里就被忽略掉了。如果想指定某个范围内的函数，如从行x到y，使用<code>:x-y</code>这样格式作为行号。</p>
<p><strong>kernel.trace(“tracepoint”)</strong></p>
<p>到达名为<code>tracepoint</code>的静态内核探测点（tracepoint）。较新的内核（&gt;&#x3D; 2.6.30）包含了特定事件的检测代码。这些事件一般会被标记成静态内核探测点。一个例子是，<code>kernel.trace(&quot;kfree_skb&quot;)</code>表示内核释放了一个网络缓冲区的事件。（译注：想知道当前内核设置了哪些静态内核探测点吗？你需要运行<code>sudo perf list</code>。）</p>
<p><strong>module(“module”).function(“function”)</strong></p>
<p>进入指定模块<code>module</code>的函数<code>function</code>。举个例子：</p>
<blockquote>
<pre><code>probe module(&quot;ext3&quot;).function(&quot;*&quot;) &#123; &#125;
probe module(&quot;ext3&quot;).function(&quot;*&quot;).return &#123; &#125;
</code></pre>
</blockquote>
<p>上面例子的第一个探针，会在每个ext3模块中的函数被调用时触发。第二个探针会在函数退出时触发。一切就跟<code>kernel.function()</code>一样。</p>
<p>系统内的所有内核模块通常都在<code>/lib/modules/kernel_version</code>，其中<code>kernel_version</code>取当前内核版本号。模块的后缀名为<code>.ko</code>。<br>（译注：在该路径下使用<code>find -name &#39;*.ko&#39; -printf &#39;%f\n&#39; | sed &#39;s/\.ko$//&#39; </code>可列出所有的内核模块）</p>
<h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><p>异步事件跟特定的指令或代码的位置无关。<br>这部分事件主要包含计数器、定时器和其它类似的东西。</p>
<p><strong>begin</strong></p>
<p>SystemTap会话的启动事件，会在脚本开始时触发。</p>
<p><strong>end</strong></p>
<p>SystemTap会话的结束事件，会在脚本结束时触发。</p>
<p><strong>timer events</strong></p>
<p>用于周期性执行某段处理程序。举个例子：</p>
<blockquote>
<p>   probe timer.s(4)<br>   {<br>       printf(“hello world\n”)<br>   }</p>
</blockquote>
<p>上面的例子中，每隔4秒就会输出<code>hello world</code>。还可以使用其它规格的定时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer.ms(milliseconds)</span><br><span class="line">timer.us(microseconds)</span><br><span class="line">timer.ns(nanoseconds)</span><br><span class="line">timer.hz(hertz)</span><br><span class="line">timer.jiffies(jiffies)</span><br></pre></td></tr></table></figure>

<p>定时事件总是跟其它事件搭配使用。其它事件负责收集信息，而定时事件定期输出当前状况，让你看到数据随时间的变化情况。</p>
<blockquote>
<p>限于篇幅，还有些SystemTap事件就不再一一介绍了。如果你想了解更多内容，请<code>man stapprobes</code>。该man page中的<code>SEE ALSO</code>一节，包括了通往其它man page的链接，你还可以随之找到某些特定子系统和组件所支持的事件。</p>
</blockquote>
<h2 id="处理程序"><a href="#处理程序" class="headerlink" title="处理程序"></a>处理程序</h2><p>看一下下面的示例脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;hello world\n&quot;)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每当会话开始时，<code>begin</code>事件会触发<code>&#123;&#125;</code>内的处理程序，输出<code>hello world</code>加一个换行符，然后退出。</p>
<blockquote>
<p>SystemTap脚本会一直运行，直到执行了<code>exit()</code>函数。如果你想中途退出一个脚本，可以用<code>Ctrl+c</code>中断。 </p>
</blockquote>
<p><strong>printf</strong></p>
<p><code>printf()</code>是最简单的SystemTap函数之一，可以跟许多函数搭配使用，用来输出数据。通常我们会这样调用<code>printf()</code>：</p>
<pre><code>printf (&quot;format string\n&quot;, arguments)
</code></pre>
<p><code>format string</code>指明<code>arguments</code>输出的格式。在前面的例子里，printf语句内没有指定format格式符。在格式字符串（format string）中，你可以用<code>%s</code>表示字符串，<code>%d</code>表示数字。格式字符串中可以包含多个格式符，每个格式符对应一个参数；每个参数之间用逗号隔开。</p>
<blockquote>
<p>SystemTap的printf语句跟C的printf语句，无论在语法还是在格式字符串上都差不多。</p>
</blockquote>
<p>下面让我们再看多一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%s(%d) open\n&quot;, execname(), pid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，SystemTap会在每次<code>open</code>被调用时，输出调用程序的名字和PID，外加<code>open</code>这个词。该探针输出的结果看上去会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vmware-guestd(2206) open</span><br><span class="line">hald(2360) open</span><br><span class="line">hald(2360) open</span><br><span class="line">hald(2360) open</span><br><span class="line">df(3433) open</span><br><span class="line">df(3433) open</span><br><span class="line">df(3433) open</span><br><span class="line">hald(2360) open</span><br></pre></td></tr></table></figure>

<p>你可以在<code>printf()</code>里使用其他的SystemTap函数。比如上面的例子中就用到<code>execname()</code>（获取触发事件的进程名）和<code>pid()</code>（当前进程ID）。</p>
<p>下面列出常用的SystemTap函数：</p>
<p><strong>tid()</strong></p>
<p>当前的tid（thread id）。</p>
<p><strong>uid()</strong></p>
<p>当前的uid。</p>
<p><strong>cpu()</strong></p>
<p>当前的CPU号</p>
<p><strong>gettimeofday_s()</strong></p>
<p>自epoch以来的秒数</p>
<p><strong>ctime()</strong></p>
<p>将上一个函数返回的秒数转化成时间字符串</p>
<p><strong>pp()</strong></p>
<p>返回描述当前处理的探测点的字符串</p>
<p><strong>thread_indent()</strong></p>
<p>你可以用这个函数来组织你的输出结果。这个函数接受一个表示缩进差额的参数，用来更新当前线程的“缩进计数器”（其实就是用于缩进的空格数）。它返回的是加了足够缩进的标识字符串。<br>这个标识字符串包括一个时间戳（表示自从该线程首次调用<code>thread_indent()</code>以来所经过的毫秒数），一个进程名，一个tid。由此可以清晰地看出函数的调用次序和调用层级，和每次调用时的间隔。<br>如果一个函数调用后随即退出，很容易就能看出被触发的两个事件是相关的。然而，在大多数情况下，一个函数调用和退出之间，往往会有调用其他别的函数。通过缩进，可以相对更清晰地看出某个函数调用和退出的时机。</p>
<p>看一下下面使用<code>thread_indent()</code>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function(&quot;*@net/socket.c&quot;).call</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%s -&gt; %s\n&quot;, thread_indent(1), probefunc())</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.function(&quot;*@net/socket.c&quot;).return</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%s &lt;- %s\n&quot;, thread_indent(-1), probefunc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它输出的结果大概是这个样子的，注意箭头前面的空格数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 ftp(7223): -&gt; sys_socketcall</span><br><span class="line">1159 ftp(7223):  -&gt; sys_socket</span><br><span class="line">2173 ftp(7223):   -&gt; __sock_create</span><br><span class="line">2286 ftp(7223):    -&gt; sock_alloc_inode</span><br><span class="line">2737 ftp(7223):    &lt;- sock_alloc_inode</span><br><span class="line">3349 ftp(7223):    -&gt; sock_alloc</span><br><span class="line">3389 ftp(7223):    &lt;- sock_alloc</span><br><span class="line">3417 ftp(7223):   &lt;- __sock_create</span><br><span class="line">4117 ftp(7223):   -&gt; sock_create</span><br><span class="line">4160 ftp(7223):   &lt;- sock_create</span><br><span class="line">4301 ftp(7223):   -&gt; sock_map_fd</span><br><span class="line">4644 ftp(7223):    -&gt; sock_map_file</span><br><span class="line">4699 ftp(7223):    &lt;- sock_map_file</span><br><span class="line">4715 ftp(7223):   &lt;- sock_map_fd</span><br><span class="line">4732 ftp(7223):  &lt;- sys_socket</span><br><span class="line">4775 ftp(7223): &lt;- sys_socketcall</span><br></pre></td></tr></table></figure>

<p>上面的输出包含如下信息：</p>
<ul>
<li>自从该线程首次调用<code>thread_indent()</code>以来所经过的毫秒数。</li>
<li>进程名和PID。</li>
<li>用于缩进的若干个空格。以上三项均为<code>thread_indent()</code>的输出。</li>
<li><code>-&gt;</code>表示函数调用，<code>&lt;-</code>表示函数退出。</li>
<li>触发事件的函数名。</li>
</ul>
<p><strong>name</strong></p>
<p>返回系统调用的名字。这个变量只能在<code>syscall.system_call</code>触发的处理程序中使用。</p>
<p><strong>target()</strong></p>
<p>当你通过<code>stap script -x PID</code>或<code>stap script -c command</code>来执行某个脚本<code>script</code>时，<code>target()</code>会返回你指定的PID或命令名。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.* &#123;</span><br><span class="line">  if (pid() == target())</span><br><span class="line">    printf(&quot;%s\n&quot;, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的例子中的脚本带命令行参数<code>-x PID</code>运行时，它会监控所有的系统调用（<code>syscall.*</code>），并输出其中由指定进程所触发的系统调用。<br>你当然可以把上面例子中的<code>target()</code>替换成你想要指定的PID。不过使用<code>target()</code>让你的脚本可以重用。现在你只需在运行时指定PID，而无需每次都修改掉硬编码的PID值。</p>
<p>要想了解更多关于SystemTap函数的信息，请<code>man stapfuncs</code>。</p>
<h1 id="3-3-处理程序的基本结构"><a href="#3-3-处理程序的基本结构" class="headerlink" title="3.3. 处理程序的基本结构"></a>3.3. 处理程序的基本结构</h1><p>SystemTap支持在处理程序中使用一些基本的结构。它们的语法基本上类似于C或awk。了解最常用的一些结构，有助于你写出更清晰的SystemTap脚本。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>处理程序里面当然可以使用变量，你所需的不过是给它取个好名字，把函数或表达式的值赋给它，然后就可以使用它了。SystemTap可以自动判定变量的类型。举个例子，如果你用<code>gettimeofday_s()</code>给变量<code>foo</code>赋值，那么<code>foo</code>就是数值类型的，可以在<code>printf()</code>中通过<code>%d</code>输出。<br>变量默认只能在其所定义的探针内可用。这意味着变量的生命周期仅仅是处理程序的某次运行。不过你也可以在探针外定义变量，并使用<code>global</code>修饰它们，这样就能在探针间共享变量了。<br>⁠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global count_jiffies, count_ms</span><br><span class="line">probe timer.jiffies(100) &#123; count_jiffies ++ &#125;</span><br><span class="line">probe timer.ms(100) &#123; count_ms ++ &#125;</span><br><span class="line">probe timer.ms(12345)</span><br><span class="line">&#123;</span><br><span class="line">  hz=(1000*count_jiffies) / count_ms</span><br><span class="line">  printf (&quot;jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d\n&quot;,</span><br><span class="line">    count_jiffies, count_ms, hz)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>timer-jiffies.stp</code>通过累加jiffies和milliseconds，来求出内核的<code>CONFIG_HZ</code>配置。<code>global</code>语句使得<code>count_jiffies</code>和<code>count_ms</code>在每个探针中可用。</p>
<blockquote>
<p>在上面的例子中，我们用<code>++</code>来将变量的值加一。如下探针中，<code>count_jiffies</code>每隔100 jiffies会自增1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe timer.jiffies(100) &#123; count_jiffies ++ &#125;</span><br></pre></td></tr></table></figure>

<p>SystemTap知道<code>count_jiffies</code>是一个整数。那是因为<code>count_jiffies</code>没有被赋予一个初始值，所以它的值默认为零。</p>
</blockquote>
<h2 id="目标变量（Target-Variables）"><a href="#目标变量（Target-Variables）" class="headerlink" title="目标变量（Target Variables）"></a>目标变量（Target Variables）</h2><p>跟内核代码相关的事件，如<code>kernel.function(&quot;function&quot;)</code>和<code>kernel.statement(&quot;statement&quot;)</code>，允许使用目标变量获取这部分代码中可访问到的变量的值。你可以使用<code>-L</code>选项来列出特定探测点下可用的目标变量。如果已经安装了内核调试信息，你可以通过这个命令获取<code>vfs_read</code>中可用的目标变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -L &#x27;kernel.function(&quot;vfs_read&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<p>它会有类似如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.function(&quot;vfs_read@fs/read_write.c:277&quot;) $file:struct file* $buf:char* $count:size_t $pos:loff_t*</span><br></pre></td></tr></table></figure>

<p>每个目标变量前面都以<code>$</code>开头，并以<code>:</code>加变量类型结尾。上面的输出表示，<code>vfs_read</code>函数入口处有三个变量可用：<code>$file</code>（指向描述文件的结构体）、<code>$buf</code>（指向接收读取的数据的用户空间缓冲区）、<code>$count</code>（读取的字节数），和<code>$pos</code>（读开始的位置）。<br>对于那些不属于本地变量的变量，像是全局变量或一个在文件中定义的静态变量，可以用<code>@var(&quot;varname@src/file.c&quot;)</code>获取。<br>SystemTap会保留目标变量的类型信息，并且允许通过<code>-&gt;</code>访问其中的成员。跟C语言不同的是，<code>-&gt;</code>既可以用来访问指针指向的值，也可以用来访问子结构体中的成员。在获取复杂结构体中的信息时，<code>-&gt;</code>可以链式使用。举个例子，<code>fs/file_table.c</code>中的静态目标变量<code>files_stat</code>存储着一些当前文件系统中可调节的参数。我们为了获取其中的一个域，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stap -e &#x27;probe kernel.function(&quot;vfs_read&quot;) &#123;</span><br><span class="line">           printf (&quot;current files_stat max_files: %d\n&quot;,</span><br><span class="line">                   @var(&quot;files_stat@fs/file_table.c&quot;)-&gt;max_files);</span><br><span class="line">           exit(); &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>会有类似如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current files_stat max_files: 386070</span><br></pre></td></tr></table></figure>

<p>有许多函数可以通过指向基本类型的指针获取内核空间对应地址上的数据，在此一一列出。在第4.2节，我们还会谈到获取用户空间数据的类似函数。</p>
<p><strong>kernel_char(address)</strong></p>
<p>从内核空间地址中获取char变量</p>
<p><strong>kernel_short(address)</strong></p>
<p>从内核空间地址中获取short变量</p>
<p><strong>kernel_int(address)</strong></p>
<p>从内核空间地址中获取int变量</p>
<p><strong>kernel_long(address)</strong></p>
<p>从内核空间地址中获取long变量</p>
<p><strong>kernel_string(address)</strong></p>
<p>从内核空间地址中获取字符串</p>
<p><strong>kernel_string_n(address, n)</strong></p>
<p>从内核空间地址中获取长为n的字符串</p>
<h3 id="整齐打印目标变量（Pretty-Printing-Target-Variables）"><a href="#整齐打印目标变量（Pretty-Printing-Target-Variables）" class="headerlink" title="整齐打印目标变量（Pretty Printing Target Variables）"></a>整齐打印目标变量（Pretty Printing Target Variables）</h3><p>某些场景中，我们可能需要输出当前可访问的各种变量，以便于记录底层的变化。SystemTap提供了一些操作，可以生成描述特定目标变量的字符串：</p>
<p><strong>$$vars</strong></p>
<p>输出作用域内每个变量的值。等价于<code>sprintf(&quot;parm1=%x ... parmN=%x var1=%x ... varN=%x&quot;, parm1, ..., parmN, var1, ..., varN)</code>。如果变量的值在运行时找不到，输出<code>=?</code>。</p>
<p><strong>$$locals</strong></p>
<p>同<code>$$vars</code>，只输出本地变量。</p>
<p><strong>$$parms</strong></p>
<p>同<code>$$vars</code>，只输出函数入参。</p>
<p><strong>$$return</strong></p>
<p>仅在带<code>return</code>的探针中可用。如果被监控的函数有返回值，它等价于<code>sprintf(&quot;return=%x&quot;, $return)</code>，否则为空字符串。</p>
<p>下面的例子中，我们会输出<code>vfs_read</code>的入参：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -e &#x27;probe kernel.function(&quot;vfs_read&quot;) &#123;printf(&quot;%s\n&quot;, $$parms); exit(); &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><code>vfs_read</code>的入参有四个：<code>file</code>，<code>buf</code>，<code>count</code>，和<code>pos</code>。<code>$$params</code>会给这些入参生成描述字符串。在这个例子里，四个变量都是指针。下面是之前的命令的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=0xffff8800b40d4c80 buf=0x7fff634403e0 count=0x2004 pos=0xffff8800af96df48</span><br></pre></td></tr></table></figure>

<p>关输出个地址值没什么用啊。要想输出指针指向的值，我们可以加上<code>$</code>后缀。下面的命令使用<code>$</code>后缀来输出<code>vfs_read</code>入参的实际值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -e &#x27;probe kernel.function(&quot;vfs_read&quot;) &#123;printf(&quot;%s\n&quot;, $$parms$); exit(); &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=&#123;.f_u=&#123;...&#125;, .f_path=&#123;...&#125;, .f_op=0xffffffffa06e1d80, .f_lock=&#123;...&#125;, .f_count=&#123;...&#125;, .f_flags=34818, .f_mode=31, .f_pos=0, .f_owner=&#123;...&#125;, .f_cred=0xffff88013148fc80, .f_ra=&#123;...&#125;, .f_version=0, .f_security=0xffff8800b8dce560, .private_data=0x0, .f_ep_links=&#123;...&#125;, .f_mapping=0xffff880037f8fdf8&#125; buf=&quot;&quot; count=8196 pos=-131938753921208</span><br></pre></td></tr></table></figure>

<p>只使用<code>$</code>后缀的话，是不会展开结构体里面嵌套的结构体的。要想展开嵌套的结构体，你需要使用<code>$$</code>后缀。下面是一个使用<code>$$</code>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -e &#x27;probe kernel.function(&quot;vfs_read&quot;) &#123;printf(&quot;%s\n&quot;, $$parms$$); exit(); &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>注意<code>$$</code>的输出，会受到字符串最长长度的限制。来自上面命令的输出，就因此被截断了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=&#123;.f_u=&#123;.fu_list=&#123;.next=0xffff8801336ca0e8, .prev=0xffff88012ded0840&#125;, .fu_rcuhead=&#123;.next=0xffff8801336ca0e8, .func=0xffff88012ded0840&#125;&#125;, .f_path=&#123;.mnt=0xffff880132fc97c0, .dentry=0xffff88001a889cc0&#125;, .f_op=0xffffffffa06f64c0, .f_lock=&#123;.raw_lock=&#123;.slock=196611&#125;&#125;, .f_count=&#123;.counter=2&#125;, .f_flags=34818, .f_mode=31, .f_pos=0, .f_owner=&#123;.lock=&#123;.raw_lock=&#123;.lock=16777216&#125;&#125;, .pid=0x0, .pid_type=0, .uid=0, .euid=0, .signum=0&#125;, .f_cred=0xffff880130129a80, .f_ra=&#123;.start=0, .size=0, .async_size=0, .ra_pages=32, .</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>有些时候，你写的SystemTap脚本较为复杂，可能需要用上条件语句。SystemTap支持C风格的条件语句，另外还支持<code>foreach (VAR in ARRAY) &#123;&#125;</code>形式的遍历。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>通过<code>$</code>或<code>@</code>加个数字的形式可以访问对应位置的命令行参数。用<code>$</code>会把用户输入当作整数，用<code>@</code>会把用户输入当作字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function(@1) &#123; &#125;</span><br><span class="line">probe kernel.function(@1).return &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>上面的脚本期望用户把要监控的函数作为命令行参数传递进来。你可以让脚本接受多个命令行参数，分别命名为<code>@1</code>，<code>@2</code>等等，按用户输入的次序逐个对应。</p>
<h1 id="3-4-关联数组"><a href="#3-4-关联数组" class="headerlink" title="3.4. 关联数组"></a>3.4. 关联数组</h1><p>SystemTap支持关联数组。关联数组就像其它编程语言中的map&#x2F;dict&#x2F;hash，你可以把它看作由互不相同的键所组成的数组，每个键都有一个关联的值。</p>
<p>关联数组需要定义为全局变量。访问关联数组的值的语法跟awk类似，就是<code>array_name[index_expression]</code>。<br>这里的<code>array_name</code>指关联数组的名字，<code>index_expression</code>指数组中某个唯一的键。比如在下面的例子中，我们需要在数组<code>foo</code>中存tom、dick、harry三个人的年龄，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo[&quot;tom&quot;] = 23</span><br><span class="line">foo[&quot;dick&quot;] = 24</span><br><span class="line">foo[&quot;harry&quot;] = 25</span><br></pre></td></tr></table></figure>

<p>在一个数组语句中你最多可以指定<strong>九个</strong>表达式，每个表达式间以<code>,</code>隔开。这样做可以给单个键附加多个信息。下面一行代码中，数组<code>device</code>的键包含五个表达式：进程PID，可执行程序名，用户UID，父进程PID，和字符串“W”。<code>devname</code>值关联到这个键上面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device[pid(),execname(),uid(),ppid(),&quot;W&quot;] = devname</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的关联数组都必须是全局变量，不管它们是否使用在多个探针内。</p>
</blockquote>
<h1 id="3-5-数组操作"><a href="#3-5-数组操作" class="headerlink" title="3.5. 数组操作"></a>3.5. 数组操作</h1><p>本节将列举SystemTap中若干常用的数组操作。</p>
<h2 id="设置给定键的值"><a href="#设置给定键的值" class="headerlink" title="设置给定键的值"></a>设置给定键的值</h2><p>使用<code>=</code>来设置给定键所对应的值，正如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo[tid()] = gettimeofday_s()</span><br></pre></td></tr></table></figure>

<p>SystemTap会把<code>tid()</code>的结果作为一个键，并把<code>gettimeofday_s()</code>的结果赋给这个键。如果这个键已经存在<code>foo</code>中，原先关联的值会被覆盖掉。</p>
<h2 id="获取给定键的值"><a href="#获取给定键的值" class="headerlink" title="获取给定键的值"></a>获取给定键的值</h2><p>使用<code>array_name[index_expression]</code>可以获取对应键上的值。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta = gettimeofday_s() - foo[tid()]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果数组中没有<code>index_expression</code>对应的键，默认情况下它会返回0（在数值计算中）或者空字符串（在字符串操作中）。</p>
</blockquote>
<h2 id="自增给定键的值"><a href="#自增给定键的值" class="headerlink" title="自增给定键的值"></a>自增给定键的值</h2><p>使用<code>++</code>来增加对应键上的值，比如：<code>array_name[index_expression] ++</code>。在下面的例子里，每次<code>vfs.read</code>都会把当前进程名所关联的值加一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">probe vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  reads[execname()] ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以用<code>if (index_expression in array_name)</code>来判断数组是否有指定的键。</p>
<h2 id="遍历数组中的多个元素"><a href="#遍历数组中的多个元素" class="headerlink" title="遍历数组中的多个元素"></a>遍历数组中的多个元素</h2><p>一旦已经收集了足够的信息到数组里，你往往需要去遍历它。正如上面的例子中，在收集了各个进程的读次数后，你可能需要遍历它，输出每个进程的结果。那该怎么做呢？</p>
<p>最好的方法就是使用<code>foreach</code>语句。看下这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global reads</span><br><span class="line">probe vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  reads[execname()] ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(3)</span><br><span class="line">&#123;</span><br><span class="line">  foreach (count in reads)</span><br><span class="line">    printf(&quot;%s : %d \n&quot;, count, reads[count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个探针中的<code>foreach</code>语句里，<code>count</code>引用了<code>reads</code>的键，所以可以通过<code>reads[count]</code>读取对应键所关联的值。</p>
<p>在这个<code>foreach</code>语句里面，我们依次遍历<code>reads</code>的每个值。假如我们不想遍历整个数组，或者想指定遍历的顺序，该怎么做呢？你可以给数组名加个后缀<code>+</code>来表示按升序遍历，或<code>-</code>按降序遍历。另外，你可以用<code>limit</code>加一个数字来限制迭代的次数。<br>看下这个类似于上一个探针的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">probe timer.s(3)</span><br><span class="line">&#123;</span><br><span class="line">  foreach (count in reads- limit 10)</span><br><span class="line">    printf(&quot;%s : %d \n&quot;, count, reads[count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>foreach</code>语句会按关联的值降序遍历数组。<code>limit 10</code>表示<code>foreach</code>语句只会迭代10次（也即输出最高的10个值）。</p>
<h2 id="清除数组或数组中某个元素"><a href="#清除数组或数组中某个元素" class="headerlink" title="清除数组或数组中某个元素"></a>清除数组或数组中某个元素</h2><p>有时，你需要清除数组值某个值，或者清空整个数组以便于在另一个探针值重用。在之前统计<code>vfs.read</code>的例子里，每三秒统计一次各个进程的调用读操作的次数。如果要想统计三秒内各个进程的数据，需要每三秒清空一次数组。你可以使用<code>delete</code>运算符来删除数组中的某个元素，或整个数组。看下下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">global reads</span><br><span class="line">probe vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  reads[execname()] ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(3)</span><br><span class="line">&#123;</span><br><span class="line">  foreach (count in reads)</span><br><span class="line">    printf(&quot;%s : %d \n&quot;, count, reads[count])</span><br><span class="line">  delete reads</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，第二个探针仅输出三秒内每个进程的读次数。这里的<code>delete</code>语句清空了整个<code>reads</code>数组。</p>
<h2 id="使用聚集变量（use-aggregates）"><a href="#使用聚集变量（use-aggregates）" class="headerlink" title="使用聚集变量（use aggregates）"></a>使用聚集变量（use aggregates）</h2><p>有时候你需要快速处理新的数值，并且数据量较大，这时候可以考虑使用聚集变量（aggregates），因为它实现了对数据的流式处理。聚集变量可以用作全局变量，也可以用作数组中的值。使用<code>&lt;&lt;&lt;</code>运算符可以往聚集变量中添加新数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global reads</span><br><span class="line">probe vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  reads[execname()] &lt;&lt;&lt; $count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在上面的例子中，<code>$count</code>的值是一段时间内当前进程的读次数。<code>&lt;&lt;&lt;</code>会把<code>$count</code>的值存储到<code>reads</code>数组<code>execname()</code>关联的聚集变量中。请注意，我们是把值存储在聚集变量里面；它们既没有加到原来的值上，也没有覆盖掉原来的值。可以这么说，就像是<code>reads</code>数组值每个键都有多个关联的值，并且探针的每次触发都会添加新的值。</p>
<p>要想从聚集变量中获取汇总的结果，使用这样的语法<code>@extractor(variable/array index expression)</code>。<code>extractor</code>可以取以下的函数：</p>
<p><strong>count</strong></p>
<p>返回<code>variable/array index expression</code>中存储的数值的数目。以上面为例，<code>@count(reads[execname()])</code>返回对应进程的聚集变量所存储的数据数。</p>
<p><strong>sum</strong></p>
<p>返回<code>variable/array index expression</code>中存储的数值的和。以上面为例，<code>@count(reads[execname()])</code>返回对应进程的读总数。</p>
<p><strong>min</strong></p>
<p>返回<code>variable/array index expression</code>中存储的数值的最小值。</p>
<p><strong>max</strong></p>
<p>返回<code>variable/array index expression</code>中存储的数值的最大值。</p>
<p><strong>avg</strong></p>
<p>返回<code>variable/array index expression</code>中存储的数值的数目。</p>
<p>你可以使用多重索引表达式在数组里关联一个聚集变量（最多使用9个索引）。这么做的好处在于，你可以在数组中附加更多的上下文信息。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global reads</span><br><span class="line">probe vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  reads[execname(),pid()] &lt;&lt;&lt; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(3)</span><br><span class="line">&#123;</span><br><span class="line">  foreach([var1,var2] in reads)</span><br><span class="line">    printf(&quot;%s (%d) : %d \n&quot;, var1, var2, @count(reads[var1,var2]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，第一个探针记录每个进程的<code>vfs.read</code>次数。跟之前的例子不同的是，这里的数组同时使用进程名和PID作为索引。</p>
<p>在第二个探针里，我们使用<code>foreach</code>语句遍历并输出每个进程的数据。注意这里我们分别使用<code>var1</code>和<code>var2</code>来引用进程名和PID。</p>
<h2 id="3-6-Tapsets"><a href="#3-6-Tapsets" class="headerlink" title="3.6. Tapsets"></a>3.6. Tapsets</h2><p>tapsets是一些包含常用的探针和函数的内置脚本，你可以在SystemTap脚本中复用它们。当用户运行一个SystemTap脚本时，SystemTap会检测脚本中的事件和处理程序，并在翻译脚本成C代码之前，加载用到的tapset。（可以回顾下本章开头所讲到的，SystemTap会话的启动过程）<br>就像SystemTap脚本一样，tapset的拓展名也是<code>.stp</code>。默认情况下tapset位于<code>/usr/share/systemtap/tapset/</code>。跟SystemTap脚本不同的是，tapset不能被直接运行；它只能作为库使用。<br>tapset库让用户能够在更高的抽象层次上定义事件和函数。tapset提供了一些常用的内核函数的别名，这样用户就不需要记住完整的内核函数名了（尤其是有些函数名可能会因内核版本的不同而不同）。另外tapset也提供了常用的辅助函数，比如之前我们见过的<code>thread_indent()</code>。</p>
<h1 id="3-工作细节-1"><a href="#3-工作细节-1" class="headerlink" title="3. 工作细节"></a>3. 工作细节</h1><p>SystemTap允许用户仅需编写和重用简单的脚本即可获取Linux繁多的运行数据。通过SystemTap脚本，你可以又好又快地提取数据、过滤数据、汇总数据。诊断复杂的性能问题（或功能问题）再也不是难事。</p>
<p>整个SystemTap脚本所做的，无非就是声明感兴趣的事件，然后添加对应的处理程序。当SystemTap脚本运行时，SystemTap会监控声明的事件；一旦事件发生，Linux内核会临时切换到对应的处理程序，完成后再重拾原先的工作。</p>
<p>可供监控的事件种类繁多：进入&#x2F;退出某个函数，定时器到期，会话终止，等等。处理程序由一组SystemTap语句构成，指明事件发生后要做的工作。其中包括从事件上下文中提取数据，存储到内部变量中，输出结果。</p>
<h1 id="4-用户空间探测"><a href="#4-用户空间探测" class="headerlink" title="4. 用户空间探测"></a>4. 用户空间探测</h1><p>SystemTap诞生的最初使命，是探测内核空间。由于许多情况下用户空间探测有助于诊断问题，SystemTap从0.6版本开始也支持探测用户空间的进程。SystemTap可以探测用户空间进程内函数的调用和退出，可以探测用户代码中预定义的标记，可以探测用户进程的事件。</p>
<p>SystemTap进行用户空间探测需要uprobes模块。如果你的Linux内核版本大于等于3.5, 它已经内置了<code>uprobes</code>。要想验证当前内核是否原生支持uprobes，运行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep CONFIG_UPROBES /boot/config-`uname -r`</span><br></pre></td></tr></table></figure>

<p>如果当前内核集成了uprobes，就会输出以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_UPROBES=y</span><br></pre></td></tr></table></figure>

<p>如果你的内核版本小于3.5, SystemTap会自动构建uprobes模块。不过，SystemTap的用户空间事件跟踪功能依然需要你的内核支持utrace拓展。可以从这个链接获取更多关于utrace的细节：<a target="_blank" rel="noopener" href="http://sourceware.org/systemtap/wiki/utrace">http://sourceware.org/systemtap/wiki/utrace</a> 。要想验证当前内核是否提供了必要的utrace支持，在终端中输入下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep CONFIG_UTRACE /boot/config-`uname -r`</span><br></pre></td></tr></table></figure>

<p>如果当前内核支持用户空间探测，就会输出以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_UTRACE=y</span><br></pre></td></tr></table></figure>

<h1 id="4-1-用户空间事件"><a href="#4-1-用户空间事件" class="headerlink" title="4.1. 用户空间事件"></a>4.1. 用户空间事件</h1><p>所有的用户空间事件都以<code>process</code>开头。你可以通过进程ID指定要检测的进程，也可以通过可执行文件名的路径名指定。SystemTap会查看系统的<code>PATH</code>环境变量，所以你既可以使用绝对路径，也可以使用在命令行中运行可执行文件时所用的名字。</p>
<p>由于SystemTap静态分析放置探针的位置时离不开调试信息，一些用户空间事件需要给定PID或可执行文件的路径（以下将两者统称为<code>PATH</code>）。不过大多数<code>process</code>事件中，PID和可执行文件路径名都是可选的。下面列出的事件都需要进程ID或可执行文件的路径。不在其中的<code>process</code>事件不需要PID和可执行文件路径名。</p>
<p><strong>process(“PATH”).function(“function”)</strong></p>
<p>进入可执行文件<code>PATH</code>的用户空间函数<code>function</code>。该事件相当于内核空间中的<code>kernel.function(&quot;function&quot;)</code>。它允许使用通配符和<code>.return</code>后缀。</p>
<p><strong>process(“PATH”).statement(“statement”)</strong></p>
<p>代码中第一次执行<code>statement</code>的地方。该事件相当于内核空间中的<code>kernel.statement(&quot;statement&quot;)</code>。</p>
<p><strong>process(“PATH”).mark(“marker”)</strong></p>
<p>在<code>PATH</code>中定义的静态探测点。你可以使用通配符，在单个探针中指定多个探测点。有些静态探测点中 允许使用编了号（numbered）的参数（<code>$1</code>，<code>$2</code>等等）。<br>有些用户空间下的可执行程序提供了这些静态探测点，比如Java。大多数提供了静态探测点的程序也一并给这些探测点提供了易于使用的别名。下面是x86_64 Java hotspot虚拟机中的一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe hotspot.gc_begin =</span><br><span class="line">  process(&quot;/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0.x86_64/jre/lib/amd64/server/libjvm.so&quot;).mark(&quot;gc__begin&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>process(“PATH”).begin</strong></p>
<p>创建了一个用户空间下的进程。你可以限定某个进程ID或可执行文件的路径，如果不限定，任意进程的创建都会触发该事件。</p>
<p><strong>process(“PATH”).thread.begin</strong></p>
<p>创建了一个用户空间下的线程。你可以限定某个进程ID或可执行文件的路径。</p>
<p><strong>process(“PATH”).end</strong></p>
<p>销毁了一个用户空间下的进程。你可以限定某个进程ID或可执行文件的路径。</p>
<p><strong>process(“PATH”).thread.end</strong></p>
<p>销毁了一个用户空间下的线程。你可以限定某个进程ID或可执行文件的路径。</p>
<p><strong>process(“PATH”).syscall</strong></p>
<p>一个用户空间进程调用了系统调用。可以通过上下文变量<code>$syscall</code>获取系统调用号。还可以通过<code>$arg1</code>到<code>$arg6</code>分别获取前六个参数。添加<code>return</code>后缀后会捕获退出系统调用的事件。在<code>syscall.return</code>中，可以通过上下文变量<code>$return</code>获取返回值。<br>你可以用某个进程ID或可执行文件的路径进行限定。</p>
<h1 id="4-2-访问用户空间目标变量"><a href="#4-2-访问用户空间目标变量" class="headerlink" title="4.2. 访问用户空间目标变量"></a>4.2. 访问用户空间目标变量</h1><p>你可以访问用户空间目标变量，所用的语法与第3.3节第二部分，“目标变量”中访问内核空间的语法相同。在Linux中，用户代码和内核代码使用的地址空间是隔绝的。不过SystemTap可以在使用<code>-&gt;</code>运算符时找到恰当的地址空间。</p>
<p>对于指向基本类型（如整数和字符串）的指针，可以使用下列的函数访问用户空间的数据。每个函数的第一个参数都是指向数据的指针（<code>address</code>）。</p>
<p><strong>user_char(address)</strong></p>
<p>从当前用户进程中获取地址对应的字符数据。</p>
<p><strong>user_short(address)</strong></p>
<p>从当前用户进程中获取地址对应的short型数据。</p>
<p><strong>user_int(address)</strong></p>
<p>从当前用户进程中获取地址对应的int型数据。</p>
<p><strong>user_long(address)</strong></p>
<p>从当前用户进程中获取地址对应的long型数据。</p>
<p><strong>user_string(address)</strong></p>
<p>从当前用户进程中获取地址对应的字符串数据。</p>
<p><strong>user_string_n(address, n)</strong></p>
<p>从当前用户进程中获取地址对应的字符串数据，取前n字节。</p>
<p>译注：这些函数都是在<code>process(PATH).xxx</code>事件的处理程序中使用的。当前用户进程指的就是<code>PATH</code>。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process(@1).syscall &#123;</span><br><span class="line">    ...</span><br><span class="line">    user_string(field) # field指向@1地址空间中的某个地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-3-用户空间栈回溯"><a href="#4-3-用户空间栈回溯" class="headerlink" title="4.3. 用户空间栈回溯"></a>4.3. 用户空间栈回溯</h1><p><code>pp</code>（probe point）函数可以返回触发当前处理程序的事件名（包含展开了的通配符和别名）。如果该事件与特定的函数相关，<code>pp</code>的输出会包括触发了该事件的函数名。然而，许多情况下触发同一个事件的函数可能来自于程序中不同的模块；特别是在该函数位于某个共享库的情况下。还好SystemTap提供了用户空间栈的回溯（backtrace）功能，便于查看事件是怎么被触发的。</p>
<p>编译器优化代码时会消除栈帧指针（stack frame pointers），这将混淆用户空间栈回溯的结果。所以要想查看栈回溯，需要有编译器生成的调试信息。SystemTap用户空间栈回溯机制可以利用这些调试信息来重建栈回溯的现场，不过该功能当前只实现在32位和64位x86处理器上，还不支持其他架构的处理器。要想使用这些调试信息来重建栈回溯，给可执行文件加上<code>-d executable</code>选项，并给共享库加上<code>-ldd</code>选项。</p>
<p>举个例子，你可以使用<code>ubacktrace</code>（user-space backtrace）函数来输出<code>ls</code>命令中<code>xmalloc</code>函数的调用情况。如果你已经安装了<code>ls</code>命令的debuginfo，下面的SystemTap命令会在<code>xmalloc</code>函数调用时输出栈回溯的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stap -d /bin/ls --ldd \</span><br><span class="line">-e &#x27;probe process(&quot;ls&quot;).function(&quot;xmalloc&quot;) &#123;print_usyms(ubacktrace())&#125;&#x27; \</span><br><span class="line">-c &quot;ls /&quot;</span><br></pre></td></tr></table></figure>

<p>译注：要想成功运行上面的命令，你需要安装coreutils的debuginfo。具体安装方式请根据自己用的发行版搜索一下。如果你跟我一样用的也是Ubuntu，可以看下<a target="_blank" rel="noopener" href="http://askubuntu.com/questions/427318/how-can-i-install-a-debug-build-for-coreutils">askubuntu上这个回答</a>，运行<code>sudo apt-get install coreutils-dbgsym</code>。</p>
<p>运行后，上面的命令会有类似下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bin dev   lib     media  net         proc   sbin     sys  var</span><br><span class="line">boot    etc   lib64   misc   op_session  profilerc  selinux  tmp</span><br><span class="line">cgroup  home  lost+found  mnt    opt         root   srv  usr</span><br><span class="line"> 0x4116c0 : xmalloc+0x0/0x20 [/bin/ls]</span><br><span class="line"> 0x4116fc : xmemdup+0x1c/0x40 [/bin/ls]</span><br><span class="line"> 0x40e68b : clone_quoting_options+0x3b/0x50 [/bin/ls]</span><br><span class="line"> 0x4087e4 : main+0x3b4/0x1900 [/bin/ls]</span><br><span class="line"> 0x3fa441ec5d : __libc_start_main+0xfd/0x1d0 [/lib64/libc-2.12.so]</span><br><span class="line"> 0x402799 : _start+0x29/0x2c [/bin/ls]</span><br><span class="line"> 0x4116c0 : xmalloc+0x0/0x20 [/bin/ls]</span><br><span class="line"> 0x4116fc : xmemdup+0x1c/0x40 [/bin/ls]</span><br><span class="line"> 0x40e68b : clone_quoting_options+0x3b/0x50 [/bin/ls]</span><br><span class="line"> 0x40884a : main+0x41a/0x1900 [/bin/ls]</span><br><span class="line"> 0x3fa441ec5d : __libc_start_main+0xfd/0x1d0 [/lib64/libc-2.12.so]</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>关于在用户空间栈回溯中可用的函数的更多内容，请查看<code>ucontext-symbols.stp</code>和<code>ucontext-unwind.stp</code>两个tapset。上述tapset中的函数的描述信息也可以在<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/tapsets/">SystemTap Tapset Reference Manual</a>找到。</p>
<h1 id="5-SystemTap脚本集锦"><a href="#5-SystemTap脚本集锦" class="headerlink" title="5. SystemTap脚本集锦"></a>5. SystemTap脚本集锦</h1><p>本章列举了若干可用于监控和调查内核子系统的SystemTap脚本。如果你安装了<code>systemtap-testsuite</code>这个RPM包，所有这些示例都能在<code>/usr/share/systemtap/testsuite/systemtap.examples/</code>下找到。</p>
<h1 id="5-1-网络"><a href="#5-1-网络" class="headerlink" title="5.1. 网络"></a>5.1. 网络</h1><p>以下各节的脚本展示了如何跟踪网络相关的函数和剖析（profile）网络活动。</p>
<h2 id="剖析网络活动"><a href="#剖析网络活动" class="headerlink" title="剖析网络活动"></a>剖析网络活动</h2><p>本节展示SystemTap中剖析网络活动的方式。下面的<code>nettop.stp</code>允许我们一窥每个进程的网络流量使用情况。</p>
<p>nettop.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">global ifxmit, ifrecv</span><br><span class="line">global ifmerged</span><br><span class="line"></span><br><span class="line">probe netdev.transmit</span><br><span class="line">&#123;</span><br><span class="line">  ifxmit[pid(), dev_name, execname(), uid()] &lt;&lt;&lt; length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe netdev.receive</span><br><span class="line">&#123;</span><br><span class="line">  ifrecv[pid(), dev_name, execname(), uid()] &lt;&lt;&lt; length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function print_activity()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%5s %5s %-7s %7s %7s %7s %7s %-15s\n&quot;,</span><br><span class="line">         &quot;PID&quot;, &quot;UID&quot;, &quot;DEV&quot;, &quot;XMIT_PK&quot;, &quot;RECV_PK&quot;,</span><br><span class="line">         &quot;XMIT_KB&quot;, &quot;RECV_KB&quot;, &quot;COMMAND&quot;)</span><br><span class="line"></span><br><span class="line">  foreach ([pid, dev, exec, uid] in ifrecv) &#123;</span><br><span class="line">      ifmerged[pid, dev, exec, uid] += @count(ifrecv[pid,dev,exec,uid]);</span><br><span class="line">  &#125;</span><br><span class="line">  foreach ([pid, dev, exec, uid] in ifxmit) &#123;</span><br><span class="line">      ifmerged[pid, dev, exec, uid] += @count(ifxmit[pid,dev,exec,uid]);</span><br><span class="line">  &#125;</span><br><span class="line">  foreach ([pid, dev, exec, uid] in ifmerged-) &#123;</span><br><span class="line">    n_xmit = @count(ifxmit[pid, dev, exec, uid])</span><br><span class="line">    n_recv = @count(ifrecv[pid, dev, exec, uid])</span><br><span class="line">    printf(&quot;%5d %5d %-7s %7d %7d %7d %7d %-15s\n&quot;,</span><br><span class="line">           pid, uid, dev, n_xmit, n_recv,</span><br><span class="line">           n_xmit ? @sum(ifxmit[pid, dev, exec, uid])/1024 : 0,</span><br><span class="line">           n_recv ? @sum(ifrecv[pid, dev, exec, uid])/1024 : 0,</span><br><span class="line">           exec)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">  delete ifxmit</span><br><span class="line">  delete ifrecv</span><br><span class="line">  delete ifmerged</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.ms(5000), end, error</span><br><span class="line">&#123;</span><br><span class="line">  print_activity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看<code>print_activity()</code>的这几个表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n_xmit ? @sum(ifxmit[pid, dev, exec, uid])/1024 : 0</span><br><span class="line">n_recv ? @sum(ifrecv[pid, dev, exec, uid])/1024 : 0</span><br></pre></td></tr></table></figure>

<p>它们也是<code>if/else</code>语句，等价于如下的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if n_recv != 0 then</span><br><span class="line">  @sum(ifrecv[pid, dev, exec, uid])/1024</span><br><span class="line">else</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>

<p><code>nettop.stp</code>跟踪用了网络流量的进程，并逐个进程输出如下的信息：</p>
<ul>
<li>PID — 进程的PID.</li>
<li>UID — 进程所有者的UID。</li>
<li>DEV — 进程使用的端口，如<code>eth0</code>、<code>eth1</code>。</li>
<li>XMIT_PK — 发送的包的数量</li>
<li>RECV_PK — 接收的包的数量</li>
<li>XMIT_KB — 发送的KB数</li>
<li>RECV_KB — 接收的KB数</li>
</ul>
<p><code>nettop.stp</code>每隔5秒就会取样一次。你可以修改<code>probe timer.ms(5000)</code>来调整取样间隔。<code>nettop.stp</code>在20秒内的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">  PID   UID DEV     XMIT_PK RECV_PK XMIT_KB RECV_KB COMMAND</span><br><span class="line">    0     0 eth0          0       5       0       0 swapper</span><br><span class="line">11178     0 eth0          2       0       0       0 synergyc</span><br><span class="line"></span><br><span class="line">  PID   UID DEV     XMIT_PK RECV_PK XMIT_KB RECV_KB COMMAND</span><br><span class="line"> 2886     4 eth0         79       0       5       0 cups-polld</span><br><span class="line">11362     0 eth0          0      61       0       5 firefox</span><br><span class="line">    0     0 eth0          3      32       0       3 swapper</span><br><span class="line"> 2886     4 lo            4       4       0       0 cups-polld</span><br><span class="line">11178     0 eth0          3       0       0       0 synergyc</span><br><span class="line"></span><br><span class="line">  PID   UID DEV     XMIT_PK RECV_PK XMIT_KB RECV_KB COMMAND</span><br><span class="line">    0     0 eth0          0       6       0       0 swapper</span><br><span class="line"> 2886     4 lo            2       2       0       0 cups-polld</span><br><span class="line">11178     0 eth0          3       0       0       0 synergyc</span><br><span class="line"> 3611     0 eth0          0       1       0       0 Xorg</span><br><span class="line"></span><br><span class="line">  PID   UID DEV     XMIT_PK RECV_PK XMIT_KB RECV_KB COMMAND</span><br><span class="line">    0     0 eth0          3      42       0       2 swapper</span><br><span class="line">11178     0 eth0         43       1       3       0 synergyc</span><br><span class="line">11362     0 eth0          0       7       0       0 firefox</span><br><span class="line"> 3897     0 eth0          0       1       0       0 multiload-apple</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h2 id="跟踪网络连接中的内核函数调用"><a href="#跟踪网络连接中的内核函数调用" class="headerlink" title="跟踪网络连接中的内核函数调用"></a>跟踪网络连接中的内核函数调用</h2><p>本节展示如何跟踪内核的<code>net/socket.c</code>中的函数的调用情况。这将帮助你从细节上看清各进程是怎么跟内核的网络功能打交道的。</p>
<p>socket-trace.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;*@net/socket.c&quot;).call &#123;</span><br><span class="line">  printf (&quot;%s -&gt; %s\n&quot;, thread_indent(1), ppfunc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;*@net/socket.c&quot;).return &#123;</span><br><span class="line">  printf (&quot;%s &lt;- %s\n&quot;, thread_indent(-1), ppfunc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>socket-trace.stp</code>这个脚本其实在我们之前在第3章介绍<code>thread_indent()</code>的时候已经见过了。下面是它在3秒内的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">0 Xorg(3611): -&gt; sock_poll</span><br><span class="line">3 Xorg(3611): &lt;- sock_poll</span><br><span class="line">0 Xorg(3611): -&gt; sock_poll</span><br><span class="line">3 Xorg(3611): &lt;- sock_poll</span><br><span class="line">0 gnome-terminal(11106): -&gt; sock_poll</span><br><span class="line">5 gnome-terminal(11106): &lt;- sock_poll</span><br><span class="line">0 scim-bridge(3883): -&gt; sock_poll</span><br><span class="line">3 scim-bridge(3883): &lt;- sock_poll</span><br><span class="line">0 scim-bridge(3883): -&gt; sys_socketcall</span><br><span class="line">4 scim-bridge(3883):  -&gt; sys_recv</span><br><span class="line">8 scim-bridge(3883):   -&gt; sys_recvfrom</span><br><span class="line">12 scim-bridge(3883):-&gt; sock_from_file</span><br><span class="line">16 scim-bridge(3883):&lt;- sock_from_file</span><br><span class="line">20 scim-bridge(3883):-&gt; sock_recvmsg</span><br><span class="line">24 scim-bridge(3883):&lt;- sock_recvmsg</span><br><span class="line">28 scim-bridge(3883):   &lt;- sys_recvfrom</span><br><span class="line">31 scim-bridge(3883):  &lt;- sys_recv</span><br><span class="line">35 scim-bridge(3883): &lt;- sys_socketcall</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h2 id="监控TCP连接的创建"><a href="#监控TCP连接的创建" class="headerlink" title="监控TCP连接的创建"></a>监控TCP连接的创建</h2><p>本节展示如何监控TCP连接的创建。这可以帮助你第一时间识别出任何未授权的、可疑的或其它不请自来的网络连接。</p>
<p>tcp_connections.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">  printf(&quot;%6s %16s %6s %6s %16s\n&quot;,</span><br><span class="line">         &quot;UID&quot;, &quot;CMD&quot;, &quot;PID&quot;, &quot;PORT&quot;, &quot;IP_SOURCE&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;tcp_accept&quot;).return?,</span><br><span class="line">      kernel.function(&quot;inet_csk_accept&quot;).return? &#123;</span><br><span class="line">  sock = $return</span><br><span class="line">  if (sock != 0)</span><br><span class="line">    printf(&quot;%6d %16s %6d %6d %16s\n&quot;, uid(), execname(), pid(),</span><br><span class="line">           inet_get_local_port(sock), inet_get_ip_source(sock))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>tcp_connections.stp</code>运行时，它会实时输出新创建的TCP连接的如下信息：</p>
<ul>
<li>当前UID</li>
<li>接受连接的程序名</li>
<li>接受连接的进程PID</li>
<li>创建连接的远程IP地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UID            CMD    PID   PORT        IP_SOURCE</span><br><span class="line">0             sshd   3165     22      10.64.0.227</span><br><span class="line">0             sshd   3165     22      10.64.0.227</span><br></pre></td></tr></table></figure>

<h2 id="监控TCP包"><a href="#监控TCP包" class="headerlink" title="监控TCP包"></a>监控TCP包</h2><p>本节展示如何监控收到的TCP包。这可以帮助你分析应用的流量使用情况。</p>
<p>tcpdumplike.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">// A TCP dump like example</span><br><span class="line"></span><br><span class="line">probe begin, timer.s(1) &#123;</span><br><span class="line">  printf(&quot;-----------------------------------------------------------------\n&quot;)</span><br><span class="line">  printf(&quot;       Source IP         Dest IP  SPort  DPort  U  A  P  R  S  F \n&quot;)</span><br><span class="line">  printf(&quot;-----------------------------------------------------------------\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe udp.recvmsg /* ,udp.sendmsg */ &#123;</span><br><span class="line">  printf(&quot; %15s %15s  %5d  %5d  UDP\n&quot;,</span><br><span class="line">         saddr, daddr, sport, dport)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe tcp.receive &#123;</span><br><span class="line">  printf(&quot; %15s %15s  %5d  %5d  %d  %d  %d  %d  %d  %d\n&quot;,</span><br><span class="line">         saddr, daddr, sport, dport, urg, ack, psh, rst, syn, fin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>tcpdumplike.stp</code>运行时，它会实时输出收到的TCP包的如下信息：</p>
<ul>
<li>源IP地址和目标IP地址（saddr和daddr）</li>
<li>源端口和目标端口（sport和dport）</li>
<li>包标识</li>
</ul>
<p><code>tcpdumplike.stp</code>使用了以下函数来获取包的标识信息：</p>
<ul>
<li>urg - urgent</li>
<li>ack - acknowledgement</li>
<li>psh - push</li>
<li>rst - reset</li>
<li>syn - synchronize</li>
<li>fin - finished</li>
</ul>
<p>上述函数返回1或0来表示包中是否存在对应的标识。<br>⁠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line">       Source IP         Dest IP  SPort  DPort  U  A  P  R  S  F</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">  209.85.229.147       10.0.2.15     80  20373  0  1  1  0  0  0</span><br><span class="line">  92.122.126.240       10.0.2.15     80  53214  0  1  0  0  1  0</span><br><span class="line">  92.122.126.240       10.0.2.15     80  53214  0  1  0  0  0  0</span><br><span class="line">  209.85.229.118       10.0.2.15     80  63433  0  1  0  0  1  0</span><br><span class="line">  209.85.229.118       10.0.2.15     80  63433  0  1  0  0  0  0</span><br><span class="line">  209.85.229.147       10.0.2.15     80  21141  0  1  1  0  0  0</span><br><span class="line">  209.85.229.147       10.0.2.15     80  21141  0  1  1  0  0  0</span><br><span class="line">  209.85.229.147       10.0.2.15     80  21141  0  1  1  0  0  0</span><br><span class="line">  209.85.229.147       10.0.2.15     80  21141  0  1  1  0  0  0</span><br><span class="line">  209.85.229.147       10.0.2.15     80  21141  0  1  1  0  0  0</span><br><span class="line">  209.85.229.118       10.0.2.15     80  63433  0  1  1  0  0  0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h2 id="监控内核中的网络丢包情况"><a href="#监控内核中的网络丢包情况" class="headerlink" title="监控内核中的网络丢包情况"></a>监控内核中的网络丢包情况</h2><p>某些情况下Linux网络栈会丢包。有些版本的Linux内核包含静态内核探测点<code>kernel.trace(&quot;kfree_skb&quot;)</code>，它可以帮助你跟踪包丢掉的原因。<code>dropwatch.stp</code>就使用了它来跟踪丢包；这个脚本每五秒统计一次丢包的位置。</p>
<p>dropwatch.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Dropwatch.stp</span><br><span class="line"># Author: Neil Horman &lt;nhorman@redhat.com&gt;</span><br><span class="line"># An example script to mimic the behavior of the dropwatch utility</span><br><span class="line"># http://fedorahosted.org/dropwatch</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line"># Array to hold the list of drop points we find</span><br><span class="line">global locations</span><br><span class="line"></span><br><span class="line"># Note when we turn the monitor on and off</span><br><span class="line">probe begin &#123; printf(&quot;Monitoring for dropped packets\n&quot;) &#125;</span><br><span class="line">probe end &#123; printf(&quot;Stopping dropped packet monitor\n&quot;) &#125;</span><br><span class="line"></span><br><span class="line"># increment a drop counter for every location we drop at</span><br><span class="line">probe kernel.trace(&quot;kfree_skb&quot;) &#123; locations[$location] &lt;&lt;&lt; 1 &#125;</span><br><span class="line"></span><br><span class="line"># Every 5 seconds report our drop locations</span><br><span class="line">probe timer.sec(5)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;\n&quot;)</span><br><span class="line">  foreach (l in locations-) &#123;</span><br><span class="line">    printf(&quot;%d packets dropped at %s\n&quot;,</span><br><span class="line">           @count(locations[l]), symname(l))</span><br><span class="line">  &#125;</span><br><span class="line">  delete locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kernel.trace(&quot;kfree_skb&quot;)</code>跟踪内核中网络包被丢弃的位置。它有两个参数：一个指向将被释放的缓冲区的指针<code>$skb</code>，和释放缓冲区时的内核位置<code>$location</code>。如果可以获取<code>$location</code>所存储的内核地址上对应的函数名，<code>dropwatch.stp</code>脚本可以把它的值映射成对应的函数。这个映射默认不会启用。对于1.4及以上的SystemTap，你可以指定<code>--all-modules</code>选项来启用该映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap --all-modules dropwatch.stp</span><br></pre></td></tr></table></figure>

<p>在低版本的SystemTap，你可以使用下面的命令模拟<code>--all-modules</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stap -dkernel \</span><br><span class="line">`cat /proc/modules | awk &#x27;BEGIN &#123; ORS = &quot; &quot; &#125; &#123;print &quot;-d&quot;$1&#125;&#x27;` \</span><br><span class="line">dropwatch.stp</span><br></pre></td></tr></table></figure>

<p>运行<code>dropwatch.stp</code>15秒会输出类似下面的结果。输出的结果会按函数名或地址聚合丢包的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Monitoring for dropped packets</span><br><span class="line"></span><br><span class="line">1762 packets dropped at unix_stream_recvmsg</span><br><span class="line">4 packets dropped at tun_do_read</span><br><span class="line">2 packets dropped at nf_hook_slow</span><br><span class="line"></span><br><span class="line">467 packets dropped at unix_stream_recvmsg</span><br><span class="line">20 packets dropped at nf_hook_slow</span><br><span class="line">6 packets dropped at tun_do_read</span><br><span class="line"></span><br><span class="line">446 packets dropped at unix_stream_recvmsg</span><br><span class="line">4 packets dropped at tun_do_read</span><br><span class="line">4 packets dropped at nf_hook_slow</span><br><span class="line">Stopping dropped packet monitor</span><br></pre></td></tr></table></figure>

<p>当运行脚本的机器不支持<code>--all-modules</code>和<code>/proc/modules</code>时，<code>symname</code>只会输出原始的地址。你可以通过<code>/boot/System.map-$(uname -r)</code>按地址找出对应的函数。下面的<code>/boot/System.map-$(uname -r)</code>片段中，地址<code>0xffffffff8149a8ed</code>映射到函数<code>unix_stream_recvmsg</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ffffffff8149a420 t unix_dgram_poll</span><br><span class="line">ffffffff8149a5e0 t unix_stream_recvmsg</span><br><span class="line">ffffffff8149ad00 t unix_find_other</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h1 id="5-2-磁盘"><a href="#5-2-磁盘" class="headerlink" title="5.2. 磁盘"></a>5.2. 磁盘</h1><p>以下各节的脚本展示了如何监控磁盘和I&#x2F;O活动。</p>
<h2 id="统计磁盘读写状况"><a href="#统计磁盘读写状况" class="headerlink" title="统计磁盘读写状况"></a>统计磁盘读写状况</h2><p>本节展示了如何找出磁盘读写最频繁的进程。</p>
<p>disktop.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env stap</span><br><span class="line">#</span><br><span class="line"># Copyright (C) 2007 Oracle Corp.</span><br><span class="line">#</span><br><span class="line"># Get the status of reading/writing disk every 5 seconds,</span><br><span class="line"># output top ten entries</span><br><span class="line">#</span><br><span class="line"># This is free software,GNU General Public License (GPL);</span><br><span class="line"># either version 2, or (at your option) any later version.</span><br><span class="line">#</span><br><span class="line"># Usage:</span><br><span class="line">#  ./disktop.stp</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">global io_stat,device</span><br><span class="line">global read_bytes,write_bytes</span><br><span class="line"></span><br><span class="line">probe vfs.read.return &#123;</span><br><span class="line">  if ($return&gt;0) &#123;</span><br><span class="line">    if (devname!=&quot;N/A&quot;) &#123;/*skip read from cache*/</span><br><span class="line">      io_stat[pid(),execname(),uid(),ppid(),&quot;R&quot;] += $return</span><br><span class="line">      device[pid(),execname(),uid(),ppid(),&quot;R&quot;] = devname</span><br><span class="line">      read_bytes += $return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe vfs.write.return &#123;</span><br><span class="line">  if ($return&gt;0) &#123;</span><br><span class="line">    if (devname!=&quot;N/A&quot;) &#123; /*skip update cache*/</span><br><span class="line">      io_stat[pid(),execname(),uid(),ppid(),&quot;W&quot;] += $return</span><br><span class="line">      device[pid(),execname(),uid(),ppid(),&quot;W&quot;] = devname</span><br><span class="line">      write_bytes += $return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.ms(5000) &#123;</span><br><span class="line">  /* skip non-read/write disk */</span><br><span class="line">  if (read_bytes+write_bytes) &#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n%-25s, %-8s%4dKb/sec, %-7s%6dKb, %-7s%6dKb\n\n&quot;,</span><br><span class="line">           ctime(gettimeofday_s()),</span><br><span class="line">           &quot;Average:&quot;, ((read_bytes+write_bytes)/1024)/5,</span><br><span class="line">           &quot;Read:&quot;,read_bytes/1024,</span><br><span class="line">           &quot;Write:&quot;,write_bytes/1024)</span><br><span class="line"></span><br><span class="line">    /* print header */</span><br><span class="line">    printf(&quot;%8s %8s %8s %25s %8s %4s %12s\n&quot;,</span><br><span class="line">           &quot;UID&quot;,&quot;PID&quot;,&quot;PPID&quot;,&quot;CMD&quot;,&quot;DEVICE&quot;,&quot;T&quot;,&quot;BYTES&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  /* print top ten I/O */</span><br><span class="line">  foreach ([process,cmd,userid,parent,action] in io_stat- limit 10)</span><br><span class="line">    printf(&quot;%8d %8d %8d %25s %8s %4s %12d\n&quot;,</span><br><span class="line">           userid,process,parent,cmd,</span><br><span class="line">           device[process,cmd,userid,parent,action],</span><br><span class="line">           action,io_stat[process,cmd,userid,parent,action])</span><br><span class="line"></span><br><span class="line">  /* clear data */</span><br><span class="line">  delete io_stat</span><br><span class="line">  delete device</span><br><span class="line">  read_bytes = 0</span><br><span class="line">  write_bytes = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end&#123;</span><br><span class="line">  delete io_stat</span><br><span class="line">  delete device</span><br><span class="line">  delete read_bytes</span><br><span class="line">  delete write_bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>disktop.stp</code>输出磁盘读写最频繁的十个进程，包含各个进程的以下数据：</p>
<ul>
<li>UID - 进程所有者的UID</li>
<li>PID - 进程的PID</li>
<li>PPID - 进程的父进程的PID</li>
<li>CMD - 进程的名字</li>
<li>DEVICE - 读&#x2F;写的设备名</li>
<li>T - 进程的操作；<code>W</code>是写，而<code>R</code>是读。</li>
<li>BYTES - 读&#x2F;写的数据量</li>
</ul>
<p><code>disktop.stp</code>使用<code>ctime()</code>和<code>gettimeofday_s()</code>输出当前时间。<code>gettimeofday_s</code>返回当前时间自epoch（1970年1月1日）以来的秒数，<code>ctime</code>把它转化成可读的时间戳。<br>在这个脚本中，<code>$return</code>是一个存储着虚拟文件系统读写的字节数的本地变量。<code>$return</code>只能在函数返回事件探针中使用（比如这里的<code>vfs.read.return</code>和<code>vfs.write.return</code>）。</p>
<p>以下是本节脚本的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">Mon Sep 29 03:38:28 2008 , Average:  19Kb/sec, Read: 7Kb, Write: 89Kb</span><br><span class="line"></span><br><span class="line">UID      PID     PPID                       CMD   DEVICE    T    BYTES</span><br><span class="line">0    26319    26294                   firefox     sda5    W        90229</span><br><span class="line">0     2758     2757           pam_timestamp_c     sda5    R         8064</span><br><span class="line">0     2885        1                     cupsd     sda5    W         1678</span><br><span class="line"></span><br><span class="line">Mon Sep 29 03:38:38 2008 , Average:   1Kb/sec, Read: 7Kb, Write: 1Kb</span><br><span class="line"></span><br><span class="line">UID      PID     PPID                       CMD   DEVICE    T    BYTES</span><br><span class="line">0     2758     2757           pam_timestamp_c     sda5    R         8064</span><br><span class="line">0     2885        1                     cupsd     sda5    W         1678</span><br></pre></td></tr></table></figure>

<h2 id="追踪对任意文件的读写"><a href="#追踪对任意文件的读写" class="headerlink" title="追踪对任意文件的读写"></a>追踪对任意文件的读写</h2><p>本节展示如何监控各进程读&#x2F;写任意文件所花费的时间。这可以帮助你发现系统中加载时间过长的文件。</p>
<p>iotime.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Copyright (C) 2006-2007 Red Hat Inc.</span><br><span class="line"> *</span><br><span class="line"> * This copyrighted material is made available to anyone wishing to use,</span><br><span class="line"> * modify, copy, or redistribute it subject to the terms and conditions</span><br><span class="line"> * of the GNU General Public License v.2.</span><br><span class="line"> *</span><br><span class="line"> * You should have received a copy of the GNU General Public License</span><br><span class="line"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span><br><span class="line"> *</span><br><span class="line"> * Print out the amount of time spent in the read and write systemcall</span><br><span class="line"> * when each file opened by the process is closed. Note that the systemtap</span><br><span class="line"> * script needs to be running before the open operations occur for</span><br><span class="line"> * the script to record data.</span><br><span class="line"> *</span><br><span class="line"> * This script could be used to to find out which files are slow to load</span><br><span class="line"> * on a machine. e.g.</span><br><span class="line"> *</span><br><span class="line"> * stap iotime.stp -c &#x27;firefox&#x27;</span><br><span class="line"> *</span><br><span class="line"> * Output format is:</span><br><span class="line"> * timestamp pid (executabable) info_type path ...</span><br><span class="line"> *</span><br><span class="line"> * 200283135 2573 (cupsd) access /etc/printcap read: 0 write: 7063</span><br><span class="line"> * 200283143 2573 (cupsd) iotime /etc/printcap time: 69</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line">global time_io</span><br><span class="line"></span><br><span class="line">function timestamp:long() &#123; return gettimeofday_us() - start &#125;</span><br><span class="line"></span><br><span class="line">function proc:string() &#123; return sprintf(&quot;%d (%s)&quot;, pid(), execname()) &#125;</span><br><span class="line"></span><br><span class="line">probe begin &#123; start = gettimeofday_us() &#125;</span><br><span class="line"></span><br><span class="line">global filehandles, fileread, filewrite</span><br><span class="line"></span><br><span class="line">probe syscall.open.return &#123;</span><br><span class="line">  filename = user_string($filename)</span><br><span class="line">  if ($return != -1) &#123;</span><br><span class="line">    filehandles[pid(), $return] = filename</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;%d %s access %s fail\n&quot;, timestamp(), proc(), filename)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.read.return &#123;</span><br><span class="line">  p = pid()</span><br><span class="line">  fd = $fd</span><br><span class="line">  bytes = $return</span><br><span class="line">  time = gettimeofday_us() - @entry(gettimeofday_us())</span><br><span class="line">  if (bytes &gt; 0)</span><br><span class="line">    fileread[p, fd] += bytes</span><br><span class="line">  time_io[p, fd] &lt;&lt;&lt; time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.write.return &#123;</span><br><span class="line">  p = pid()</span><br><span class="line">  fd = $fd</span><br><span class="line">  bytes = $return</span><br><span class="line">  time = gettimeofday_us() - @entry(gettimeofday_us())</span><br><span class="line">  if (bytes &gt; 0)</span><br><span class="line">    filewrite[p, fd] += bytes</span><br><span class="line">  time_io[p, fd] &lt;&lt;&lt; time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.close &#123;</span><br><span class="line">  if ([pid(), $fd] in filehandles) &#123;</span><br><span class="line">    printf(&quot;%d %s access %s read: %d write: %d\n&quot;,</span><br><span class="line">           timestamp(), proc(), filehandles[pid(), $fd],</span><br><span class="line">           fileread[pid(), $fd], filewrite[pid(), $fd])</span><br><span class="line">    if (@count(time_io[pid(), $fd]))</span><br><span class="line">      printf(&quot;%d %s iotime %s time: %d\n&quot;,  timestamp(), proc(),</span><br><span class="line">             filehandles[pid(), $fd], @sum(time_io[pid(), $fd]))</span><br><span class="line">   &#125;</span><br><span class="line">  delete fileread[pid(), $fd]</span><br><span class="line">  delete filewrite[pid(), $fd]</span><br><span class="line">  delete filehandles[pid(), $fd]</span><br><span class="line">  delete time_io[pid(),$fd]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iotime.stp</code>跟踪每次<code>open</code>、<code>close</code>、<code>read</code>和<code>write</code>系统调用。对于访问到的每个文件，<code>iotime.stp</code>都会计算读写操作花费的时间和读写的数据量（以字节为单位）。<br>虽然我们可以在读写事件（<code>syscall.read</code>和<code>syscall.write</code>）中使用本地变量<code>$count</code>，但是<code>$count</code>存储的是系统调用想要读写的数据量，要获取实际读写到的数据量需要使用<code>$return</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">825946 3364 (NetworkManager) access /sys/class/net/eth0/carrier read: 8190 write: 0</span><br><span class="line">825955 3364 (NetworkManager) iotime /sys/class/net/eth0/carrier time: 9</span><br><span class="line">[...]</span><br><span class="line">117061 2460 (pcscd) access /dev/bus/usb/003/001 read: 43 write: 0</span><br><span class="line">117065 2460 (pcscd) iotime /dev/bus/usb/003/001 time: 7</span><br><span class="line">[...]</span><br><span class="line">3973737 2886 (sendmail) access /proc/loadavg read: 4096 write: 0</span><br><span class="line">3973744 2886 (sendmail) iotime /proc/loadavg time: 11</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>本节的脚本会输出以下数据：</p>
<ul>
<li>时间戳，精确到毫秒</li>
<li>PID和进程名</li>
<li>access或iotime</li>
<li>访问的文件</li>
</ul>
<p>如果一个进程读写了数据，你会看到<code>access</code>和<code>iotime</code>成对出现。<code>access</code>那一行的时间戳表示进程访问了文件；在结尾处会输出读写的数据（以字节为单位）。<code>iotime</code>那一行会输出读写消耗的时间（以毫秒为单位）。如果一行<code>access</code>后面没有<code>iotime</code>，意味着进程没有读写到数据。</p>
<h2 id="追踪I-x2F-O的累计总量"><a href="#追踪I-x2F-O的累计总量" class="headerlink" title="追踪I&#x2F;O的累计总量"></a>追踪I&#x2F;O的累计总量</h2><p>本节展示如何累计I&#x2F;O总量。</p>
<p>traceio.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"># traceio.stp</span><br><span class="line"># Copyright (C) 2007 Red Hat, Inc., Eugene Teo &lt;eteo@redhat.com&gt;</span><br><span class="line"># Copyright (C) 2009 Kai Meyer &lt;kai@unixlords.com&gt;</span><br><span class="line">#   Fixed a bug that allows this to run longer</span><br><span class="line">#   And added the humanreadable function</span><br><span class="line">#</span><br><span class="line"># This program is free software; you can redistribute it and/or modify</span><br><span class="line"># it under the terms of the GNU General Public License version 2 as</span><br><span class="line"># published by the Free Software Foundation.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">global reads, writes, total_io</span><br><span class="line"></span><br><span class="line">probe vfs.read.return &#123;</span><br><span class="line">  if ($return &gt; 0) &#123;</span><br><span class="line">    reads[pid(),execname()] += $return</span><br><span class="line">    total_io[pid(),execname()] += $return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe vfs.write.return &#123;</span><br><span class="line">  if ($return &gt; 0) &#123;</span><br><span class="line">    writes[pid(),execname()] += $return</span><br><span class="line">    total_io[pid(),execname()] += $return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function humanreadable(bytes) &#123;</span><br><span class="line">  if (bytes &gt; 1024*1024*1024) &#123;</span><br><span class="line">    return sprintf(&quot;%d GiB&quot;, bytes/1024/1024/1024)</span><br><span class="line">  &#125; else if (bytes &gt; 1024*1024) &#123;</span><br><span class="line">    return sprintf(&quot;%d MiB&quot;, bytes/1024/1024)</span><br><span class="line">  &#125; else if (bytes &gt; 1024) &#123;</span><br><span class="line">    return sprintf(&quot;%d KiB&quot;, bytes/1024)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return sprintf(&quot;%d   B&quot;, bytes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(1) &#123;</span><br><span class="line">  foreach([p,e] in total_io- limit 10)</span><br><span class="line">    printf(&quot;%8d %15s r: %12s w: %12s\n&quot;,</span><br><span class="line">           p, e, humanreadable(reads[p,e]),</span><br><span class="line">           humanreadable(writes[p,e]))</span><br><span class="line">  printf(&quot;\n&quot;)</span><br><span class="line">  # Note we don&#x27;t zero out reads, writes and total_io,</span><br><span class="line">  # so the values are cumulative since the script started.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>traceio.stp</code>逐秒输出累计I&#x2F;O最频繁的前十个进程。此外，它还会累计每个进程的I&#x2F;O情况。注意该脚本跟开头找出磁盘读写最频繁的进程的脚本一样，也通过本地变量<code>$return</code>获取实际的读写数据量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">           Xorg r:   583401 KiB w:        0 KiB</span><br><span class="line">       floaters r:       96 KiB w:     7130 KiB</span><br><span class="line">multiload-apple r:      538 KiB w:      537 KiB</span><br><span class="line">           sshd r:       71 KiB w:       72 KiB</span><br><span class="line">pam_timestamp_c r:      138 KiB w:        0 KiB</span><br><span class="line">        staprun r:       51 KiB w:       51 KiB</span><br><span class="line">          snmpd r:       46 KiB w:        0 KiB</span><br><span class="line">          pcscd r:       28 KiB w:        0 KiB</span><br><span class="line">     irqbalance r:       27 KiB w:        4 KiB</span><br><span class="line">          cupsd r:        4 KiB w:       18 KiB</span><br><span class="line"></span><br><span class="line">           Xorg r:   588140 KiB w:        0 KiB</span><br><span class="line">       floaters r:       97 KiB w:     7143 KiB</span><br><span class="line">multiload-apple r:      543 KiB w:      542 KiB</span><br><span class="line">           sshd r:       72 KiB w:       72 KiB</span><br><span class="line">pam_timestamp_c r:      138 KiB w:        0 KiB</span><br><span class="line">        staprun r:       51 KiB w:       51 KiB</span><br><span class="line">          snmpd r:       46 KiB w:        0 KiB</span><br><span class="line">          pcscd r:       28 KiB w:        0 KiB</span><br><span class="line">     irqbalance r:       27 KiB w:        4 KiB</span><br><span class="line">          cupsd r:        4 KiB w:       18 KiB</span><br></pre></td></tr></table></figure>

<h2 id="监控指定设备的I-x2F-O"><a href="#监控指定设备的I-x2F-O" class="headerlink" title="监控指定设备的I&#x2F;O"></a>监控指定设备的I&#x2F;O</h2><p>本节展示如何监控指定设备的I&#x2F;O活动。</p>
<p>traceio2.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">global device_of_interest</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">  /* The following is not the most efficient way to do this.</span><br><span class="line">      One could directly put the result of usrdev2kerndev()</span><br><span class="line">      into device_of_interest.  However, want to test out</span><br><span class="line">      the other device functions */</span><br><span class="line">  dev = usrdev2kerndev($1)</span><br><span class="line">  device_of_interest = MKDEV(MAJOR(dev), MINOR(dev))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe vfs.write, vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  if (dev == device_of_interest)</span><br><span class="line">    printf (&quot;%s(%d) %s 0x%x\n&quot;,</span><br><span class="line">            execname(), pid(), ppfunc(), dev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>traceio2.stp</code>接受一个参数：设备号，要想获取名为<code>directory</code>的文件夹所在设备的设备号，使用<code>stat -c &quot;0x%D&quot; directory</code>。<br><code>usrdev2kerndev()</code>把设备号转化成内核理解的格式。<code>usrdev2kerndev()</code>的输出经过<code>MAJOR()</code>和<code>MINOR()</code>处理，分别得到主设备号和次设备号，再经过<code>MKDEV()</code>处理，得到内核里对应的设备号。<br><code>traceio2.stp</code>的输出包括了读&#x2F;写进程的名字和PID，所调用的函数（<code>vfs_read</code>或<code>vfs_write</code>）和内核里对应的设备号。</p>
<p>下面是<code>stap traceio2.stp 0x805</code>的输出，其中<code>0x805</code>是<code>/home</code>的设备号。<code>/home</code>位于<code>/dev/sda5</code>，正是我们想要监控的设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">synergyc(3722) vfs_read 0x800005</span><br><span class="line">synergyc(3722) vfs_read 0x800005</span><br><span class="line">cupsd(2889) vfs_write 0x800005</span><br><span class="line">cupsd(2889) vfs_write 0x800005</span><br><span class="line">cupsd(2889) vfs_write 0x800005</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h2 id="监控对指定文件的读写"><a href="#监控对指定文件的读写" class="headerlink" title="监控对指定文件的读写"></a>监控对指定文件的读写</h2><p>本节展示如何实时监控对指定文件的读写。</p>
<p>inodewatch.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">probe vfs.write, vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  # dev and ino are defined by vfs.write and vfs.read</span><br><span class="line">  if (dev == MKDEV($1,$2) # major/minor device</span><br><span class="line">      &amp;&amp; ino == $3)</span><br><span class="line">    printf (&quot;%s(%d) %s 0x%x/%u\n&quot;,</span><br><span class="line">      execname(), pid(), ppfunc(), dev, ino)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inodewatch.stp</code>从命令行中依次获取如下参数：</p>
<ol>
<li>文件的主设备号</li>
<li>文件的次设备号</li>
<li>文件的inode号</li>
</ol>
<p>要获取上述信息，使用<code>stat -c &#39;%D %i&#39; filename</code>，注意<code>filename</code>取绝对路径。<br>比如：要监控<code>/etc/crontab</code>，先运行<code>stat -c &#39;%D %i&#39; /etc/crontab</code>。应该会有如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">805 1078319</span><br></pre></td></tr></table></figure>

<p>805是十六进制的设备号。最小的两位是次设备号，其余是主设备号。1078319是inode号。要监控<code>/etc/crontab</code>，运行<code>stap inodewatch.stp 0x8 0x05 1078319</code>.（加<code>0x</code>以表示这是十六进制的数）</p>
<p>该命令的输出包括进程名和进程PID，以及调用的函数（<code>vfs_read</code>或<code>vfs_write</code>），设备号（以十六进制的格式输出）和inode号。下面就是<code>stap inodewatch.stp 0x8 0x05 1078319</code>的输出（当脚本运行时，<code>/etc/crontab</code>也正在执行中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat(16437) vfs_read 0x800005/1078319</span><br><span class="line">cat(16437) vfs_read 0x800005/1078319</span><br></pre></td></tr></table></figure>

<h2 id="监控对指定文件的属性的修改"><a href="#监控对指定文件的属性的修改" class="headerlink" title="监控对指定文件的属性的修改"></a>监控对指定文件的属性的修改</h2><p>本节展示如何实时监控对指定文件的属性的修改。</p>
<p>inodewatch2.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">global ATTR_MODE = 1</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;setattr_copy&quot;)!,</span><br><span class="line">      kernel.function(&quot;generic_setattr&quot;)!,</span><br><span class="line">      kernel.function(&quot;inode_setattr&quot;) &#123;</span><br><span class="line">  dev_nr = $inode-&gt;i_sb-&gt;s_dev</span><br><span class="line">  inode_nr = $inode-&gt;i_ino</span><br><span class="line"></span><br><span class="line">  if (dev_nr == MKDEV($1,$2) # major/minor device</span><br><span class="line">      &amp;&amp; inode_nr == $3</span><br><span class="line">      &amp;&amp; $attr-&gt;ia_valid &amp; ATTR_MODE)</span><br><span class="line">    printf (&quot;%s(%d) %s 0x%x/%u %o %d\n&quot;,</span><br><span class="line">      execname(), pid(), ppfunc(), dev_nr, inode_nr, $attr-&gt;ia_mode, uid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟上一节的脚本类似，<code>inodewatch2.stp</code>也需要提供目标文件的设备号和inode号作为参数。用上一节的方法可以获取这些数据。<br><code>inodewatch.stp</code>的输出也类似于上一节的脚本，不过<code>inodewatch.stp</code>还包括文件属性的变化，和对应用户的UID。下面就是监控<code>/home/joe/bigfile</code>时，用户job执行<code>chmod 777 /home/joe/bigfile</code>和<code>chmod 666 /home/joe/bigfile</code>后的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod(17448) inode_setattr 0x800005/6011835 100777 500</span><br><span class="line">chmod(17449) inode_setattr 0x800005/6011835 100666 500</span><br></pre></td></tr></table></figure>

<h2 id="定期输出块I-x2F-O等待时间"><a href="#定期输出块I-x2F-O等待时间" class="headerlink" title="定期输出块I&#x2F;O等待时间"></a>定期输出块I&#x2F;O等待时间</h2><p>本节展示如何跟踪每个块I&#x2F;O的等待时间。这可以帮助你发现给定时间内块I&#x2F;O操作是否排起了长队。</p>
<p>ioblktime.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">global req_time%[25000], etimes</span><br><span class="line"></span><br><span class="line">probe ioblock.request</span><br><span class="line">&#123;</span><br><span class="line">  req_time[$bio] = gettimeofday_us()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe ioblock.end</span><br><span class="line">&#123;</span><br><span class="line">  t = gettimeofday_us()</span><br><span class="line">  s =  req_time[$bio]</span><br><span class="line">  delete req_time[$bio]</span><br><span class="line">  if (s) &#123;</span><br><span class="line">    etimes[devname, bio_rw_str(rw)] &lt;&lt;&lt; t - s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* for time being delete things that get merged with others */</span><br><span class="line">probe kernel.trace(&quot;block_bio_frontmerge&quot;),</span><br><span class="line">      kernel.trace(&quot;block_bio_backmerge&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  delete req_time[$bio]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(10), end &#123;</span><br><span class="line">  ansi_clear_screen()</span><br><span class="line">  printf(&quot;%10s %3s %10s %10s %10s\n&quot;,</span><br><span class="line">         &quot;device&quot;, &quot;rw&quot;, &quot;total (us)&quot;, &quot;count&quot;, &quot;avg (us)&quot;)</span><br><span class="line">  foreach ([dev,rw] in etimes - limit 20) &#123;</span><br><span class="line">    printf(&quot;%10s %3s %10d %10d %10d\n&quot;, dev, rw,</span><br><span class="line">           @sum(etimes[dev,rw]), @count(etimes[dev,rw]), @avg(etimes[dev,rw]))</span><br><span class="line">  &#125;</span><br><span class="line">  delete etimes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ioblktime.stp</code>计算每个设备上块I&#x2F;O平均等待时间，每10秒更新一次。你可以修改<code>probe timer.s(10), end &#123;</code>来更改刷新频率。<br>有时候，在设备上的块I&#x2F;O操作实在太多，以致于超过了默认的<code>MAXMAPENTRIES</code>值。如果你在定义数组时没有指定大小，SystemTap会以<code>MAXMAPENTRIES</code>作为数组的最大长度。它的默认值是2048,不过你可以使用stap命令的选项<code>-DMAXMAPENTRIES=10000</code>来指定该变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">device  rw total (us)      count   avg (us)</span><br><span class="line">   sda   W       9659          6       1609</span><br><span class="line">  dm-0   W      20278          6       3379</span><br><span class="line">  dm-0   R      20524          5       4104</span><br><span class="line">   sda   R      19277          5       3855</span><br></pre></td></tr></table></figure>

<p>上面的输出展示了设备名，操作类型（<code>rw</code>），总等待时间（<code>total(us)</code>），操作数（<code>count</code>），和平均等待时间（<code>avg(us)</code>）。这里面的时间都是以毫秒为单位。</p>
<h1 id="5-3-剖析"><a href="#5-3-剖析" class="headerlink" title="5.3. 剖析"></a>5.3. 剖析</h1><p>以下各节的脚本展示了如何通过监控函数调用来剖析（profile）内核活动。</p>
<h2 id="统计函数调用次数"><a href="#统计函数调用次数" class="headerlink" title="统计函数调用次数"></a>统计函数调用次数</h2><p>本节展示如何统计30秒内某个内核函数调用次数。通过使用通配符，你可以用这个脚本同时统计多个内核函数。</p>
<p>functioncallcount.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"># The following line command will probe all the functions</span><br><span class="line"># in kernel&#x27;s memory management code:</span><br><span class="line">#</span><br><span class="line"># stap  functioncallcount.stp &quot;*@mm/*.c&quot;</span><br><span class="line"></span><br><span class="line">probe kernel.function(@1).call &#123;  # probe functions listed on commandline</span><br><span class="line">  called[ppfunc()] &lt;&lt;&lt; 1  # add a count efficiently</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global called</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">  foreach (fn in called-)  # Sort by call count (in decreasing order)</span><br><span class="line">  #       (fn+ in called)  # Sort by function name</span><br><span class="line">    printf(&quot;%s %d\n&quot;, fn, @count(called[fn]))</span><br><span class="line">  exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>functioncallcount.stp</code>接受内核函数名作为参数。你可以使用通配符，这样就能同时监控多个内核函数。<br>它的输出包括调用者的名字和取样时间内调用次数。下面是<code>stap functioncallcount.stp &quot;*@mm/*.c&quot;</code>的输出片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">__vma_link 97</span><br><span class="line">__vma_link_file 66</span><br><span class="line">__vma_link_list 97</span><br><span class="line">__vma_link_rb 97</span><br><span class="line">__xchg 103</span><br><span class="line">add_page_to_active_list 102</span><br><span class="line">add_page_to_inactive_list 19</span><br><span class="line">add_to_page_cache 19</span><br><span class="line">add_to_page_cache_lru 7</span><br><span class="line">all_vm_events 6</span><br><span class="line">alloc_pages_node 4630</span><br><span class="line">alloc_slabmgmt 67</span><br><span class="line">anon_vma_alloc 62</span><br><span class="line">anon_vma_free 62</span><br><span class="line">anon_vma_lock 66</span><br><span class="line">anon_vma_prepare 98</span><br><span class="line">anon_vma_unlink 97</span><br><span class="line">anon_vma_unlock 66</span><br><span class="line">arch_get_unmapped_area_topdown 94</span><br><span class="line">arch_get_unmapped_exec_area 3</span><br><span class="line">arch_unmap_area_topdown 97</span><br><span class="line">atomic_add 2</span><br><span class="line">atomic_add_negative 97</span><br><span class="line">atomic_dec_and_test 5153</span><br><span class="line">atomic_inc 470</span><br><span class="line">atomic_inc_and_test 1</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h2 id="追踪函数调用链"><a href="#追踪函数调用链" class="headerlink" title="追踪函数调用链"></a>追踪函数调用链</h2><p>本节展示如何追踪函数调用链。</p>
<p>para-callgraph.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">function trace(entry_p, extra) &#123;</span><br><span class="line">  %( $# &gt; 1 %? if (tid() in trace) %)</span><br><span class="line">  printf(&quot;%s%s%s %s\n&quot;,</span><br><span class="line">         thread_indent (entry_p),</span><br><span class="line">         (entry_p&gt;0?&quot;-&gt;&quot;:&quot;&lt;-&quot;),</span><br><span class="line">         ppfunc (),</span><br><span class="line">         extra)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%( $# &gt; 1 %?</span><br><span class="line">global trace</span><br><span class="line">probe $2.call &#123;</span><br><span class="line">  trace[tid()] = 1</span><br><span class="line">&#125;</span><br><span class="line">probe $2.return &#123;</span><br><span class="line">  delete trace[tid()]</span><br><span class="line">&#125;</span><br><span class="line">%)</span><br><span class="line"></span><br><span class="line">probe $1.call   &#123; trace(1, $$parms) &#125;</span><br><span class="line">probe $1.return &#123; trace(-1, $$return) &#125;</span><br></pre></td></tr></table></figure>

<p><code>para-callgraph.stp</code>接受两个命令行参数：</p>
<ol>
<li>想要跟踪的函数（<code>$1</code>）</li>
<li>可选的触发函数。该函数可以在线程范围内启动&#x2F;停止追踪。只要触发函数不退出，追踪就不会结束。<br><code>para-callgraph.stp</code>使用了<code>thread_indent()</code>；此外它的输出包括了时间戳、进程名，和<code>$1</code>所在的线程ID。关于<code>thread_indent()</code>的更多信息，请参考<a href="3.2%E8%8A%82">。。。</a>。<br>（译注：这个脚本的编码风格小朋友们可不要学。前两个探针里的<code>trace</code>是数组，后两个探针里的<code>trace</code>是函数。另外<code>$#</code>表示参数的个数，写过shell的都明白。<code>%( $# &gt; 1 %? if (tid() in trace) %)</code>是一个预处理三元表达式，见<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/langref/Language_elements.html">langref</a>中的“5.8.1 Conditions”）</li>
</ol>
<p>下面是<code>stap para-callgraph.stp &#39;kernel.function(&quot;*@fs/*.c&quot;)&#39; &#39;kernel.function(&quot;sys_read&quot;)&#39;</code>的输出片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">   267 gnome-terminal(2921): &lt;-do_sync_read return=0xfffffffffffffff5</span><br><span class="line">   269 gnome-terminal(2921):&lt;-vfs_read return=0xfffffffffffffff5</span><br><span class="line">     0 gnome-terminal(2921):-&gt;fput file=0xffff880111eebbc0</span><br><span class="line">     2 gnome-terminal(2921):&lt;-fput</span><br><span class="line">     0 gnome-terminal(2921):-&gt;fget_light fd=0x3 fput_needed=0xffff88010544df54</span><br><span class="line">     3 gnome-terminal(2921):&lt;-fget_light return=0xffff8801116ce980</span><br><span class="line">     0 gnome-terminal(2921):-&gt;vfs_read file=0xffff8801116ce980 buf=0xc86504 count=0x1000 pos=0xffff88010544df48</span><br><span class="line">     4 gnome-terminal(2921): -&gt;rw_verify_area read_write=0x0 file=0xffff8801116ce980 ppos=0xffff88010544df48 count=0x1000</span><br><span class="line">     7 gnome-terminal(2921): &lt;-rw_verify_area return=0x1000</span><br><span class="line">    12 gnome-terminal(2921): -&gt;do_sync_read filp=0xffff8801116ce980 buf=0xc86504 len=0x1000 ppos=0xffff88010544df48</span><br><span class="line">    15 gnome-terminal(2921): &lt;-do_sync_read return=0xfffffffffffffff5</span><br><span class="line">    18 gnome-terminal(2921):&lt;-vfs_read return=0xfffffffffffffff5</span><br><span class="line">     0 gnome-terminal(2921):-&gt;fput file=0xffff8801116ce980</span><br></pre></td></tr></table></figure>

<h2 id="统计给定线程在内核空间和用户空间上的耗时"><a href="#统计给定线程在内核空间和用户空间上的耗时" class="headerlink" title="统计给定线程在内核空间和用户空间上的耗时"></a>统计给定线程在内核空间和用户空间上的耗时</h2><p>本节展示如何统计给定线程花费在内核空间或用户空间上的运行时间。</p>
<p>thread-times.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line">probe perf.sw.cpu_clock!, timer.profile &#123;</span><br><span class="line">  // NB: To avoid contention on SMP machines, no global scalars/arrays used,</span><br><span class="line">  // only contention-free statistics aggregates.</span><br><span class="line">  tid=tid(); e=execname()</span><br><span class="line">  if (!user_mode())</span><br><span class="line">    kticks[e,tid] &lt;&lt;&lt; 1</span><br><span class="line">  else</span><br><span class="line">    uticks[e,tid] &lt;&lt;&lt; 1</span><br><span class="line">  ticks &lt;&lt;&lt; 1</span><br><span class="line">  tids[e,tid] &lt;&lt;&lt; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global uticks%, kticks%, ticks</span><br><span class="line"></span><br><span class="line">global tids%</span><br><span class="line"></span><br><span class="line">probe timer.s(5), end &#123;</span><br><span class="line">  allticks = @count(ticks)</span><br><span class="line">  printf (&quot;%16s %5s %7s %7s (of %d ticks)\n&quot;,</span><br><span class="line">          &quot;comm&quot;, &quot;tid&quot;, &quot;%user&quot;, &quot;%kernel&quot;, allticks)</span><br><span class="line">  foreach ([e,tid] in tids- limit 20) &#123;</span><br><span class="line">    uscaled = @count(uticks[e,tid])*10000/allticks</span><br><span class="line">    kscaled = @count(kticks[e,tid])*10000/allticks</span><br><span class="line">    printf (&quot;%16s %5d %3d.%02d%% %3d.%02d%%\n&quot;,</span><br><span class="line">      e, tid, uscaled/100, uscaled%100, kscaled/100, kscaled%100)</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">  delete uticks</span><br><span class="line">  delete kticks</span><br><span class="line">  delete ticks</span><br><span class="line">  delete tids</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thread-time.stp</code>列出5秒内花费CPU时间最多的20个进程，和这段时间CPU滴答（ticks）的总数。脚本的输出还包括每个进程CPU占用百分比，分别按内核空间和用户空间列出。<br>下面就是它的输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  tid   %user %kernel (of 20002 ticks)</span><br><span class="line">    0   0.00%  87.88%</span><br><span class="line">32169   5.24%   0.03%</span><br><span class="line"> 9815   3.33%   0.36%</span><br><span class="line"> 9859   0.95%   0.00%</span><br><span class="line"> 3611   0.56%   0.12%</span><br><span class="line"> 9861   0.62%   0.01%</span><br><span class="line">11106   0.37%   0.02%</span><br><span class="line">32167   0.08%   0.08%</span><br><span class="line"> 3897   0.01%   0.08%</span><br><span class="line"> 3800   0.03%   0.00%</span><br><span class="line"> 2886   0.02%   0.00%</span><br><span class="line"> 3243   0.00%   0.01%</span><br><span class="line"> 3862   0.01%   0.00%</span><br><span class="line"> 3782   0.00%   0.00%</span><br><span class="line">21767   0.00%   0.00%</span><br><span class="line"> 2522   0.00%   0.00%</span><br><span class="line"> 3883   0.00%   0.00%</span><br><span class="line"> 3775   0.00%   0.00%</span><br><span class="line"> 3943   0.00%   0.00%</span><br><span class="line"> 3873   0.00%   0.00%</span><br></pre></td></tr></table></figure>

<h2 id="监控应用轮询情况"><a href="#监控应用轮询情况" class="headerlink" title="监控应用轮询情况"></a>监控应用轮询情况</h2><p>本节展示如何监控应用的轮询（polling）情况。这将允许你跟踪多余的或过度的轮询，帮助锁定CPU使用或能源消耗需要改善的地方。</p>
<p>timeout.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"># Copyright (C) 2009 Red Hat, Inc.</span><br><span class="line"># Written by Ulrich Drepper &lt;drepper@redhat.com&gt;</span><br><span class="line"># Modified by William Cohen &lt;wcohen@redhat.com&gt;</span><br><span class="line"></span><br><span class="line">global process, timeout_count, to</span><br><span class="line">global poll_timeout, epoll_timeout, select_timeout, itimer_timeout</span><br><span class="line">global nanosleep_timeout, futex_timeout, signal_timeout</span><br><span class="line"></span><br><span class="line">probe syscall.poll, syscall.epoll_wait &#123;</span><br><span class="line">  if (timeout) to[pid()]=timeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.poll.return &#123;</span><br><span class="line">  if ($return == 0 &amp;&amp; to[pid()] &gt; 0 ) &#123;</span><br><span class="line">    poll_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[pid()] = execname()</span><br><span class="line">    delete to[pid()]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.epoll_wait.return &#123;</span><br><span class="line">  if ($return == 0 &amp;&amp; to[pid()] &gt; 0 ) &#123;</span><br><span class="line">    epoll_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[p] = execname()</span><br><span class="line">    delete to[pid()]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.select.return &#123;</span><br><span class="line">  if ($return == 0) &#123;</span><br><span class="line">    select_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[pid()] = execname()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.futex.return &#123;</span><br><span class="line">  if (errno_str($return) == &quot;ETIMEDOUT&quot;) &#123;</span><br><span class="line">    futex_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[pid()] = execname()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.nanosleep.return &#123;</span><br><span class="line">  if ($return == 0) &#123;</span><br><span class="line">    nanosleep_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[pid()] = execname()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;it_real_fn&quot;) &#123;</span><br><span class="line">  itimer_timeout[pid()]++</span><br><span class="line">  timeout_count[pid()]++</span><br><span class="line">  process[pid()] = execname()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.rt_sigtimedwait.return &#123;</span><br><span class="line">  if (errno_str($return) == &quot;EAGAIN&quot;) &#123;</span><br><span class="line">    signal_timeout[pid()]++</span><br><span class="line">    timeout_count[pid()]++</span><br><span class="line">    process[pid()] = execname()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.exit &#123;</span><br><span class="line">  if (pid() in process) &#123;</span><br><span class="line">    delete process[pid()]</span><br><span class="line">    delete timeout_count[pid()]</span><br><span class="line">    delete poll_timeout[pid()]</span><br><span class="line">    delete epoll_timeout[pid()]</span><br><span class="line">    delete select_timeout[pid()]</span><br><span class="line">    delete itimer_timeout[pid()]</span><br><span class="line">    delete futex_timeout[pid()]</span><br><span class="line">    delete nanosleep_timeout[pid()]</span><br><span class="line">    delete signal_timeout[pid()]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(1) &#123;</span><br><span class="line">  ansi_clear_screen()</span><br><span class="line">  printf (&quot;  pid |   poll  select   epoll  itimer   futex nanosle  signal| process\n&quot;)</span><br><span class="line">  foreach (p in timeout_count- limit 20) &#123;</span><br><span class="line">     printf (&quot;%5d |%7d %7d %7d %7d %7d %7d %7d| %-.38s\n&quot;, p,</span><br><span class="line">              poll_timeout[p], select_timeout[p],</span><br><span class="line">              epoll_timeout[p], itimer_timeout[p],</span><br><span class="line">              futex_timeout[p], nanosleep_timeout[p],</span><br><span class="line">              signal_timeout[p], process[p])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timeout.stp</code>跟踪下列系统调用，并仅当因为超时而退出该调用时记录次数：</p>
<ul>
<li>poll</li>
<li>select</li>
<li>epoll</li>
<li>itimer</li>
<li>futex</li>
<li>nanosleep</li>
<li>signal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  uid |   poll  select   epoll  itimer   futex nanosle  signal| process</span><br><span class="line">28937 | 148793       0       0    4727   37288       0       0| firefox</span><br><span class="line">22945 |      0   56949       0       1       0       0       0| scim-bridge</span><br><span class="line">    0 |      0       0       0   36414       0       0       0| swapper</span><br><span class="line"> 4275 |  23140       0       0       1       0       0       0| mixer_applet2</span><br><span class="line"> 4191 |      0   14405       0       0       0       0       0| scim-launcher</span><br><span class="line">22941 |   7908       1       0      62       0       0       0| gnome-terminal</span><br><span class="line"> 4261 |      0       0       0       2       0    7622       0| escd</span><br><span class="line"> 3695 |      0       0       0       0       0    7622       0| gdm-binary</span><br><span class="line"> 3483 |      0    7206       0       0       0       0       0| dhcdbd</span><br><span class="line"> 4189 |   6916       0       0       2       0       0       0| scim-panel-gtk</span><br><span class="line"> 1863 |   5767       0       0       0       0       0       0| iscsid</span><br><span class="line"> 2562 |      0    2881       0       1       0    1438       0| pcscd</span><br><span class="line"> 4257 |   4255       0       0       1       0       0       0| gnome-power-man</span><br><span class="line"> 4278 |   3876       0       0      60       0       0       0| multiload-apple</span><br><span class="line"> 4083 |      0    1331       0    1728       0       0       0| Xorg</span><br><span class="line"> 3921 |   1603       0       0       0       0       0       0| gam_server</span><br><span class="line"> 4248 |   1591       0       0       0       0       0       0| nm-applet</span><br><span class="line"> 3165 |      0    1441       0       0       0       0       0| xterm</span><br><span class="line">29548 |      0    1440       0       0       0       0       0| httpd</span><br><span class="line"> 1862 |      0       0       0       0       0    1438       0| iscsid</span><br></pre></td></tr></table></figure>

<p>你可以通过修改最后一个探针（<code>timer.s(1)</code>）来增大取样时间。<code>timeout.stp</code>的输出包括前20个轮询应用的名字和UID，连带每个应用调用每种轮询系统调用的累计次数。在上面的输出片段中，由于某个插件模块，firefox进行了过度的轮询。</p>
<h2 id="监控最常调用的系统调用"><a href="#监控最常调用的系统调用" class="headerlink" title="监控最常调用的系统调用"></a>监控最常调用的系统调用</h2><p>上一节的<code>timeout.stp</code>通过监控系统调用的某个子集，帮助你找到过度轮询的应用。同样，如果你怀疑某些系统调用被过度地调用了，通过类似的监控，你也能把它们找出来。下面就通过<code>topsys.stp</code>实现这一点：</p>
<p>topsys.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line">#</span><br><span class="line"># This script continuously lists the top 20 systemcalls in the interval </span><br><span class="line"># 5 seconds</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">global syscalls_count</span><br><span class="line"></span><br><span class="line">probe syscall.* &#123;</span><br><span class="line">  syscalls_count[name] &lt;&lt;&lt; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function print_systop () &#123;</span><br><span class="line">  printf (&quot;%25s %10s\n&quot;, &quot;SYSCALL&quot;, &quot;COUNT&quot;)</span><br><span class="line">  foreach (syscall in syscalls_count- limit 20) &#123;</span><br><span class="line">    printf(&quot;%25s %10d\n&quot;, syscall, @count(syscalls_count[syscall]))</span><br><span class="line">  &#125;</span><br><span class="line">  delete syscalls_count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s(5) &#123;</span><br><span class="line">  print_systop ()</span><br><span class="line">  printf(&quot;--------------------------------------------------------------\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>topsys.stp</code>每5秒列出调用最多的20个系统调用。它也列出了这段时间内每个系统调用被调用的次数。下面是它的一个输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------</span><br><span class="line">                  SYSCALL      COUNT</span><br><span class="line">             gettimeofday       1857</span><br><span class="line">                     read       1821</span><br><span class="line">                    ioctl       1568</span><br><span class="line">                     poll       1033</span><br><span class="line">                    close        638</span><br><span class="line">                     open        503</span><br><span class="line">                   select        455</span><br><span class="line">                    write        391</span><br><span class="line">                   writev        335</span><br><span class="line">                    futex        303</span><br><span class="line">                  recvmsg        251</span><br><span class="line">                   socket        137</span><br><span class="line">            clock_gettime        124</span><br><span class="line">           rt_sigprocmask        121</span><br><span class="line">                   sendto        120</span><br><span class="line">                setitimer        106</span><br><span class="line">                     stat         90</span><br><span class="line">                     time         81</span><br><span class="line">                sigreturn         72</span><br><span class="line">                    fstat         66</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="找出每个进程的系统调用量"><a href="#找出每个进程的系统调用量" class="headerlink" title="找出每个进程的系统调用量"></a>找出每个进程的系统调用量</h2><p>本节展示如何找出调用系统调用最多的进程。在上一节，我们谈到了如何找出调用最多的系统调用。而在上上节，我们也谈到了如何找出轮询最多的进程。通过监控每个进程的调用系统调用的次数，可以在调查轮询进程和其他滥用资源者时提供更多的数据。</p>
<p><code>syscalls_by_proc.stp</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line"># Copyright (C) 2006 IBM Corp.</span><br><span class="line">#</span><br><span class="line"># This file is part of systemtap, and is free software.  You can</span><br><span class="line"># redistribute it and/or modify it under the terms of the GNU General</span><br><span class="line"># Public License (GPL); either version 2, or (at your option) any</span><br><span class="line"># later version.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Print the system call count by process name in descending order.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">global syscalls</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">  print (&quot;Collecting data... Type Ctrl-C to exit and display results\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe nd_syscall.* &#123;</span><br><span class="line">  syscalls[execname()]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">  printf (&quot;%-10s %-s\n&quot;, &quot;#SysCalls&quot;, &quot;Process Name&quot;)</span><br><span class="line">  foreach (proc in syscalls-)</span><br><span class="line">    printf(&quot;%-10d %-s\n&quot;, syscalls[proc], proc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>syscalls_by_proc.stp</code>列出调用系统调用最多的20个进程。它也列出了这段时间内每个进程调用系统调用的数量。下面是它的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collecting data... Type Ctrl-C to exit and display results</span><br><span class="line">#SysCalls  Process Name</span><br><span class="line">1577       multiload-apple</span><br><span class="line">692        synergyc</span><br><span class="line">408        pcscd</span><br><span class="line">376        mixer_applet2</span><br><span class="line">299        gnome-terminal</span><br><span class="line">293        Xorg</span><br><span class="line">206        scim-panel-gtk</span><br><span class="line">95         gnome-power-man</span><br><span class="line">90         artsd</span><br><span class="line">85         dhcdbd</span><br><span class="line">84         scim-bridge</span><br><span class="line">78         gnome-screensav</span><br><span class="line">66         scim-launcher</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>要想输出进程PID而非进程名，改用下面的脚本：</p>
<p>syscalls_by_pid.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line"># Copyright (C) 2006 IBM Corp.</span><br><span class="line">#</span><br><span class="line"># This file is part of systemtap, and is free software.  You can</span><br><span class="line"># redistribute it and/or modify it under the terms of the GNU General</span><br><span class="line"># Public License (GPL); either version 2, or (at your option) any</span><br><span class="line"># later version.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Print the system call count by process ID in descending order.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">global syscalls</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">  print (&quot;Collecting data... Type Ctrl-C to exit and display results\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe nd_syscall.* &#123;</span><br><span class="line">  syscalls[pid()]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">  printf (&quot;%-10s %-s\n&quot;, &quot;#SysCalls&quot;, &quot;PID&quot;)</span><br><span class="line">  foreach (pid in syscalls-)</span><br><span class="line">    printf(&quot;%-10d %-d\n&quot;, syscalls[pid], pid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如在输出中提到的，你需要手动Ctrl-C退出程序来显示结果。你可以简单地添加一个<code>timer.s()</code>探针，让脚本在给定时间后自动退出。举个例子，要想让脚本5秒后退出，往里面添加下面的探针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">probe timer.s(5)</span><br><span class="line">&#123;</span><br><span class="line">    exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-4-标识用户空间锁竞争"><a href="#5-4-标识用户空间锁竞争" class="headerlink" title="5.4. 标识用户空间锁竞争"></a>5.4. 标识用户空间锁竞争</h1><p>本节展示如何显示特定时间内用户空间锁竞争的情况。通过展示锁竞争的图景，你可以判断当前的性能问题是否由对<code>futex</code>的竞争所造成的。<br>简单地说，如果在同一时间内多个进程试图获取同一把锁，就会产生对<code>futex</code>的竞争。由于仅有一个进程可以持有锁，其他的进程都只能等待锁重新可用，锁竞争会导致性能的下降。<br>下面的<code>futexes.stp</code>脚本通过探测<code>futex</code>系统调用来显示锁竞争的情况：</p>
<p>futexes.stp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env stap</span><br><span class="line"></span><br><span class="line"># This script tries to identify contended user-space locks by hooking</span><br><span class="line"># into the futex system call.</span><br><span class="line"></span><br><span class="line">global FUTEX_WAIT = 0 /*, FUTEX_WAKE = 1 */</span><br><span class="line">global FUTEX_PRIVATE_FLAG = 128 /* linux 2.6.22+ */</span><br><span class="line">global FUTEX_CLOCK_REALTIME = 256 /* linux 2.6.29+ */</span><br><span class="line"></span><br><span class="line">global lock_waits # long-lived stats on (tid,lock) blockage elapsed time</span><br><span class="line">global process_names # long-lived pid-to-execname mapping</span><br><span class="line"></span><br><span class="line">probe syscall.futex.return &#123;  </span><br><span class="line">  if (($op &amp; ~(FUTEX_PRIVATE_FLAG|FUTEX_CLOCK_REALTIME)) != FUTEX_WAIT) next</span><br><span class="line">  process_names[pid()] = execname()</span><br><span class="line">  elapsed = gettimeofday_us() - @entry(gettimeofday_us())</span><br><span class="line">  lock_waits[pid(), $uaddr] &lt;&lt;&lt; elapsed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">  foreach ([pid+, lock] in lock_waits) </span><br><span class="line">    printf (&quot;%s[%d] lock %p contended %d times, %d avg us\n&quot;,</span><br><span class="line">            process_names[pid], pid, lock, @count(lock_waits[pid,lock]),</span><br><span class="line">            @avg(lock_waits[pid,lock]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>futexes.stp</code>需要手动Ctrl+C退出。一旦退出后，它会输出下面信息：</p>
<ul>
<li>参与锁竞争的进程的名字和ID</li>
<li>被竞争的锁变量的地址</li>
<li>锁被竞争的次数</li>
<li>竞争锁的平均耗时</li>
</ul>
<p>⁠下面是<code>futexes.stp</code>在运行约20秒 退出时，大致的输出情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">automount[2825] lock 0x00bc7784 contended 18 times, 999931 avg us</span><br><span class="line">synergyc[3686] lock 0x0861e96c contended 192 times, 101991 avg us</span><br><span class="line">synergyc[3758] lock 0x08d98744 contended 192 times, 101990 avg us</span><br><span class="line">synergyc[3938] lock 0x0982a8b4 contended 192 times, 101997 avg us</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h1 id="6-解读错误信息"><a href="#6-解读错误信息" class="headerlink" title="6. 解读错误信息"></a>6. 解读错误信息</h1><p>本章解释使用SystemTap过程中常见的错误信息。</p>
<h1 id="6-1-解析和文法错误"><a href="#6-1-解析和文法错误" class="headerlink" title="6.1. 解析和文法错误"></a>6.1. 解析和文法错误</h1><p>解析和文法错误发生在SystemTap解析脚本和编译成C代码时。举个例子，把无效的值赋给变量或数组时，会报类型错误。</p>
<p><strong>parse error: expected foo, saw bar</strong></p>
<p>脚本存在语法或排版错误。SystemTap会探测到脚本中存在的不正确结构，并指出有问题的探针。<br>举个例子，下面的SystemTap脚本是有问题的，里面的探针缺了处理程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe vfs.read</span><br><span class="line">probe vfs.write</span><br></pre></td></tr></table></figure>

<p>尝试运行这个脚本，它会报告以下的错误信息，声称第2行第1列不应该是<code>probe</code>关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parse error: expected one of &#x27;. , ( ? ! &#123; = +=&#x27;</span><br><span class="line">    saw: keyword at perror.stp:2:1</span><br><span class="line">1 parse error(s).</span><br></pre></td></tr></table></figure>

<p><strong>parse error: embedded code in unprivileged script</strong></p>
<p>脚本中嵌入了不安全的C代码。SystemTap允许你通过<code>%&#123;...%&#125;</code>代码块嵌入C代码，以便于定义适合的tapset。然而，这样做是不安全的，一旦你真的在脚本里这么做了，SystemTap用这个错误来警告你。</p>
<p>如果你确信你的做法是安全的，并且拥有<code>stapdev</code>权限（或root权限），可以带上<code>-g</code>选项，以“guru”模式运行脚本来消除这个报错。（<code>stap -g script</code>）</p>
<p><strong>semantic error: type mismatch for identifier ‘foo’ … string vs. long</strong></p>
<p>脚本中的函数<code>foo</code>使用了错误的类型（比如<code>%s</code>或<code>%d</code>）。在下面的例子中，格式标志符应该是<code>%s</code>而不是<code>%d</code>，因为<code>execname()</code>函数返回一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%d(%d) open\n&quot;, execname(), pid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>semantic error: unresolved type for identifier ‘foo’</strong></p>
<p>你使用了一个变量（identifier），但是没办法推导出它的类型（数值或字符串）。举个例子，如果你在一个<code>printf</code>语句中使用了从未赋过值的变量，就会遇到这样的错误。</p>
<p><strong>semantic error: Expecting symbol or array index expression</strong></p>
<p>SystemTap不能完成某个赋值操作，因为这个操作的接收者不合理。下面的示例代码就会发生这个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe begin &#123; printf(&quot;x&quot;) = 1 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>while searching for arity N function, semantic error: unresolved function call</strong></p>
<p>脚本中的函数调用或数组索引表达式使用了不合理的参数个数。在SystemTap，<em>arity</em>可以指数组的索引个数，也可以指函数的参数个数。</p>
<p><strong>semantic error: array locals not supported, missing global declaration?</strong></p>
<p>在脚本中使用了一个数组，却没有把它定义成全局变量（SystemTap脚本中，全局变量可以定义在使用的位置之后）。如果一个数组使用的索引个数不一致，也会报告相似的错误。（SystemTap中数组可以使用一组值作为索引，而不仅仅是一个下标）</p>
<p><strong>semantic error: variable ‘foo’ modified during ‘foreach’ iteration</strong></p>
<p>用<code>foreach</code>迭代数组<code>foo</code>的同时修改了该数组（赋新的值或使用了delete）。如果在<code>foreach</code>迭代的过程中对数组<code>foo</code>调用了函数，也会显示这个错误。</p>
<p><strong>semantic error: probe point mismatch at position N, while resolving probe point foo</strong></p>
<p>SystemTap无法找到事件或SystemTap函数<code>foo</code>的定义。通常意味着SystemTap在tapset库中找不到匹配foo的项。<code>N</code>表示错误的行号和列号。</p>
<p><strong>semantic error: no match for probe point, while resolving probe point foo</strong></p>
<p>SystemTap因为一些原因不能解析事件或处理函数<code>foo</code>。比如说脚本包含事件<code>kernel.function(&quot;something&quot;)</code>，而<code>something</code>并不存在。在某些时候，这个错误也意味着脚本中包含不存在的内核文件名或源代码行号。</p>
<p><strong>semantic error: unresolved target-symbol expression</strong></p>
<p>脚本中的一个处理程序用到了某个目标变量（target variable)，但这个目标变量无法解析。这个错误意味着该目标变量在处理程序的上下文里不存在。也许是编译器把代码优化掉了。</p>
<p><strong>semantic error: libdwfl failure</strong></p>
<p>在处理调试信息的时候遇到一个问题。在大多数情况下，这个错误的产生源于安装的<code>kernel-debuginfo</code>包没有完全匹配要探测的内核。也许是安装的<code>kernel-debuginfo</code>包中存在某些完整性或正确性问题。</p>
<p><strong>semantic error: cannot find foo debuginfo</strong></p>
<p>SystemTap找不到适合的<code>kernel-debuginfo</code>包。</p>
<h1 id="6-2-运行时错误和警告"><a href="#6-2-运行时错误和警告" class="headerlink" title="6.2. 运行时错误和警告"></a>6.2. 运行时错误和警告</h1><p>运行时错误和警告发生在SystemTap安装了检测代码并开始收集数据的时候。</p>
<p><strong>⁠WARNING: Number of errors: N, skipped probes: M</strong></p>
<p>在运行时出错并&#x2F;或跳过某些探针。由于诸如给定时间不足以执行完处理程序的原因，某些探针没有得到执行，<code>N</code>和<code>M</code>就是这些探针的数目。</p>
<p><strong>⁠division by 0</strong></p>
<p>代码里出现了除零错误。</p>
<p><strong>⁠aggregate element not found</strong></p>
<p>在一个空的聚集变量上调用除<code>@count</code>以外的提取函数。这就跟除零差不多。关于聚集变量的更多信息，参见<a href="3_5_ArrayOperationsInSystemTap.md">3.5 数组操作</a>中的“使用聚集变量”部分。</p>
<p><strong>⁠aggregation overflow</strong></p>
<p>聚集变量数组中包含太多的键。（译注：前文有提及，数组的索引中最多只能使用九个键）</p>
<p><strong>⁠MAXNESTING exceeded</strong></p>
<p>过多的嵌套函数调用。默认函数调用层级是10。可以使用<code>-DMAXNESTING=NN</code>重编译脚本来修改这个限制。</p>
<p><strong>⁠MAXACTION exceeded</strong></p>
<p>处理程序太长了。默认一个探针的处理程序里面最多只能执行1000个语句。可以使用<code>--DMAXACTION=NN</code>或<code>-DMAXACTION_INTERRUPTIBLE=NN</code>重编译脚本来修改这个限制。</p>
<p><strong>⁠kernel&#x2F;user string copy fault at ADDR</strong></p>
<p>处理程序试图把一个来自内核或用户空间的字符串拷贝到无效地址<code>ADDR</code>。</p>
<p><strong>pointer dereference fault</strong></p>
<p>指针解引用时发生了一个错误，可能发生在诸如计算目标变量的时候。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li><a href="1_Introduction.md">介绍</a><ul>
<li><a href="1_1_DocumentationGuide.md">编写本文档的目标</a></li>
<li><a href="1_2_SystemTapCapabilities.md">SystemTap的能力</a></li>
<li><a href="1_3_LimitationsOfSystemTap.md">SystemTap的局限</a></li>
</ul>
</li>
<li><a href="2_UsingSystemTap.md">使用</a><ul>
<li><a href="2_1_InstallationAndSetup.md">安装和配置</a></li>
<li><a href="2_2_GeneratingInstrumentationForOtherComputers.md">为其它计算机生成检测模块</a></li>
<li><a href="2_3_RunningSystemTapScripts.md">运行SystemTap脚本</a></li>
</ul>
</li>
<li><a href="3_UnderstandingHowSystemTapWorks.md">工作细节</a><ul>
<li><a href="3_1_Architecture.md">结构</a></li>
<li><a href="3_2_SystemTapScripts.md">脚本</a></li>
<li><a href="3_3_BasicSystemTapHandlerConstructs.md">处理程序的基本结构</a></li>
<li><a href="3_4_AssociativeArrays.md">关联数组</a></li>
<li><a href="3_5_ArrayOperationsInSystemTap.md">数组操作</a></li>
<li><a href="3_6_Tapsets.md">Tapsets</a></li>
</ul>
</li>
<li><a href="4_UserSpaceProbing.md">用户空间探测</a><ul>
<li><a href="4_1_UserSpaceEvents.md">用户空间事件</a></li>
<li><a href="4_2_AccessingUserSpaceTargetVariables.md">访问用户空间目标变量</a></li>
<li><a href="4_3_UserSpaceStackBacktraces.md">用户空间栈回溯</a></li>
</ul>
</li>
<li><a href="5_UsefulSystemTapScripts.md">SystemTap脚本集锦</a><ul>
<li><a href="5_1_Network.md">网络</a></li>
<li><a href="5_2_Disk.md">磁盘</a></li>
<li><a href="5_3_Profiling.md">剖析</a></li>
<li><a href="5_4_IdentifyingContendedUserSpaceLocks.md">标识用户空间锁竞争</a></li>
</ul>
</li>
<li><a href="6_UnderstandingSystemTapErrors.md">解读错误信息</a><ul>
<li><a href="6_1_ParseAndSemanticErrors.md">解析和文法错误</a></li>
<li><a href="6_2_RuntimeErrorsAndWarnings.md">运行时错误和警告</a></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">哪吒藕霸</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/')">systemtap starter</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=systemtap starter&amp;url=https://shippomx.github.io/2022/12/23/linux/systemtap/systemtap%20starter/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shippomx.github.io" target="_blank">远辰</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/linux/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>linux<span class="tagsPageCount">22</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/13/linux/systemtap/systemtap_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">systemtap使用技巧</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/14/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">简易环境配置</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2017/06/08/Nginx%20%E9%85%8D%E7%BD%AE%20HTTPS%20%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Nginx 配置 HTTPS 服务器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2017-06-08</div><div class="title">Nginx 配置 HTTPS 服务器</div></div></a></div><div><a href="/2023/02/14/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="简易环境配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-02-14</div><div class="title">简易环境配置</div></div></a></div><div><a href="/2023/06/21/pty-studio/" title="使用c代码实现伪终端"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-21</div><div class="title">使用c代码实现伪终端</div></div></a></div><div><a href="/2023/06/21/vscode%20cmake/" title="使用vscode调试c代码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-21</div><div class="title">使用vscode调试c代码</div></div></a></div><div><a href="/2023/06/21/containers/What%20happens%20behind%20the%20scenes%20of%20a%20rootless%20Podman%20container/" title="podman创建rootless容器发生了什么"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-21</div><div class="title">podman创建rootless容器发生了什么</div></div></a></div><div><a href="/2023/06/21/containers/gvisor/" title="gVisor容器引擎"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-21</div><div class="title">gVisor容器引擎</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1. 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-1-%E7%BC%96%E5%86%99%E6%9C%AC%E6%96%87%E6%A1%A3%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">1.1. 编写本文档的目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-SystemTap%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">3.</span> <span class="toc-text">1.2. SystemTap的能力</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-3-SystemTap%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">4.</span> <span class="toc-text">1.3. SystemTap的局限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">2. 安装和配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">6.</span> <span class="toc-text">2.1. 安装和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85SystemTap"><span class="toc-number">6.1.</span> <span class="toc-text">安装SystemTap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%9A%84%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%8C%85"><span class="toc-number">6.2.</span> <span class="toc-text">手动安装依赖的内核调试信息包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="toc-number">6.3.</span> <span class="toc-text">检查安装是否成功</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-2-%E4%B8%BA%E5%85%B6%E5%AE%83%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%88%90%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">7.</span> <span class="toc-text">2.2. 为其它计算机生成检测模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3-%E8%BF%90%E8%A1%8CSystemTap%E8%84%9A%E6%9C%AC"><span class="toc-number">8.</span> <span class="toc-text">2.3. 运行SystemTap脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%9E%E8%A1%8C%E8%AE%B0%E5%BD%95%E4%BB%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">飞行记录仪模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9E%8B%E9%A3%9E%E8%A1%8C%E8%AE%B0%E5%BD%95%E4%BB%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">内存型飞行记录仪模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9E%8B%E9%A3%9E%E8%A1%8C%E8%AE%B0%E5%BD%95%E4%BB%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">文件型飞行记录仪模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B7%A5%E4%BD%9C%E7%BB%86%E8%8A%82"><span class="toc-number">9.</span> <span class="toc-text">3. 工作细节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1-%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">3.1. 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-2-%E8%84%9A%E6%9C%AC"><span class="toc-number">11.</span> <span class="toc-text">3.2. 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.1.</span> <span class="toc-text">同步事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.2.</span> <span class="toc-text">异步事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.2.</span> <span class="toc-text">处理程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-3-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">3.3. 处理程序的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">12.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F%EF%BC%88Target-Variables%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">目标变量（Target Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E9%BD%90%E6%89%93%E5%8D%B0%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F%EF%BC%88Pretty-Printing-Target-Variables%EF%BC%89"><span class="toc-number">12.2.1.</span> <span class="toc-text">整齐打印目标变量（Pretty Printing Target Variables）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.3.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">命令行参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-4-%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84"><span class="toc-number">13.</span> <span class="toc-text">3.4. 关联数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-5-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">14.</span> <span class="toc-text">3.5. 数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BB%99%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC"><span class="toc-number">14.1.</span> <span class="toc-text">设置给定键的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%99%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC"><span class="toc-number">14.2.</span> <span class="toc-text">获取给定键的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E7%BB%99%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC"><span class="toc-number">14.3.</span> <span class="toc-text">自增给定键的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">14.4.</span> <span class="toc-text">遍历数组中的多个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%95%B0%E7%BB%84%E6%88%96%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">14.5.</span> <span class="toc-text">清除数组或数组中某个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%9A%E9%9B%86%E5%8F%98%E9%87%8F%EF%BC%88use-aggregates%EF%BC%89"><span class="toc-number">14.6.</span> <span class="toc-text">使用聚集变量（use aggregates）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Tapsets"><span class="toc-number">14.7.</span> <span class="toc-text">3.6. Tapsets</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B7%A5%E4%BD%9C%E7%BB%86%E8%8A%82-1"><span class="toc-number">15.</span> <span class="toc-text">3. 工作细节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8E%A2%E6%B5%8B"><span class="toc-number">16.</span> <span class="toc-text">4. 用户空间探测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-1-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">17.</span> <span class="toc-text">4.1. 用户空间事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-2-%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F"><span class="toc-number">18.</span> <span class="toc-text">4.2. 访问用户空间目标变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-3-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="toc-number">19.</span> <span class="toc-text">4.3. 用户空间栈回溯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-SystemTap%E8%84%9A%E6%9C%AC%E9%9B%86%E9%94%A6"><span class="toc-number">20.</span> <span class="toc-text">5. SystemTap脚本集锦</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-%E7%BD%91%E7%BB%9C"><span class="toc-number">21.</span> <span class="toc-text">5.1. 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%96%E6%9E%90%E7%BD%91%E7%BB%9C%E6%B4%BB%E5%8A%A8"><span class="toc-number">21.1.</span> <span class="toc-text">剖析网络活动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">21.2.</span> <span class="toc-text">跟踪网络连接中的内核函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">21.3.</span> <span class="toc-text">监控TCP连接的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7TCP%E5%8C%85"><span class="toc-number">21.4.</span> <span class="toc-text">监控TCP包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%83%85%E5%86%B5"><span class="toc-number">21.5.</span> <span class="toc-text">监控内核中的网络丢包情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-2-%E7%A3%81%E7%9B%98"><span class="toc-number">22.</span> <span class="toc-text">5.2. 磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E7%8A%B6%E5%86%B5"><span class="toc-number">22.1.</span> <span class="toc-text">统计磁盘读写状况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E5%AF%B9%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">22.2.</span> <span class="toc-text">追踪对任意文件的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AAI-x2F-O%E7%9A%84%E7%B4%AF%E8%AE%A1%E6%80%BB%E9%87%8F"><span class="toc-number">22.3.</span> <span class="toc-text">追踪I&#x2F;O的累计总量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E5%AE%9A%E8%AE%BE%E5%A4%87%E7%9A%84I-x2F-O"><span class="toc-number">22.4.</span> <span class="toc-text">监控指定设备的I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%AF%B9%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">22.5.</span> <span class="toc-text">监控对指定文件的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%AF%B9%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">22.6.</span> <span class="toc-text">监控对指定文件的属性的修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E8%BE%93%E5%87%BA%E5%9D%97I-x2F-O%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-number">22.7.</span> <span class="toc-text">定期输出块I&#x2F;O等待时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-3-%E5%89%96%E6%9E%90"><span class="toc-number">23.</span> <span class="toc-text">5.3. 剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">23.1.</span> <span class="toc-text">统计函数调用次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">23.2.</span> <span class="toc-text">追踪函数调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%BB%99%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%9C%A8%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E8%80%97%E6%97%B6"><span class="toc-number">23.3.</span> <span class="toc-text">统计给定线程在内核空间和用户空间上的耗时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%BA%94%E7%94%A8%E8%BD%AE%E8%AF%A2%E6%83%85%E5%86%B5"><span class="toc-number">23.4.</span> <span class="toc-text">监控应用轮询情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%9C%80%E5%B8%B8%E8%B0%83%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">23.5.</span> <span class="toc-text">监控最常调用的系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%87%8F"><span class="toc-number">23.6.</span> <span class="toc-text">找出每个进程的系统调用量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-4-%E6%A0%87%E8%AF%86%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E9%94%81%E7%AB%9E%E4%BA%89"><span class="toc-number">24.</span> <span class="toc-text">5.4. 标识用户空间锁竞争</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%A7%A3%E8%AF%BB%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">25.</span> <span class="toc-text">6. 解读错误信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-1-%E8%A7%A3%E6%9E%90%E5%92%8C%E6%96%87%E6%B3%95%E9%94%99%E8%AF%AF"><span class="toc-number">26.</span> <span class="toc-text">6.1. 解析和文法错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="toc-number">27.</span> <span class="toc-text">6.2. 运行时错误和警告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Summary"><span class="toc-number">28.</span> <span class="toc-text">Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/IEEE%20802.1Q%20%E5%B0%81%E8%A3%85%E7%9A%84%20VLAN%20%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F%20/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/Linux%20%E4%B8%8B%20Pcap%20%E5%8C%85%E9%87%8D%E6%94%BE%E5%B7%A5%E5%85%B7%20Tcpreplay%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/OpenFlow%20%E6%B5%81%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/sdn/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F%E3%80%81IP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E3%80%81TCPUDP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/" title="无题">无题</a><time datetime="2023-12-08T09:57:19.865Z" title="发表于 2023-12-08 17:57:19">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/02/sdn/netperf%20%E7%9A%84%E4%BD%BF%E7%94%A8/" title="无题">无题</a><time datetime="2023-12-02T05:58:53.067Z" title="发表于 2023-12-02 13:58:53">2023-12-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="哪吒藕霸" target="_blank">哪吒藕霸</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/algorithm/" style="font-size: 0.88rem;">algorithm<sup>1</sup></a><a href="/tags/blockchain/" style="font-size: 0.88rem;">blockchain<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>27</sup></a><a href="/tags/go/" style="font-size: 0.88rem;">go<sup>11</sup></a><a href="/tags/kidgets/" style="font-size: 0.88rem;">kidgets<sup>3</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>22</sup></a><a href="/tags/rust/" style="font-size: 0.88rem;">rust<sup>6</sup></a><a href="/tags/sdn/" style="font-size: 0.88rem;">sdn<sup>1</sup></a><a href="/tags/tools/" style="font-size: 0.88rem;">tools<sup>1</sup></a><a href="/tags/tvbox/" style="font-size: 0.88rem;">tvbox<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 哪吒藕霸 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>